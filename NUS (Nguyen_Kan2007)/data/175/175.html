<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>D:\Paper\HTML\175</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2006-11-10T12:58:35+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Times;color:#000000;}
	.ft1{font-size:8px;font-family:Times;color:#000000;}
	.ft2{font-size:15px;font-family:Times;color:#000000;}
	.ft3{font-size:12px;font-family:Times;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:9px;font-family:Times;color:#000000;}
	.ft6{font-size:16px;font-family:Courier;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft9{font-size:11px;line-height:13px;font-family:Times;color:#000000;}
	.ft10{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="175001.png" alt="background image">
<DIV style="position:absolute;top:107;left:176"><nobr><span class="ft0"><b>Secure Hierarchical In-Network Aggregation</b></span></nobr></DIV>
<DIV style="position:absolute;top:137;left:332"><nobr><span class="ft0"><b>in Sensor Networks</b></span></nobr></DIV>
<DIV style="position:absolute;top:142;left:583"><nobr><span class="ft1"></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:181"><nobr><span class="ft2">Haowen Chan</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:149"><nobr><span class="ft3">Carnegie Mellon University</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:144"><nobr><span class="ft2">haowenchan@cmu.edu</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:405"><nobr><span class="ft2">Adrian Perrig</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:368"><nobr><span class="ft3">Carnegie Mellon University</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:391"><nobr><span class="ft2">perrig@cmu.edu</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:630"><nobr><span class="ft2">Dawn Song</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:587"><nobr><span class="ft3">Carnegie Mellon University</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:593"><nobr><span class="ft2">dawnsong@cmu.edu</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:81"><nobr><span class="ft2">ABSTRACT</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:81"><nobr><span class="ft8">In-network aggregation is an essential primitive for performing<br>queries on sensor network data. However, most aggregation algo-<br>rithms assume that all intermediate nodes are trusted. In contrast,<br>the standard threat model in sensor network security assumes that<br>an attacker may control a fraction of the nodes, which may misbe-<br>have in an arbitrary (Byzantine) manner.</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:94"><nobr><span class="ft4">We present the first algorithm for provably secure hierarchical</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:81"><nobr><span class="ft8">in-network data aggregation. Our algorithm is guaranteed to detect<br>any manipulation of the aggregate by the adversary beyond what is<br>achievable through direct injection of data values at compromised<br>nodes. In other words, the adversary can never gain any advan-<br>tage from misrepresenting intermediate aggregation computations.<br>Our algorithm incurs only O</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:240"><nobr><span class="ft4">(log</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:272"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:279"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:286"><nobr><span class="ft4">) node congestion, supports</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:81"><nobr><span class="ft8">arbitrary tree-based aggregator topologies and retains its resistance<br>against aggregation manipulation in the presence of arbitrary num-<br>bers of malicious nodes. The main algorithm is based on perform-<br>ing the</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:123"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:151"><nobr><span class="ft4">aggregation securely by first forcing the adversary to</span></nobr></DIV>
<DIV style="position:absolute;top:603;left:81"><nobr><span class="ft8">commit to its choice of intermediate aggregation results, and then<br>having the sensor nodes independently verify that their contribu-<br>tions to the aggregate are correctly incorporated. We show how to<br>reduce secure</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:158"><nobr><span class="ft1">MEDIAN</span></nobr></DIV>
<DIV style="position:absolute;top:650;left:205"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:212"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:650;left:252"><nobr><span class="ft4">, and</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:282"><nobr><span class="ft1">AVERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:650;left:339"><nobr><span class="ft4">to this primitive.</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:81"><nobr><span class="ft2">Categories and Subject Descriptors</span></nobr></DIV>
<DIV style="position:absolute;top:712;left:81"><nobr><span class="ft8">C.2.0 [Computer-Communication Networks]: General--Secu-<br>rity and Protection</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:81"><nobr><span class="ft2">General Terms</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:81"><nobr><span class="ft4">Security, Algorithms</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:81"><nobr><span class="ft1"></span></nobr></DIV>
<DIV style="position:absolute;top:818;left:87"><nobr><span class="ft4">This research was supported in part by CyLab at Carnegie Mellon</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:81"><nobr><span class="ft9">under grant DAAD19-02-1-0389 from the Army Research Office,<br>and grant CNS-0347807 from the National Science Foundation,<br>and by a gift from Bosch. The views and conclusions contained<br>here are those of the authors and should not be interpreted as nec-<br>essarily representing the official policies or endorsements, either<br>express or implied, of ARO, Bosch, Carnegie Mellon University,<br>NSF, or the U.S. Government or any of its agencies.</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:81"><nobr><span class="ft10">Permission to make digital or hard copies of all or part of this work for<br>personal or classroom use is granted without fee provided that copies are<br>not made or distributed for profit or commercial advantage and that copies<br>bear this notice and the full citation on the first page. To copy otherwise, to<br>republish, to post on servers or to redistribute to lists, requires prior specific<br>permission and/or a fee.<br>CCS'06, October 30­November 3, 2006, Alexandria, Virginia, USA.<br>Copyright 2006 ACM 1-59593-518-5/06/0010 ...</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:315"><nobr><span class="ft4">$</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:322"><nobr><span class="ft5">5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:475"><nobr><span class="ft2">Keywords</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:475"><nobr><span class="ft4">Secure aggregation, Sensor Networks, Data aggregation</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:475"><nobr><span class="ft2">1.</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:507"><nobr><span class="ft2">INTRODUCTION</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:489"><nobr><span class="ft4">Wireless sensor networks are increasingly deployed in security-</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:475"><nobr><span class="ft8">critical applications such as factory monitoring, environmental mon-<br>itoring, burglar alarms and fire alarms. The sensor nodes for these<br>applications are typically deployed in unsecured locations and are<br>not made tamper-proof due to cost considerations. Hence, an adver-<br>sary could undetectably take control of one or more sensor nodes<br>and launch active attacks to subvert correct network operations.<br>Such environments pose a particularly challenging set of constraints<br>for the protocol designer: sensor network protocols must be highly<br>energy efficient while being able to function securely in the pres-<br>ence of possible malicious nodes within the network.</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:489"><nobr><span class="ft4">In this paper we focus on the particular problem of securely and</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:475"><nobr><span class="ft4">efficiently performing aggregate queries (such as</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:753"><nobr><span class="ft1">MEDIAN</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:800"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:809"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:475"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:598;left:498"><nobr><span class="ft1">AVERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:552"><nobr><span class="ft4">) on sensor networks. In-network data aggregation is</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:475"><nobr><span class="ft8">an efficient primitive for reducing the total message complexity of<br>aggregate sensor queries. For example, in-network aggregation of<br>the</span></nobr></DIV>
<DIV style="position:absolute;top:645;left:496"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:526"><nobr><span class="ft4">function is performed by having each intermediate node</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:475"><nobr><span class="ft8">forward a single message containing the sum of the sensor readings<br>of all the nodes downstream from it, rather than forwarding each<br>downstream message one-by-one to the base station. The energy<br>savings of performing in-network aggregation have been shown to<br>be significant and are crucial for energy-constrained sensor net-<br>works [9, 11, 20].</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:489"><nobr><span class="ft4">Unfortunately, most in-network aggregation schemes assume that</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:475"><nobr><span class="ft8">all sensor nodes are trusted [12, 20]. An adversary controlling just<br>a few aggregator nodes could potentially cause the sensor network<br>to return arbitrary results, thus completely subverting the function<br>of the network to the adversary's own purposes.</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:489"><nobr><span class="ft4">Despite the importance of the problem and a significant amount</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:475"><nobr><span class="ft8">of work on the area, the known approaches to secure aggregation<br>either require strong assumptions about network topology or ad-<br>versary capabilities, or are only able to provide limited probabilis-<br>tic security properties. For example, Hu and Evans [8] propose<br>a secure aggregation scheme under the assumption that at most a<br>single node is malicious. Przydatek et al. [17] propose Secure In-<br>formation Aggregation (SIA), which provides a statistical security<br>property under the assumption of a single-aggregator model. In the<br>single-aggregator model, sensor nodes send their data to a single<br>aggregator node, which computes the aggregate and sends it to the<br>base station. This form of aggregation reduces communications<br>only on the link between the aggregator and the base station, and is<br>not scalable to large multihop sensor deployments. Most of the al-<br>gorithms in SIA (in particular,</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:643"><nobr><span class="ft1">MEDIAN</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:690"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:697"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:725"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:749"><nobr><span class="ft1">AVERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:803"><nobr><span class="ft4">) can-</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:475"><nobr><span class="ft4">not be directly adapted to a hierarchical aggregation model since</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">278</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="175002.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">they involve sorting all of the input values; the final aggregator in<br>the hierarchy thus needs to access all the data values of the sensor<br>nodes.</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:94"><nobr><span class="ft4">In this paper, we present the first provably secure sensor network</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:81"><nobr><span class="ft8">data aggregation protocol for general networks and multiple adver-<br>sarial nodes. The algorithm limits the adversary's ability to ma-<br>nipulate the aggregation result with the tightest bound possible for<br>general algorithms with no knowledge of the distribution of sen-<br>sor data values. Specifically, an adversary can gain no additional<br>influence over the final result by manipulating the results of the<br>in-network aggregate computation as opposed to simply reporting<br>false data readings for the compromised nodes under its control.<br>Furthermore, unlike prior schemes, our algorithm is designed for<br>general hierarchical aggregator topologies and multiple malicious<br>sensor nodes. Our metric for communication cost is congestion,<br>which is the maximum communication load on any node in the<br>network. Let n be the number of nodes in the network, and</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:414"><nobr><span class="ft4"> be</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:81"><nobr><span class="ft8">the maximum degree of any node in the aggregation tree. Our algo-<br>rithm induces only O</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:195"><nobr><span class="ft4">(log</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:227"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:235"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:242"><nobr><span class="ft4">) node congestion in the aggregation</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:81"><nobr><span class="ft4">tree.</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:81"><nobr><span class="ft2">2.</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:112"><nobr><span class="ft2">RELATED WORK</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:94"><nobr><span class="ft4">Researchers have investigated resilient aggregation algorithms to</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:81"><nobr><span class="ft8">provide increased likelihood of accurate results in environments<br>prone to message loss or node failures. This class of algorithms<br>includes work by Gupta et al. [7], Nath et al. [15], Chen et al. [3]<br>and Manjhi et al. [14].</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:94"><nobr><span class="ft4">A number of aggregation algorithms have been proposed to en-</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:81"><nobr><span class="ft8">sure secrecy of the data against intermediate aggregators. Such al-<br>gorithms have been proposed by Girao et al. [5], Castelluccia et<br>al. [2], and Cam et al. [1].</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:94"><nobr><span class="ft4">Hu and Evans [8] propose securing in-network aggregation against</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:81"><nobr><span class="ft8">a single Byzantine adversary by requiring aggregator nodes to for-<br>ward their inputs to their parent nodes in the aggregation tree. Jadia<br>and Mathuria [10] extend the Hu and Evans approach by incorpo-<br>rating privacy, but also considered only a single malicious node.</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:94"><nobr><span class="ft4">Several secure aggregation algorithms have been proposed for</span></nobr></DIV>
<DIV style="position:absolute;top:678;left:81"><nobr><span class="ft8">the single-aggregator model. Przydatek et al. [17] proposed Se-<br>cure Information Aggregation (SIA) for this topology. Also for the<br>single-aggregator case, Du et al. [4] propose using multiple wit-<br>ness nodes as additional aggregators to verify the integrity of the<br>aggregator's result. Mahimkar and Rappaport [13] also propose<br>an aggregation-verification scheme for the single-aggregator model<br>using a threshold signature scheme to ensure that at least t of the<br>nodes agree with the aggregation result. Yang et al. [19] describe<br>a probabilistic aggregation algorithm which subdivides an aggre-<br>gation tree into subtrees, each of which reports their aggregates<br>directly to the base station. Outliers among the subtrees are then<br>probed for inconsistencies.</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:94"><nobr><span class="ft4">Wagner [18] addressed the issue of measuring and bounding ma-</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:81"><nobr><span class="ft8">licious nodes' contribution to the final aggregation result. The pa-<br>per measures how much damage an attacker can inflict by taking<br>control of a number of nodes and using them solely to inject erro-<br>neous data values.</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:81"><nobr><span class="ft2">3.</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:112"><nobr><span class="ft2">PROBLEM MODEL</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:94"><nobr><span class="ft4">In general, the goal of secure aggregation is to compute aggre-</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:81"><nobr><span class="ft4">gate functions (such as</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:211"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:236"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:244"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:289"><nobr><span class="ft4">or</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:305"><nobr><span class="ft1">AVERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:358"><nobr><span class="ft4">) of the sensed</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft8">data values residing on sensor nodes, while assuming that a por-<br>tion of the sensor nodes are controlled by an adversary which is<br>attempting to skew the final result. In this section, we present the<br>formal parameters of the problem.</span></nobr></DIV>
<DIV style="position:absolute;top:83;left:475"><nobr><span class="ft2">3.1</span></nobr></DIV>
<DIV style="position:absolute;top:83;left:516"><nobr><span class="ft2">Network Assumptions</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:489"><nobr><span class="ft4">We assume a general multihop network with a set S</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:761"><nobr><span class="ft4">= {s</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:785"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:791"><nobr><span class="ft4">,...,s</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:823"><nobr><span class="ft1">n</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:829"><nobr><span class="ft4">}</span></nobr></DIV>
<DIV style="position:absolute;top:121;left:475"><nobr><span class="ft8">of n sensor nodes and a single (untrusted) base station R, which is<br>able to communicate with the querier which resides outside of the<br>network. The querier knows the total number of sensor nodes n,<br>and that all n nodes are alive and reachable.</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:489"><nobr><span class="ft4">We assume the aggregation is performed over an aggregation</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:475"><nobr><span class="ft8">tree which is the directed tree formed by the union of all the paths<br>from the sensor nodes to the base station (one such tree is shown<br>in Figure 1(a)). These paths may be arbitrarily chosen and are not<br>necessarily shortest paths. The optimisation of the aggregation tree<br>structure is out of the scope of this paper--our algorithm takes the<br>structure of the aggregation tree as given. One method for con-<br>structing an aggregation tree is described in TaG [11].</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:475"><nobr><span class="ft2">3.2</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:516"><nobr><span class="ft2">Security Infrastructure</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:489"><nobr><span class="ft4">We assume that each sensor node has a unique identifier s and</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:475"><nobr><span class="ft4">shares a unique secret symmetric key K</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:690"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:699"><nobr><span class="ft4">with the querier. We fur-</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:475"><nobr><span class="ft8">ther assume the existence of a broadcast authentication primitive<br>where any node can authenticate a message from the querier. This<br>broadcast authentication could, for example, be performed using<br>µTESLA [16]. We assume the sensor nodes have the ability to per-<br>form symmetric-key encryption and decryption as well as compu-<br>tations of a collision-resistant cryptographic hash function H.</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:475"><nobr><span class="ft2">3.3</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:516"><nobr><span class="ft2">Attacker Model</span></nobr></DIV>
<DIV style="position:absolute;top:495;left:489"><nobr><span class="ft4">We assume that the attacker is in complete control of an arbitrary</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:475"><nobr><span class="ft8">number of sensor nodes, including knowledge of all their secret<br>keys. The attacker has a network-wide presence and can record and<br>inject messages at will. The sole goal of the attacker is to launch<br>what Przydatek et al. [17] call a stealthy attack, i.e., to cause the<br>querier to accept a false aggregate that is higher or lower than the<br>true aggregate value.</span></nobr></DIV>
<DIV style="position:absolute;top:605;left:489"><nobr><span class="ft4">We do not consider denial-of-service (DoS) attacks where the</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:475"><nobr><span class="ft8">goal of the adversary is to prevent the querier from getting any<br>aggregation result at all. While such attacks can disrupt the nor-<br>mal operation of the sensor network, they are not as potentially<br>hazardous in security-critical applications as the ability to cause<br>the operator of the network to accept arbitrary data. Furthermore,<br>any maliciously induced extended loss of service is a detectable<br>anomaly which will (eventually) expose the adversary's presence<br>if subsequent protocols or manual intervention do not succeed in<br>resolving the problem.</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:475"><nobr><span class="ft2">3.4</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:516"><nobr><span class="ft2">Problem Definition and Metrics</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:489"><nobr><span class="ft4">Each sensor node s</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:597"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:606"><nobr><span class="ft4">has a data value a</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:708"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:712"><nobr><span class="ft4">. We assume that the</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:475"><nobr><span class="ft4">data value is a non-negative bounded real value a</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:740"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:746"><nobr><span class="ft4"> [0,r] for some</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:475"><nobr><span class="ft8">maximum allowed data value r. The objective of the aggregation<br>process is to compute some function f over all the data values,<br>i.e., f</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:506"><nobr><span class="ft4">(a</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:518"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:524"><nobr><span class="ft4">,...,a</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:557"><nobr><span class="ft1">n</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:563"><nobr><span class="ft4">). Note that for the</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:668"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:696"><nobr><span class="ft4">aggregate, the case where</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:475"><nobr><span class="ft4">data values are in a range</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:626"><nobr><span class="ft4">[r</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:635"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:641"><nobr><span class="ft4">,r</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:652"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:658"><nobr><span class="ft4">] (where r</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:715"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:721"><nobr><span class="ft4">,r</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:731"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:743"><nobr><span class="ft4">can be negative)</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:475"><nobr><span class="ft4">is reducible to this case by setting r</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:677"><nobr><span class="ft4">= r</span></nobr></DIV>
<DIV style="position:absolute;top:891;left:696"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:704"><nobr><span class="ft4">- r</span></nobr></DIV>
<DIV style="position:absolute;top:891;left:722"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:733"><nobr><span class="ft4">and add nr</span></nobr></DIV>
<DIV style="position:absolute;top:891;left:792"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:803"><nobr><span class="ft4">to the</span></nobr></DIV>
<DIV style="position:absolute;top:902;left:475"><nobr><span class="ft4">aggregation result.</span></nobr></DIV>
<DIV style="position:absolute;top:931;left:475"><nobr><span class="ft8">Definition 1 A direct data injection attack occurs when an attacker<br>modifies the data readings reported by the nodes under its direct<br>control, under the constraint that only legal readings in</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:787"><nobr><span class="ft4">[0,r] are</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:475"><nobr><span class="ft4">reported.</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:489"><nobr><span class="ft4">Wagner [18] performed a quantitative study measuring the ef-</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:475"><nobr><span class="ft8">fect of direct data injection on various aggregates, and concludes<br>that the aggregates addressed in this paper (truncated</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:763"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:792"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:815"><nobr><span class="ft1">AV</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:829"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:476"><nobr><span class="ft1">ERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:514"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:521"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:565"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:1048;left:588"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:604"><nobr><span class="ft1">QUANTILE</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:663"><nobr><span class="ft4">) can be resilient under such at-</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:475"><nobr><span class="ft4">tacks.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">279</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="175003.png" alt="background image">
<DIV style="position:absolute;top:86;left:94"><nobr><span class="ft4">Without domain knowledge about what constitutes an anoma-</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:81"><nobr><span class="ft8">lous sensor reading, it is impossible to detect a direct data injection<br>attack, since they are indistinguishable from legitimate sensor read-<br>ings [17, 19]. Hence, if a secure aggregation scheme does not make<br>assumptions on the distribution of data values, it cannot limit the<br>adversary's capability to perform direct data injection. We can thus<br>define an optimal level of aggregation security as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:81"><nobr><span class="ft8">Definition 2 An aggregation algorithm is optimally secure if, by<br>tampering with the aggregation process, an adversary is unable to<br>induce the querier to accept any aggregation result which is not<br>already achievable by direct data injection.</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:94"><nobr><span class="ft4">As a metric for communication overhead, we consider node con-</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:81"><nobr><span class="ft8">gestion, which is the worst case communication load on any sin-<br>gle sensor node during the algorithm. Congestion is a commonly<br>used metric in ad-hoc networks since it measures how quickly the<br>heaviest-loaded nodes will exhaust their batteries [6, 12]. Since the<br>heaviest-loaded nodes are typically the nodes which are most es-<br>sential to the connectivity of the network (e.g., the nodes closest to<br>the base station), their failure may cause the network to partition<br>even though other sensor nodes in the network may still have high<br>battery levels. A lower communication load on the heaviest-loaded<br>nodes is thus desirable even if the trade-off is a larger amount of<br>communication in the network as a whole.</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:94"><nobr><span class="ft4">For a lower bound on congestion, consider an unsecured aggre-</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:81"><nobr><span class="ft8">gation protocol where each node sends just a single message to<br>its parent in the aggregation tree. This is the minimum number<br>of messages that ensures that each sensor node contributes to the<br>aggregation result. There is</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:236"><nobr><span class="ft4">(1) congestion on each edge on the</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:81"><nobr><span class="ft4">aggregation tree, thus resulting in</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:267"><nobr><span class="ft4">(d) congestion on the node(s)</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:81"><nobr><span class="ft8">with highest degree d in the aggregation tree. The parameter d is<br>dependent on the shape of the given aggregation tree and can be as<br>large as</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:126"><nobr><span class="ft4">(n) for a single-aggregator topology or as small as (1)</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:81"><nobr><span class="ft8">for a balanced aggregation tree. Since we are taking the aggrega-<br>tion tree topology as an input, we have no control over d. Hence,<br>it is often more informative to consider per-edge congestion, which<br>can be independent of the structure of the aggregation tree.</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:94"><nobr><span class="ft4">Consider the simplest solution where we omit aggregation al-</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:81"><nobr><span class="ft8">together and simply send all data values (encrypted and authenti-<br>cated) directly to the base station, which then forwards it to the<br>querier. This provides perfect data integrity, but induces O</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:395"><nobr><span class="ft4">(n) con-</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:81"><nobr><span class="ft8">gestion at the nodes and edges nearest the base station. For an algo-<br>rithm to be practical, it must cause only sublinear edge congestion.</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:94"><nobr><span class="ft4">Our goal is to design an optimally secure aggregation algorithm</span></nobr></DIV>
<DIV style="position:absolute;top:791;left:81"><nobr><span class="ft4">with only sublinear edge congestion.</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:81"><nobr><span class="ft2">4.</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:112"><nobr><span class="ft2">THE SUM ALGORITHM</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:94"><nobr><span class="ft4">In this section we describe our algorithm for the</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:356"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:384"><nobr><span class="ft4">aggregate,</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:81"><nobr><span class="ft8">where the aggregation function f is addition. Specifically, we wish<br>to compute a</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:152"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:160"><nobr><span class="ft4">+ ··· + a</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:208"><nobr><span class="ft1">n</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:214"><nobr><span class="ft4">, where a</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:265"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:273"><nobr><span class="ft4">is the data value at node i. We</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:81"><nobr><span class="ft8">defer analysis of the algorithm properties to Section 5, and discuss<br>the application of the algorithm to other aggregates such as</span></nobr></DIV>
<DIV style="position:absolute;top:912;left:396"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:436"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:81"><nobr><span class="ft1">AVERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:138"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:161"><nobr><span class="ft1">MEDIAN</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:211"><nobr><span class="ft4">in Section 6.</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:94"><nobr><span class="ft4">We build on the aggregate-commit-prove framework described</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:81"><nobr><span class="ft8">by Przydatek et al. [17] but extend their single aggregator model<br>to a fully distributed setting. Our algorithm involves computing a<br>cryptographic commitment structure (similar to a hash tree) over<br>the data values of the sensor nodes as well as the aggregation pro-<br>cess. This forces the adversary to choose a fixed aggregation topol-<br>ogy and set of aggregation results. The individual sensor nodes<br>then independently audit the commitment structure to verify that</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">their respective contributions have been added to the aggregate. If<br>the adversary attempts to discard or reduce the contribution of a<br>legitimate sensor node, this necessarily induces an inconsistency<br>in the commitment structure which can be detected by the affected<br>node. This basic approach provides us with a lower bound for the</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:476"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:505"><nobr><span class="ft4">aggregate. To provide an upper-bound for</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:742"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:767"><nobr><span class="ft4">, we can re-</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:475"><nobr><span class="ft8">use the same lower-bounding approach, but on a complementary<br>aggregate called the</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:588"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:673"><nobr><span class="ft4">aggregate. Where</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:775"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:804"><nobr><span class="ft4">is de-</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:475"><nobr><span class="ft4">fined as</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:521"><nobr><span class="ft4">a</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:539"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:542"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:550"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:634"><nobr><span class="ft4">is defined as</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:705"><nobr><span class="ft4">(r - a</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:746"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:208;left:750"><nobr><span class="ft4">) where r is the</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:475"><nobr><span class="ft8">upper bound on allowable data values. When the final aggregates<br>are computed, the querier enforces the constraint that</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:763"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:791"><nobr><span class="ft4">+</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:803"><nobr><span class="ft1">COM</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:829"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:476"><nobr><span class="ft1">PLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:533"><nobr><span class="ft4">= nr. Hence any adversary that wishes to increase</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:809"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:475"><nobr><span class="ft4">must also decrease</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:584"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:664"><nobr><span class="ft4">, and vice-versa, otherwise the</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:475"><nobr><span class="ft8">discrepancy will be detected. Hence, by enforcing a lower-bound<br>on</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:492"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:573"><nobr><span class="ft4">, we are also enforcing an upper-bound on</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:803"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:828"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:489"><nobr><span class="ft4">The overall algorithm has three main phases: query dissemina-</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:475"><nobr><span class="ft4">tion, aggregation-commit, and result-checking.</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:489"><nobr><span class="ft4">Query dissemination. The base station broadcasts the query to</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:475"><nobr><span class="ft8">the network. An aggregation tree, or a directed spanning tree over<br>the network topology with the base station at the root, is formed as<br>the query is sent to all the nodes, if one is not already present in the<br>network.</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:489"><nobr><span class="ft4">Aggregation commit. In this phase, the sensor nodes iteratively</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:475"><nobr><span class="ft8">construct a commitment structure resembling a hash tree. First, the<br>leaf nodes in the aggregation tree send their data values to their par-<br>ents in the aggregation tree. Each internal sensor node in the ag-<br>gregation tree performs an aggregation operation whenever it has<br>heard from all its child sensor nodes. Whenever a sensor node s<br>performs an aggregation operation, s creates a commitment to the<br>set of inputs used to compute the aggregate by computing a hash<br>over all the inputs (including the commitments that were computed<br>by the children of s). Both the aggregation result and the commit-<br>ment are then passed on to the parent of s. After the final commit-<br>ment values are reported to the base station (and thus also to the<br>querier), the adversary cannot subsequently claim a different ag-<br>gregation structure or result. We describe an optimisation to ensure<br>that the constructed commitment trees are perfectly balanced, thus<br>requiring low congestion overhead in the next phase.</span></nobr></DIV>
<DIV style="position:absolute;top:683;left:489"><nobr><span class="ft4">Result-checking. The result-checking phase is a novel distributed</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:475"><nobr><span class="ft8">verification process. In prior work, algorithms have relied on the<br>querier to issue probes into the commitment structure to verify its<br>integrity [17, 19]. This induces congestion nearest the base station,<br>and moreover, such algorithms yield at best probabilistic security<br>properties. We show that if the verification step is instead fully dis-<br>tributed, it is possible to achieve provably optimal security while<br>maintaining sublinear edge congestion.</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:489"><nobr><span class="ft4">The result-checking phase proceeds as follows. Once the querier</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:475"><nobr><span class="ft8">has received the final commitment values, it disseminates them to<br>the rest of the network in an authenticated broadcast. At the same<br>time, sensor nodes disseminate information that will allow their<br>peers to verify that their respective data values have been incor-<br>porated into the aggregate. Each sensor node is responsible for<br>checking that its own contribution was added into the aggregate.<br>If a sensor node determines that its data value was indeed added<br>towards the final sum, it sends an authentication code up the aggre-<br>gation tree towards to the base station. Authentication codes are ag-<br>gregated along the way with the XOR function for communication<br>efficiency. When the querier has received the XOR of all the au-<br>thentication codes, it can then verify that all the sensor nodes have<br>confirmed that the aggregation structure is consistent with their data<br>values. If so, then it accepts the aggregation result.</span></nobr></DIV>
<DIV style="position:absolute;top:1044;left:489"><nobr><span class="ft4">We now describe the details of each of the three phases in turn.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">280</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft11{font-size:5px;font-family:Times;color:#000000;}
	.ft12{font-size:14px;font-family:Times;color:#000000;}
	.ft13{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="175004.png" alt="background image">
<DIV style="position:absolute;top:278;left:127"><nobr><span class="ft9">(a) Example network graph.<br>Arrows:</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:189"><nobr><span class="ft4">Aggregation</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:273"><nobr><span class="ft4">tree.</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:127"><nobr><span class="ft4">R: Base station. Q: Querier.</span></nobr></DIV>
<DIV style="position:absolute;top:255;left:477"><nobr><span class="ft4">G</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:487"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:496"><nobr><span class="ft4">= 1,a</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:533"><nobr><span class="ft1">G</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:541"><nobr><span class="ft4">,r - a</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:573"><nobr><span class="ft1">G</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:581"><nobr><span class="ft4">,G</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:477"><nobr><span class="ft4">F</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:484"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:493"><nobr><span class="ft4">= 2,v</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:529"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:535"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:540"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:551"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:556"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:562"><nobr><span class="ft4">,H[N||2||v</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:619"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:625"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:630"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:643"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:649"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:654"><nobr><span class="ft4">||F</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:668"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:674"><nobr><span class="ft4">||G</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:691"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:697"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:476"><nobr><span class="ft4">C</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:485"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:494"><nobr><span class="ft4">= 4,v</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:530"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:537"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:542"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:552"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:559"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:564"><nobr><span class="ft4">,H[N||4||v</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:622"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:628"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:634"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:646"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:653"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:658"><nobr><span class="ft4">||C</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:674"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:680"><nobr><span class="ft4">||E</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:696"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:701"><nobr><span class="ft4">||F</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:716"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:722"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:477"><nobr><span class="ft4">A</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:485"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:494"><nobr><span class="ft4">= 9,v</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:531"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:537"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:542"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:553"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:560"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:565"><nobr><span class="ft4">,H[N||9||v</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:623"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:629"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:634"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:648"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:654"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:659"><nobr><span class="ft4">||A</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:675"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:681"><nobr><span class="ft4">||B</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:697"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:703"><nobr><span class="ft4">||C</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:718"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:724"><nobr><span class="ft4">||D</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:741"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:747"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:87;left:477"><nobr><span class="ft4">R</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:488"><nobr><span class="ft4">= 12,v</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:531"><nobr><span class="ft1">R</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:539"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:550"><nobr><span class="ft1">R</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:557"><nobr><span class="ft4">,H[N||12||v</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:621"><nobr><span class="ft1">R</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:628"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:642"><nobr><span class="ft1">R</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:649"><nobr><span class="ft4">||H</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:666"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:672"><nobr><span class="ft4">||A</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:688"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:693"><nobr><span class="ft4">||I</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:705"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:711"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:314"><nobr><span class="ft9">(b) Naive commitment tree, showing derivations of some of the vertices. For each sensor<br>node X , X</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:369"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:380"><nobr><span class="ft4">is its leaf vertex, while X</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:517"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:527"><nobr><span class="ft4">is the internal vertex representing the aggregate</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:314"><nobr><span class="ft9">computation at X (if any). On the right we list the labels of the vertices on the path of<br>node G to the root.</span></nobr></DIV>
<DIV style="position:absolute;top:352;left:258"><nobr><span class="ft4">Figure 1: Aggregation and naive commitment tree in network context</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:81"><nobr><span class="ft2">4.1</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:121"><nobr><span class="ft2">Query Dissemination</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:94"><nobr><span class="ft4">First, an aggregation tree is established if one is not already</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:81"><nobr><span class="ft8">present. Various algorithms for selecting the structure of an ag-<br>gregation tree may be used. For completeness, we describe one<br>such process, while noting that our algorithm is directly applicable<br>to any aggregation tree structure. The Tiny Aggregation Service<br>(TaG) [11] uses a broadcast from the base station where each node<br>chooses as its parent in the aggregation tree, the node from which<br>it first heard the tree-formation message.</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:94"><nobr><span class="ft4">To initiate a query in the aggregation tree, the base station orig-</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:81"><nobr><span class="ft8">inates a query request message which is distributed following the<br>aggregation tree. The query request message contains an attached<br>nonce N to prevent replay of messages belonging to a prior query,<br>and the entire request message is sent using an authenticated broad-<br>cast.</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:81"><nobr><span class="ft2">4.2</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:121"><nobr><span class="ft2">Aggregation-Commit Phase</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:94"><nobr><span class="ft4">The goal of the aggregation-commit phase is to iteratively con-</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:81"><nobr><span class="ft8">struct a series of cryptographic commitments to data values and to<br>intermediate in-network aggregation operations. This commitment<br>is then passed on to the querier. The querier then rebroadcasts the<br>commitment to the sensor network using an authenticated broad-<br>cast so that the rest of the sensor network is able to verify that their<br>respective data values have been incorporated into the aggregate.</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:85"><nobr><span class="ft12"><i>4.2.1</i></span></nobr></DIV>
<DIV style="position:absolute;top:841;left:134"><nobr><span class="ft12"><i>Aggregation-Commit: Naive Approach</i></span></nobr></DIV>
<DIV style="position:absolute;top:863;left:94"><nobr><span class="ft4">We first describe a naive approach that yields the desired secu-</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:81"><nobr><span class="ft8">rity properties but has suboptimal congestion overhead when sensor<br>nodes perform their respective verifications. In the naive approach,<br>when each sensor node performs an aggregation operation, it com-<br>putes a cryptographic hash of all its inputs (including its own data<br>value). The hash value is then passed on to the parent in the aggre-<br>gation tree along with the aggregation result. Figure 1(b) shows a<br>commitment tree which consists of a series of hashes of data values<br>and intermediate results, culminating in a set of final commitment<br>values which is passed on by the base station to the querier along<br>with the aggregation results. Conceptually, a commitment tree is<br>a hash tree with some additional aggregate accounting information<br>attached to the nodes. A definition follows. Recall that N is the<br>query nonce that is disseminated with each query.</span></nobr></DIV>
<DIV style="position:absolute;top:397;left:475"><nobr><span class="ft8">Definition 3 A commitment tree is a tree where each vertex has<br>an associated label representing the data that is passed on to its<br>parent. The labels have the following format:</span></nobr></DIV>
<DIV style="position:absolute;top:455;left:509"><nobr><span class="ft4">count, value, complement, commitment</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:475"><nobr><span class="ft8">Where count is the number of leaf vertices in the subtree rooted<br>at this vertex; value is the</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:643"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:674"><nobr><span class="ft4">aggregate computed over all</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:475"><nobr><span class="ft4">the leaves in the subtree; complement is the aggregate over the</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:476"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:560"><nobr><span class="ft4">of the data values; and commitment is a crypto-</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:475"><nobr><span class="ft4">graphic commitment. The labels are defined inductively as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:489"><nobr><span class="ft4">There is one leaf vertex u</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:634"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:644"><nobr><span class="ft4">for each sensor node s, which we</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:475"><nobr><span class="ft4">call the leaf vertex of s. The label of u</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:701"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:711"><nobr><span class="ft4">consists of count=1,</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:475"><nobr><span class="ft4">value</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:516"><nobr><span class="ft4">=a</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:531"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:540"><nobr><span class="ft4">where a</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:583"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:592"><nobr><span class="ft4">is the data value of s, complement=r</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:810"><nobr><span class="ft4">- a</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:829"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:606;left:475"><nobr><span class="ft13">where r is the upper bound on allowable data values, and<br>commitment</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:559"><nobr><span class="ft4">is the node's unique ID.</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:489"><nobr><span class="ft4">Internal vertices represent aggregation operations, and have la-</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:475"><nobr><span class="ft8">bels that are defined based on their children. Suppose an internal<br>vertex has child vertices with the following labels: u</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:768"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:774"><nobr><span class="ft4">,u</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:786"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:792"><nobr><span class="ft4">,...,u</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:825"><nobr><span class="ft1">q</span></nobr></DIV>
<DIV style="position:absolute;top:669;left:831"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:684;left:475"><nobr><span class="ft4">where u</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:518"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:525"><nobr><span class="ft4">= c</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:550"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:554"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:565"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:568"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:580"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:583"><nobr><span class="ft4">,h</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:595"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:684;left:604"><nobr><span class="ft4">. Then the vertex has label c</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:765"><nobr><span class="ft4">,v,v,h , with</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:475"><nobr><span class="ft4">c</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:484"><nobr><span class="ft4">= c</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:515"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:518"><nobr><span class="ft4">, v</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:534"><nobr><span class="ft4">= v</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:565"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:568"><nobr><span class="ft4">, v</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:584"><nobr><span class="ft4">= v</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:614"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:621"><nobr><span class="ft4">and h</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:655"><nobr><span class="ft4">= H[N||c||v||v||u</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:747"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:753"><nobr><span class="ft4">||u</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:768"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:774"><nobr><span class="ft4">||···||u</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:812"><nobr><span class="ft1">q</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:818"><nobr><span class="ft4">].</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:489"><nobr><span class="ft4">For brevity, in the remainder of the paper we will often omit ref-</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:475"><nobr><span class="ft13">erences to labels and instead refer directly to the count, value,<br>complement</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:559"><nobr><span class="ft4">or commitment of a vertex.</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:489"><nobr><span class="ft4">While there exists a natural mapping between vertices in a com-</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:475"><nobr><span class="ft8">mitment tree and sensor nodes in the aggregation tree, a vertex is<br>a logical element in a graph while a sensor node is a physical de-<br>vice. To prevent confusion, we will always refer to the vertices in<br>the commitment tree; the term nodes always refers to the physical<br>sensor node device.</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:489"><nobr><span class="ft4">Since we assume that our hash function provides collision resis-</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:475"><nobr><span class="ft8">tance, it is computationally infeasible for an adversary to change<br>any of the contents of the commitment tree once the final commit-<br>ment values have reached the root.</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:489"><nobr><span class="ft4">With knowledge of the root commitment value, a node s may</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:475"><nobr><span class="ft4">verify the aggregation steps between its leaf vertex u</span></nobr></DIV>
<DIV style="position:absolute;top:954;left:761"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:769"><nobr><span class="ft4">and the root</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:475"><nobr><span class="ft8">of the commitment tree. To do so, s needs the labels of all its off-<br>path vertices.</span></nobr></DIV>
<DIV style="position:absolute;top:1018;left:475"><nobr><span class="ft8">Definition 4 The set of off-path vertices for a vertex u in a tree is<br>the set of all the siblings of each of the vertices on the path from u<br>to the root of the tree that u is in (the path is inclusive of u).</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">281</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="175005.png" alt="background image">
<DIV style="position:absolute;top:221;left:81"><nobr><span class="ft8">Figure 2: Off-path vertices for u are highlighted in bold. The<br>path from u to the root of its tree is shaded grey.</span></nobr></DIV>
<DIV style="position:absolute;top:282;left:94"><nobr><span class="ft4">Figure 2 shows a pictorial depiction of the off-path vertices for a</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:81"><nobr><span class="ft8">vertex u in a tree. For a more concrete example, the set of off-path<br>commitment tree vertices for G</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:256"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:267"><nobr><span class="ft4">in Figure 1 is</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:348"><nobr><span class="ft4">{F</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:361"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:367"><nobr><span class="ft4">, E</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:384"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:390"><nobr><span class="ft4">, C</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:407"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:413"><nobr><span class="ft4">, B</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:430"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:436"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:81"><nobr><span class="ft4">A</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:89"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:95"><nobr><span class="ft4">, D</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:112"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:118"><nobr><span class="ft4">, H</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:135"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:141"><nobr><span class="ft4">, I</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:153"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:159"><nobr><span class="ft4">}. To allow sensor node G to verify its contribution</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:81"><nobr><span class="ft8">to the aggregate, the sensor network delivers labels of each off-<br>path vertex to G</span></nobr></DIV>
<DIV style="position:absolute;top:364;left:167"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:173"><nobr><span class="ft4">. Sensor node G then recomputes the sequence of</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:81"><nobr><span class="ft8">computations and hashes and verifies that they lead to the correct<br>root commitment value.</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:94"><nobr><span class="ft4">Consider the congestion on the naive scheme. Let h be the height</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:81"><nobr><span class="ft4">of the aggregation tree and</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:230"><nobr><span class="ft4"> be the maximum degree of any node</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:81"><nobr><span class="ft4">inside the tree. Each leaf vertex has O</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:285"><nobr><span class="ft4">(h) off-path vertices, and it</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:81"><nobr><span class="ft8">needs to receive all their labels to verify its contribution to the ag-<br>gregate, thus leading to O</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:219"><nobr><span class="ft4">(h) congestion at the leaves of the com-</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:81"><nobr><span class="ft8">mitment tree. For an aggregation tree constructed with TaG, the<br>height h of the aggregation tree depends on the diameter (in number<br>of hops) of the network, which in turn depends on the node density<br>and total number of nodes n in the network. In a 2-dimensional<br>deployment area with a constant node density, the best bound on<br>the diameter of the network is O</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:262"><nobr><span class="ft4">(n) if the network is regularly</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:81"><nobr><span class="ft4">shaped. In irregular topologies the diameter of the network may be</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:81"><nobr><span class="ft4">(n).</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:85"><nobr><span class="ft12"><i>4.2.2</i></span></nobr></DIV>
<DIV style="position:absolute;top:621;left:134"><nobr><span class="ft12"><i>Aggregation-Commit: Improved Approach</i></span></nobr></DIV>
<DIV style="position:absolute;top:643;left:94"><nobr><span class="ft4">We present an optimization to improve the congestion cost. The</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:81"><nobr><span class="ft8">main observation is that, since the aggregation trees are a sub-<br>graph of the network topology, they may be arbitrarily unbalanced.<br>Hence, if we decouple the structure of the commitment tree from<br>the structure of the aggregation tree, then the commitment tree<br>could be perfectly balanced.</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:94"><nobr><span class="ft4">In the naive commitment tree, each sensor node always com-</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:81"><nobr><span class="ft8">putes the aggregate sum of all its inputs. This can be considered<br>a strategy of greedy aggregation. Consider instead the benefit of<br>delayed aggregation at node C</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:251"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:262"><nobr><span class="ft4">in Figure 1(b). Suppose that C,</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:81"><nobr><span class="ft8">instead of greedily computing the aggregate sum over its own read-<br>ing (C</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:114"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:120"><nobr><span class="ft4">) and both its child nodes E</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:271"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:281"><nobr><span class="ft4">and F</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:312"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:318"><nobr><span class="ft4">, instead computes the</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:81"><nobr><span class="ft4">sum only over C</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:171"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:182"><nobr><span class="ft4">and E</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:214"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:220"><nobr><span class="ft4">, and passes F</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:297"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:308"><nobr><span class="ft4">directly to A along with</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:80"><nobr><span class="ft4">C</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:89"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:98"><nobr><span class="ft4">= C</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:120"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:128"><nobr><span class="ft4">+ E</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:149"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:155"><nobr><span class="ft4">. In such a commitment tree, F</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:326"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:336"><nobr><span class="ft4">becomes a child of</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:81"><nobr><span class="ft4">A</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:89"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:98"><nobr><span class="ft4">(instead of C</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:167"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:173"><nobr><span class="ft4">), thus reducing the depth of the commitment tree</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:81"><nobr><span class="ft8">by 1. Delayed aggregation thus trades off increased communica-<br>tion during the aggregation phase in return for a more balanced<br>commitment tree, which results in lower verification overhead in<br>the result-checking phase. Greenwald and Khanna [6] used a form<br>of delayed aggregation in their quantile summary algorithm.</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:94"><nobr><span class="ft4">Our strategy for delayed aggregation is as follows: we perform</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:81"><nobr><span class="ft8">an aggregation operation (along with the associated commit oper-<br>ation) if and only if it results in a complete, binary commitment<br>tree.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:94"><nobr><span class="ft4">We now describe our delayed aggregation algorithm for produc-</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft8">ing balanced commitment trees. In the naive commitment tree,<br>each sensor node passes to its parent a single message contain-<br>ing the label of the root vertex of its commitment subtree T</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:412"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:417"><nobr><span class="ft4">. In</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">the delayed aggregation algorithm, each sensor node now passes<br>on the labels of the root vertices of a set of commitment subtrees<br>F</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:489"><nobr><span class="ft4">= {T</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:516"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:522"><nobr><span class="ft4">,...,T</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:555"><nobr><span class="ft1">q</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:561"><nobr><span class="ft4">}. We call this set a commitment forest, and we</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:475"><nobr><span class="ft8">enforce the condition that the trees in the forest must be complete<br>binary trees, and no two trees have the same height. These con-<br>straints are enforced by continually combining equal-height trees<br>into complete binary trees of greater height.</span></nobr></DIV>
<DIV style="position:absolute;top:220;left:475"><nobr><span class="ft8">Definition 5 A commitment forest is a set of complete binary com-<br>mitment trees such that there is at most one commitment tree of any<br>given height.</span></nobr></DIV>
<DIV style="position:absolute;top:282;left:489"><nobr><span class="ft4">A commitment forest has at most n leaf vertices (one for each</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:475"><nobr><span class="ft8">sensor node included in the forest, up to a maximum of n). Since<br>all the trees are complete binary trees, the tallest tree in any com-<br>mitment forest has height at most log n. Since there are no two trees<br>of the same height, any commitment forest has at most log n trees.</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:489"><nobr><span class="ft4">In the following discussion, we will for brevity make reference</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:475"><nobr><span class="ft8">to "communicating a vertex" to another sensor node, or "commu-<br>nicating a commitment forest" to another sensor node. The actual<br>data communicated is the label of the vertex and the labels of the<br>roots of the trees in the commitment forest, respectively.</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:489"><nobr><span class="ft4">The commitment forest is built as follows. Leaf sensor nodes in</span></nobr></DIV>
<DIV style="position:absolute;top:455;left:475"><nobr><span class="ft8">the aggregation tree originate a single-vertex commitment forest,<br>which they then communicate to their parent sensor nodes. Each<br>internal sensor node s originates a similar single-vertex commit-<br>ment forest. In addition, s also receives commitment forests from<br>each of its children. Sensor node s keeps track of which root ver-<br>tices were received from which of its children. It then combines all<br>the forests to form a new forest as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:489"><nobr><span class="ft4">Suppose s wishes to combine q commitment forests F</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:786"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:792"><nobr><span class="ft4">,...,F</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:825"><nobr><span class="ft1">q</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:831"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:475"><nobr><span class="ft8">Note that since all commitment trees are complete binary trees, tree<br>heights can be determined by inspecting the count field of the<br>root vertex. We let the intermediate result be F</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:730"><nobr><span class="ft4">= F</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:750"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:758"><nobr><span class="ft4"> ···F</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:802"><nobr><span class="ft1">q</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:808"><nobr><span class="ft4">, and</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:475"><nobr><span class="ft8">repeat the following until no two trees are the same height in F:<br>Let h be the smallest height such that more than one tree in F has<br>height h. Find two commitment trees T</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:692"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:702"><nobr><span class="ft4">and T</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:732"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:742"><nobr><span class="ft4">of height h in F,</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:475"><nobr><span class="ft4">and merge them into a tree of height h</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:681"><nobr><span class="ft4">+1 by creating a new vertex</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:475"><nobr><span class="ft4">that is the parent of both the roots of T</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:693"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:703"><nobr><span class="ft4">and T</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:734"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:745"><nobr><span class="ft4">according to the</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:475"><nobr><span class="ft8">inductive rule in Definition 3. Figure 3 shows an example of the<br>process for node A based on the topology in Figure 1.</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:489"><nobr><span class="ft4">The algorithm terminates in O</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:654"><nobr><span class="ft4">(qlogn) steps since each step re-</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:475"><nobr><span class="ft8">duces the number of trees in the forest by one, and there are at most<br>q log n</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:511"><nobr><span class="ft4">+ 1 trees in the forest. Hence, each sensor node creates at</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:475"><nobr><span class="ft4">most q log n</span></nobr></DIV>
<DIV style="position:absolute;top:781;left:540"><nobr><span class="ft4">+ 1 = O(logn) vertices in the commitment forest.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:489"><nobr><span class="ft4">When F is a valid commitment forest, s sends the root vertices of</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:475"><nobr><span class="ft8">each tree in F to its parent sensor node in the aggregation tree. The<br>sensor node s also keeps track of every vertex that it created, as well<br>as all the inputs that it received (i.e., the labels of the root vertices<br>of the commitment forests that were sent to s by its children). This<br>takes O</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:516"><nobr><span class="ft4">(d logn) memory per sensor node.</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:489"><nobr><span class="ft4">Consider the communication costs of the entire process of creat-</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:475"><nobr><span class="ft8">ing the final commitment forest. Since there are at most log n com-<br>mitment trees in each of the forests presented by any sensor node to<br>its parent, the per-node communication cost for constructing the fi-<br>nal forest is O</span></nobr></DIV>
<DIV style="position:absolute;top:953;left:551"><nobr><span class="ft4">(logn). This is greater than the O(1) congestion cost</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:475"><nobr><span class="ft8">of constructing the naive commitment tree. However, no path in the<br>forest is longer than log n hops. This will eventually enable us to<br>prove a bound of O</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:578"><nobr><span class="ft4">(log</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:601"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:608"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:615"><nobr><span class="ft4">) edge congestion for the result-checking</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:475"><nobr><span class="ft4">phase in Section 5.2.</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:489"><nobr><span class="ft4">Once the querier has received the final commitment forest from</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:475"><nobr><span class="ft4">the base station, it checks that none of the</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:709"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:738"><nobr><span class="ft4">or</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:753"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:475"><nobr><span class="ft4">aggregates of the roots of the trees in the forest are negative. If</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">282</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft14{font-size:11px;line-height:19px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="175006.png" alt="background image">
<DIV style="position:absolute;top:93;left:536"><nobr><span class="ft4">A</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:544"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:90;left:553"><nobr><span class="ft4">= 1,a</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:590"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:90;left:597"><nobr><span class="ft4">,r - a</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:629"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:90;left:636"><nobr><span class="ft4">,A</span></nobr></DIV>
<DIV style="position:absolute;top:120;left:536"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:545"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:554"><nobr><span class="ft4">= 1,a</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:592"><nobr><span class="ft1">D</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:600"><nobr><span class="ft4">,r - a</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:632"><nobr><span class="ft1">D</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:640"><nobr><span class="ft4">,D</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:536"><nobr><span class="ft4">K</span></nobr></DIV>
<DIV style="position:absolute;top:208;left:544"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:553"><nobr><span class="ft4">= 1,a</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:591"><nobr><span class="ft1">K</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:599"><nobr><span class="ft4">,r - a</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:631"><nobr><span class="ft1">K</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:639"><nobr><span class="ft4">,K</span></nobr></DIV>
<DIV style="position:absolute;top:148;left:535"><nobr><span class="ft4">C</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:544"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:553"><nobr><span class="ft4">= 4,v</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:589"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:595"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:601"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:611"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:618"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:623"><nobr><span class="ft4">,H[N||4||v</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:681"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:687"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:692"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:705"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:712"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:717"><nobr><span class="ft4">||F</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:732"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:738"><nobr><span class="ft4">||C</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:753"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:759"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:536"><nobr><span class="ft4">B</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:544"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:553"><nobr><span class="ft4">= 2,v</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:589"><nobr><span class="ft1">B</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:596"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:601"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:612"><nobr><span class="ft1">B</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:619"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:624"><nobr><span class="ft4">,H[N||2||v</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:682"><nobr><span class="ft1">B</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:688"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:693"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:707"><nobr><span class="ft1">B</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:713"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:718"><nobr><span class="ft4">||B</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:734"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:740"><nobr><span class="ft4">||J</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:753"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:759"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:93"><nobr><span class="ft4">(a) Inputs: A generates A</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:232"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:238"><nobr><span class="ft4">, and receives D</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:327"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:338"><nobr><span class="ft4">from D, C</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:394"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:404"><nobr><span class="ft4">from C, and</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:475"><nobr><span class="ft4">(B</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:489"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:495"><nobr><span class="ft4">,K</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:509"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:514"><nobr><span class="ft4">) from B. Each dashed-line box shows the commitment</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:93"><nobr><span class="ft9">forest received from a given sensor node. The solid-line box shows the vertex labels, each solid-line box below shows the labels of the<br>new vertices.</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:532"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:537"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:319;left:544"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:307;left:552"><nobr><span class="ft4">= a</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:572"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:307;left:581"><nobr><span class="ft4">+ a</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:600"><nobr><span class="ft1">D</span></nobr></DIV>
<DIV style="position:absolute;top:338;left:532"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:537"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:544"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:552"><nobr><span class="ft4">= r - a</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:592"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:601"><nobr><span class="ft4">+ r - a</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:640"><nobr><span class="ft1">D</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:532"><nobr><span class="ft4">A</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:540"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:549"><nobr><span class="ft4">= 2,v</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:585"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:374;left:592"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:597"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:608"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:374;left:614"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:620"><nobr><span class="ft4">,H[N||2||v</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:678"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:374;left:684"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:689"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:702"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:374;left:709"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:714"><nobr><span class="ft4">||A</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:730"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:736"><nobr><span class="ft4">||D</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:753"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:759"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:365"><nobr><span class="ft4">(b) First merge: Vertex A</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:501"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:511"><nobr><span class="ft4">created</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:531"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:537"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:543"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:551"><nobr><span class="ft4">= v</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:571"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:577"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:584"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:602"><nobr><span class="ft1">B</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:609"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:484;left:531"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:537"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:543"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:551"><nobr><span class="ft4">= v</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:571"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:577"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:584"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:602"><nobr><span class="ft1">B</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:609"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:531"><nobr><span class="ft4">A</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:539"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:548"><nobr><span class="ft4">= 4,v</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:584"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:591"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:596"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:607"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:614"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:619"><nobr><span class="ft4">,H[N||4||v</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:677"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:683"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:688"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:702"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:708"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:713"><nobr><span class="ft4">||A</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:729"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:735"><nobr><span class="ft4">||B</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:751"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:757"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:358"><nobr><span class="ft4">(c) Second merge: Vertex A</span></nobr></DIV>
<DIV style="position:absolute;top:564;left:508"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:518"><nobr><span class="ft4">created</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:531"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:537"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:543"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:552"><nobr><span class="ft4">= v</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:571"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:577"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:584"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:602"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:609"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:531"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:537"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:543"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:552"><nobr><span class="ft4">= v</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:571"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:577"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:584"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:602"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:609"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:531"><nobr><span class="ft4">A</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:539"><nobr><span class="ft1">3</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:548"><nobr><span class="ft4">= 8,v</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:585"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:591"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:596"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:608"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:614"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:619"><nobr><span class="ft4">,H[N||8||v</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:677"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:683"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:689"><nobr><span class="ft4">||v</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:702"><nobr><span class="ft1">A</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:708"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:714"><nobr><span class="ft4">||A</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:729"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:735"><nobr><span class="ft4">||C</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:751"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:757"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:198"><nobr><span class="ft4">(d) Final merge: Vertex A</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:337"><nobr><span class="ft1">3</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:346"><nobr><span class="ft4">created. A</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:401"><nobr><span class="ft1">3</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:410"><nobr><span class="ft4">and K</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:442"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:451"><nobr><span class="ft4">are sent to the parent of A in the aggregation tree.</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:82"><nobr><span class="ft4">Figure 3: Process of node A (from Figure 1) deriving its commitment forest from the commitment forests received from its children.</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:81"><nobr><span class="ft8">any aggregates are negative, the querier rejects the result and raises<br>an alarm: a negative aggregate is a sure sign of tampering since<br>all the data values (and their complements) are non-negative. Oth-<br>erwise, the querier then computes the final pair of aggregates</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:414"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:81"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:103"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:184"><nobr><span class="ft4">. The querier verifies that</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:321"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:348"><nobr><span class="ft4">+</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:359"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:884;left:81"><nobr><span class="ft8">= nr where r is the upper bound on the range of allowable data val-<br>ues on each node. If this verifies correctly, the querier then initiates<br>the result-checking phase.</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:81"><nobr><span class="ft2">4.3</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:121"><nobr><span class="ft2">Result-checking phase</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:94"><nobr><span class="ft4">The purpose of the result-checking phase is to enable each sensor</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:81"><nobr><span class="ft4">node s to independently verify that its data value a</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:351"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:359"><nobr><span class="ft4">was added into</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:81"><nobr><span class="ft4">the</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:102"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:131"><nobr><span class="ft4">aggregate, and the complement</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:305"><nobr><span class="ft4">(r - a</span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:338"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:342"><nobr><span class="ft4">) of its data value</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft4">was added into the</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:190"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:275"><nobr><span class="ft4">aggregate. The verification is</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft8">performed by inspecting the inputs and aggregation operations in<br>the commitment forest on the path from the leaf vertex of s to the<br>root of its tree; if all the operations are consistent, then the root</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:475"><nobr><span class="ft4">aggregate value must have increased by a</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:697"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:705"><nobr><span class="ft4">due to the incorporation</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:475"><nobr><span class="ft8">of the data value. If each legitimate node performs this verification,<br>then it ensures that the</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:601"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:630"><nobr><span class="ft4">aggregate is at least the sum of all the</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:475"><nobr><span class="ft4">data values of the legitimate nodes. Similarly, the</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:753"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:475"><nobr><span class="ft8">aggregate is at least the sum of all the complements of the data<br>values of the legitimate nodes. Since the querier enforces</span></nobr></DIV>
<DIV style="position:absolute;top:890;left:797"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:826"><nobr><span class="ft4">+</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:476"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:560"><nobr><span class="ft4">= nr, these two inequalities form lower and upper</span></nobr></DIV>
<DIV style="position:absolute;top:919;left:475"><nobr><span class="ft8">bounds on an adversary's ability to manipulate the final result. In<br>Section 5 we shall show that they are in fact the tightest bounds<br>possible.</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:489"><nobr><span class="ft4">A high level overview of the process is as follows. First, the</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:475"><nobr><span class="ft8">aggregation results from the aggregation-commit phase are sent us-<br>ing authenticated broadcast to every sensor node in the network.<br>Each sensor node then individually verifies that its contributions<br>to the respective</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:569"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:598"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:622"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:706"><nobr><span class="ft4">aggregates were indeed</span></nobr></DIV>
<DIV style="position:absolute;top:1045;left:475"><nobr><span class="ft8">counted. If so, it sends an authentication code to the base station.<br>The authentication code is also aggregated for communication effi-</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">283</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="175007.png" alt="background image">
<DIV style="position:absolute;top:248;left:81"><nobr><span class="ft8">Figure 4: Dissemination of off-path values: t sends the label of<br>u</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:87"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:98"><nobr><span class="ft4">to u</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:121"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:131"><nobr><span class="ft4">and vice-versa; each node then forwards it to all the</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:81"><nobr><span class="ft4">vertices in their subtrees.</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:81"><nobr><span class="ft8">ciency. When the querier has received all the authentication codes,<br>it is then able to verify that all sensor nodes have checked that their<br>contribution to the aggregate has been correctly counted.</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:94"><nobr><span class="ft4">For simplicity, we describe each step of the process with refer-</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:81"><nobr><span class="ft8">ence to the commitment tree visualised as an overlay network over<br>the actual aggregation tree. Hence, we will refer to vertices in the<br>commitment tree sending information to each other; in the physical<br>world, it is the sensor node that created the vertex is the physical<br>entity that is responsible for performing communications and com-<br>putations on behalf of the vertex. Each edge in the commitment<br>tree may involve multiple hops in the aggregation tree; the routing<br>on the aggregation tree is straightforward.</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:94"><nobr><span class="ft4">Dissemination of final commitment values. After the querier</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:81"><nobr><span class="ft8">has received the labels of the roots of the final commitment forest,<br>the querier sends each of these labels to the entire sensor network<br>using authenticated broadcast.</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:94"><nobr><span class="ft4">Dissemination of off-path values. To enable verification, each</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:81"><nobr><span class="ft8">leaf vertex must receive all its off-path values. Each internal vertex<br>t in the commitment forest has two children u</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:325"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:334"><nobr><span class="ft4">and u</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:363"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:369"><nobr><span class="ft4">. To dissemi-</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:81"><nobr><span class="ft4">nate off-path values, t sends the label of u</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:306"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:316"><nobr><span class="ft4">to u</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:336"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:342"><nobr><span class="ft4">, and vice-versa (t</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:81"><nobr><span class="ft4">also attaches relevant information tagging u</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:316"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:326"><nobr><span class="ft4">as the right child and</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:81"><nobr><span class="ft4">u</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:87"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:98"><nobr><span class="ft4">as the left child). Vertex t also sends any labels (and left/right</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:81"><nobr><span class="ft8">tags) received from its parent to both its children. See Figure 4 for<br>an illustration of the process. The correctness of this algorithm in<br>delivering all the necessary off-path vertex labels to each vertex is<br>proven in Theorem 14 in Section 5.2. Once a vertex has received all<br>the labels of its off-path vertices, it can proceed to the verification<br>step.</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:94"><nobr><span class="ft4">Verification of inclusion. When the leaf vertex u</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:370"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:379"><nobr><span class="ft4">of a sensor</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:81"><nobr><span class="ft8">node s has received all the labels of its off-path vertices, it may<br>then verify that no aggregation result-tampering has occurred on<br>the path between u</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:183"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:192"><nobr><span class="ft4">and the root of its commitment tree. For each</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:81"><nobr><span class="ft4">vertex t on the path from u</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:228"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:236"><nobr><span class="ft4">to the root of its commitment tree, u</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:435"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:81"><nobr><span class="ft8">derives the label of t (via the computations in Definition 3). It is<br>able to do so since the off-path labels provide all the necessary data<br>to perform the label computation. During the computation, u</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:415"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:424"><nobr><span class="ft4">in-</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:81"><nobr><span class="ft4">spects the off-path labels: for each node t on the path from u</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:402"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:409"><nobr><span class="ft4">to the</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:81"><nobr><span class="ft4">root, u</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:116"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:125"><nobr><span class="ft4">checks that the input values fed into the aggregation oper-</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:81"><nobr><span class="ft8">ation at t are never negative. Negative values should never occur<br>since the data and complement values are non-negative; hence if<br>a negative input is encountered, the verification fails. Once u</span></nobr></DIV>
<DIV style="position:absolute;top:961;left:413"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:421"><nobr><span class="ft4">has</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:81"><nobr><span class="ft8">derived the label of the root of its commitment tree, it compares<br>the derived label against the label with the same count that was<br>disseminated by the querier. If the labels are identical, then u</span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:409"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:417"><nobr><span class="ft4">pro-</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft4">ceeds to the next step. Otherwise, the verification fails and u</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:408"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:416"><nobr><span class="ft4">may</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft8">either immediately raise an alarm (for example, using broadcast),<br>or it may simply do nothing and allow the aggregate algorithm to<br>fail due to the absence of its confirmation message in the subse-<br>quent steps.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:489"><nobr><span class="ft4">Collection of confirmations. After each sensor node s has suc-</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:475"><nobr><span class="ft4">cessfully performed the verification step for its leaf vertex u</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:813"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:817"><nobr><span class="ft4">, it</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:475"><nobr><span class="ft8">sends an authentication code to the querier. The authentication code<br>for sensor node s is MAC</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:610"><nobr><span class="ft1">K</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:617"><nobr><span class="ft11">s</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:620"><nobr><span class="ft4">(N||OK) where OK is a unique message</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:475"><nobr><span class="ft4">identifier and K</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:559"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:568"><nobr><span class="ft4">is the key that s shares with the querier. The col-</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:475"><nobr><span class="ft8">lation of the authentication codes proceeds as follows (note that we<br>are referring to the aggregation tree at this point, not the commit-<br>ment tree). Leaf sensor nodes in the aggregation tree first send their<br>authentication codes to their parents in the aggregation tree. Once<br>an internal sensor node has received authentication codes from all<br>its children, it computes the XOR of its own authentication code<br>with all the received codes, and forwards it to its parent. At the end<br>of the process, the querier will receive a single authentication code<br>from the base station that consists of the XOR of all the authenti-<br>cation codes received in the network.</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:489"><nobr><span class="ft4">Verification of confirmations. Since the querier knows the key</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:475"><nobr><span class="ft4">K</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:484"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:494"><nobr><span class="ft4">for each sensor node s, it verifies that every sensor node has</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:475"><nobr><span class="ft8">released its authentication code by computing the XOR of the au-<br>thentication codes for all the sensor nodes in the network, i.e.,<br>MAC</span></nobr></DIV>
<DIV style="position:absolute;top:389;left:505"><nobr><span class="ft1">K</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:512"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:517"><nobr><span class="ft4">(N||OK)  ···  MAC</span></nobr></DIV>
<DIV style="position:absolute;top:389;left:639"><nobr><span class="ft1">K</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:645"><nobr><span class="ft11">n</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:650"><nobr><span class="ft4">(N||OK). The querier then com-</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:475"><nobr><span class="ft8">pares the computed code with the received code. If the two codes<br>match, then the querier accepts the aggregation result. Otherwise,<br>the querier rejects the result. A rejection may indicate the presence<br>of the adversary in some unknown nodes in the network, or it may<br>be due to natural factors such as node death or message loss. The<br>querier may either retry the query or attempt to determine the cause<br>of the rejection. For example, it could directly request the leaf val-<br>ues of every sensor node: if rejections due to natural causes are<br>sufficiently rare, the high cost of this direct query is incurred infre-<br>quently and can be amortised over the other successful queries.</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:475"><nobr><span class="ft2">5.</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:507"><nobr><span class="ft2">ANALYSIS OF SUM</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:489"><nobr><span class="ft4">In this section we prove the properties of the</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:734"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:762"><nobr><span class="ft4">algorithm. In</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:475"><nobr><span class="ft8">Section 5.1 we prove the security properties of the algorithm, and<br>in Section 5.2 we prove bounds on the congestion of the algorithm.</span></nobr></DIV>
<DIV style="position:absolute;top:656;left:475"><nobr><span class="ft2">5.1</span></nobr></DIV>
<DIV style="position:absolute;top:656;left:516"><nobr><span class="ft2">Security Properties</span></nobr></DIV>
<DIV style="position:absolute;top:678;left:489"><nobr><span class="ft4">We assume that the adversary is able to freely choose any ar-</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:475"><nobr><span class="ft8">bitrary topology and set of labels for the final commitment forest.<br>We then show that any such forest which passes all the verification<br>tests must report an aggregate result that is (optimally) close to the<br>actual result. First, we define the notion of an inconsistency, or<br>evidence of tampering, at a given node in the commitment forest.</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:475"><nobr><span class="ft4">Definition 6 Let t</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:578"><nobr><span class="ft4">= c</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:602"><nobr><span class="ft1">t</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:607"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:618"><nobr><span class="ft1">t</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:622"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:633"><nobr><span class="ft1">t</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:637"><nobr><span class="ft4">,H</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:652"><nobr><span class="ft1">t</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:665"><nobr><span class="ft4">be an internal vertex in a com-</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:475"><nobr><span class="ft4">mitment forest. Let its two children be u</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:707"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:717"><nobr><span class="ft4">= c</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:742"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:748"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:759"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:765"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:777"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:783"><nobr><span class="ft4">,H</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:797"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:814"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:475"><nobr><span class="ft4">u</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:482"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:490"><nobr><span class="ft4">= c</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:515"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:521"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:532"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:538"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:549"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:555"><nobr><span class="ft4">,H</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:570"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:581"><nobr><span class="ft4">. There is an inconsistency at vertex t in a com-</span></nobr></DIV>
<DIV style="position:absolute;top:840;left:475"><nobr><span class="ft4">mitment tree if either (1) v</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:618"><nobr><span class="ft1">t</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:625"><nobr><span class="ft4">= v</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:645"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:653"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:671"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:840;left:681"><nobr><span class="ft4">or v</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:702"><nobr><span class="ft1">t</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:710"><nobr><span class="ft4">= v</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:729"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:737"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:756"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:840;left:765"><nobr><span class="ft4">or (2) any of</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:475"><nobr><span class="ft4">{v</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:488"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:494"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:505"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:511"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:522"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:528"><nobr><span class="ft4">,v</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:539"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:545"><nobr><span class="ft4">} is negative.</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:489"><nobr><span class="ft4">Informally, an inconsistency occurs at t if the sums don't add up</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:475"><nobr><span class="ft8">at t, or if any of the inputs to t are negative. Intuitively, if there<br>are no inconsistencies on a path from a vertex to the root of the<br>commitment tree, then the aggregate value along the path should<br>be non-decreasing towards the root.</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:475"><nobr><span class="ft8">Definition 7 Call a leaf-vertex u accounted-for if there is no in-<br>consistency at any vertex on the path from the leaf-vertex u to the<br>root of its commitment tree, including at the root vertex.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:475"><nobr><span class="ft8">Lemma 8 Suppose there is a set of accounted-for leaf-vertices with<br>distinct labels u</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:563"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:1063;left:569"><nobr><span class="ft4">,...,u</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:601"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:614"><nobr><span class="ft4">and committed data values v</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:773"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:1063;left:779"><nobr><span class="ft4">,...,v</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:811"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:823"><nobr><span class="ft4">in</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">284</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="175008.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">the commitment forest. Then the total of the aggregation values at<br>the roots of the commitment trees in the forest is at least</span></nobr></DIV>
<DIV style="position:absolute;top:100;left:385"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:99;left:394"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:394"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:397"><nobr><span class="ft1">=1</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:413"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:419"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:422"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:94"><nobr><span class="ft4">Lemma 8 can be rigorously proven using induction on the height</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:81"><nobr><span class="ft8">of the subtrees in the forest (see Appendix A). Here we present a<br>more intuitive argument.</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:96"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:104"><nobr><span class="ft1">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:134"><nobr><span class="ft4">. (Sketch) We show the result for m</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:337"><nobr><span class="ft4">= 2; a similar rea-</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:81"><nobr><span class="ft4">soning applies for arbitrary m. Case 1: Suppose u</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:357"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:368"><nobr><span class="ft4">and u</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:398"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:408"><nobr><span class="ft4">are in</span></nobr></DIV>
<DIV style="position:absolute;top:211;left:81"><nobr><span class="ft8">different trees. Then, since there is no inconsistency on any ver-<br>tex on the path from u</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:204"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:226;left:214"><nobr><span class="ft4">to the root of its tree, the root of the tree</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:81"><nobr><span class="ft4">containing u</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:148"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:158"><nobr><span class="ft4">must have an aggregation value of at least v</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:398"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:404"><nobr><span class="ft4">. By a</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:81"><nobr><span class="ft4">similar reasoning, the root of the tree containing u</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:357"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:367"><nobr><span class="ft4">must have an</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:81"><nobr><span class="ft4">aggregation value of at least v</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:243"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:249"><nobr><span class="ft4">. Hence the total aggregation value</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:81"><nobr><span class="ft4">of the two trees containing u</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:234"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:243"><nobr><span class="ft4">and u</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:273"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:282"><nobr><span class="ft4">is at least v</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:342"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:350"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:368"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:374"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:94"><nobr><span class="ft4">Case 2: Now suppose u</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:221"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:231"><nobr><span class="ft4">and u</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:261"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:270"><nobr><span class="ft4">are in the same tree. Since they</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:81"><nobr><span class="ft8">have distinct labels, they must be distinct vertices, and they must<br>have a lowest common ancestor t in the commitment tree. The ver-<br>tices between u</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:164"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:352;left:174"><nobr><span class="ft4">and t (including u</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:271"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:352;left:277"><nobr><span class="ft4">) must have aggregation value</span></nobr></DIV>
<DIV style="position:absolute;top:368;left:81"><nobr><span class="ft4">at least v</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:130"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:368;left:141"><nobr><span class="ft4">since there are no inconsistencies on the path from u</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:433"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:81"><nobr><span class="ft8">to t, so the aggregation value could not have decreased. Similarly,<br>the vertices between u</span></nobr></DIV>
<DIV style="position:absolute;top:403;left:200"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:209"><nobr><span class="ft4">and t (including u</span></nobr></DIV>
<DIV style="position:absolute;top:403;left:305"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:311"><nobr><span class="ft4">) must have aggregation</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:81"><nobr><span class="ft4">value at least v</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:163"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:169"><nobr><span class="ft4">. Hence, one of the children of t has aggregation</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:81"><nobr><span class="ft4">value at least v</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:165"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:176"><nobr><span class="ft4">and the other has aggregation value at least v</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:430"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:436"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:81"><nobr><span class="ft8">Since there was no inconsistency at t, vertex t must have aggrega-<br>tion value at least v</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:183"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:191"><nobr><span class="ft4">+v</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:209"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:462;left:215"><nobr><span class="ft4">. Since there are no inconsistencies on the</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:81"><nobr><span class="ft8">path from t to the root of the commitment tree, the root also must<br>have aggregation value at least v</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:255"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:263"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:281"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:287"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:94"><nobr><span class="ft4">Negative root aggregate values are detected by the querier at the</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:81"><nobr><span class="ft8">end of the aggregate-commit phase, so the total sum of the aggre-<br>gate values of the roots of all the trees is thus at least v</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:374"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:381"><nobr><span class="ft4">+ v</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:400"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:406"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:94"><nobr><span class="ft4">The following is a restatement of Lemma 8 for the</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:387"><nobr><span class="ft1">COMPLE</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:435"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:81"><nobr><span class="ft1">MENTARY SUM</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:170"><nobr><span class="ft4">aggregate; its proof follows an identical structure</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:81"><nobr><span class="ft4">and is thus omitted.</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:81"><nobr><span class="ft8">Lemma 9 Suppose there is a set of accounted-for leaf vertices<br>with distinct labels u</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:196"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:202"><nobr><span class="ft4">,...,u</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:235"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:247"><nobr><span class="ft4">with committed complement values</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:81"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:87"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:93"><nobr><span class="ft4">,...,v</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:125"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:137"><nobr><span class="ft4">in the commitment forest. Then the total</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:359"><nobr><span class="ft1">COMPLEMENT</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:81"><nobr><span class="ft8">aggregation value of the roots of the commitment trees in the forest<br>is at least</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:136"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:686;left:145"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:145"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:148"><nobr><span class="ft1">=1</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:164"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:170"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:173"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:81"><nobr><span class="ft8">Lemma 10 A legitimate sensor node will only release its confir-<br>mation MAC if it is accounted-for.</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:96"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:104"><nobr><span class="ft1">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:134"><nobr><span class="ft4">. By construction, each sensor node s only releases its</span></nobr></DIV>
<DIV style="position:absolute;top:771;left:81"><nobr><span class="ft8">confirmation MAC if (1) s receives an authenticated message from<br>the querier containing the query nonce N and the root labels of all<br>the trees in the final commitment forest and (2) s receives all labels<br>of its off-path vertices (the sibling vertices to the vertices on the<br>path from the leaf vertex corresponding to s to the root of the com-<br>mitment tree containing the leaf vertex in the commitment forest),<br>and (3) s is able to recompute the root commitment value that it<br>received from the base station and correctly authenticated, and (4)<br>s verified that all the computations on the path from its leaf vertex<br>u</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:87"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:912;left:96"><nobr><span class="ft4">to the root of its commitment tree are correct, i.e., there are no</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:81"><nobr><span class="ft4">inconsistencies on the path from u</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:267"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:276"><nobr><span class="ft4">to the root of the commitment</span></nobr></DIV>
<DIV style="position:absolute;top:944;left:81"><nobr><span class="ft4">tree containing u</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:174"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:944;left:179"><nobr><span class="ft4">. Since the hash function is collision-resistant,</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:81"><nobr><span class="ft8">it is computationally infeasible for an adversary to provide s with<br>false labels that also happen to compute to the correct root com-<br>mitment value. Hence, it must be that s was accounted-for in the<br>commitment forest.</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:81"><nobr><span class="ft8">Lemma 11 The querier can only receive the correct final XOR<br>check value if all the legitimate sensor nodes replied with their con-<br>firmation MACs.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:490"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:88;left:499"><nobr><span class="ft1">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:529"><nobr><span class="ft4">. To compute the correct final XOR check value, the ad-</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:475"><nobr><span class="ft8">versary needs to know the XOR of all the legitimate sensor nodes<br>that did not release their MAC. Since we assume that each of the<br>distinct MACs are unforgeable (and not correlated with each other),<br>the adversary has no information about this XOR value. Hence, the<br>only way to produce the correct XOR check value is for all the<br>legitimate sensor nodes to have released their relevant MACs.</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:475"><nobr><span class="ft4">Theorem 12 Let the final</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:621"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:650"><nobr><span class="ft4">aggregate received by the querier</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:475"><nobr><span class="ft4">be S. If the querier accepts S, then S</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:672"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:681"><nobr><span class="ft4"> S  (S</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:730"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:739"><nobr><span class="ft4">+ µr) where S</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:815"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:825"><nobr><span class="ft4">is</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:475"><nobr><span class="ft8">the sum of the data values of all the legitimate nodes, µ is the total<br>number of malicious nodes, and r is the upper bound on the range<br>of allowable values on each node.</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:490"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:499"><nobr><span class="ft1">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:529"><nobr><span class="ft4">. Suppose the querier accepts the</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:716"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:745"><nobr><span class="ft4">result S. Let the</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:476"><nobr><span class="ft1">COMPLEMENT SUM</span></nobr></DIV>
<DIV style="position:absolute;top:314;left:589"><nobr><span class="ft4">received by the querier be S. The querier ac-</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:475"><nobr><span class="ft8">cepts S if and only if it receives the correct final XOR check value<br>in the result-checking phase, and S</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:666"><nobr><span class="ft4">+ S = nr. Since the querier re-</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:475"><nobr><span class="ft8">ceived the correct XOR check value, we know that each legitimate<br>sensor node must have released its confirmation MAC (Lemma 11),<br>and so the leaf vertices of each legitimate sensor node must be<br>accounted-for (Lemma 10). The set of labels of the leaf vertices of<br>the legitimate nodes is distinct since the labels contain the (unique)<br>node ID of each legitimate node. Since all the leaf vertices of the le-<br>gitimate sensor nodes are distinct and accounted-for, by Theorem 8,<br>S</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:485"><nobr><span class="ft4"> S</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:506"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:516"><nobr><span class="ft4">where S</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:559"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:570"><nobr><span class="ft4">is the sum of the data values of all the legitimate</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:475"><nobr><span class="ft4">nodes. Furthermore, by Theorem 9, S</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:688"><nobr><span class="ft4"> S</span></nobr></DIV>
<DIV style="position:absolute;top:491;left:708"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:715"><nobr><span class="ft4">, where S</span></nobr></DIV>
<DIV style="position:absolute;top:491;left:767"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:777"><nobr><span class="ft4">is the sum</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:475"><nobr><span class="ft8">of the complements of the data values of all the legitimate nodes.<br>Let L be the set of legitimate sensor nodes, with</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:743"><nobr><span class="ft4">|L| = l. Observe</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:475"><nobr><span class="ft4">that S</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:506"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:517"><nobr><span class="ft4">= </span></nobr></DIV>
<DIV style="position:absolute;top:539;left:540"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:536;left:543"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:558"><nobr><span class="ft4">r</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:566"><nobr><span class="ft4">- a</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:585"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:593"><nobr><span class="ft4">= lr - S</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:638"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:648"><nobr><span class="ft4">= (n - µ)r - S</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:728"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:738"><nobr><span class="ft4">= nr - (S</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:792"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:800"><nobr><span class="ft4">+ µr).</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:475"><nobr><span class="ft4">We have that S</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:564"><nobr><span class="ft4">+ S = nr and S  nr - (S</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:711"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:721"><nobr><span class="ft4">+ µr). Substituting,</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:475"><nobr><span class="ft4">S</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:485"><nobr><span class="ft4">= nr - S  S</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:555"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:563"><nobr><span class="ft4">+ µr. Hence, S</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:643"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:653"><nobr><span class="ft4"> S  (S</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:702"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:710"><nobr><span class="ft4">+ µr).</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:489"><nobr><span class="ft4">Note that nowhere was it assumed that the malicious nodes were</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:475"><nobr><span class="ft4">constrained to reporting data values between</span></nobr></DIV>
<DIV style="position:absolute;top:605;left:718"><nobr><span class="ft4">[0,r]: in fact it is pos-</span></nobr></DIV>
<DIV style="position:absolute;top:624;left:475"><nobr><span class="ft8">sible to have malicious nodes with data values above r or below 0<br>without risking detection if S</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:631"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:641"><nobr><span class="ft4"> S  (S</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:690"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:698"><nobr><span class="ft4">+ µr).</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:475"><nobr><span class="ft4">Theorem 13 The</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:575"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:603"><nobr><span class="ft4">algorithm is optimally secure.</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:490"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:499"><nobr><span class="ft1">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:529"><nobr><span class="ft4">. Let the sum of the data values of all the legitimate nodes</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:475"><nobr><span class="ft4">be S</span></nobr></DIV>
<DIV style="position:absolute;top:714;left:499"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:505"><nobr><span class="ft4">. Consider an adversary with µ malicious nodes which only</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:475"><nobr><span class="ft8">performs direct data injection attacks. Recall that in a direct data in-<br>jection attack, an adversary only causes the nodes under its control<br>to each report a data value within the legal range</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:742"><nobr><span class="ft4">[0,r]. The lowest</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:475"><nobr><span class="ft8">result the adversary can induce is by setting all its malicious nodes<br>to have data value 0; in this case the computed aggregate is S</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:799"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:806"><nobr><span class="ft4">. The</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:475"><nobr><span class="ft8">highest result the adversary can induce is by setting all µ nodes un-<br>der its control to yield the highest value r. In this case the computed<br>aggregate is S</span></nobr></DIV>
<DIV style="position:absolute;top:840;left:550"><nobr><span class="ft1">L</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:559"><nobr><span class="ft4">+ µr. Clearly any aggregation value between these</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:475"><nobr><span class="ft8">two extremes is also achievable by direct data injection. The bound<br>proven in Theorem 12 falls exactly on the range of possible results<br>achievable by direct data injection, hence the algorithm is optimal<br>by Definition 2.</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:489"><nobr><span class="ft4">The optimal security property holds regardless of the number or</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:475"><nobr><span class="ft8">fraction of malicious nodes; this is significant since the security<br>property holds in general, and not just for a subclass of attacker<br>multiplicities. For example, we do not assume that the attacker is<br>limited to some</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:562"><nobr><span class="ft4"> fraction of the nodes in the network.</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:475"><nobr><span class="ft2">5.2</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:516"><nobr><span class="ft2">Congestion Complexity</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:489"><nobr><span class="ft4">We now consider the congestion induced by the secure</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:791"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:820"><nobr><span class="ft4">al-</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:475"><nobr><span class="ft8">gorithm. Recall that node congestion is defined as the communi-<br>cation load on the most heavily loaded sensor node in the network,</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">285</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="175009.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">and edge congestion is the heaviest communication load on a given<br>link in the network. We only need to consider the case where the<br>adversary is not performing an attack. If the adversary attempts<br>to send more messages than the proven congestion bound, legiti-<br>mate nodes can easily detect this locally and either raise an alarm<br>or refuse to respond with their confirmation values, thus expos-<br>ing the presence of the adversary. Recall that when we refer to a<br>vertex sending and receiving information, we are referring to the<br>commitment tree overlay network that lies over the actual physical<br>aggregation tree.</span></nobr></DIV>
<DIV style="position:absolute;top:260;left:81"><nobr><span class="ft8">Theorem 14 Each vertex u receives the labels of its off-path ver-<br>tices and no others.</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:96"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:104"><nobr><span class="ft1">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:134"><nobr><span class="ft4">. Since, when the vertices are disseminating their labels</span></nobr></DIV>
<DIV style="position:absolute;top:314;left:81"><nobr><span class="ft8">in the result-checking phase, every vertex always forwards any la-<br>bels received from its parents to both its children, it is clear that<br>when a label is forwarded to a vertex u , it is eventually forwarded<br>to the entire subtree rooted at u .</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:94"><nobr><span class="ft4">By definition, every off-path vertex u</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:294"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:303"><nobr><span class="ft4">of u has a parent p which</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:81"><nobr><span class="ft8">is a node on the path between u and the root of its commitment<br>tree. By construction, p sends the label of u</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:313"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:322"><nobr><span class="ft4">to its sibling u</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:398"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:406"><nobr><span class="ft4">which</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:81"><nobr><span class="ft4">is on the path to u (i.e., either u</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:258"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:268"><nobr><span class="ft4">is an ancestor of u, or u</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:401"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:411"><nobr><span class="ft4">= u).</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:81"><nobr><span class="ft4">Hence, the label u</span></nobr></DIV>
<DIV style="position:absolute;top:444;left:180"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:190"><nobr><span class="ft4">is eventually forwarded to u. Every vertex u</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:433"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:455;left:81"><nobr><span class="ft4">that is not an off-path vertex has a sibling u</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:323"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:455;left:333"><nobr><span class="ft4">which is not on the</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:81"><nobr><span class="ft8">path between u and the root of its commitment tree. Hence, u is not<br>in the subtree rooted at u</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:215"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:221"><nobr><span class="ft4">. Since the label of u</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:335"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:344"><nobr><span class="ft4">is only forwarded</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:81"><nobr><span class="ft4">to the subtree rooted at its sibling and nowhere else, the label of u</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:433"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:518;left:81"><nobr><span class="ft4">never reaches u.</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:81"><nobr><span class="ft4">Theorem 15 The</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:181"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:210"><nobr><span class="ft4">algorithm induces O</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:322"><nobr><span class="ft4">(log</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:345"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:352"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:359"><nobr><span class="ft4">) edge conges-</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:81"><nobr><span class="ft4">tion (and hence O</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:182"><nobr><span class="ft4">(log</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:215"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:222"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:229"><nobr><span class="ft4">) node congestion) in the aggregation</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:81"><nobr><span class="ft4">tree.</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:96"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:606;left:104"><nobr><span class="ft1">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:134"><nobr><span class="ft4">. Every step in the algorithm except the label dissemi-</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:81"><nobr><span class="ft8">nation step involves either broadcast or convergecast of messages<br>that are at most O</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:179"><nobr><span class="ft4">(logn) size. The label-dissemination step is the</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:81"><nobr><span class="ft4">dominating factor.</span></nobr></DIV>
<DIV style="position:absolute;top:667;left:94"><nobr><span class="ft4">Consider an arbitrary edge in the commitment-tree between par-</span></nobr></DIV>
<DIV style="position:absolute;top:683;left:81"><nobr><span class="ft8">ent vertex x and child vertex y. In the label dissemination step,<br>messages are only sent from parent to child in the commitment tree.<br>Hence the edge xy carries exactly the labels that y receives. From<br>Theorem 14, y receives O</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:221"><nobr><span class="ft4">(logn) labels, hence the total number of</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:81"><nobr><span class="ft4">labels passing through xy is O</span></nobr></DIV>
<DIV style="position:absolute;top:742;left:245"><nobr><span class="ft4">(logn). Hence, the edge congestion</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:81"><nobr><span class="ft4">in the commitment tree is O</span></nobr></DIV>
<DIV style="position:absolute;top:758;left:232"><nobr><span class="ft4">(logn). Now consider an arbitrary ag-</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:81"><nobr><span class="ft8">gregation tree edge with parent node u and child node v. The child<br>node v presents (i.e., sends) at most log n commitment-tree vertices<br>to its parent u, and hence the edge uv is responsible for carrying<br>traffic on behalf of at most log n commitment-tree edges -- these<br>are the edges incident on the commitment tree vertices that v pre-<br>sented to u. Note that v may not be responsible for creating all<br>the vertices that it presents to u, but v is nonetheless responsible<br>for forwarding the messages down to the sensor nodes which cre-<br>ated those vertices. Since each edge in the commitment tree has<br>O</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:90"><nobr><span class="ft4">(logn) congestion, and each edge in the aggregation tree carries</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:81"><nobr><span class="ft8">traffic for at most log n commitment-tree edges, the edge congestion<br>in the aggregation tree is O</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:233"><nobr><span class="ft4">(log</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:256"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:263"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:270"><nobr><span class="ft4">). The node-congestion bound</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:81"><nobr><span class="ft4">of O</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:105"><nobr><span class="ft4">(log</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:137"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:145"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:152"><nobr><span class="ft4">) follows from the O(log</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:286"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:293"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:300"><nobr><span class="ft4">) edge congestion and the</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:81"><nobr><span class="ft4">definition of</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:150"><nobr><span class="ft4"> as the greatest degree in the aggregation tree.</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:81"><nobr><span class="ft2">6.</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:112"><nobr><span class="ft2">OTHER AGGREGATION FUNCTIONS</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:94"><nobr><span class="ft4">In this section we briefly discuss how to use the</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:358"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:387"><nobr><span class="ft4">algorithm</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft4">as a primitive for the</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:198"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:238"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:246"><nobr><span class="ft1">AVERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:303"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:1048;left:327"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:342"><nobr><span class="ft1">QUANTILE</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:405"><nobr><span class="ft4">aggre-</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:81"><nobr><span class="ft4">gates.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:489"><nobr><span class="ft4">The C</span></nobr></DIV>
<DIV style="position:absolute;top:88;left:527"><nobr><span class="ft1">OUNT</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:565"><nobr><span class="ft4">Aggregate. The query</span></nobr></DIV>
<DIV style="position:absolute;top:88;left:696"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:741"><nobr><span class="ft4">is generally used</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:475"><nobr><span class="ft8">to determine the total number of nodes in the network with some<br>property; without loss of generality it can be considered a</span></nobr></DIV>
<DIV style="position:absolute;top:120;left:788"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:817"><nobr><span class="ft4">ag-</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:475"><nobr><span class="ft8">gregation where all the nodes have value either 1 (the node has the<br>property) or 0 (otherwise). More formally, each sensor node s has<br>a data value a</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:552"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:161;left:560"><nobr><span class="ft4"> {0,1}, and we wish to compute f (a</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:770"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:161;left:776"><nobr><span class="ft4">,...,a</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:809"><nobr><span class="ft1">n</span></nobr></DIV>
<DIV style="position:absolute;top:161;left:815"><nobr><span class="ft4">) =</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:475"><nobr><span class="ft4">a</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:482"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:490"><nobr><span class="ft4">+a</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:508"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:516"><nobr><span class="ft4">+···+a</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:562"><nobr><span class="ft1">n</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:568"><nobr><span class="ft4">. Since count is a special case of</span></nobr></DIV>
<DIV style="position:absolute;top:182;left:744"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:769"><nobr><span class="ft4">, we can use</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:475"><nobr><span class="ft4">the basic algorithm for</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:601"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:629"><nobr><span class="ft4">without modification.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:489"><nobr><span class="ft4">The A</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:526"><nobr><span class="ft1">VERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:580"><nobr><span class="ft4">Aggregate. The</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:680"><nobr><span class="ft1">AVERAGE</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:739"><nobr><span class="ft4">aggregate can be</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:475"><nobr><span class="ft4">computed by first computing the</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:652"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:680"><nobr><span class="ft4">of data values over the nodes</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:475"><nobr><span class="ft4">of interest, and then the</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:605"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:649"><nobr><span class="ft4">of the number of nodes of interest,</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:475"><nobr><span class="ft4">and then dividing the</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:593"><nobr><span class="ft1">SUM</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:621"><nobr><span class="ft4">by the</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:658"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:698"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:489"><nobr><span class="ft4">The</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:515"><nobr><span class="ft4">-Q</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:542"><nobr><span class="ft1">UANTILE</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:598"><nobr><span class="ft4">Aggregate. In the</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:700"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:716"><nobr><span class="ft1">QUANTILE</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:778"><nobr><span class="ft4">aggregate,</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:475"><nobr><span class="ft4">we wish to find the value that is in the</span></nobr></DIV>
<DIV style="position:absolute;top:287;left:685"><nobr><span class="ft4">n-th position in the sorted</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:475"><nobr><span class="ft4">list of data values. For example, the median is a special case where</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:475"><nobr><span class="ft14"> = 0.5. Without loss of generality we can assume that all the data<br>values are distinct; ties can be broken using unique node IDs.</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:489"><nobr><span class="ft4">If we wished to verify the correctness of a proposed</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:763"><nobr><span class="ft4">-quantile q,</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:475"><nobr><span class="ft4">we can perform a</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:570"><nobr><span class="ft1">COUNT</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:612"><nobr><span class="ft4">computation where each node s presents a</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:475"><nobr><span class="ft4">value a</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:513"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:520"><nobr><span class="ft4">= 1 if its data value a</span></nobr></DIV>
<DIV style="position:absolute;top:389;left:632"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:639"><nobr><span class="ft4"> q and presents a</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:736"><nobr><span class="ft1">s</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:743"><nobr><span class="ft4">= 0 otherwise. If</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:475"><nobr><span class="ft4">q is the</span></nobr></DIV>
<DIV style="position:absolute;top:397;left:518"><nobr><span class="ft4">-quantile, then the computed sum should be equal to n.</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:475"><nobr><span class="ft4">Hence, we can use any insecure approximate</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:725"><nobr><span class="ft4">-quantile aggrega-</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:475"><nobr><span class="ft4">tion scheme to compute a proposed</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:673"><nobr><span class="ft4">-quantile, and then securely</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:475"><nobr><span class="ft8">test to see if the result truly is within the approximation bounds of<br>the</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:495"><nobr><span class="ft4">-quantile algorithm.</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:475"><nobr><span class="ft2">7.</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:507"><nobr><span class="ft2">CONCLUSION</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:489"><nobr><span class="ft4">In-network data aggregation is an important primitive for sensor</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:475"><nobr><span class="ft8">network operation. The strong standard threat model of multiple<br>Byzantine nodes in sensor networks requires the use of aggrega-<br>tion techniques that are robust against malicious result-tampering<br>by covert adversaries.</span></nobr></DIV>
<DIV style="position:absolute;top:597;left:489"><nobr><span class="ft4">We present the first optimally secure aggregation scheme for ar-</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:475"><nobr><span class="ft8">bitrary aggregator topologies and multiple malicious nodes. This<br>contribution significantly improves on prior work which requires<br>strict limitations on aggregator topology or malicious node multi-<br>plicity, or which only yields a probabilistic security bound. Our al-<br>gorithm is based on a novel method of distributing the verification<br>of aggregation results onto the sensor nodes, and combining this<br>with a unique technique for balancing commitment trees to achieve<br>sublinear congestion bounds. The algorithm induces O</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:782"><nobr><span class="ft4">(log</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:814"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:822"><nobr><span class="ft4">n</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:829"><nobr><span class="ft4">)</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:475"><nobr><span class="ft4">node congestion (where</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:613"><nobr><span class="ft4"> is the maximum degree in the aggre-</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:475"><nobr><span class="ft8">gation tree) and provides the strongest security bound that can be<br>proven for any secure aggregation scheme without making assump-<br>tions about the distribution of data values.</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:475"><nobr><span class="ft2">8.</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:507"><nobr><span class="ft2">REFERENCES</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:482"><nobr><span class="ft4">[1] H. Cam, S. Ozdemir, P. Nair, D. Muthuavinashiappan, and</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:504"><nobr><span class="ft8">H. O. Sanli. Energy-efficient secure pattern based data<br>aggregation for wireless sensor networks. Computer<br>Communications, 29:446­455, 2006.</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:482"><nobr><span class="ft4">[2] C. Castelluccia, E. Mykletun, and G. Tsudik. Efficient</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:504"><nobr><span class="ft8">aggregation of encrypted data in wireless sensor networks. In<br>Proceedings of The Second Annual International Conference<br>on Mobile and Ubiquitous Systems, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:482"><nobr><span class="ft4">[3] J.-Y. Chen, G. Pandurangan, and D. Xu. Robust computation</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:504"><nobr><span class="ft8">of aggregates in wireless sensor networks: distributed<br>randomized algorithms and analysis. In Proceedings of the<br>Fourth International Symposium on Information Processing<br>in Sensor Networks, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:482"><nobr><span class="ft4">[4] W. Du, J. Deng, Y. Han, and P. K. Varshney. A witness-based</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:504"><nobr><span class="ft4">approach for data fusion assurance in wireless sensor</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">286</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="175010.png" alt="background image">
<DIV style="position:absolute;top:86;left:110"><nobr><span class="ft8">networks. In Proceedings of the IEEE Global<br>Telecommunications Conference, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:119;left:87"><nobr><span class="ft4">[5] J. Girao, M. Schneider, and D. Westhoff. CDA: Concealed</span></nobr></DIV>
<DIV style="position:absolute;top:135;left:110"><nobr><span class="ft8">data aggregation in wireless sensor networks. In Proceedings<br>of the ACM Workshop on Wireless Security, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:87"><nobr><span class="ft4">[6] M. B. Greenwald and S. Khanna. Power-conserving</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:110"><nobr><span class="ft8">computation of order-statistics over sensor networks. In<br>Proceedings of the twenty-third ACM<br>SIGMOD-SIGACT-SIGART symposium on Principles of<br>database systems, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:87"><nobr><span class="ft4">[7] I. Gupta, R. van Renesse, and K. P. Birman. Scalable</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:110"><nobr><span class="ft8">fault-tolerant aggregation in large process groups. In<br>Proceedings of the International Conference on Dependable<br>Systems and Networks, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:87"><nobr><span class="ft4">[8] L. Hu and D. Evans. Secure aggregation for wireless</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:110"><nobr><span class="ft8">networks. In Workshop on Security and Assurance in Ad hoc<br>Networks, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:87"><nobr><span class="ft4">[9] C. Intanagonwiwat, D. Estrin, R. Govindan, and</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:110"><nobr><span class="ft8">J. Heidemann. Impact of network density on data<br>aggregation in wireless sensor networks. In Proceedings of<br>the 22nd International Conference on Distributed Computing<br>Systems, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:81"><nobr><span class="ft4">[10] P. Jadia and A. Mathuria. Efficient secure aggregation in</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:110"><nobr><span class="ft8">sensor networks. In Proceedings of the 11th International<br>Conference on High Performance Computing, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:81"><nobr><span class="ft4">[11] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:110"><nobr><span class="ft8">TAG: a tiny aggregation service for ad-hoc sensor networks.<br>SIGOPS Oper. Syst. Rev., 36(SI):131­146, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:81"><nobr><span class="ft4">[12] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:110"><nobr><span class="ft8">The design of an acquisitional query processor for sensor<br>networks. In Proceedings of the 2003 ACM International<br>Conference on Management of Data, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:81"><nobr><span class="ft4">[13] A. Mahimkar and T. Rappaport. SecureDAV: A secure data</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:110"><nobr><span class="ft8">aggregation and verification protocol for sensor networks. In<br>Proceedings of the IEEE Global Telecommunications<br>Conference, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:81"><nobr><span class="ft4">[14] A. Manjhi, S. Nath, and P. B. Gibbons. Tributaries and</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:110"><nobr><span class="ft8">deltas: efficient and robust aggregation in sensor network<br>streams. In Proceedings of the ACM International<br>Conference on Management of Data, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:81"><nobr><span class="ft4">[15] S. Nath, P. B. Gibbons, S. Seshan, and Z. R. Anderson.</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:110"><nobr><span class="ft8">Synopsis diffusion for robust aggregation in sensor networks.<br>In Proceedings of the 2nd International Conference on<br>Embedded Networked Sensor Systems, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:81"><nobr><span class="ft4">[16] A. Perrig, R. Szewczyk, J. D. Tygar, V. Wen, and D. E.</span></nobr></DIV>
<DIV style="position:absolute;top:810;left:110"><nobr><span class="ft8">Culler. SPINS: Security protocols for sensor networks. Wirel.<br>Netw., 8(5):521­534, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:81"><nobr><span class="ft4">[17] B. Przydatek, D. Song, and A. Perrig. SIA: Secure</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:110"><nobr><span class="ft8">information aggregation in sensor networks. In Proceedings<br>of the 1st International Conference on Embedded Networked<br>Sensor Systems, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:81"><nobr><span class="ft4">[18] D. Wagner. Resilient aggregation in sensor networks. In</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:110"><nobr><span class="ft8">Proceedings of the 2nd ACM Workshop on Security of<br>Ad-hoc and Sensor Networks, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:956;left:81"><nobr><span class="ft4">[19] Y. Yang, X. Wang, S. Zhu, and G. Cao. SDAP: A secure</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:110"><nobr><span class="ft8">hop-by-hop data aggregation protocol for sensor networks.<br>In Proceedings of the ACM International Symposium on<br>Mobile Ad Hoc Networking and Computing, 2006.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft4">[20] Y. Yao and J. Gehrke. The COUGAR approach to in-network</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:110"><nobr><span class="ft8">query processing in sensor networks. SIGMOD Rec.,<br>31(3):9­18, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:83;left:475"><nobr><span class="ft2">APPENDIX</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:475"><nobr><span class="ft2">A.</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:511"><nobr><span class="ft2">PROOF OF LEMMA 8</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:489"><nobr><span class="ft4">We first prove the following:</span></nobr></DIV>
<DIV style="position:absolute;top:166;left:475"><nobr><span class="ft8">Lemma 16 Let F be a collection of commitment trees of height at<br>most h. Suppose there is a set U of accounted-for leaf-vertices with<br>distinct labels u</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:560"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:194;left:566"><nobr><span class="ft4">,...,u</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:599"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:610"><nobr><span class="ft4">and committed values v</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:737"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:194;left:743"><nobr><span class="ft4">,...,v</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:775"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:786"><nobr><span class="ft4">in F. Let</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:475"><nobr><span class="ft4">the set of trees that contain at least one member of U be T</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:783"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:791"><nobr><span class="ft4">. Define</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:475"><nobr><span class="ft4">val</span></nobr></DIV>
<DIV style="position:absolute;top:226;left:492"><nobr><span class="ft4">(X) for any forest X to be the total of the aggregation values at</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:475"><nobr><span class="ft4">the roots of the trees in X . Then val</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:666"><nobr><span class="ft4">(T</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:678"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:686"><nobr><span class="ft4">)  </span></nobr></DIV>
<DIV style="position:absolute;top:242;left:717"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:717"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:720"><nobr><span class="ft1">=1</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:736"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:742"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:745"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:269;left:490"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:499"><nobr><span class="ft1">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:269;left:529"><nobr><span class="ft4">. Proof: By induction on h.</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:489"><nobr><span class="ft4">Base case: h</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:558"><nobr><span class="ft4">= 0. Then all the trees are singleton-trees. The total</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:475"><nobr><span class="ft8">aggregation value of all the singleton-trees that contain at least one<br>member of U is exactly</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:605"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:313;left:615"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:615"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:618"><nobr><span class="ft1">=1</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:633"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:639"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:643"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:489"><nobr><span class="ft4">Induction step: Assume the theorem holds for h, and consider</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:475"><nobr><span class="ft8">an arbitrary collection F of commitment trees with at most height<br>h</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:484"><nobr><span class="ft4">+ 1 where the premise holds. If there are no trees of height h + 1</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:475"><nobr><span class="ft8">then we are done. Otherwise, let the set R be all the root vertices<br>of the trees of height h</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:605"><nobr><span class="ft4">+ 1. Consider F = F\R, i.e., remove all</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:475"><nobr><span class="ft8">the vertices in R from F. The result is a collection of trees with<br>height at most h. Let T</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:608"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:426;left:624"><nobr><span class="ft4">be the set of trees in F containing at</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:475"><nobr><span class="ft8">least one member of U . The induction hypothesis holds for F , so<br>val</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:492"><nobr><span class="ft4">(T</span></nobr></DIV>
<DIV style="position:absolute;top:462;left:504"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:515"><nobr><span class="ft4">)  </span></nobr></DIV>
<DIV style="position:absolute;top:454;left:547"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:463;left:547"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:550"><nobr><span class="ft1">=1</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:565"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:571"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:575"><nobr><span class="ft4">. We now show that replacing the vertices from</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:475"><nobr><span class="ft4">R cannot produce an T</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:596"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:607"><nobr><span class="ft4">such that val</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:676"><nobr><span class="ft4">(T</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:688"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:696"><nobr><span class="ft4">) &lt; val(T</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:746"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:757"><nobr><span class="ft4">). Each vertex</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:475"><nobr><span class="ft8">r from R is the root of two subtrees of height h in F. We have three<br>cases:</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:489"><nobr><span class="ft4">Case 1: Neither subtree contains any members of U . Then the</span></nobr></DIV>
<DIV style="position:absolute;top:536;left:475"><nobr><span class="ft4">new tree contains no members of U , and so is not a member of T</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:822"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:536;left:830"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:551;left:489"><nobr><span class="ft4">Case 2: One subtree t</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:612"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:551;left:622"><nobr><span class="ft4">contains members of U . Since all the</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:475"><nobr><span class="ft8">members of U are accounted-for, this implies that there is no in-<br>consistency at r. Hence, the subtree without a member of U must<br>have a non-negative aggregate value. We know that r performs the<br>aggregate sum correctly over its inputs, so it must have aggregate<br>value at least equal to the aggregate value of t</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:720"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:630;left:726"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:645;left:489"><nobr><span class="ft4">Case 3: Both subtrees contain members of U . Since all the mem-</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:475"><nobr><span class="ft8">bers of U are accounted-for, this implies that there is no inconsis-<br>tency at r. The aggregate result of r is exactly the sum of the ag-<br>gregate values of the two subtrees.</span></nobr></DIV>
<DIV style="position:absolute;top:708;left:489"><nobr><span class="ft4">In case 2 and 3, the aggregate values of the roots of the trees of</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:475"><nobr><span class="ft4">height h</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:520"><nobr><span class="ft4">+1 that were in T</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:615"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:623"><nobr><span class="ft4">, was no less than the sum of the aggre-</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:475"><nobr><span class="ft4">gate values of their constituent subtrees in T</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:716"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:727"><nobr><span class="ft4">. Hence, val</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:795"><nobr><span class="ft4">(T</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:807"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:815"><nobr><span class="ft4">) </span></nobr></DIV>
<DIV style="position:absolute;top:755;left:475"><nobr><span class="ft4">val</span></nobr></DIV>
<DIV style="position:absolute;top:752;left:492"><nobr><span class="ft4">(T</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:504"><nobr><span class="ft1">F</span></nobr></DIV>
<DIV style="position:absolute;top:752;left:515"><nobr><span class="ft4">)  </span></nobr></DIV>
<DIV style="position:absolute;top:752;left:546"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:546"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:549"><nobr><span class="ft1">=1</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:565"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:571"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:574"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:785;left:489"><nobr><span class="ft4">Let the commitment forest in Lemma 8 be F. Let the set of trees</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:475"><nobr><span class="ft8">in F that contain at least one of the accounted-for leaf-vertices be<br>T . By the above lemma, val</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:627"><nobr><span class="ft4">(T)  </span></nobr></DIV>
<DIV style="position:absolute;top:813;left:673"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:822;left:673"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:676"><nobr><span class="ft1">=1</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:692"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:698"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:701"><nobr><span class="ft4">. We know that there are</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:475"><nobr><span class="ft8">no root labels with negative aggregation values in the commitment<br>forest, otherwise the querier would have rejected the result. Hence,<br>val</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:492"><nobr><span class="ft4">(F)  val(T)  </span></nobr></DIV>
<DIV style="position:absolute;top:860;left:591"><nobr><span class="ft1">m</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:591"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:594"><nobr><span class="ft1">=1</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:610"><nobr><span class="ft4">v</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:616"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:619"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">287</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
