<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>D:\Paper\HTML\109</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2004-03-30T09:59:33+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Helvetica;color:#000000;}
	.ft1{font-size:15px;font-family:Helvetica;color:#000000;}
	.ft2{font-size:12px;font-family:Helvetica;color:#000000;}
	.ft3{font-size:15px;font-family:Times;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:11px;font-family:Times;color:#000000;}
	.ft6{font-size:11px;font-family:Times;color:#000000;}
	.ft7{font-size:9px;font-family:Times;color:#000000;}
	.ft8{font-size:16px;font-family:Courier;color:#000000;}
	.ft9{font-size:11px;font-family:Helvetica;color:#000000;}
	.ft10{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="917" height="1187" src="109001.png" alt="background image">
<DIV style="position:absolute;top:108;left:165"><nobr><span class="ft0"><b>Index Structures and Algorithms for Querying</b></span></nobr></DIV>
<DIV style="position:absolute;top:137;left:270"><nobr><span class="ft0"><b>Distributed RDF Repositories</b></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:146"><nobr><span class="ft1">Heiner Stuckenschmidt</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:144"><nobr><span class="ft2">Vrije Universiteit Amsterdam</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:183"><nobr><span class="ft2">The Netherlands</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:174"><nobr><span class="ft1">heiner@cs.vu.nl</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:392"><nobr><span class="ft1">Richard Vdovjak</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:383"><nobr><span class="ft1">Geert-Jan Houben</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:379"><nobr><span class="ft2">Eindhoven University of</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:420"><nobr><span class="ft2">Technology</span></nobr></DIV>
<DIV style="position:absolute;top:273;left:402"><nobr><span class="ft2">The Netherlands</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:378"><nobr><span class="ft1">richardv@win.tue.nl</span></nobr></DIV>
<DIV style="position:absolute;top:314;left:385"><nobr><span class="ft1">g.j.houben@tue.nl</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:616"><nobr><span class="ft1">Jeen Broekstra</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:605"><nobr><span class="ft2">Aduna B.V. Amerfoort</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:594"><nobr><span class="ft2">(formerly: Aidministrator)</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:621"><nobr><span class="ft2">The Netherlands</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:575"><nobr><span class="ft1">jeen.broekstra@aduna.biz</span></nobr></DIV>
<DIV style="position:absolute;top:368;left:81"><nobr><span class="ft3"><b>ABSTRACT</b></span></nobr></DIV>
<DIV style="position:absolute;top:393;left:81"><nobr><span class="ft10">A technical infrastructure for storing, querying and managing RDF<br>data is a key element in the current semantic web development.<br>Systems like Jena, Sesame or the ICS-FORTH RDF Suite are widely<br>used for building semantic web applications. Currently, none of<br>these systems supports the integrated querying of distributed RDF<br>repositories. We consider this a major shortcoming since the se-<br>mantic web is distributed by nature. In this paper we present an ar-<br>chitecture for querying distributed RDF repositories by extending<br>the existing Sesame system. We discuss the implications of our ar-<br>chitecture and propose an index structure as well as algorithms for<br>query processing and optimization in such a distributed context.</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:81"><nobr><span class="ft3"><b>Categories and Subject Descriptors</b></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:81"><nobr><span class="ft10">E.1 [<b>Data</b>]: DATA STRUCTURES--<i>Distributed Data Structures</i>;<br>H.2.4 [<b>Information Systems </b>]: DATABASE MANAGEMENT SYS-<br>TEMS--<i>Distributed Databases, Query Processing</i></span></nobr></DIV>
<DIV style="position:absolute;top:670;left:81"><nobr><span class="ft3"><b>General Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:694;left:81"><nobr><span class="ft4">Algorithms, Performance, Design</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:81"><nobr><span class="ft3"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:751;left:81"><nobr><span class="ft4">RDF Querying, Index Structures, Optimization</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:81"><nobr><span class="ft3"><b>1.</b></span></nobr></DIV>
<DIV style="position:absolute;top:783;left:112"><nobr><span class="ft3"><b>MOTIVATION</b></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:94"><nobr><span class="ft4">The need for handling multiple sources of knowledge and infor-</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:81"><nobr><span class="ft10">mation is quite obvious in the context of semantic web applications.<br>First of all we have the duality of schema and information content<br>where multiple information sources can adhere to the same schema.<br>Further, the re-use, extension and combination of multiple schema<br>files is considered to be common practice on the semantic web [7].<br>Despite the inherently distributed nature of the semantic web, most<br>current RDF infrastructures (for example [4]) store information lo-<br>cally as a single knowledge repository, i.e., RDF models from re-<br>mote sources are replicated locally and merged into a single model.<br>Distribution is virtually retained through the use of namespaces to<br>distinguish between different models. We argue that many interest-<br>ing applications on the semantic web would benefit from or even<br>require an RDF infrastructure that supports real distribution of in-<br>formation sources that can be accessed from a single point. Beyond</span></nobr></DIV>
<DIV style="position:absolute;top:1044;left:81"><nobr><span class="ft7">Copyright is held by the author/owner(s).</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:81"><nobr><span class="ft6"><i>WWW2004</i></span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:141"><nobr><span class="ft7">, May 17­22, 2004, New York, New York, USA.</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:81"><nobr><span class="ft7">ACM 1-58113-844-X/04/0005.</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:475"><nobr><span class="ft10">the argument of conceptual adequacy, there are a number of techni-<br>cal reasons for real distribution in the spirit of distributed databases:</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:489"><nobr><span class="ft5"><b>Freshness:</b></span></nobr></DIV>
<DIV style="position:absolute;top:418;left:554"><nobr><span class="ft4">The commonly used approach of using a local copy</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:475"><nobr><span class="ft10">of a remote source suffers from the problem of changing informa-<br>tion. Directly using the remote source frees us from the need of<br>managing change as we are always working with the original.</span></nobr></DIV>
<DIV style="position:absolute;top:497;left:489"><nobr><span class="ft5"><b>Flexibility:</b></span></nobr></DIV>
<DIV style="position:absolute;top:497;left:557"><nobr><span class="ft4">Keeping different sources separate from each other</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:475"><nobr><span class="ft10">provides us with a greater flexibility concerning the addition and<br>removal of sources. In the distributed setting, we only have to ad-<br>just the corresponding system parameters.</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:489"><nobr><span class="ft4">In many cases, it will even be unavoidable to adopt a distributed</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:475"><nobr><span class="ft10">architecture, for example in scenarios in which the data is not owned<br>by the person querying it. In this case, it will often not be permitted<br>to copy the data. More and more information providers, however,<br>create interfaces that can be used to query the information. The<br>same holds for cases where the information sources are too large to<br>just create a single model containing all the information, but they<br>still can be queried using a special interface (Musicbrainz is an ex-<br>ample of this case). Further, we might want to include sources that<br>are not available in RDF, but that can be wrapped to produce query<br>results in RDF format. A typical example is the use of a free-text<br>index as one source of information. Sometimes there is not even<br>a fixed model that could be stored in RDF, because the result of a<br>query is only calculated at runtime (Google, for instance, provides a<br>programming interface that could be wrapped into an RDF source).<br>In all these scenarios, we are forced to access external information<br>sources from an RDF infrastructure without being able to create a<br>local copy of the information we want to query. On the semantic<br>web, we almost always want to combine such external sources with<br>each other and with additional schema knowledge. This confirms<br>the need to consider an RDF infrastructure that deals with informa-<br>tion sources that are actually distributed across different locations.</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:489"><nobr><span class="ft4">In this paper, we address the problem of integrated access to dis-</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:475"><nobr><span class="ft10">tributed RDF repositories from a practical point of view. In par-<br>ticular, starting from a real-life use case where we are considering<br>a number of distributed sources that contain research results in the<br>form of publications, we take the existing RDF storage and retrieval<br>system Sesame and describe how the architecture and the query<br>processing methods of the system have to be extended in order to<br>move to a distributed setting.</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">631</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
	.ft11{font-size:8px;font-family:Times;color:#000000;}
	.ft12{font-size:6px;font-family:Times;color:#000000;}
	.ft13{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="917" height="1187" src="109002.png" alt="background image">
<DIV style="position:absolute;top:86;left:94"><nobr><span class="ft4">The paper is structured as follows. In Section 2 we present an</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:81"><nobr><span class="ft10">extension of the Sesame architecture to multiple, distributed repos-<br>itories and discuss basic assumptions and implications of the ar-<br>chitecture. Section 3 presents source index hierarchies as suit-<br>able mechanisms to support the localization of relevant data during<br>query processing. In Section 4 we introduce a cost model for pro-<br>cessing queries in the distributed architecture, and show its use in<br>optimizing query execution as a basis for the two-phase optimiza-<br>tion heuristics for join ordering. Section 5 reviews previous work<br>on index structures for object-oriented data bases. It also summa-<br>rizes related work on query optimization particularly focusing on<br>the join ordering problem. We conclude with a discussion of open<br>problems and future work.</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:81"><nobr><span class="ft3"><b>2.</b></span></nobr></DIV>
<DIV style="position:absolute;top:308;left:112"><nobr><span class="ft3"><b>INTEGRATION ARCHITECTURE</b></span></nobr></DIV>
<DIV style="position:absolute;top:330;left:94"><nobr><span class="ft4">Before discussing the technical aspects of distributed data and</span></nobr></DIV>
<DIV style="position:absolute;top:346;left:81"><nobr><span class="ft10">knowledge access, we need to put our work in context by introduc-<br>ing the specific integration architecture we have to deal with. This<br>architecture limits the possible ways of accessing and processing<br>data, and thereby provides a basis for defining some requirements<br>for our approach. It is important to note that our work is based on<br>an existing RDF storage and retrieval system, which more or less<br>predefines the architectural choices we made. In this section, we<br>describe an extension of the Sesame system [4] to distributed data<br>sources.</span></nobr></DIV>
<DIV style="position:absolute;top:503;left:94"><nobr><span class="ft4">The Sesame architecture is flexible enough to allow a straight-</span></nobr></DIV>
<DIV style="position:absolute;top:518;left:81"><nobr><span class="ft10">forward extension to a setting where we have to deal with multiple<br>distributed RDF repositories. In the current setting, queries, ex-<br>pressed in Sesame's query language SeRQL, are directly passed<br>from the query engine to an RDF API (SAIL) that abstracts from<br>the specific implementation of the repository. In the distributed set-<br>ting, we have several repositories that can be implemented in dif-<br>ferent ways. In order to abstract from this technical heterogeneity,<br>it is useful to introduce RDF API implementations on top of each<br>repository, making them accessible in the same way.</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:94"><nobr><span class="ft4">The specific problem of a distributed architecture is now that in-</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:81"><nobr><span class="ft10">formation relevant to a query might be distributed over the different<br>sources. This requires to locate relevant information, retrieve it, and<br>combine the individual answers. For this purpose, we introduce a<br>new component between the query parser and the actual SAILs -<br>the mediator SAIL (see Figure 1).</span></nobr></DIV>
<DIV style="position:absolute;top:785;left:94"><nobr><span class="ft4">In this work, we assume that local repositories are implemented</span></nobr></DIV>
<DIV style="position:absolute;top:801;left:81"><nobr><span class="ft10">using database systems that translate queries posed to the RDF API<br>into SQL queries and use the database functionality to evaluate<br>them (compare [5]). This assumption has an important influence on<br>the design of the distributed query processing: the database engines<br>underlying the individual repositories have the opportunity to per-<br>form local optimization on the SQL queries they pose to the data.<br>Therefore we do not have to perform optimizations on sub-queries<br>that are to be forwarded to a single source, because the repository<br>will deal with it. Our task is rather to determine which part of the<br>overall query has to be sent to which repository.</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:94"><nobr><span class="ft4">In the remainder of this paper, we describe an approach for query-</span></nobr></DIV>
<DIV style="position:absolute;top:989;left:81"><nobr><span class="ft10">ing distributed RDF sources that addresses these requirements im-<br>plied by the adopted architecture. We focus our attention on index<br>structures and algorithms implemented in the mediator SAIL.</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:552"><nobr><span class="ft5"><b>Figure 1: Distribution Architecture.</b></span></nobr></DIV>
<DIV style="position:absolute;top:407;left:475"><nobr><span class="ft3"><b>3.</b></span></nobr></DIV>
<DIV style="position:absolute;top:407;left:507"><nobr><span class="ft3"><b>INDEX STRUCTURES</b></span></nobr></DIV>
<DIV style="position:absolute;top:430;left:489"><nobr><span class="ft4">As discussed above, in order to be able to make use of the opti-</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:475"><nobr><span class="ft10">mization mechanisms of the database engines underlying the differ-<br>ent repositories, we have to forward entire queries to the different<br>repositories. In the case of multiple external models, we can further<br>speed up the process by only pushing down queries to information<br>sources we can expect to contain an answer. The ultimate goal<br>is to push down to a repository exactly that part of a more com-<br>plex query for which a repository contains an answer. This part<br>can range from a single statement template to the entire query. We<br>can have a situation where a subset of the query result can directly<br>be extracted from one source, and the rest has to be extracted and<br>combined from different sources. This situation is illustrated in the<br>following example.</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:490"><nobr><span class="ft4">E</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:499"><nobr><span class="ft11">XAMPLE</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:555"><nobr><span class="ft4">1. <i>Consider the case where we want to extract infor-</i></span></nobr></DIV>
<DIV style="position:absolute;top:667;left:475"><nobr><span class="ft13"><i>mation about research results. This information is scattered across<br>a variety of data sources containing information about publica-<br>tions, projects, patents, etc. In order to access these sources in<br>a uniform way, we use the OntoWeb research ontology. Figure 2<br>shows parts of this ontology.</i></span></nobr></DIV>
<DIV style="position:absolute;top:929;left:537"><nobr><span class="ft5"><b>Figure 2: Part of the OntoWeb Ontology.</b></span></nobr></DIV>
<DIV style="position:absolute;top:977;left:489"><nobr><span class="ft6"><i>Suppose we now want to ask for the titles of articles by employ-</i></span></nobr></DIV>
<DIV style="position:absolute;top:993;left:475"><nobr><span class="ft13"><i>ees of organizations that have projects in the area "RDF". The<br>path expression of a corresponding SeRQL query would be the fol-<br>lowing</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:512"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:517"><nobr><span class="ft6"><i>:</i></span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:477"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:482"><nobr><span class="ft4">For the sake of readability we omit namespaces whenever they do</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:475"><nobr><span class="ft4">not play a technical role.</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">632</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
	.ft14{font-size:9px;font-family:Courier;color:#000000;}
	.ft15{font-size:11px;font-family:Times;color:#000000;}
	.ft16{font-size:6px;font-family:Times;color:#000000;}
	.ft17{font-size:9px;line-height:13px;font-family:Courier;color:#000000;}
	.ft18{font-size:11px;line-height:19px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="917" height="1187" src="109003.png" alt="background image">
<DIV style="position:absolute;top:88;left:81"><nobr><span class="ft14">{A} title {T};</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:109"><nobr><span class="ft17">author {W} affiliation {O}<br>carriesOut {P} topic {'RDF'}</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:94"><nobr><span class="ft6"><i>Now, let's assume that we have three information sources</i></span></nobr></DIV>
<DIV style="position:absolute;top:138;left:400"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:143;left:409"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:415"><nobr><span class="ft6"><i>,</i></span></nobr></DIV>
<DIV style="position:absolute;top:138;left:421"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:143;left:430"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:436"><nobr><span class="ft6"><i>,</i></span></nobr></DIV>
<DIV style="position:absolute;top:157;left:81"><nobr><span class="ft6"><i>and</i></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:106"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:159;left:114"><nobr><span class="ft16">Q</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:120"><nobr><span class="ft6"><i>.</i></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:132"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:159;left:140"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:151"><nobr><span class="ft6"><i>is a publication data base that contains information</i></span></nobr></DIV>
<DIV style="position:absolute;top:173;left:81"><nobr><span class="ft6"><i>about articles, titles, authors and their affiliations.</i></span></nobr></DIV>
<DIV style="position:absolute;top:169;left:360"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:175;left:369"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:379"><nobr><span class="ft6"><i>is a project</i></span></nobr></DIV>
<DIV style="position:absolute;top:188;left:81"><nobr><span class="ft13"><i>data base with information about industrial projects, topics, and<br>organizations. Finally,</i></span></nobr></DIV>
<DIV style="position:absolute;top:200;left:208"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:206;left:217"><nobr><span class="ft16">Q</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:227"><nobr><span class="ft6"><i>is a research portal that contains all of</i></span></nobr></DIV>
<DIV style="position:absolute;top:220;left:81"><nobr><span class="ft6"><i>the above information for academic research.</i></span></nobr></DIV>
<DIV style="position:absolute;top:235;left:94"><nobr><span class="ft6"><i>If we want to answer the query above completely we need all</i></span></nobr></DIV>
<DIV style="position:absolute;top:251;left:81"><nobr><span class="ft6"><i>three information sources. By pushing down the entire query to</i></span></nobr></DIV>
<DIV style="position:absolute;top:248;left:425"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:253;left:433"><nobr><span class="ft16">Q</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:81"><nobr><span class="ft13"><i>we get results for academic research. In order to also retrieve the<br>information for industrial research, we need to split up the query,<br>push the fragment</i></span></nobr></DIV>
<DIV style="position:absolute;top:326;left:81"><nobr><span class="ft14">{A} title {T};</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:109"><nobr><span class="ft14">author {W} affiliation {O}</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:94"><nobr><span class="ft6"><i>to</i></span></nobr></DIV>
<DIV style="position:absolute;top:360;left:108"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:365;left:116"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:123"><nobr><span class="ft6"><i>, the fragment</i></span></nobr></DIV>
<DIV style="position:absolute;top:388;left:81"><nobr><span class="ft14">{O} carriesOut {P} topic {'RDF'}</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:94"><nobr><span class="ft6"><i>to</i></span></nobr></DIV>
<DIV style="position:absolute;top:408;left:109"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:414;left:117"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:123"><nobr><span class="ft6"><i>, and join the result based on the identity of the organiza-</i></span></nobr></DIV>
<DIV style="position:absolute;top:427;left:81"><nobr><span class="ft6"><i>tion.</i></span></nobr></DIV>
<DIV style="position:absolute;top:455;left:94"><nobr><span class="ft4">The example illustrates the need for sophisticated indexing struc-</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:81"><nobr><span class="ft10">tures for deciding which part of a query to direct to which informa-<br>tion source. On the one hand we need to index complex query<br>patterns in order to be able to push down larger queries to a source;<br>on the other hand we also need to be able to identify sub-queries<br>needed for retrieving partial results from individual sources.</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:94"><nobr><span class="ft4">In order to solve this problem we build upon existing work on</span></nobr></DIV>
<DIV style="position:absolute;top:581;left:81"><nobr><span class="ft10">indexing complex object models using join indices [14]. The idea<br>of join indices is to create additional database tables that explic-<br>itly contain the result of a join over a specific property. At runtime,<br>rather than computing a join, the system just accesses the join index<br>relation which is less computationally expensive. The idea of join<br>indices has been adapted to deal with complex object models. The<br>resulting index structure is a join index hierarchy [21]. The most<br>general element in the hierarchy is an index table for elements con-<br>nected by a certain path</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:212"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:708;left:219"><nobr><span class="ft16">HXXn I</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:256"><nobr><span class="ft4">of length</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:307"><nobr><span class="ft15">n. Every following level</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:81"><nobr><span class="ft4">contains all the paths of a particular length from 2 paths of length</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:81"><nobr><span class="ft10">n I at the second level of the hierarchy to n paths of length 1 at the<br>bottom of the hierarchy. In the following, we show how the notion<br>of join index hierarchies can be adapted to deal with the problem of<br>determining information sources that contain results for a particular<br>sub-query.</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:81"><nobr><span class="ft3"><b>3.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:825;left:121"><nobr><span class="ft3"><b>Source Index Hierarchies</b></span></nobr></DIV>
<DIV style="position:absolute;top:847;left:94"><nobr><span class="ft4">The majority of work in the area of object oriented databases is</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:81"><nobr><span class="ft10">focused on indexing schema-based paths in complex object models.<br>We can make use of this work by relating it to the graph-based in-<br>terpretation of RDF models. More specifically, every RDF model<br>can be seen as a graph where nodes correspond to resources and<br>edges to properties linking these resources. The result of a query to<br>such a model is a set of subgraphs corresponding to a path expres-<br>sion. While a path expression does not necessarily describe a single<br>path, it describes a tree that can be created by joining a set of paths.<br>Making use of this fact, we first decompose the path expression<br>into a set of expressions describing simple paths, then forward the<br>simpler path expressions to sources that contain the corresponding<br>information using a path-based index structure, and join retrieved<br>answers to create the result.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:489"><nobr><span class="ft4">The problem with using path indices to select information sources</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:475"><nobr><span class="ft10">is the fact that the information that makes up a path might be dis-<br>tributed across different information sources (compare Example 1).<br>We therefore have to use an index structure that also contains infor-<br>mation about sub-paths without loosing the advantage of indexing<br>complete paths. An index structure that combines these two charac-<br>teristics is the join index hierarchy proposed in [21]. We therefore<br>take their approach as a basis for defining a <i>source index hierarchy</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:490"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:501"><nobr><span class="ft11">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:563"><nobr><span class="ft4">1</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:584"><nobr><span class="ft4">(S</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:598"><nobr><span class="ft11">CHEMA</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:643"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:650"><nobr><span class="ft11">ATH</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:673"><nobr><span class="ft4">). <i>Let</i></span></nobr></DIV>
<DIV style="position:absolute;top:238;left:711"><nobr><span class="ft15">q a hY iY vY sY tY li</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:475"><nobr><span class="ft6"><i>be a labelled graph of an RDF model where</i></span></nobr></DIV>
<DIV style="position:absolute;top:253;left:716"><nobr><span class="ft15"> <i>is a set of nodes, </i>i</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:475"><nobr><span class="ft6"><i>a set of edges,</i></span></nobr></DIV>
<DIV style="position:absolute;top:269;left:555"><nobr><span class="ft15">v <i>a set of labels, </i>sY t X i 3  <i>and </i>l X i 3 v<i>.</i></span></nobr></DIV>
<DIV style="position:absolute;top:304;left:489"><nobr><span class="ft6"><i>For every</i></span></nobr></DIV>
<DIV style="position:absolute;top:300;left:543"><nobr><span class="ft15">e P i<i>, we have </i>s@eA a r</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:680"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:686"><nobr><span class="ft15">Y t@eA a r</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:739"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:749"><nobr><span class="ft6"><i>and</i></span></nobr></DIV>
<DIV style="position:absolute;top:300;left:773"><nobr><span class="ft15">l@eA a l</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:817"><nobr><span class="ft16">e</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:826"><nobr><span class="ft6"><i>if</i></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:475"><nobr><span class="ft6"><i>and only if the model contains the triple</i></span></nobr></DIV>
<DIV style="position:absolute;top:316;left:693"><nobr><span class="ft15">@r</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:705"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:711"><nobr><span class="ft15">Y l</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:722"><nobr><span class="ft16">e</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:728"><nobr><span class="ft15">Y r</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:740"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:746"><nobr><span class="ft15">A<i>. A path in G is</i></span></nobr></DIV>
<DIV style="position:absolute;top:335;left:475"><nobr><span class="ft6"><i>a list of edges</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:554"><nobr><span class="ft15">e</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:560"><nobr><span class="ft16">H</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:567"><nobr><span class="ft15">Y ¡ ¡ ¡ Y e</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:606"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:632"><nobr><span class="ft6"><i>such that</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:684"><nobr><span class="ft15">t@e</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:701"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:706"><nobr><span class="ft15">A a s@e</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:749"><nobr><span class="ft16">iCI</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:768"><nobr><span class="ft15">A <i>for all </i>i a</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:475"><nobr><span class="ft15">HY ¡ ¡ ¡ Y n   P<i>. Let </i>p a e</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:608"><nobr><span class="ft16">H</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:614"><nobr><span class="ft15">Y ¡ ¡ ¡ Y e</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:654"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:679"><nobr><span class="ft6"><i>be a path, the corresponding</i></span></nobr></DIV>
<DIV style="position:absolute;top:367;left:475"><nobr><span class="ft6"><i>schema path is the list of labels</i></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:647"><nobr><span class="ft15">l</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:651"><nobr><span class="ft16">H</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:658"><nobr><span class="ft15">Y ¡ ¡ ¡ Y l</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:695"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:720"><nobr><span class="ft6"><i>such that</i></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:772"><nobr><span class="ft15">l</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:776"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:785"><nobr><span class="ft15">a l@e</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:815"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:820"><nobr><span class="ft15">A<i>.</i></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:489"><nobr><span class="ft4">The definition establishes the notion of a path for RDF models.</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:475"><nobr><span class="ft10">We can now use path-based index structures and adapt them to the<br>task of locating path instances in different RDF models. The basic<br>structure we use for this purpose is an index table of sources that<br>contain instances of a certain path.</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:490"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:501"><nobr><span class="ft11">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:563"><nobr><span class="ft4">2</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:584"><nobr><span class="ft4">(S</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:598"><nobr><span class="ft11">OURCE</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:641"><nobr><span class="ft4">I</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:646"><nobr><span class="ft11">NDEX</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:678"><nobr><span class="ft4">). <i>Let</i></span></nobr></DIV>
<DIV style="position:absolute;top:484;left:715"><nobr><span class="ft15">p <i>be a schema path; a</i></span></nobr></DIV>
<DIV style="position:absolute;top:503;left:475"><nobr><span class="ft6"><i>source index for</i></span></nobr></DIV>
<DIV style="position:absolute;top:500;left:568"><nobr><span class="ft15">p <i>is a set of pairs </i>@s</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:681"><nobr><span class="ft16">k</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:688"><nobr><span class="ft15">Y n</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:702"><nobr><span class="ft16">k</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:709"><nobr><span class="ft15">A <i>where </i>s</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:762"><nobr><span class="ft16">k</span></nobr></DIV>
<DIV style="position:absolute;top:503;left:773"><nobr><span class="ft6"><i>is an infor-</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:475"><nobr><span class="ft6"><i>mation source (in particular, an RDF model) and the graph of</i></span></nobr></DIV>
<DIV style="position:absolute;top:515;left:821"><nobr><span class="ft15">s</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:827"><nobr><span class="ft16">k</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:475"><nobr><span class="ft6"><i>contains exactly</i></span></nobr></DIV>
<DIV style="position:absolute;top:531;left:565"><nobr><span class="ft15">n</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:574"><nobr><span class="ft16">k</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:584"><nobr><span class="ft6"><i>paths with schema path</i></span></nobr></DIV>
<DIV style="position:absolute;top:531;left:714"><nobr><span class="ft15">p <i>and </i>n</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:756"><nobr><span class="ft16">k</span></nobr></DIV>
<DIV style="position:absolute;top:531;left:767"><nobr><span class="ft15">b H<i>.</i></span></nobr></DIV>
<DIV style="position:absolute;top:564;left:489"><nobr><span class="ft4">A source index can be used to determine information sources that</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:475"><nobr><span class="ft10">contain instances of a particular schema path. If our query contains<br>the path</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:521"><nobr><span class="ft15">p, the corresponding source index provides us with a list of</span></nobr></DIV>
<DIV style="position:absolute;top:611;left:475"><nobr><span class="ft10">information sources we have to forward the query to in order to get<br>results. The information about the number of instance paths can be<br>used to estimate communication costs and will be used for join or-<br>dering (see Section 4). So far the index satisfies the requirement of<br>being able to list complete paths and push down the corresponding<br>queries to external sources. In order to be able to retrieve informa-<br>tion that is distributed across different sources, we have to extend<br>the structure based on the idea of a hierarchy of indices for arbitrary<br>sub-paths. The corresponding structure is defined as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:490"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:501"><nobr><span class="ft11">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:563"><nobr><span class="ft4">3</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:584"><nobr><span class="ft4">(S</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:598"><nobr><span class="ft11">OURCE</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:641"><nobr><span class="ft4">I</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:646"><nobr><span class="ft11">NDEX</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:682"><nobr><span class="ft4">H</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:692"><nobr><span class="ft11">IERARCHY</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:753"><nobr><span class="ft4">). <i>Let</i></span></nobr></DIV>
<DIV style="position:absolute;top:778;left:475"><nobr><span class="ft15">p a l</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:506"><nobr><span class="ft16">H</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:513"><nobr><span class="ft15">Y ¡ ¡ ¡ Y l</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:550"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:781;left:575"><nobr><span class="ft6"><i>be a schema path. A source index hierarchy for</i></span></nobr></DIV>
<DIV style="position:absolute;top:793;left:475"><nobr><span class="ft15">p <i>is an n-tuple </i>h</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:570"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:578"><nobr><span class="ft15">Y ¡ ¡ ¡ Y </span></nobr></DIV>
<DIV style="position:absolute;top:799;left:620"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:626"><nobr><span class="ft15">i <i>where</i></span></nobr></DIV>
<DIV style="position:absolute;top:819;left:495"><nobr><span class="ft15"> </span></nobr></DIV>
<DIV style="position:absolute;top:825;left:518"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:529"><nobr><span class="ft6"><i>is a source index for</i></span></nobr></DIV>
<DIV style="position:absolute;top:819;left:641"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:846;left:495"><nobr><span class="ft15"> </span></nobr></DIV>
<DIV style="position:absolute;top:852;left:518"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:528"><nobr><span class="ft6"><i>is the set of all source indices for sub-paths of</i></span></nobr></DIV>
<DIV style="position:absolute;top:846;left:798"><nobr><span class="ft15">p <i>with</i></span></nobr></DIV>
<DIV style="position:absolute;top:865;left:509"><nobr><span class="ft6"><i>length</i></span></nobr></DIV>
<DIV style="position:absolute;top:861;left:546"><nobr><span class="ft15">i <i>that have at least one entry.</i></span></nobr></DIV>
<DIV style="position:absolute;top:894;left:489"><nobr><span class="ft4">The most suitable way to represent such index structure is a hi-</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:475"><nobr><span class="ft10">erarchy, where the source index of the indexed path is the root ele-<br>ment. The hierarchy is formed in such a way that the subpart rooted<br>at the source index for a path</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:637"><nobr><span class="ft15">p always contains source indices for</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:475"><nobr><span class="ft4">all sub-paths of</span></nobr></DIV>
<DIV style="position:absolute;top:953;left:566"><nobr><span class="ft15">p. This property will later be used in the query</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:475"><nobr><span class="ft10">answering algorithm. Forming a lattice of source indices, a source<br>index hierarchy contains information about every possible schema<br>sub-path. Therefore we can locate all fragments of paths that might<br>be combined into a query result. At the same time, we can first<br>concentrate on complete path instances and successively investi-<br>gate smaller fragments using the knowledge about the existence of<br>longer paths. We illustrate this principle in the following example.</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">633</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
	.ft19{font-size:8px;font-family:Times;color:#000000;}
	.ft20{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="917" height="1187" src="109004.png" alt="background image">
<DIV style="position:absolute;top:86;left:96"><nobr><span class="ft4">E</span></nobr></DIV>
<DIV style="position:absolute;top:88;left:105"><nobr><span class="ft11">XAMPLE</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:160"><nobr><span class="ft4">2. <i>Let us reconsider the situation in Example 1. The</i></span></nobr></DIV>
<DIV style="position:absolute;top:102;left:81"><nobr><span class="ft13"><i>schema path we want to index is given by the list (author, affilia-<br>tion, carriesOut, topic). The source index hierarchy for this path<br>therefore contains source indices for the paths</i></span></nobr></DIV>
<DIV style="position:absolute;top:157;left:101"><nobr><span class="ft15"> p</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:121"><nobr><span class="ft16">HXXQ</span></nobr></DIV>
<DIV style="position:absolute;top:161;left:143"><nobr><span class="ft6"><i>: (author, affiliation, carriesOut, topic)</i></span></nobr></DIV>
<DIV style="position:absolute;top:185;left:101"><nobr><span class="ft15"> p</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:121"><nobr><span class="ft16">HXXP</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:140"><nobr><span class="ft6"><i>: (author, affiliation, carriesOut),</i></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:114"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:121"><nobr><span class="ft16">IXXQ</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:140"><nobr><span class="ft6"><i>: (affiliation, carriesOut, topic)</i></span></nobr></DIV>
<DIV style="position:absolute;top:229;left:101"><nobr><span class="ft15"> p</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:121"><nobr><span class="ft16">HXXI</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:140"><nobr><span class="ft6"><i>:(author, affiliation),</i></span></nobr></DIV>
<DIV style="position:absolute;top:245;left:114"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:121"><nobr><span class="ft16">IXXP</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:140"><nobr><span class="ft6"><i>:(affiliation, carriesOut),</i></span></nobr></DIV>
<DIV style="position:absolute;top:261;left:114"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:266;left:121"><nobr><span class="ft16">PXXQ</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:140"><nobr><span class="ft6"><i>:(carriesOut, topic)</i></span></nobr></DIV>
<DIV style="position:absolute;top:289;left:101"><nobr><span class="ft15"> p</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:121"><nobr><span class="ft16">H</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:127"><nobr><span class="ft6"><i>:(author),</i></span></nobr></DIV>
<DIV style="position:absolute;top:305;left:114"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:121"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:127"><nobr><span class="ft6"><i>:(affiliation),</i></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:114"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:121"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:127"><nobr><span class="ft6"><i>:(carriesOut),</i></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:114"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:121"><nobr><span class="ft16">Q</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:127"><nobr><span class="ft6"><i>(topic)</i></span></nobr></DIV>
<DIV style="position:absolute;top:367;left:94"><nobr><span class="ft6"><i>Starting from the longest path, we compare our query expression</i></span></nobr></DIV>
<DIV style="position:absolute;top:383;left:81"><nobr><span class="ft13"><i>with the index (see Figure 3 for an example of index contents). We<br>immediately get the information that</i></span></nobr></DIV>
<DIV style="position:absolute;top:395;left:284"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:400;left:292"><nobr><span class="ft16">Q</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:302"><nobr><span class="ft6"><i>contains results. Turning</i></span></nobr></DIV>
<DIV style="position:absolute;top:414;left:81"><nobr><span class="ft6"><i>to sub-paths, we also find out that</i></span></nobr></DIV>
<DIV style="position:absolute;top:410;left:269"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:278"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:288"><nobr><span class="ft6"><i>contains results for the sub-</i></span></nobr></DIV>
<DIV style="position:absolute;top:430;left:81"><nobr><span class="ft6"><i>path (author, affiliation) and</i></span></nobr></DIV>
<DIV style="position:absolute;top:426;left:234"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:432;left:243"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:252"><nobr><span class="ft6"><i>for the sub-path (carriesOut, topic)</i></span></nobr></DIV>
<DIV style="position:absolute;top:445;left:81"><nobr><span class="ft13"><i>that we can join in order to compute results, because together both<br>sub-paths make up the path we are looking for.</i></span></nobr></DIV>
<DIV style="position:absolute;top:492;left:94"><nobr><span class="ft6"><i>The source indices also contain information about the fact that</i></span></nobr></DIV>
<DIV style="position:absolute;top:505;left:81"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:510;left:89"><nobr><span class="ft16">Q</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:100"><nobr><span class="ft6"><i>contains results for all sub-paths of our target path. We still</i></span></nobr></DIV>
<DIV style="position:absolute;top:524;left:81"><nobr><span class="ft13"><i>have to take this information into account, because in combination<br>with fragments from other sources we might get additional results.<br>However, we do not have to consider joining sub-paths from the<br>same source, because these results are already covered by longer<br>paths. In the example we see that</i></span></nobr></DIV>
<DIV style="position:absolute;top:583;left:259"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:589;left:268"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:277"><nobr><span class="ft6"><i>will return far less results than</i></span></nobr></DIV>
<DIV style="position:absolute;top:599;left:81"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:604;left:89"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:99"><nobr><span class="ft6"><i>(because there are less projects than publications). We can use</i></span></nobr></DIV>
<DIV style="position:absolute;top:618;left:81"><nobr><span class="ft6"><i>this information to optimize the process of joining results.</i></span></nobr></DIV>
<DIV style="position:absolute;top:649;left:94"><nobr><span class="ft4">A key issue connected with indexing information sources is the</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:81"><nobr><span class="ft10">trade-off between required storage space and computational proper-<br>ties of index-based query processing. Compared to index structures<br>used to speed up query processing within an information source, a<br>source index is relatively small as it does not encode information<br>about individual elements in a source. Therefore, the size of the in-<br>dex is independent of the size of the indexed information sources.<br>The relevant parameters in our case are the number of sources</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:411"><nobr><span class="ft15">s and</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:81"><nobr><span class="ft4">the lengths of the schema path</span></nobr></DIV>
<DIV style="position:absolute;top:771;left:253"><nobr><span class="ft15">n. More specifically, in the worst</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:81"><nobr><span class="ft10">case a source index hierarchy contains source indices for every sub-<br>path of the indexed schema path. As the number of all sub-path of</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:81"><nobr><span class="ft4">a path is</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:135"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:132"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:840;left:130"><nobr><span class="ft16">iaI</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:150"><nobr><span class="ft15">i, the worst-case</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:240"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:249"><nobr><span class="ft4">space complexity of a source index</span></nobr></DIV>
<DIV style="position:absolute;top:854;left:81"><nobr><span class="ft4">hierarchy is</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:147"><nobr><span class="ft15">y@s ¡ n</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:189"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:195"><nobr><span class="ft15">A. We conclude that the length of the indexed</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:81"><nobr><span class="ft4">path is the significant parameter here.</span></nobr></DIV>
<DIV style="position:absolute;top:896;left:81"><nobr><span class="ft3"><b>3.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:896;left:121"><nobr><span class="ft3"><b>Query Answering Algorithm</b></span></nobr></DIV>
<DIV style="position:absolute;top:918;left:94"><nobr><span class="ft4">Using the notion of a source index hierarchy, we can now define</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:81"><nobr><span class="ft10">a basic algorithm for answering queries using multiple sources of<br>information. The task of this algorithm is to determine all possi-<br>ble combinations of sub-paths of the given query path. For each of<br>these combinations, it then has to determine the sources containing<br>results for the path fragments, retrieve these results, and join them<br>into a result for the complete path. The main task is to guarantee<br>that we indeed check all possible combinations of sub-paths for the</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:82"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:87"><nobr><span class="ft4">It is the case where all sources contain results for the complete</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:81"><nobr><span class="ft4">schema path.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft10">query path. The easiest way of guaranteeing this is to use a simple<br>tree-recursion algorithm that retrieves results for the complete path,<br>then splits the original path, and joins the results of recursive calls<br>for the sub-paths. In order to capture all possible splits this has to<br>be done for every possible split point in the original path. The cor-<br>responding semi-formal algorithm is given below (Algorithm 1).</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:475"><nobr><span class="ft5"><b>Algorithm 1</b></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:548"><nobr><span class="ft4">Compute Answers.</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:475"><nobr><span class="ft5"><b>Require:</b></span></nobr></DIV>
<DIV style="position:absolute;top:229;left:532"><nobr><span class="ft4">A schema path</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:616"><nobr><span class="ft15">p a l</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:645"><nobr><span class="ft16">H</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:652"><nobr><span class="ft15">Y ¡ ¡ ¡ Y l</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:689"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:475"><nobr><span class="ft5"><b>Require:</b></span></nobr></DIV>
<DIV style="position:absolute;top:244;left:532"><nobr><span class="ft4">A source index hierarchy</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:671"><nobr><span class="ft15">h a @</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:712"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:719"><nobr><span class="ft15">Y ¡ ¡ ¡ Y </span></nobr></DIV>
<DIV style="position:absolute;top:247;left:761"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:767"><nobr><span class="ft15">A for p</span></nobr></DIV>
<DIV style="position:absolute;top:260;left:489"><nobr><span class="ft5"><b>for all</b></span></nobr></DIV>
<DIV style="position:absolute;top:260;left:526"><nobr><span class="ft4">sources</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:570"><nobr><span class="ft15">s</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:577"><nobr><span class="ft16">k</span></nobr></DIV>
<DIV style="position:absolute;top:260;left:587"><nobr><span class="ft4">in source index</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:672"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:262;left:681"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:260;left:692"><nobr><span class="ft5"><b>do</b></span></nobr></DIV>
<DIV style="position:absolute;top:278;left:502"><nobr><span class="ft19"><b>ANSWERS</b></span></nobr></DIV>
<DIV style="position:absolute;top:276;left:563"><nobr><span class="ft4">:= instances of schema path</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:715"><nobr><span class="ft15">p in source s</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:785"><nobr><span class="ft16">k</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:502"><nobr><span class="ft19"><b>RESULT</b></span></nobr></DIV>
<DIV style="position:absolute;top:292;left:552"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:288;left:566"><nobr><span class="ft15">result  nswers</span></nobr></DIV>
<DIV style="position:absolute;top:307;left:489"><nobr><span class="ft20"><b>end for<br>if</b></span></nobr></DIV>
<DIV style="position:absolute;top:319;left:500"><nobr><span class="ft15">n ! P <b>then</b></span></nobr></DIV>
<DIV style="position:absolute;top:339;left:502"><nobr><span class="ft5"><b>for all</b></span></nobr></DIV>
<DIV style="position:absolute;top:335;left:540"><nobr><span class="ft15">i a I ¡ ¡ ¡ n   I <b>do</b></span></nobr></DIV>
<DIV style="position:absolute;top:351;left:516"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:523"><nobr><span class="ft16">HXXi I</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:557"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:572"><nobr><span class="ft15">l</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:576"><nobr><span class="ft16">H</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:582"><nobr><span class="ft15">Y ¡ ¡ ¡ l</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:611"><nobr><span class="ft16">i I</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:516"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:523"><nobr><span class="ft16">iXXn I</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:558"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:573"><nobr><span class="ft15">l</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:577"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:582"><nobr><span class="ft15">Y ¡ ¡ ¡ l</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:611"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:516"><nobr><span class="ft15">h</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:524"><nobr><span class="ft16">HXXi I</span></nobr></DIV>
<DIV style="position:absolute;top:386;left:558"><nobr><span class="ft4">:= Sub-hierarchy of</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:666"><nobr><span class="ft15">h rooted at the source index for</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:516"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:404;left:523"><nobr><span class="ft16">HXXi I</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:516"><nobr><span class="ft15">h</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:524"><nobr><span class="ft16">iXXn I</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:559"><nobr><span class="ft4">:= Sub-hierarchy of</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:667"><nobr><span class="ft15">h rooted at the source index for</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:516"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:523"><nobr><span class="ft16">iXXn I</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:516"><nobr><span class="ft15">res</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:535"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:545"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:559"><nobr><span class="ft15">gomputeenswers@p</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:683"><nobr><span class="ft16">HXXi I</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:714"><nobr><span class="ft15">Y h</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:728"><nobr><span class="ft16">HXXi I</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:759"><nobr><span class="ft15">A</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:516"><nobr><span class="ft15">res</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:535"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:545"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:559"><nobr><span class="ft15">gomputeenswers@p</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:683"><nobr><span class="ft16">iXXn I</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:715"><nobr><span class="ft15">Y h</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:729"><nobr><span class="ft16">iXXn I</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:762"><nobr><span class="ft15">A</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:516"><nobr><span class="ft19"><b>RESULT</b></span></nobr></DIV>
<DIV style="position:absolute;top:480;left:565"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:580"><nobr><span class="ft15">result  join@res</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:683"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:689"><nobr><span class="ft15">Y res</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:715"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:721"><nobr><span class="ft15">A</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:502"><nobr><span class="ft5"><b>end for</b></span></nobr></DIV>
<DIV style="position:absolute;top:511;left:489"><nobr><span class="ft20"><b>end if<br>return</b></span></nobr></DIV>
<DIV style="position:absolute;top:527;left:529"><nobr><span class="ft4">result</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:489"><nobr><span class="ft4">Note that Algorithm 1 is far from being optimal with respect to</span></nobr></DIV>
<DIV style="position:absolute;top:581;left:475"><nobr><span class="ft10">runtime performance. The straightforward recursion scheme does<br>not take specific actions to prevent unnecessary work and it neither<br>selects an optimal order for joining sub-paths. We can improve this<br>situation by using knowledge about the information in the different<br>sources and performing query optimization.</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:475"><nobr><span class="ft3"><b>4.</b></span></nobr></DIV>
<DIV style="position:absolute;top:676;left:507"><nobr><span class="ft3"><b>QUERY OPTIMIZATION</b></span></nobr></DIV>
<DIV style="position:absolute;top:698;left:489"><nobr><span class="ft4">In the previous section we described a light-weight index struc-</span></nobr></DIV>
<DIV style="position:absolute;top:714;left:475"><nobr><span class="ft10">ture for distributed RDF querying. Its main task is to index schema<br>paths w.r.t. underlying sources that contain them. Compared to<br>instance-level indexing, our approach does not require creating and<br>maintaining oversized indices since there are far fewer sources than<br>there are instances. Instance indexing would not scale in the web<br>environment and as mentioned above in many cases it would not<br>even be applicable, e.g., when sources do not allow replication<br>of their data (which is what instance indices essentially do). The<br>downside of our approach, however, is that query answering with-<br>out the index support at the instance level is much more computa-<br>tionally intensive. Moreover, in the context of semantic web portal<br>applications the queries are not man-entered anymore but rather<br>generated by a portal's front-end (triggered by the user) and of-<br>ten exceed the size</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:578"><nobr><span class="ft12">3</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:587"><nobr><span class="ft4">which can be easily computed by using brute</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:475"><nobr><span class="ft10">force. Therefore we focus in this section on query optimization as<br>an important part of a distributed RDF query system. We try to<br>avoid re-inventing the wheel and once again seek for inspiration in<br>the database field, making it applicable by "relationizing" the RDF<br>model.</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:489"><nobr><span class="ft4">Each single schema path</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:626"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:633"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:641"><nobr><span class="ft4">of length 1 (also called 1-</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:780"><nobr><span class="ft15">pth) can</span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:475"><nobr><span class="ft4">be perceived as a relation with two attributes: the source vertex</span></nobr></DIV>
<DIV style="position:absolute;top:1064;left:477"><nobr><span class="ft12">3</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:482"><nobr><span class="ft4">Especially, the length of the path expression.</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">634</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
	.ft21{font-size:5px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="917" height="1187" src="109005.png" alt="background image">
<DIV style="position:absolute;top:351;left:290"><nobr><span class="ft5"><b>Figure 3: Source index hierarchy for the given query path.</b></span></nobr></DIV>
<DIV style="position:absolute;top:406;left:81"><nobr><span class="ft15">s@p</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:99"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:104"><nobr><span class="ft15">A and the target vertex t@p</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:249"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:254"><nobr><span class="ft15">A. A schema path of length more</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:81"><nobr><span class="ft10">than 1 is modelled as a set of relations joined together by the iden-<br>tity of the adjacent vertices, essentially representing a chain query<br>of joins as defined in Definition 4. This relational view over an<br>RDF graph offers the possibility to re-use the extensive research on<br>join optimization in databases, e.g. [1, 8, 9, 17, 20].</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:94"><nobr><span class="ft4">Taking into account the (distributed) RDF context of the join or-</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:81"><nobr><span class="ft10">dering problem there are several specifics to note when devising<br>a good query plan. As in distributed databases, communication<br>costs significantly contribute to the overall cost of a query plan.<br>Since in our case the distribution is assumed to be realized via an<br>IP network with a variable bandwidth, the communications costs<br>are likely to contribute substantially to the overall processing costs,<br>which makes the minimization of data transmission across the net-<br>work very important. Unless the underlying sources provide join<br>capabilities, the data transmission cannot be largely reduced: all<br>(selected) bits of data from the sources are joined by the mediator<br>and hence must be transmitted via the network.</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:94"><nobr><span class="ft4">There may exist different dependencies (both structural and ex-</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:81"><nobr><span class="ft10">tensional) on the way the data is distributed. If the information<br>about such dependencies is available, it essentially enables the op-<br>timizer to prune join combinations which cannot yield any results.<br>The existence of such dependencies can be (to some extent) com-<br>puted/discovered prior to querying, during the initial integration<br>phase. Human insight is, however, often needed in order to avoid<br>false dependency conclusions, which could potentially influence<br>the completeness of query answering.</span></nobr></DIV>
<DIV style="position:absolute;top:880;left:94"><nobr><span class="ft4">The performance and data statistics are both necessary for the</span></nobr></DIV>
<DIV style="position:absolute;top:896;left:81"><nobr><span class="ft10">optimizer to make the right decision. In general, the more the op-<br>timizer knows about the underlying sources and data, the better<br>optimized the query plan is. However, taking into account the au-<br>tonomy of the sources, the necessary statistics do not have to be<br>always available. We design our mediator to cope with incomplete<br>statistical information in such a way that the missing parameters are<br>estimated as being worse than those that are known (pessimistic ap-<br>proach). Naturally, the performance of the optimizer is then lower<br>but it increases steadily when the estimations are made more real-<br>istic based on the actual response from the underlying sources; this<br>is also known as optimizer calibration.</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:489"><nobr><span class="ft4">As indicated above, the computational capabilities of the under-</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:475"><nobr><span class="ft10">lying sources may vary considerably. We distinguish between those<br>sources that can only retrieve the selected local data (pull up strat-<br>egy) and those that can perform joins of their local and incoming<br>external data (push down strategy), thus offering computational ser-<br>vices that could be used to achieve both a higher degree of paral-<br>lelism and smaller data transmission over the network, e.g., by ap-<br>plying semi-join reductions [1]. At present, however, most sources<br>are capable only of selecting the desired data within their extent,<br>i.e., they do not offer the join capability. Therefore, further we fo-<br>cus mainly on local optimization at the mediator's side.</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:489"><nobr><span class="ft4">For this purpose we need to perceive an RDF model as a set of</span></nobr></DIV>
<DIV style="position:absolute;top:598;left:475"><nobr><span class="ft10">relations on which we can apply optimization results from the area<br>of relational databases. In this context the problem of join ordering<br>arises, when we want to compute the results for schema paths from<br>partial results obtained from different sources. Creating the result<br>for a schema corresponds to the problem of computing the result of<br>a chain query as defined below:</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:490"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:501"><nobr><span class="ft11">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:563"><nobr><span class="ft4">4</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:584"><nobr><span class="ft4">(C</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:599"><nobr><span class="ft11">HAIN</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:632"><nobr><span class="ft4">Q</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:642"><nobr><span class="ft11">UERY</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:674"><nobr><span class="ft4">). <i>Let</i></span></nobr></DIV>
<DIV style="position:absolute;top:702;left:709"><nobr><span class="ft15">p <i>be a schema path com-</i></span></nobr></DIV>
<DIV style="position:absolute;top:721;left:475"><nobr><span class="ft6"><i>posed from the 1-paths</i></span></nobr></DIV>
<DIV style="position:absolute;top:718;left:603"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:610"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:718;left:616"><nobr><span class="ft15">Y ¡ ¡ ¡ Y p</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:656"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:664"><nobr><span class="ft6"><i>. The chain query of</i></span></nobr></DIV>
<DIV style="position:absolute;top:718;left:779"><nobr><span class="ft15">p <i>is the n-</i></span></nobr></DIV>
<DIV style="position:absolute;top:737;left:475"><nobr><span class="ft6"><i>join</i></span></nobr></DIV>
<DIV style="position:absolute;top:733;left:500"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:507"><nobr><span class="ft16">I</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:519"><nobr><span class="ft15">FG</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:530"><nobr><span class="ft16">t@p</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:544"><nobr><span class="ft21">I</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:550"><nobr><span class="ft16">Aas@p</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:578"><nobr><span class="ft21">P</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:584"><nobr><span class="ft16">A</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:594"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:601"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:613"><nobr><span class="ft15">FG</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:624"><nobr><span class="ft16">t@p</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:639"><nobr><span class="ft21">P</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:645"><nobr><span class="ft16">Aas@p</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:673"><nobr><span class="ft21">Q</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:678"><nobr><span class="ft16">A</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:689"><nobr><span class="ft15">p</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:696"><nobr><span class="ft16">Q</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:707"><nobr><span class="ft15">FG ¡ ¡ ¡ p</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:749"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:761"><nobr><span class="ft6"><i>, where</i></span></nobr></DIV>
<DIV style="position:absolute;top:733;left:805"><nobr><span class="ft15">s@p</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:824"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:828"><nobr><span class="ft15">A</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:475"><nobr><span class="ft6"><i>and</i></span></nobr></DIV>
<DIV style="position:absolute;top:749;left:500"><nobr><span class="ft15">t@p</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:518"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:749;left:523"><nobr><span class="ft15">A <i>are returning an identity of a source and target node,</i></span></nobr></DIV>
<DIV style="position:absolute;top:768;left:475"><nobr><span class="ft13"><i>respectively. As the join condition and attributes follow the same<br>pattern for all joins in the chain query, we omit them whenever they<br>are clear from the context.</i></span></nobr></DIV>
<DIV style="position:absolute;top:829;left:489"><nobr><span class="ft4">In other words, to follow a path</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:670"><nobr><span class="ft15">p of length 2 means perform-</span></nobr></DIV>
<DIV style="position:absolute;top:845;left:475"><nobr><span class="ft4">ing a join between the two paths of length 1 which</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:756"><nobr><span class="ft15">p is composed</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:475"><nobr><span class="ft10">from. The problem of join optimization is to determine the right<br>order in which the joins should be computed, such that the over-<br>all response time for computing the path instances is minimized.</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:829"><nobr><span class="ft12">4</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:475"><nobr><span class="ft10">Note that a chain query in Definition 4 does not include explicit<br>joins, i.e., those specified in the</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:647"><nobr><span class="ft15"> here clause, or by assigning the</span></nobr></DIV>
<DIV style="position:absolute;top:939;left:475"><nobr><span class="ft10">same variable names along the path expression. When we append<br>these explicit joins, the shape of the query usually changes from a<br>linear chain to a query graph containing a circle or a star, making<br>the join ordering problem NP-hard [15].</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:477"><nobr><span class="ft12">4</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:482"><nobr><span class="ft4">In case the sources offer also join capabilities the problem is not</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:475"><nobr><span class="ft4">only in which order but also where the joins should take place.</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">635</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
	.ft22{font-size:11px;font-family:Times;color:#000000;}
	.ft23{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="917" height="1187" src="109006.png" alt="background image">
<DIV style="position:absolute;top:84;left:81"><nobr><span class="ft3"><b>4.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:84;left:121"><nobr><span class="ft3"><b>Space Complexity</b></span></nobr></DIV>
<DIV style="position:absolute;top:106;left:94"><nobr><span class="ft4">Disregarding the solutions obtained by the commutativity of joins,</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:81"><nobr><span class="ft10">each query execution plan can be associated with a sequence of<br>numbers that represents the order in which the relations are joined.<br>We refer to this sequence as footprint of the execution plan.</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:96"><nobr><span class="ft4">E</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:105"><nobr><span class="ft11">XAMPLE</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:160"><nobr><span class="ft4">3. <i>For brevity reasons, assume the following name</i></span></nobr></DIV>
<DIV style="position:absolute;top:197;left:81"><nobr><span class="ft23"><i>substitutions in the model introduced in Example 1: the concept<br>names <b>Article, Employee, Organization, Project, ResearchTopic<br></b>become <b>a, b, c, d, e</b>, respectively; the property names <b>author, affili-<br>ation, carriesOut, topic</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:244;left:211"><nobr><span class="ft6"><i>are substituted with <b>1, 2, 3, 4</b>, respectively.</i></span></nobr></DIV>
<DIV style="position:absolute;top:260;left:81"><nobr><span class="ft6"><i>Figure 4 presents two possible execution plans and their footprints.</i></span></nobr></DIV>
<DIV style="position:absolute;top:548;left:85"><nobr><span class="ft5"><b>Figure 4: Two possible query executions and their footprints.</b></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:94"><nobr><span class="ft4">If also the order of the join operands matters, i.e., the commuta-</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:81"><nobr><span class="ft10">tivity law is considered, the sequence of the operands of each join<br>is recorded in the footprint as well. The solution space consists of<br>query plans (their footprints) which can be generated. We distin-<br>guish two cases: first the larger solution space of bushy trees and<br>then its subset consisting of right-deep trees.</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:94"><nobr><span class="ft4">If we allow for an arbitrary order of joins the resulting query</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:81"><nobr><span class="ft10">plans are so-called bushy trees where the operands of a join can<br>be both a base relation</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:204"><nobr><span class="ft12">5</span></nobr></DIV>
<DIV style="position:absolute;top:747;left:213"><nobr><span class="ft4">or a result of a previous join. For a query</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:81"><nobr><span class="ft4">with</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:109"><nobr><span class="ft15">n joins there are n3 possibilities of different query execution</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:81"><nobr><span class="ft10">plans if we disregard the commutativity of joins and cross prod-<br>ucts. Note that in the case of bushy trees, there might be several<br>footprints associated with one query tree. For instance, the bushy<br>tree in Example 3 can be evaluated in different order yielding two<br>more footprints: <i>(2, 4, 1, 3) </i>or <i>(4, 2, 1, 3)</i>. In our current approach,<br>these footprints would be equivalent w.r.t. the cost they represent.<br>However, treating them independently allows us to consider in the<br>future also semi-join optimization [1] where their cost might differ<br>considerably.</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:94"><nobr><span class="ft4">If the commutativity of join is taken into account, there are  </span></nobr></DIV>
<DIV style="position:absolute;top:915;left:412"><nobr><span class="ft16">Pn</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:415"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:424"><nobr><span class="ft15">¡</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:434"><nobr><span class="ft16">n3</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:432"><nobr><span class="ft16">P</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:438"><nobr><span class="ft21">n</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:81"><nobr><span class="ft10">different possibilities of ordering joins and their individual con-<br>stituents [22]. However, in case of memory-resident databases where<br>all data fits in main memory, the possibilities generated by the com-<br>mutativity law can be for some join methods neglected as they<br>mainly play a role in the cost model minimizing disk-memory oper-<br>ations; we discuss this issue further in Subsection 4.2. We adopt the<br>memory-only strategy as in our context there are always only two</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:82"><nobr><span class="ft12">5</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:87"><nobr><span class="ft4">A base relation is that part of the path which can be retrieved di-</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:81"><nobr><span class="ft4">rectly from one source.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft10">attributes per relation, both of them being URI references which,<br>when the namespace prefix is stored separately, yield a very small<br>size. Of course, the assumption we make here is that the Sesame<br>server is equipped with a sufficient amount of memory to accom-<br>modate all intermediate tuples of relations appearing in the query.</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:489"><nobr><span class="ft4">A special case of a general execution plan is a so-called right-</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:475"><nobr><span class="ft10">deep tree which has the left-hand join operands consisting only of<br>base relations. For a footprint that starts with the</span></nobr></DIV>
<DIV style="position:absolute;top:208;left:739"><nobr><span class="ft15">r-th join there are</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:475"><nobr><span class="ft15"> </span></nobr></DIV>
<DIV style="position:absolute;top:222;left:482"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:482"><nobr><span class="ft16">r</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:488"><nobr><span class="ft15">¡ possibilities of finishing the joining sequence. Thus there are</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:475"><nobr><span class="ft4">in total</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:518"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:521"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:266;left:520"><nobr><span class="ft16">iaH</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:542"><nobr><span class="ft15"> </span></nobr></DIV>
<DIV style="position:absolute;top:249;left:548"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:556"><nobr><span class="ft16">i</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:569"><nobr><span class="ft15">¡ a P</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:603"><nobr><span class="ft16">n I</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:629"><nobr><span class="ft4">possibilities of different query execu-</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:475"><nobr><span class="ft4">tion plans.</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:531"><nobr><span class="ft12">6</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:537"><nobr><span class="ft4">. In this specially shaped query tree exists an execution</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:475"><nobr><span class="ft4">pipeline of length</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:572"><nobr><span class="ft15">n I that allows both for easier parallelizing and</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:475"><nobr><span class="ft10">for shortening the response time [8] This property is very useful in<br>the context of the WWW where many applications are built in a<br>producer-consumer paradigm.</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:475"><nobr><span class="ft3"><b>4.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:371;left:516"><nobr><span class="ft3"><b>Cost Model</b></span></nobr></DIV>
<DIV style="position:absolute;top:393;left:489"><nobr><span class="ft4">The main goal of query optimization is to reduce the computa-</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:475"><nobr><span class="ft10">tional cost of processing the query both in terms of the transmission<br>cost and the cost of performing join operations on the retrieved re-<br>sult fragments. In order to determine a good strategy for process-<br>ing a query, we have to be able to exactly determine the cost of a<br>query execution plan and to compare it to costs of alternative plans.<br>For this purpose, we capture the computational costs of alternative<br>query plans in a cost model that provides the basis for the optimiza-<br>tion algorithm that is discussed later.</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:489"><nobr><span class="ft4">As mentioned earlier, we adopt the memory-resident paradigm,</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:475"><nobr><span class="ft10">and the cost we are trying to minimize is equivalent to minimizing<br>the total execution time. There are two main factors that influence<br>the resulting cost in our model. First is the cost of data transmission<br>to the mediator, and second is the data processing cost.</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:490"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:501"><nobr><span class="ft11">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:563"><nobr><span class="ft4">5</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:584"><nobr><span class="ft4">(T</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:598"><nobr><span class="ft11">RANSMISSION</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:682"><nobr><span class="ft4">C</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:692"><nobr><span class="ft11">OST</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:714"><nobr><span class="ft4">). <i>The transmission</i></span></nobr></DIV>
<DIV style="position:absolute;top:662;left:475"><nobr><span class="ft6"><i>cost of path instances of the schema path</i></span></nobr></DIV>
<DIV style="position:absolute;top:658;left:712"><nobr><span class="ft15">p <i>from a source </i> <i>to</i></span></nobr></DIV>
<DIV style="position:absolute;top:677;left:475"><nobr><span class="ft6"><i>the mediator is modelled as</i></span></nobr></DIV>
<DIV style="position:absolute;top:674;left:635"><nobr><span class="ft15"> g</span></nobr></DIV>
<DIV style="position:absolute;top:679;left:655"><nobr><span class="ft16">p</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:668"><nobr><span class="ft15">a ginit</span></nobr></DIV>
<DIV style="position:absolute;top:679;left:719"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:674;left:734"><nobr><span class="ft15">C jpj £ vngth</span></nobr></DIV>
<DIV style="position:absolute;top:679;left:816"><nobr><span class="ft16">p</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:827"><nobr><span class="ft15">£</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:475"><nobr><span class="ft15">ksk</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:518"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:689;left:531"><nobr><span class="ft15">£ g</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:551"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:693;left:565"><nobr><span class="ft6"><i>where</i></span></nobr></DIV>
<DIV style="position:absolute;top:689;left:600"><nobr><span class="ft15">ginit</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:634"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:693;left:648"><nobr><span class="ft6"><i>represents the cost of initiating the</i></span></nobr></DIV>
<DIV style="position:absolute;top:709;left:475"><nobr><span class="ft6"><i>data transmission,</i></span></nobr></DIV>
<DIV style="position:absolute;top:705;left:580"><nobr><span class="ft15">jpj <i>denotes the cardinality, </i>vngth</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:769"><nobr><span class="ft16">p</span></nobr></DIV>
<DIV style="position:absolute;top:709;left:779"><nobr><span class="ft6"><i>stands for</i></span></nobr></DIV>
<DIV style="position:absolute;top:724;left:475"><nobr><span class="ft6"><i>the length of the schema path</i></span></nobr></DIV>
<DIV style="position:absolute;top:721;left:641"><nobr><span class="ft15">p<i>, </i>ksk</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:698"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:724;left:713"><nobr><span class="ft6"><i>is the size of a URI at</i></span></nobr></DIV>
<DIV style="position:absolute;top:740;left:475"><nobr><span class="ft6"><i>the source X</i></span></nobr></DIV>
<DIV style="position:absolute;top:737;left:544"><nobr><span class="ft12">7</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:554"><nobr><span class="ft6"><i>and</i></span></nobr></DIV>
<DIV style="position:absolute;top:736;left:579"><nobr><span class="ft15">g</span></nobr></DIV>
<DIV style="position:absolute;top:742;left:588"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:740;left:603"><nobr><span class="ft6"><i>represents transmission cost per data unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:756;left:475"><nobr><span class="ft6"><i>from</i></span></nobr></DIV>
<DIV style="position:absolute;top:752;left:503"><nobr><span class="ft15"> <i>to the mediator.</i></span></nobr></DIV>
<DIV style="position:absolute;top:789;left:489"><nobr><span class="ft4">Since we apply all reducing operations (e.g., selections and pro-</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:475"><nobr><span class="ft10">jections) prior to the data transmission phase, the data processing<br>mainly consists of join costs. The cost of a join operation is influ-<br>enced by the cardinality of the two operands and the join-method<br>which is utilized. As we already pointed out, there are no instance<br>indices at the mediator side that would allow us to use some join<br>"shortcuts". In the following we consider two join methods: a<br>nested loop join and a hash join both without additional indexing<br>support.</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:490"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:501"><nobr><span class="ft11">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:563"><nobr><span class="ft4">6</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:584"><nobr><span class="ft4">(N</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:600"><nobr><span class="ft11">ESTED LOOP JOIN COST</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:734"><nobr><span class="ft4">). <i>The processing</i></span></nobr></DIV>
<DIV style="position:absolute;top:964;left:475"><nobr><span class="ft6"><i>cost of a nested loop join of two relations</i></span></nobr></DIV>
<DIV style="position:absolute;top:960;left:696"><nobr><span class="ft15">pY r <i>is defined as </i>xtg</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:818"><nobr><span class="ft16">pYr</span></nobr></DIV>
<DIV style="position:absolute;top:976;left:475"><nobr><span class="ft15">a jpj£jrj£u@pY rA<i>, where </i>jxj <i>denotes the cardinality of the relation</i></span></nobr></DIV>
<DIV style="position:absolute;top:991;left:475"><nobr><span class="ft15">x <i>and </i>u@pY rA <i>represents the cost of the identity comparison.</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:477"><nobr><span class="ft12">6</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:482"><nobr><span class="ft4">The number corresponds to a sum of the</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:698"><nobr><span class="ft15">n I-th line in the Pascal</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:475"><nobr><span class="ft4">triangle.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:477"><nobr><span class="ft12">7</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:482"><nobr><span class="ft4">Different sources may model URIs differently, however, we as-</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:475"><nobr><span class="ft4">sume that at the mediator all URIs are represented in the same way.</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">636</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
	.ft24{font-size:11px;line-height:19px;font-family:Times;color:#000000;}
	.ft25{font-size:11px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="917" height="1187" src="109007.png" alt="background image">
<DIV style="position:absolute;top:86;left:94"><nobr><span class="ft4">Note that the nested loop join allows for a more sophisticated</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:81"><nobr><span class="ft10">definition of object equality than a common URI comparison. In<br>particular, if necessary, the basic URI comparison can be comple-<br>mented by (recursive) comparisons of property values or mapping<br>look-ups. This offers room to address the issue of URI diversity<br>also known as the designation problem, when two different URIs<br>refer to the same real-life object.</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:96"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:211;left:106"><nobr><span class="ft11">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:168"><nobr><span class="ft4">7</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:190"><nobr><span class="ft4">(H</span></nobr></DIV>
<DIV style="position:absolute;top:211;left:205"><nobr><span class="ft11">ASH JOIN COST</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:292"><nobr><span class="ft4">). <i>The processing cost of a</i></span></nobr></DIV>
<DIV style="position:absolute;top:225;left:81"><nobr><span class="ft6"><i>hash join of two relations</i></span></nobr></DIV>
<DIV style="position:absolute;top:221;left:225"><nobr><span class="ft15">pY r <i>is defined as </i>rtg</span></nobr></DIV>
<DIV style="position:absolute;top:227;left:352"><nobr><span class="ft16">pYr</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:373"><nobr><span class="ft15">a s £ jpj C</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:81"><nobr><span class="ft13"> £ jrj £ f<i>, where </i>jxj <i>denotes the cardinality of the relation </i>x<i>, </i>s<br><i>represents the cost of inserting a path instance in the hash table (the<br>building factor),</i></span></nobr></DIV>
<DIV style="position:absolute;top:268;left:173"><nobr><span class="ft15"> <i>models the cost of retrieving a bucket from the</i></span></nobr></DIV>
<DIV style="position:absolute;top:288;left:81"><nobr><span class="ft6"><i>hash table, and</i></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:166"><nobr><span class="ft15">f <i>stands for the average number of path instances</i></span></nobr></DIV>
<DIV style="position:absolute;top:303;left:81"><nobr><span class="ft6"><i>in the bucket.</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:94"><nobr><span class="ft4">Unlike the previous join method, the hash join algorithm as-</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:81"><nobr><span class="ft10">sumes that the object equality can be determined by a simple URI<br>comparison, in other words that the URI references are consistent<br>across the sources. Another difference is that in the case of the<br>nested loop join for in-memory relations the join commutativity can<br>be neglected, as the query plan produced from another query plan<br>by the commutativity law will have exactly the same cost. How-<br>ever, in the case of the hash join method the order of operands<br>influences the cost and thus the solution space must also include<br>those solutions produced by the commutativity law.</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:96"><nobr><span class="ft4">D</span></nobr></DIV>
<DIV style="position:absolute;top:504;left:106"><nobr><span class="ft11">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:168"><nobr><span class="ft4">8</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:190"><nobr><span class="ft4">(Q</span></nobr></DIV>
<DIV style="position:absolute;top:504;left:205"><nobr><span class="ft11">UERY PLAN COST</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:304"><nobr><span class="ft4">). <i>The overall cost of a</i></span></nobr></DIV>
<DIV style="position:absolute;top:518;left:81"><nobr><span class="ft6"><i>query plan</i></span></nobr></DIV>
<DIV style="position:absolute;top:514;left:141"><nobr><span class="ft15"> <i>consists of the sum of all communication costs and all</i></span></nobr></DIV>
<DIV style="position:absolute;top:540;left:81"><nobr><span class="ft6"><i>join processing costs of the query tree.</i></span></nobr></DIV>
<DIV style="position:absolute;top:537;left:288"><nobr><span class="ft15"> g</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:320"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:537;left:330"><nobr><span class="ft15">a</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:350"><nobr><span class="ft16">n</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:346"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:552;left:345"><nobr><span class="ft16">iaI</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:365"><nobr><span class="ft15"> g</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:385"><nobr><span class="ft16">p</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:391"><nobr><span class="ft21">i</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:397"><nobr><span class="ft15">C g</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:430"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:540;left:436"><nobr><span class="ft6"><i>,</i></span></nobr></DIV>
<DIV style="position:absolute;top:564;left:81"><nobr><span class="ft6"><i>where</i></span></nobr></DIV>
<DIV style="position:absolute;top:560;left:117"><nobr><span class="ft15"> g</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:138"><nobr><span class="ft16"></span></nobr></DIV>
<DIV style="position:absolute;top:564;left:148"><nobr><span class="ft6"><i>represents the join processing cost of the query tree</i></span></nobr></DIV>
<DIV style="position:absolute;top:560;left:432"><nobr><span class="ft15"></span></nobr></DIV>
<DIV style="position:absolute;top:580;left:81"><nobr><span class="ft13"><i>and it is computed as a sum of recurrent applications of the formula<br>in Definition 6 or 7 depending on which join method is utilized. To<br>compute the cardinality of non-base join arguments, a join selec-<br>tivity is used. The join selectivity</i></span></nobr></DIV>
<DIV style="position:absolute;top:623;left:268"><nobr><span class="ft15">' <i>is defined as a ratio between</i></span></nobr></DIV>
<DIV style="position:absolute;top:642;left:81"><nobr><span class="ft25"><i>the tuples retained by the join and those created by the Cartesian<br>product:</i></span></nobr></DIV>
<DIV style="position:absolute;top:656;left:131"><nobr><span class="ft15">' a</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:159"><nobr><span class="ft16">jpFGrj</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:160"><nobr><span class="ft16">jp¢rj</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:189"><nobr><span class="ft6"><i>.</i></span></nobr></DIV>
<DIV style="position:absolute;top:690;left:94"><nobr><span class="ft4">As it is not possible to determine the precise join selectivity be-</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:81"><nobr><span class="ft4">fore the query is evaluated,</span></nobr></DIV>
<DIV style="position:absolute;top:702;left:231"><nobr><span class="ft15">' for each sub-path join is assumed to</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:81"><nobr><span class="ft10">be estimated and available in the source index hierarchy. After the<br>evaluation of each query initial</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:249"><nobr><span class="ft15">' estimates are improved and made</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:81"><nobr><span class="ft4">more realistic.</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:81"><nobr><span class="ft3"><b>4.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:778;left:121"><nobr><span class="ft3"><b>Heuristics for join ordering</b></span></nobr></DIV>
<DIV style="position:absolute;top:800;left:94"><nobr><span class="ft4">While the join ordering problem in the context of a linear/chain</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:81"><nobr><span class="ft10">query can be solved in a polynomial time [12], we have to take into<br>account the more complex problem when also the explicit joins are<br>involved which is proven to be NP-hard [15]. It is apparent that<br>evaluating all possible join strategies for achieving the global opti-<br>mum becomes quickly unfeasible for a larger</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:329"><nobr><span class="ft15">n. In these cases we</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:81"><nobr><span class="ft10">have to rely on heuristics that compute a "good-enough" solution<br>given the constraints. In fact, this is a common approach for op-<br>timizers in interactive systems. There, optimization is often about<br>avoiding bad query plans in very short time, rather than devoting<br>a lot of the precious CPU time to find the optimal plan, especially,<br>when it is not so uncommon that the optimal plan improves the<br>heuristically obtained solutions only marginally.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:94"><nobr><span class="ft4">Heuristics for the join ordering problem have been studied exten-</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft10">sively in the database community. In this work we adopt the results<br>of comparing different join ordering heuristics from [17]. Inspired<br>from this survey, we chose to apply the two-phase optimization</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft10">consisting of the iterative improvement (II) algorithm followed by<br>the simulated annealing (SA) algorithm [20]. This combination<br>performs very well on the class of queries we are interested in,<br>both in the bushy and the right-deep tree solution space, and de-<br>grades gracefully under time constrains.</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:489"><nobr><span class="ft4">The II algorithm is a simple greedy heuristics which accepts any</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:475"><nobr><span class="ft10">improvement on the cost function. The II randomly generates sev-<br>eral initial solutions, taking them as starting points for a walk in<br>the chosen solution space. The actual traversal is performed by ap-<br>plying a series of random moves from a predefined set. The cost<br>function is evaluated for every such move, remembering the best<br>solution so far. The main idea of this phase is to descent rapidly<br>into several local minima assuring aforementioned graceful degra-<br>dation. For each of the sub-optimal solutions, the second phase<br>of the SA algorithm is applied. The task of the SA phase is to<br>explore the "neighborhood" of a prosperous solution more thor-<br>oughly, hopefully lowering the cost.</span></nobr></DIV>
<DIV style="position:absolute;top:397;left:475"><nobr><span class="ft5"><b>Algorithm 2</b></span></nobr></DIV>
<DIV style="position:absolute;top:397;left:548"><nobr><span class="ft4">Simulated annealing algorithm</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:475"><nobr><span class="ft5"><b>Require:</b></span></nobr></DIV>
<DIV style="position:absolute;top:415;left:532"><nobr><span class="ft4">start solution</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:606"><nobr><span class="ft15">solution</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:475"><nobr><span class="ft5"><b>Require:</b></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:532"><nobr><span class="ft4">start temperature</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:627"><nobr><span class="ft15">s empr</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:489"><nobr><span class="ft15">solution := solution</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:489"><nobr><span class="ft15">estolution := solution</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:489"><nobr><span class="ft15">tempr := s empr</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:489"><nobr><span class="ft15">ost := gost@estolutionA</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:489"><nobr><span class="ft24">mingost := ost<br><b>repeat</b></span></nobr></DIV>
<DIV style="position:absolute;top:541;left:502"><nobr><span class="ft5"><b>repeat</b></span></nobr></DIV>
<DIV style="position:absolute;top:553;left:516"><nobr><span class="ft15">newolution := NEW(solution)</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:516"><nobr><span class="ft24">newgost := gost@newolutionA<br><b>if</b></span></nobr></DIV>
<DIV style="position:absolute;top:584;left:531"><nobr><span class="ft15">newgost   ost <b>then</b></span></nobr></DIV>
<DIV style="position:absolute;top:600;left:529"><nobr><span class="ft15">solution := newolution</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:529"><nobr><span class="ft15">ost := newCost</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:516"><nobr><span class="ft5"><b>else if</b></span></nobr></DIV>
<DIV style="position:absolute;top:635;left:551"><nobr><span class="ft15">e</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:560"><nobr><span class="ft21"> @newgost ostA</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:588"><nobr><span class="ft21">tempr</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:651"><nobr><span class="ft15">! exh@HXXIA <b>then</b></span></nobr></DIV>
<DIV style="position:absolute;top:650;left:529"><nobr><span class="ft15">solution := newolution</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:529"><nobr><span class="ft15">ost := newCost</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:516"><nobr><span class="ft20"><b>end if<br>if</b></span></nobr></DIV>
<DIV style="position:absolute;top:697;left:527"><nobr><span class="ft15">ost ` mingost <b>then</b></span></nobr></DIV>
<DIV style="position:absolute;top:713;left:529"><nobr><span class="ft15">estolution := solution</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:529"><nobr><span class="ft15">mingost := ost</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:516"><nobr><span class="ft5"><b>end if</b></span></nobr></DIV>
<DIV style="position:absolute;top:764;left:502"><nobr><span class="ft5"><b>until</b></span></nobr></DIV>
<DIV style="position:absolute;top:764;left:532"><nobr><span class="ft4">equilibrium reached</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:502"><nobr><span class="ft4">DECREASE(</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:576"><nobr><span class="ft15">tempr)</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:489"><nobr><span class="ft5"><b>until</b></span></nobr></DIV>
<DIV style="position:absolute;top:795;left:519"><nobr><span class="ft4">frozen</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:489"><nobr><span class="ft5"><b>return</b></span></nobr></DIV>
<DIV style="position:absolute;top:807;left:529"><nobr><span class="ft15">estolution</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:489"><nobr><span class="ft4">The pseudo-code of the SA phase is presented in Algorithm 2.</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:475"><nobr><span class="ft10">It takes a starting point/solution from the II phase, and similarly to<br>II performs random moves from a predefined set accepting all cost<br>improvements. However, unlike the II, the SA algorithm can accept<br>with a certain probability also those moves that result in a solution<br>with a higher cost than the current best solution. The probability of<br>such acceptance depends on the temperature of the system and the<br>cost difference. The idea is that at the beginning the system is hot<br>and accepts easier the moves yielding even solutions with higher<br>costs. However, as the temperature decreases the system is be-<br>coming more stable, strongly preferring those solutions with lower<br>costs. The SA algorithm improves on the II heuristics by making<br>the stop condition less prone to get trapped in a local minimum; SA<br>stops when the temperature drops below a certain threshold or if the<br>best solution so far was not improved in a number of consecutive</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">637</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="917" height="1187" src="109008.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft10">temperature decrements, the system is considered frozen. There<br>are two sets of moves: one for the bushy solution space and one for<br>the right-deep solution space; for details we refer the reader to [20].</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:81"><nobr><span class="ft20"><b>Figure 5: Acceptance probability with respect to the tempera-<br>ture and the cost difference.</b></span></nobr></DIV>
<DIV style="position:absolute;top:462;left:94"><nobr><span class="ft4">Figure 5 shows the acceptance probability dependency in the SA</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:81"><nobr><span class="ft10">phase computed for the range of parameters that we used in our ex-<br>periments. As we adopted the two-phase algorithm our simulations<br>were able to reproduce the trends in results presented in [17]; due<br>to the lack of space we omit the detail performance analysis and the<br>interested reader is referred to the aforementioned survey.</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:81"><nobr><span class="ft3"><b>5.</b></span></nobr></DIV>
<DIV style="position:absolute;top:574;left:112"><nobr><span class="ft3"><b>RELATED WORK</b></span></nobr></DIV>
<DIV style="position:absolute;top:596;left:94"><nobr><span class="ft4">In this paper we focused mainly on basic techniques such as in-</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:81"><nobr><span class="ft10">dexing and join ordering. Relevant related work is described in the<br>remainder of this section. More advanced techniques such as site<br>selection and dynamic data placement are not considered, because<br>they are not supported by the current architecture of the system.<br>We also do not consider techniques that involve view-based query<br>answering techniques [6] because we are currently not considering<br>the problem of integrating heterogeneous data.</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:81"><nobr><span class="ft3"><b>5.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:121"><nobr><span class="ft3"><b>Index Structures for Object Models</b></span></nobr></DIV>
<DIV style="position:absolute;top:753;left:94"><nobr><span class="ft4">There has been quite a lot of research on indexing object oriented</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:81"><nobr><span class="ft10">databases. The aim of this work was to speed up querying and nav-<br>igation in large object databases. The underlying idea of many ex-<br>isting approaches is to regard an object base as a directed graph,<br>where objects correspond to nodes, and object properties to links<br>[16]. This view directly corresponds to RDF data, that is often also<br>regarded as a directed graph. Indices over such graph structures<br>now describe paths in the graph based on a certain pattern normally<br>provided by the schema. Different indexing techniques vary on the<br>kind of path patterns they describe and on the structure of the index.<br>Simple index structures only refer to a single property and organize<br>objects according to the value of that property. Nested indices and<br>path indices cover a complete path in the model that might contain<br>a number of objects and properties [2]. In RDF as well as in object<br>oriented databases, the inheritance relation plays a special role as it<br>is connected with a predefined semantics. Special index structures<br>have been developed to speed up queries about such hierarchies and<br>have recently been rediscovered for indexing RDF data [5]. In the<br>area of object-oriented database systems, these two kinds of index-<br>ing structures have been combined resulting in the so-called nested<br>inheritance indices [3] and generalized nested inheritance indices</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft10">[16]. These index structures directly represent implications of in-<br>heritance reasoning, an approach that is equivalent to indexing the<br>deductive closure of the model.</span></nobr></DIV>
<DIV style="position:absolute;top:158;left:475"><nobr><span class="ft3"><b>5.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:158;left:516"><nobr><span class="ft3"><b>Query Optimization</b></span></nobr></DIV>
<DIV style="position:absolute;top:180;left:489"><nobr><span class="ft4">There is a long tradition of work on distributed databases in gen-</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:475"><nobr><span class="ft10">eral [13] and distributed query processing in particular [10]. The<br>dominant problem is the generation of an optimal query plan that<br>reduces execution costs as much as possible while guaranteeing<br>completeness of the result. As described by Kossmann in [10],<br>the choice of techniques for query plan generation depends on the<br>architecture of the distributed system. He discusses basic tech-<br>niques as well as methods for client-server architectures and for<br>heterogeneous databases. Due to our architectural limitations (e.g.,<br>limited source capabilities) we focused on join-ordering optimiza-<br>tion which can be performed in a centralized manner by the medi-<br>ator. While some restricted cases of this problem can be solved in<br>a polynomial time [12, 11], the general problem of finding an opti-<br>mal plan for evaluating join queries has been proven to be NP-hard<br>[15]. The approaches to tackle this problem can be split into several<br>categories [17]: deterministic algorithms, randomized algorithms,<br>and genetic algorithms. Deterministic algorithms often use tech-<br>niques of dynamic programming (e.g. [12]), however, due to the<br>complexity of the problem they introduce simplifications, which<br>render them as heuristics. Randomized algorithms (e.g. [20, 19]),<br>perform a random walk in the solution space according to certain<br>rules. After the stop-condition is fulfilled, the best solution found<br>so far is declared as the result. Genetic algorithms (e.g. [18]) per-<br>ceive the problem as biological evolution; they usually start with a<br>random population (set of solutions) and generate offspring by ap-<br>plying a crossover and mutation. Subsequently, the selection phase<br>eliminates weak members of the new population.</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:475"><nobr><span class="ft3"><b>6.</b></span></nobr></DIV>
<DIV style="position:absolute;top:621;left:507"><nobr><span class="ft3"><b>LIMITATIONS AND FUTURE WORK</b></span></nobr></DIV>
<DIV style="position:absolute;top:643;left:489"><nobr><span class="ft4">The work reported in this paper can be seen as a very first step</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:475"><nobr><span class="ft10">towards a solution for the problem of distributed processing of RDF<br>queries. We motivated the overall problem and proposed some data<br>structures and algorithms that deal with the most fundamental prob-<br>lems of distributed querying in a predefined setting. We identified<br>a number of limitations of the current proposal with respect to the<br>generality of the approach and assumptions made. These limita-<br>tions also set the agenda for future work to be done on distributed<br>RDF querying and its support in Sesame.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:489"><nobr><span class="ft5"><b>Implementation</b></span></nobr></DIV>
<DIV style="position:absolute;top:800;left:585"><nobr><span class="ft4">Currently, our work on distributed query pro-</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:475"><nobr><span class="ft10">cessing is of a purely theoretical nature. The design and evaluation<br>of the methods described are based on previous work reported in<br>the literature and on worst-case complexity estimations. The next<br>step is to come up with a test implementation of a distributed RDF<br>storage system. The implementation will follow the architecture<br>introduced in the beginning of the paper and will be built on top of<br>the Sesame storage and retrieval engine. The implementation will<br>provide the basis for a more practical evaluation of our approach<br>and will allow us to make assertions about the real system behavior<br>in the presence of different data sets and different ways they are<br>distributed. Such a practical evaluation will be the basis for further<br>optimization of the methods.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:489"><nobr><span class="ft5"><b>Schema-Awareness</b></span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:603"><nobr><span class="ft4">One of the limitations of the approach de-</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:475"><nobr><span class="ft10">scribed in this paper concerns schema aware querying in a dis-<br>tributed setting. Even if every single repository is capable of com-<br>puting the deductive closure of the model it contains, the overall</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">638</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:917;height:1187;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="917" height="1187" src="109009.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft10">result is not necessarily complete, as schema information in one<br>repository can have an influence on information in other reposito-<br>ries. This information could lead to additional conclusions if taken<br>into account during query processing. In order to be able to deal<br>with this situation, we need to do some additional reasoning within<br>the mediator in order to detect and process dependencies between<br>the different models.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:94"><nobr><span class="ft5"><b>Object Identity</b></span></nobr></DIV>
<DIV style="position:absolute;top:212;left:185"><nobr><span class="ft4">One of the basic operations of query processing</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:81"><nobr><span class="ft10">is the computation of joins of relations that correspond to individual<br>properties. The basic assumption we make at this point is that we<br>are able to uniquely determine object identity. Identity is essential<br>because it is the main criterion that determines whether to connect<br>two paths or not. From a pragmatic point of view, the URI of an<br>RDF resource provides us with an identity criterion. While this<br>may be the case in a single repository, it is not clear at all whether<br>we can make this assumption in a distributed setting as different<br>repositories can contain information about the same real world ob-<br>ject (e.g., a paper) and assign different URIs to it. To deal with this<br>situation we have to develop heuristics capable of deciding whether<br>two resources describe the same real world object.</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:94"><nobr><span class="ft5"><b>Query Model</b></span></nobr></DIV>
<DIV style="position:absolute;top:432;left:174"><nobr><span class="ft4">In order to be able to design efficient index struc-</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:81"><nobr><span class="ft10">tures we restricted ourselves to path queries as a query model that<br>is directly supported. We argued above that tree-shaped queries<br>can be easily split into a number of path queries that have to be<br>joined afterwards. Nevertheless, this simplification does not apply<br>to the optimization part which is capable of processing also differ-<br>ent query shapes. An important aspect of future work is to extend<br>our indexing approach to more expressive query models that also<br>include tree and graph shaped queries which can be found in exist-<br>ing RDF query languages. It remains to be seen whether the same<br>kind of structures and algorithms can be used for more complex<br>queries or whether we have to find alternatives.</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:94"><nobr><span class="ft5"><b>Architecture</b></span></nobr></DIV>
<DIV style="position:absolute;top:636;left:171"><nobr><span class="ft4">The starting point of our investigation was a par-</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:81"><nobr><span class="ft10">ticular architecture, namely a distributed repository where the data<br>is accessed at a single point but stored in different repositories. We<br>further made the assumption that these repositories are read-only,<br>i.e., they only provide answers to path queries that they are known<br>to contain some information about.</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:94"><nobr><span class="ft4">An interesting question is how more flexible architectures can</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:81"><nobr><span class="ft10">be supported. We think of architectures where information is ac-<br>cessed from multiple points and repositories are able to forward<br>queries. Further we can imagine grid-based architectures where<br>components can perform local query processing on data received<br>from other repositories. A prominent example of such more flex-<br>ible architectures are peer-to-peer systems. This would also bring<br>a new potential for optimization as peers may collaborate on query<br>evaluation which in turn may help in reducing both the communi-<br>cation and processing costs.</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:81"><nobr><span class="ft3"><b>7.</b></span></nobr></DIV>
<DIV style="position:absolute;top:911;left:112"><nobr><span class="ft3"><b>REFERENCES</b></span></nobr></DIV>
<DIV style="position:absolute;top:938;left:87"><nobr><span class="ft4">[1] P. Bernstein and D. Chiu. Using semi-joins to solve</span></nobr></DIV>
<DIV style="position:absolute;top:954;left:110"><nobr><span class="ft4">relational queries. <i>Journal of the ACM</i>, 28:25­40, 1981.</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:87"><nobr><span class="ft4">[2] E. Bertino. An indexing technique for object-oriented</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:110"><nobr><span class="ft13">databases. In <i>Proceedings of the Seventh International<br>Conference on Data Engineering, April 8-12, 1991, Kobe,<br>Japan</i>, pages 160­170. IEEE Computer Society, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:87"><nobr><span class="ft4">[3] E. Bertino and P. Foscoli. Index organizations for</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:110"><nobr><span class="ft10">object-oriented database systems. <i>TKDE</i>, 7(2):193­209,<br>1995.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:482"><nobr><span class="ft4">[4] J. Broekstra, A. Kampman, and F. van Harmelen. Sesame: A</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:504"><nobr><span class="ft10">generic architecture for storing and querying rdf and rdf<br>schema. In <i>The Semantic Web - ISWC 2002</i>, volume 2342 of<br><i>LNCS</i>, pages 54­68. Springer, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:151;left:482"><nobr><span class="ft4">[5] V. Christophides, D. Plexousakisa, M. Scholl, and</span></nobr></DIV>
<DIV style="position:absolute;top:166;left:504"><nobr><span class="ft10">S. Tourtounis. On labeling schemes for the semantic web. In<br><i>Proceedings of the 13th World Wide Web Conference</i>, pages<br>544­555, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:482"><nobr><span class="ft4">[6] A. Halevy. Answering queries using views - a survey. <i>The</i></span></nobr></DIV>
<DIV style="position:absolute;top:231;left:504"><nobr><span class="ft6"><i>VLDB Journal</i>, 10(4):270­294, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:482"><nobr><span class="ft4">[7] J. Hendler. Agents and the semantic web. <i>IEEE Intelligent</i></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:504"><nobr><span class="ft6"><i>Systems</i>, (2), 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:482"><nobr><span class="ft4">[8] H. Hsiao, M. Chen, and P. Yu. Parallel execution of hash</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:504"><nobr><span class="ft13">joins in parallel databases. <i>IEEE Transactions on Parallel<br>and Distributed Systems</i>, 8:872­883, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:482"><nobr><span class="ft4">[9] Y. Ioannidis and E. Wong. Query optimization by simulated</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:504"><nobr><span class="ft13">annealing. In <i>ACM SIGMOD International Conference on<br>Management of Data</i>, pages 9­22. ACM:Press, 1987.</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:475"><nobr><span class="ft4">[10] D. Kossmann. The state of the art in distributed query</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:504"><nobr><span class="ft4">processing. <i>ACM Computing Surveys</i>, 32(4):422­469, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:475"><nobr><span class="ft4">[11] G. Moerkotte. Constructing optimal bushy trees possibly</span></nobr></DIV>
<DIV style="position:absolute;top:426;left:504"><nobr><span class="ft10">containing cross products for order preserving joins is in p,<br>tr-03-012. Technical report, University of Mannheim, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:475"><nobr><span class="ft4">[12] K. Ono and G. M. Lohman. Measuring the complexity of</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:504"><nobr><span class="ft10">join enumeration in query optimization. In <i>16th International<br>Conference on Very Large Data Bases</i>, pages 314­325.<br>Morgan Kaufmann, 1990.</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:475"><nobr><span class="ft4">[13] M. Ozsu and P. Valduriez. <i>Principles of Distributed</i></span></nobr></DIV>
<DIV style="position:absolute;top:539;left:504"><nobr><span class="ft6"><i>Database Systems</i>. Prentice Hall, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:475"><nobr><span class="ft4">[14] D. Rotem. Spatial join indices. In <i>Proceedings of</i></span></nobr></DIV>
<DIV style="position:absolute;top:572;left:504"><nobr><span class="ft6"><i>International Conference on Data Engineering</i>, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:475"><nobr><span class="ft4">[15] W. Scheufele and G. Moerkotte. Constructing optimal bushy</span></nobr></DIV>
<DIV style="position:absolute;top:605;left:504"><nobr><span class="ft10">processing trees for join queries is np-hard, tr-96-011.<br>Technical report, University of Mannheim, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:475"><nobr><span class="ft4">[16] B. Shidlovsky and E. Bertino. A graph-theoretic approach to</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:504"><nobr><span class="ft13">indexing in object-oriented databases. In S. Y. W. Su, editor,<br><i>Proceedings of the Twelfth International Conference on Data<br>Engineering, February 26 - March 1, 1996, New Orleans,<br>Louisiana</i>, pages 230­237. IEEE Computer Society, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:718;left:475"><nobr><span class="ft4">[17] M. Steinbrunn, G. Moerkotte, and A. Kemper. Heuristic and</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:504"><nobr><span class="ft13">randomized optimization for join ordering problem. <i>The<br>VLDB Journal</i>, 6:191­208, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:475"><nobr><span class="ft4">[18] M. Stillger and M. Spiliopoulou. Genetic programming in</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:504"><nobr><span class="ft10">database query optimization. In J. R. Koza, D. E. Goldberg,<br>D. B. Fogel, and R. L. Riolo, editors, <i>Genetic Programming<br>1996: Proceedings of the First Annual Conference</i>, pages<br>388­393. MIT Press, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:846;left:475"><nobr><span class="ft4">[19] A. Swami. Optimization of large join queries: combining</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:504"><nobr><span class="ft10">heuristics and combinatorial techniques. In <i>ACM SIGMOD<br>International Conference on Management of Data</i>, pages<br>367­376. ACM:Press, 1989.</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:475"><nobr><span class="ft4">[20] A. Swami and A. Gupta. Optimization of large join queries.</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:504"><nobr><span class="ft13">In <i>ACM SIGMOD International Conference on Management<br>of Data</i>, pages 8­17. ACM:Press, 1988.</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:475"><nobr><span class="ft4">[21] Z. Xie and J. Han. Join index hierarchies for supporting</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:504"><nobr><span class="ft13">efficient navigations in object-oriented databases. In<br><i>Proceedings of the International Conference on Very Large<br>Data Bases</i>, pages 522­533, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:475"><nobr><span class="ft4">[22] C. Yu and W. Meng. <i>Principles of Database Query</i></span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:504"><nobr><span class="ft10"><i>Processing for Advanced Applications</i>. Morgan Kaufmann<br>Publishers, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:1127;left:447"><nobr><span class="ft9">639</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
