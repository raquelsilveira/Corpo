<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>FINAL6.MKR</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="1998-06-01T19:02:20+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:18px;font-family:Helvetica;color:#000000;}
	.ft1{font-size:12px;font-family:Times;color:#000000;}
	.ft2{font-size:9px;font-family:Times;color:#000000;}
	.ft3{font-size:16px;font-family:Helvetica;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:11px;font-family:Times;color:#000000;}
	.ft6{font-size:11px;font-family:Helvetica;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:9px;font-family:Helvetica;color:#000000;}
	.ft9{font-size:9px;font-family:Times;color:#000000;}
	.ft10{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft11{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft12{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft13{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft14{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="6001.png" alt="background image">
<DIV style="position:absolute;top:80;left:290"><nobr><span class="ft0"><b>A Distributed 3D Graphics Library</b></span></nobr></DIV>
<DIV style="position:absolute;top:119;left:352"><nobr><span class="ft1">Blair MacIntyre and Steven Feiner</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:560"><nobr><span class="ft2">1</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:358"><nobr><span class="ft1">Department of Computer Science</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:396"><nobr><span class="ft1">Columbia University</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:81"><nobr><span class="ft3"><b>Abstract</b></span></nobr></DIV>
<DIV style="position:absolute;top:241;left:81"><nobr><span class="ft10">We present Repo-3D, a general-purpose, object-oriented library for<br>developing distributed, interactive 3D graphics applications across<br>a range of heterogeneous workstations. Repo-3D is designed to<br>make it easy for programmers to rapidly build prototypes using a<br>familiar multi-threaded, object-oriented programming paradigm.<br>All data sharing of both graphical and non-graphical data is done<br>via general-purpose remote and replicated objects, presenting the<br>illusion of a single distributed shared memory. Graphical objects<br>are directly distributed, circumventing the "duplicate database"<br>problem and allowing programmers to focus on the application<br>details.</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:90"><nobr><span class="ft4">Repo-3D is embedded in Repo, an interpreted, lexically-scoped,</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:81"><nobr><span class="ft10">distributed programming language, allowing entire applications to<br>be rapidly prototyped. We discuss Repo-3D's design, and introduce<br>the notion of <i>local variations</i> to the graphical objects, which allow<br>local changes to be applied to shared graphical structures. Local<br>variations are needed to support transient local changes, such as<br>highlighting, and responsive local editing operations. Finally, we<br>discuss how our approach could be applied using other program-<br>ming languages, such as Java.</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:81"><nobr><span class="ft6"><b>Categories and Subject Descriptors: </b></span></nobr></DIV>
<DIV style="position:absolute;top:548;left:341"><nobr><span class="ft4">D.1.3 [<b>Program-</b></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:81"><nobr><span class="ft7"><b>ming Techniques</b></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:182"><nobr><span class="ft4">]: Concurrent Programming--<i>Distributed Pro-</i></span></nobr></DIV>
<DIV style="position:absolute;top:577;left:81"><nobr><span class="ft12"><i>gramming</i>; H.4.1 [<b>Information Systems Applications</b>]: Office<br>Automation--<i>Groupware</i>; I.3.2 [<b>Computer Graphics</b>]: Graphics<br>Systems--<i>Distributed/network graphics</i>; I.3.6 [<b>Computer Graph-<br>ics</b></span></nobr></DIV>
<DIV style="position:absolute;top:622;left:96"><nobr><span class="ft4">]: Methodology and Techniques--<i>Graphics data structures and</i></span></nobr></DIV>
<DIV style="position:absolute;top:637;left:81"><nobr><span class="ft11"><i>data types</i>; I.3.7 [<b>Computer Graphics</b>]: Three-Dimensional<br>Graphics and Realism--<i>Virtual reality</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:81"><nobr><span class="ft6"><b>Additional Keywords and Phrases: </b></span></nobr></DIV>
<DIV style="position:absolute;top:674;left:306"><nobr><span class="ft4">object-oriented graphics,</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:81"><nobr><span class="ft10">distributed shared memory, distributed virtual environments,<br>shared-data object model.</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:81"><nobr><span class="ft3"><b>1  INTRODUCTION</b></span></nobr></DIV>
<DIV style="position:absolute;top:762;left:81"><nobr><span class="ft10">Traditionally,  <i>distributed graphics </i>has referred to the architecture<br>of a single graphical application whose components are distributed<br>over multiple machines [14, 15, 19, 27<A href="6.html#1">] (Figure 1</a></span></nobr></DIV>
<DIV style="position:absolute;top:791;left:367"><nobr><span class="ft1">a</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:373"><nobr><span class="ft4">). By taking</span></nobr></DIV>
<DIV style="position:absolute;top:807;left:81"><nobr><span class="ft10">advantage of the combined power of multiple machines, and the<br>particular features of individual machines, otherwise impractical<br>applications became feasible. However, as machines have grown<br>more powerful and application domains such as Computer</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:81"><nobr><span class="ft2">1. {bm,feiner}@cs.columbia.edu, http://www.cs.columbia.edu/graphics</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:475"><nobr><span class="ft10">Supported Cooperative Work (CSCW) and Distributed Virtual<br>Environments (DVEs) have been making the transition from<br>research labs to commercial products, the term <i>distributed graphics<br></i>is increasingly used to refer to systems for distributing the shared<br>graphical state of multi-display/multi-person, distributed, interac-<br>tive applications<A href="6.html#1"> (Figure 1</a>b). This is the definition that we use here.</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:484"><nobr><span class="ft4">While many excellent, high-level programming libraries are</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:475"><nobr><span class="ft11">available for building stand-alone 3D applications (e.g. Inventor<br>[35], Performer [29], Java 3D [33]), there are no similarly powerful<br>and general libraries for building distributed 3D graphics applica-<br>tions. All CSCW and DVE systems with which we are familiar<br>(e.g., [1, 7, 11, 12, 16, 28, 30, 31, 32, 34, 37, 41]) use the following<br>approach: A mechanism is provided for distributing application<br>state (either a custom solution or one based on a general-purpose<br>distributed programming environment, such as ISIS [4] or Obliq<br>[8]), and the state of the graphical display is maintained separately<br>in the local graphics library. Keeping these "dual databases" syn-<br>chronized is a complex, tedious, and error-prone endeavor. In con-<br>trast, some non-distributed libraries, such as Inventor [35], allow<br>programmers to avoid this problem by using the graphical scene<br>description to encode application state. Extending this "single data-<br>base" model to a distributed 3D graphics library is the goal of our<br>work on Repo-3D.</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:484"><nobr><span class="ft4">Repo-3D is an object-oriented, high-level graphics package,</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:475"><nobr><span class="ft10">derived from Obliq-3D [25]. Its 3D graphics facilities are similar to<br>those of other modern high-level graphics libraries. However, the<br>objects used to create the graphical scenes are directly distribut-<br>able--from the programmer's viewpoint, the objects reside in one<br>large distributed shared memory (DSM) instead of in a single<br>process. The underlying system replicates any of the fine-grained<br>objects across as many processes as needed, with no additional<br>effort on the part of the programmer. Updates to objects are<br>automatically reflected in all replicas, with any required objects<br>automatically distributed as needed. By integrating the replicated<br>objects into the programming languages we use, distributed<br>applications may be built using Repo-3D with little more difficulty<br>than building applications in a single process.</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:487"><nobr><span class="ft8"><b>Figure 1: </b></span></nobr></DIV>
<DIV style="position:absolute;top:425;left:541"><nobr><span class="ft2">Two meanings of <i>distributed graphics</i>: (a) a single logical</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:487"><nobr><span class="ft14">graphics system with distributed components, and (b) multiple dis-<br>tributed logical graphics systems. We use the second definition here.</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft15{font-size:14px;font-family:Courier;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="6002.png" alt="background image">
<DIV style="position:absolute;top:81;left:90"><nobr><span class="ft4">No matter how simple the construction of a distributed applica-</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:81"><nobr><span class="ft11">tion may be, a number of differences between distributed and<br>monolithic applications must be addressed. These include:</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:102"><nobr><span class="ft10"><i>Distributed control</i>. In a monolithic application, a single com-<br>ponent can oversee the application and coordinate activities<br>among the separate components by notifying them of changes<br>to the application state. This is not possible in a non-trivial dis-<br>tributed application. Therefore, we must provide mechanisms<br>for different components to be notified of changes to the<br>distributed state.</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:231;left:102"><nobr><span class="ft10"><i>Interactivity.</i> Updates to distributed state will be slower than<br>updates to local state, and the amount of data that can be<br>distributed is limited by network bandwidth. If we do not want<br>to sacrifice interactive speed, we must be able to perform some<br>operations locally. For example, an object could be dragged<br>locally with the mouse, with only a subset of the changes<br>applied to the replicated state.</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:102"><nobr><span class="ft10"><i>Local variations.</i> There are times when a shared graphical<br>scene may need to be modified locally. For example, a<br>programmer may want to highlight the object under one user's<br>mouse pointer without affecting the scene graph viewed by<br>other users. </span></nobr></DIV>
<DIV style="position:absolute;top:411;left:90"><nobr><span class="ft4">Repo-3D addresses these problems in two ways. First, a</span></nobr></DIV>
<DIV style="position:absolute;top:426;left:81"><nobr><span class="ft10">programmer can associate a <i>notification</i> object with any replicated<br>object. The notification object's methods will be invoked when the<br>replicated object is updated. This allows reactive programs to be<br>built in a straightforward manner. To deal with the second and third<br>problems, we introduce the notion of <i>local variations</i> to graphical<br>objects. That is, we allow the properties of a graphical object to be<br>modified locally, and parts of the scene graph to be locally added,<br>removed, or replaced.</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:90"><nobr><span class="ft4">In<A href="6.html#2"> Section 2 we</a> describe how we arrived at the solution presented</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:81"><nobr><span class="ft11">here.<A href="6.html#2"> Section 3</a> discusses related work, and<A href="6.html#3"> Section 4</a> offers a<br>detailed description of the underlying infrastructure that was used.<br>The design of Repo-3D is presented in <A href="6.html#5">Section 5</a>, followed by<br>some examples and concluding remarks in Sectio<A href="6.html#8">ns 6</a> <A href="6.html#8">and 7</a>.</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:81"><nobr><span class="ft3"><b>2  BACKGROUND</b></span></nobr></DIV>
<DIV style="position:absolute;top:664;left:81"><nobr><span class="ft11">Repo-3D was created as part of a project to support rapid prototyp-<br>ing of distributed, interactive 3D graphical applications, with a<br>particular focus on DVEs. Our fundamental belief is that by<br>providing uniform high-level support for distributed programming<br>in the languages and toolkits we use, prototyping and experiment-<br>ing with distributed interactive applications can be (almost) as<br>simple as multi-threaded programming in a single process. While<br>care must be taken to deal with network delays and bandwidth<br>limitations at some stage of the program design (the languages and<br>toolkits ought to facilitate this), it should be possible to ignore such<br>issues until they become a problem. Our view can be summarized<br>by a quote attributed to Alan Kay, "Simple things should be<br>simple; complex things should be possible."</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:90"><nobr><span class="ft4">This is especially true during the exploration and prototyping</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:81"><nobr><span class="ft11">phase of application programming. If programmers are forced to<br>expend significant effort building the data-distribution components<br>of the application at an early stage, not only will less time be spent<br>exploring different prototypes, but radical changes in direction will<br>become difficult, and thus unlikely. For example, the implementa-<br>tion effort could cause programs to get locked into using a commu-<br>nication scheme that may eventually prove less than ideal, or even<br>detrimental, to the program's final design.</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:90"><nobr><span class="ft4">Since we are using object-oriented languages, we also believe</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:81"><nobr><span class="ft10">that data distribution should be tightly integrated with the<br>language's general-purpose objects. This lets the language's type<br>system and programming constructs reduce or eliminate errors in<br>the use of the data-distribution system. Language-level integration</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:477"><nobr><span class="ft10">also allows the system to exhibit a high degree of <i>network data<br>transparency</i>, or the ability for the programmer to use remote and<br>local data in a uniform manner. Without pervasive, structured,<br>high-level data-distribution support integrated into our program-<br>ming languages and libraries, there are applications that will never<br>be built or explored, either because there is too much programming<br>overhead to justify trying simple things ("simple things are not<br>simple"), or because the added complexity of using relatively<br>primitive tools causes the application to become intractable ("com-<br>plex things are not possible").</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:486"><nobr><span class="ft4">Of the tools available for integrating distributed objects into</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:477"><nobr><span class="ft10">programming languages, client-server data sharing is by far the<br>most common approach, as exemplified by CORBA [26],<br>Modula-3 Network Objects [5], and Java RMI [39]. Unfortunately,<br>interactive graphical applications, such as virtual reality, require<br>that the data used to refresh the display be local to the process<br>doing the rendering or acceptable frame refresh rates will not be<br>achieved. Therefore, pure client-server approaches are inappropri-<br>ate because at least some of the shared data must be replicated.<br>Furthermore, since the time delay of synchronous remote method<br>calls is unsuitable for rapidly changing graphical applications,<br>shared data should be updated asynchronously. Finally, when data<br>is replicated, local access must still be fast.</span></nobr></DIV>
<DIV style="position:absolute;top:426;left:486"><nobr><span class="ft4">The most widely used protocols for replicated data consistency,</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:477"><nobr><span class="ft11">and thus many of the toolkits (e.g., ISIS [4] and Visual-Obliq [3]),<br>allow data updates to proceed unimpeded, but block threads read-<br>ing local data until necessary updates arrive. The same reason we<br>need replicated data in the first place--fast local read access to the<br>data--makes these protocols unsuitable for <i>direct</i> replication of the<br>graphical data. Of course, these protocols are fine for replicating<br>application state that will then be synchronized with a parallel<br>graphical scene description, but that is what we are explicitly try-<br>ing to avoid. Fortunately, there are replicated data systems (e.g.,<br>Orca [2] or COTERIE [24]) that provide replicated objects that are<br>well suited to interactive applications, and it is upon the second of<br>these systems that Repo-3D is built. </span></nobr></DIV>
<DIV style="position:absolute;top:638;left:477"><nobr><span class="ft3"><b>3  RELATED WORK</b></span></nobr></DIV>
<DIV style="position:absolute;top:664;left:477"><nobr><span class="ft10">There has been a significant amount of work that falls under the<br>first, older definition of distributed graphics. A large number of<br>systems, ranging from established commercial products (e.g., IBM<br>Visualization Data Explorer [21]) to research systems (e.g.,<br>PARADISE [19] and ATLAS [14]), have been created to distribute<br>interactive graphical applications over a set of machines. However,<br>the goal of these systems is to facilitate sharing of application data<br>between processes, with one process doing the rendering. While<br>some of these systems can be used to display graphics on more<br>than one display, they were not designed to support high-level<br>sharing of graphical scenes.</span></nobr></DIV>
<DIV style="position:absolute;top:829;left:486"><nobr><span class="ft4">Most high-level graphics libraries, such as UGA [40], Inventor</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:477"><nobr><span class="ft10">[35] and Java 3D [33], do not provide any support for distribution.<br>Others, such as Performer [29], provide support for distributing<br>components of the 3D graphics rendering system across multiple<br>processors, but do not support distribution across multiple<br>machines. One notable exception is TBAG [13], a high-level<br>constraint-based, declarative 3D graphics framework. Scenes in<br>TBAG are defined using constrained relationships between time-<br>varying functions. TBAG allows a set of processes to share a<br>single, replicated constraint graph. When any process asserts or<br>retracts a constraint, it is asserted or retracted in all processes.<br>However, this means that all processes share the same scene, and<br>that the system's scalability is limited because all processes have a<br>copy of (and must evaluate) all constraints, whether or not they are<br>interested in them. There is also no support for local variations of<br>the scene in different processes.</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft16{font-size:8px;font-family:Times;color:#000000;}
	.ft17{font-size:9px;line-height:12px;font-family:Times;color:#000000;}
	.ft18{font-size:9px;line-height:11px;font-family:Times;color:#000000;}
	.ft19{font-size:12px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="6003.png" alt="background image">
<DIV style="position:absolute;top:81;left:90"><nobr><span class="ft4">Machiraju [22] investigated an approach similar in flavor to ours,</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:81"><nobr><span class="ft11">but it was not aimed at the same fine-grained level of interactivity<br>and was ultimately limited by the constraints of the implementa-<br>tion platform (CORBA and C++). For example, CORBA objects<br>are heavyweight and do not support replication, so much of their<br>effort was spent developing techniques to support object migration<br>and "fine-grained" object sharing. However, their fine-grained<br>objects are coarser than ours, and, more importantly, they do not<br>support the kind of lightweight, transparent replication we desire.<br>A programmer must explicitly choose whether to replicate, move,<br>or copy an object between processes when the action is to occur (as<br>opposed to at object creation time). Replicated objects are indepen-<br>dent new copies that can be modified and used to replace the origi-<br>nal--simultaneous editing of objects, or real-time distribution of<br>changes as they are made is not supported. </span></nobr></DIV>
<DIV style="position:absolute;top:306;left:90"><nobr><span class="ft4">Of greater significance is the growing interest for this sort of sys-</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:81"><nobr><span class="ft10">tem in the Java and VRML communities. Java, like Modula-3, is<br>much more suitable as an implementation language than C or C++<br>because of its cross-platform compatibility and support for threads<br>and garbage collection: Without the latter two language features,<br>implementing complex, large-scale distributed applications is<br>extremely difficult. Most of the current effort has been focused on<br>using Java as a mechanism to facilitate multi-user VRML worlds<br>(e.g., Open Communities [38]). Unfortunately, these efforts<br>concentrate on the particulars of implementing shared virtual<br>environments and fall short of providing a general-purpose shared<br>graphics library. For example, the Open Communities work is<br>being done on top of SPLINE [1], which supports only a single<br>top-level world in the local scene database.</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:90"><nobr><span class="ft4">Most DVEs [11, 12, 16, 31, 32] provide support for creating</span></nobr></DIV>
<DIV style="position:absolute;top:531;left:81"><nobr><span class="ft10">shared virtual environments, not general purpose interactive 3D<br>graphics applications. They implement a higher level of abstrac-<br>tion, providing support for rooms, objects, avatars, collision detec-<br>tion, and other things needed in single, shared, immersive virtual<br>environments. These systems provide neither general-purpose<br>programming facilities nor the ability to work with 3D scenes at a<br>level provided by libraries such as Obliq-3D or Inventor. Some use<br>communication schemes that prevent them from scaling beyond a<br>relatively small number of distributed processes, but for most the<br>focus is explicitly on efficient communication. SIMNET [7], and<br>the later NPSNet [41], are perhaps the best known large-scale<br>distributed virtual-environment systems. They use a fixed, well-<br>defined communication protocol designed to support a single,<br>large-scale, shared, military virtual environment. </span></nobr></DIV>
<DIV style="position:absolute;top:741;left:90"><nobr><span class="ft4">The techniques for object sharing implemented in recent CSCW</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:81"><nobr><span class="ft10">toolkits [28, 30, 34, 37] provide some of the features we need,<br>particularly automatic replication of data to ease construction of<br>distributed applications. However, none of these toolkits has<br>integrated the distribution of data into its programming language's<br>object model as tightly as we desire. As a result, they do not pro-<br>vide a high enough level of network data transparency or suffi-<br>ciently strong consistency guarantees. In groupware applications,<br>inconsistencies tend to arise when multiple users attempt to per-<br>form conflicting actions: the results are usually obvious to the<br>users and can be corrected using social protocols. This is not an<br>acceptable solution for a general-purpose, distributed 3D graphics<br>toolkit. Furthermore, none of these CSCW systems provides any<br>support for asynchronous update notification, or is designed to<br>support the kind of large-scale distribution we have in mind. </span></nobr></DIV>
<DIV style="position:absolute;top:966;left:90"><nobr><span class="ft4">Finally, while distributed games, such as Quake, have become</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:81"><nobr><span class="ft11">very popular, they only distribute the minimum amount of applica-<br>tion state necessary. They do not use (or provide) an abstract, high-<br>level distributed 3D graphics system.</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:477"><nobr><span class="ft3"><b>4  UNDERLYING INFRASTRUCTURE</b></span></nobr></DIV>
<DIV style="position:absolute;top:488;left:477"><nobr><span class="ft10">Our work was done in the Modula-3 programming language [18].<br>We decided to use Modula-3 because of the language itself and the<br>availability of a set of packages that provide a solid foundation for<br>our infrastructure. Modula-3 is a descendant of Pascal that corrects<br>many of its deficiencies, and heavily influenced the design of Java.<br>In particular, Modula-3 retains strong type safety, while adding<br>facilities for exception handling, concurrency, object-oriented<br>programming, and automatic garbage collection</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:739"><nobr><span class="ft16">2</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:744"><nobr><span class="ft4">. One of its most</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:477"><nobr><span class="ft10">important features for our work is that it gives us uniform access to<br>these facilities across all architectures. </span></nobr></DIV>
<DIV style="position:absolute;top:638;left:486"><nobr><span class="ft4">Repo-3D relies on a number of Modula-3 libraries, as illustrated</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:477"><nobr><span class="ft10">in<A href="6.html#3"> Figure 2</a>. Distributed data sharing is provided by two packages,<br>the Network Object client-server object package [5], and the<br>Replicated Object shared object package [2<A href="6.html#3">4] (see Section 4.1).<br></a>DistAnim-3D is derived from Anim-3D [25], a powerful, non-<br>distributed, general-purpose 3D library originally designed for 3D<br>algorithm animation (see<A href="6.html#5"> Section 4.2</a>). Finally, Repo itself is a<br>direct descendant of Obliq [8], and uses the Replicated Object<br>package to add replicated data to Obliq (se<A href="6.html#5">e Section 4</a>.3).</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:477"><nobr><span class="ft3"><b>4.1  Distributed Shared Memory</b></span></nobr></DIV>
<DIV style="position:absolute;top:818;left:477"><nobr><span class="ft10">Repo-3D's data sharing mechanism is based on the Shared Data-<br>Object Model of Distributed Shared Memory (DSM) [20]. DSM<br>allows a network of computers to be programmed much like a mul-<br>tiprocessor, since the programmer is presented with the familiar<br>paradigm of a common shared memory. The Shared Data-Object<br>Model of DSM is particularly well suited to our needs since it is a<br>high-level approach that can be implemented efficiently at the<br>application level. In this model, shared data is encapsulated in<br>user-defined objects and can only be accessed through those<br>objects' method calls. The DSM address space is partitioned<br>implicitly by the application programmer, with an object being the<br>smallest unit of sharing. All shared data is fully network transpar-</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:477"><nobr><span class="ft2">2. The Modula-3 compiler we used is available from Critical Mass, Inc. as</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:495"><nobr><span class="ft18">part of the Reactor programming environment. The compiler, and thus<br>our system, runs on all the operating systems we have available (plus<br>others): Solaris, IRIX, HP-UX, Linux, and Windows NT and 95.</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:487"><nobr><span class="ft8"><b>Figure 2: </b></span></nobr></DIV>
<DIV style="position:absolute;top:306;left:544"><nobr><span class="ft2">The architecture of Repo-3D. Aside from native graphics</span></nobr></DIV>
<DIV style="position:absolute;top:319;left:487"><nobr><span class="ft14">libraries (X, Win32, OpenGL, Renderware) the Modula-3 runtime<br>shields most of the application from the OS. The Replicated Object<br>package uses an Event communication package and the Network<br>Object package. DistAnim-3D is implemented on top of a variety of<br>native graphics libraries and Replicated Objects. Repo exposes most of<br>the useful Modula-3 packages, as well as using Network Objects and<br>Replicated Objects to present a distributed shared memory model to<br>the programmer.</span></nobr></DIV>
<DIV style="position:absolute;top:224;left:511"><nobr><span class="ft1">Operating System Services</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:541"><nobr><span class="ft1">Network Objects</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:595"><nobr><span class="ft1">Replicated Objects</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:511"><nobr><span class="ft1">Modula-3 Runtime</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:670"><nobr><span class="ft1">Events </span></nobr></DIV>
<DIV style="position:absolute;top:167;left:737"><nobr><span class="ft19">Native<br>Graphics</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:701"><nobr><span class="ft1">DistAnim-3D</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:516"><nobr><span class="ft1">Repo</span></nobr></DIV>
<DIV style="position:absolute;top:100;left:659"><nobr><span class="ft1">Repo-3D</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:626"><nobr><span class="ft1">Network</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft20{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="6004.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft10">ent because it is encapsulated within the programming language<br>objects. </span></nobr></DIV>
<DIV style="position:absolute;top:111;left:90"><nobr><span class="ft4">Distribution of new objects between the processes is as simple as</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:81"><nobr><span class="ft10">passing them back and forth as parameters to, or return values<br>from, method calls--the underlying systems take care of the rest.</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:436"><nobr><span class="ft16">3</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:81"><nobr><span class="ft10">Objects are only distributed to new processes as necessary, and (in<br>our system) are removed by the garbage collector when they are no<br>longer referenced. Furthermore, distributed garbage collection is<br>supported, so objects that are no longer referenced in any process<br>are removed completely.</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:90"><nobr><span class="ft4">There are three kinds of distributed object semantics in our DSM:</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:246;left:102"><nobr><span class="ft10"><i>Simple</i> objects correspond to normal data objects, and have no<br>special distributed semantics. When a simple object is copied<br>between processes, a new copy is created in the destination<br>process that has no implied relationship to the object in the<br>source process. </span></nobr></DIV>
<DIV style="position:absolute;top:319;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:321;left:102"><nobr><span class="ft11"><i>Remote</i> objects have client-server distribution semantics. When<br>a remote object is copied between processes, all processes<br>except the one in which the object was created end up with a<br>proxy object that forwards method invocations across the<br>network to the original object.</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:102"><nobr><span class="ft10"><i>Replicated</i> objects have replicated distribution semantics.<br>When a replicated object is passed between processes, a new<br>replica is created in the destination process. If any replica is<br>changed, the change is reflected in all replicas.</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:90"><nobr><span class="ft4">The Network Object package provides support for remote</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:81"><nobr><span class="ft10">objects. It implements distributed garbage collection, exception<br>propagation back to the calling site, and automatic marshalling and<br>unmarshalling of method arguments and return values of virtually<br>any data type between heterogeneous machine architectures. The<br>package is similar to other remote method invocation (RMI) pack-<br>ages developed later, such as the Java RMI library [39]. All method<br>invocations are forwarded to the original object, where they are<br>executed in the order they are received.</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:90"><nobr><span class="ft4">The Replicated Object package supports replicated objects. Each</span></nobr></DIV>
<DIV style="position:absolute;top:606;left:81"><nobr><span class="ft10">process can call any method of an object it shares, just as it can<br>with a simple or remote object. We will describe the Replicated<br>Object package in more detail, as Repo-3D relies heavily on its<br>design, and the design of a replicated object system is less straight-<br>forward than a remote one. The model supported by the Replicated<br>Object package follows two principles:</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:696;left:102"><nobr><span class="ft10">All operations on an instance of an object are <i>atomic </i>and<br><i>serializable</i>. All operations are performed in the same order on<br>all copies of the object. If two methods are invoked simulta-<br>neously, the order of invocation is nondeterministic, just as if<br>two threads attempted to access the same memory location<br>simultaneously in a single process.</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:786;left:102"><nobr><span class="ft10">The above principle applies to operations on single objects.<br>Making sequences of operations atomic is up to the program-<br>mer.</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:90"><nobr><span class="ft4">The implementation of the Replicated Object package is based</span></nobr></DIV>
<DIV style="position:absolute;top:846;left:81"><nobr><span class="ft10">on the approach used in the Orca distributed programming<br>language [2]. A full replication scheme is used, where a single<br>object is either fully replicated in a process or not present at all.<br>Avoiding partial replication significantly simplifies the implemen-<br>tation and the object model, and satisfies the primary rationale for<br>replication: fast read-access to shared data. To maintain replication<br>consistency an update scheme is used, where <i>updates</i> to the object<br>are applied to all copies. </span></nobr></DIV>
<DIV style="position:absolute;top:81;left:486"><nobr><span class="ft4">The method of deciding what is and is not an update is what</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:477"><nobr><span class="ft10">makes the Orca approach particularly interesting and easy to<br>implement. All methods are marked as either <i>read</i> or <i>update</i> meth-<br>ods by the programmer who creates the object type. Read methods<br>are assumed to not change the state of the object and are therefore<br>applied immediately to the local object without violating consis-<br>tency. Update methods are assumed to change the state. To distrib-<br>ute updates, arguments to the update method are marshalled into a<br>message and sent to all replicas. To ensure all updates are applied<br>in the same order, the current implementation of the Replicated<br>Object package designates a <i>sequencer</i> process for each object.<br>There may be more than one sequencer in the system to avoid<br>overloading one process with all the objects (in this case, each<br>object has its updates managed by exactly one of the sequencers.)<br>The sequencer is responsible for assigning a sequence number to<br>each message before it is sent to all object replicas. The replicas<br>then execute the incoming update messages in sequence. The pro-<br>cess that initiated the update does not execute the update until it<br>receives a message back from the sequencer and all updates with<br>earlier sequence numbers have been executed. </span></nobr></DIV>
<DIV style="position:absolute;top:381;left:486"><nobr><span class="ft4">There are three very important reasons for choosing this</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:477"><nobr><span class="ft10">approach. First, it is easy to implement on top of virtually any<br>object-oriented language, using automatically generated object<br>subtypes and method wrappers that communicate with a simple<br>runtime system. We do this in our Modula-3 implementation, and it<br>would be equally applicable to an implementation in C++ or Java.<br>For example, the JSDT [36] data-sharing package in Java uses a<br>similar approach.</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:486"><nobr><span class="ft4">Second, the Replicated Object package does not pay attention to</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:477"><nobr><span class="ft11">(or even care) when the internal data fields of an object change.<br>This allows the programmer great flexibility in deciding exactly<br>what constitutes an update or not, and what constitutes the shared<br>state</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:502"><nobr><span class="ft16">4</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:507"><nobr><span class="ft4">. For example, objects could have a combination of global</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:477"><nobr><span class="ft10">and local state, and the methods that change the local state could<br>be classified as <i>read </i>methods since they do not modify the global<br>state. Alternatively, <i>read</i> methods could do some work locally and<br>then call an <i>update</i> method to propagate the results, allowing time-<br>consuming computation to be done once and the result distributed<br>in a clean way. We took advantage of both of these techniques in<br>implementing Repo-3D.</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:486"><nobr><span class="ft4">Finally, the immediate distribution of update methods ensures</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:477"><nobr><span class="ft11">that changes are distributed in a timely fashion, and suggests a<br>straightforward solution to the asynchronous notification problem.<br>The Replicated Object package generates a <i>Notification Object<br></i>type for each Replicated Object type. These new objects have<br>methods corresponding to the <i>update</i> methods of their associated<br>Replicated Object. The arguments to these methods are the same as<br>the corresponding Replicated Object methods, plus an extra<br>argument to hold the Replicated Object instance. These notifiers<br>can be used by a programmer to receive notification of changes to<br>a Replicated Object in a structured fashion. To react to updates to a<br>Replicated Object instance, a programmer simply overrides the<br>methods of the corresponding Notification Object with methods<br>that react appropriately to those updates, and associates an instance</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:81"><nobr><span class="ft2">3. An important detail is how the communication is bootstrapped. In the</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:99"><nobr><span class="ft17">case of the Network and Replicated Object packages, to pass a first<br>object between processes, one of them exports the object to a special<br><i>network object demon</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:213"><nobr><span class="ft2"> under some known name on some known</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:99"><nobr><span class="ft2">machine. The second process then retrieves the object.</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:477"><nobr><span class="ft2">4. Of course, it falls squarely on the shoulders of the programmer to</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:495"><nobr><span class="ft18">ensure that the methods provided always leave the object in a consistent<br>state. This is not significantly different than what needs to be done<br>when building a complex object that is simultaneously accessed by<br>multiple threads in a non-distributed system. For example, if a<br>programmer reads an array of numbers from inside the object and then<br>uses an update method to write a computed average back into the<br>object, the internal array may have changed before the average is<br>written, resulting in a classic inconsistency problem. In general,<br>methods that perform computations based on internal state (rather than<br>on the method arguments) are potentially problematic and need to be<br>considered carefully.</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft21{font-size:11px;font-family:Courier;color:#000000;}
	.ft22{font-size:9px;font-family:Helvetica;color:#000000;}
	.ft23{font-size:10px;font-family:Helvetica;color:#000000;}
	.ft24{font-size:11px;font-family:Helvetica;color:#000000;}
	.ft25{font-size:25px;font-family:Helvetica;color:#000000;}
	.ft26{font-size:9px;line-height:12px;font-family:Helvetica;color:#000000;}
	.ft27{font-size:9px;line-height:11px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="6005.png" alt="background image">
<DIV style="position:absolute;top:611;left:81"><nobr><span class="ft11">of it with the Replicated Object instance. Each time an update<br>method of the Replicated Object is invoked, the corresponding<br>method of the Notifier Object is also invoked. Notification Objects<br>eliminate the need for object polling and enable a "data-driven"<br>flow of control.</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:81"><nobr><span class="ft3"><b>4.2  Obliq-3D</b></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:81"><nobr><span class="ft11">Obliq-3D is composed of Anim-3D, a 3D animation package<br>written in Modula-3, and a set of wrappers that expose Anim-3D to<br>the Obliq programming language (see<A href="6.html#5"> Section 4.3</a>). Anim-3D is<br>based on three simple and powerful concepts: <i>graphical objects</i> for<br>building graphical scenes, <i>properties</i> for specifying the behavior of<br>the graphical objects, and input event <i>callbacks</i> to support interac-<br>tive behavior. Anim-3D uses the <i>damage-repair</i> model: whenever a<br>graphical object or property changes (is damaged), the image is<br>repaired without programmer intervention.</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:90"><nobr><span class="ft5"><i>Graphical objects</i> (GOs) represent all the logical entities in the</span></nobr></DIV>
<DIV style="position:absolute;top:881;left:81"><nobr><span class="ft10">graphical scene: geometry (e.g., lines, polygons, spheres, polygon<br>sets, and text), lights and cameras of various sorts, and groups of<br>other GOs. One special type of group, the </span></nobr></DIV>
<DIV style="position:absolute;top:912;left:319"><nobr><span class="ft21">RootGO</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:368"><nobr><span class="ft4">, represents a</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:81"><nobr><span class="ft10">window into which graphics are rendered. GOs can be grouped<br>together in any valid directed acyclic graph (DAG). The GO class<br>hierarchy is shown i<A href="6.html#5">n Figure 3</a></span></nobr></DIV>
<DIV style="position:absolute;top:955;left:245"><nobr><span class="ft1">.</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:90"><nobr><span class="ft4">A <i>property</i> is a defined by a <i>name</i> and a <i>value</i>. The name deter-</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:81"><nobr><span class="ft10">mines which attribute is affected by the property, such as "Texture<br>Mode" or "Box Corner1". The value specifies how it is affected<br>and is determined by its <i>behavior</i>, a time-variant function that<br>takes the current animation time and returns a value. Properties,<br>property values, and behaviors are all objects, and their relation-<br>ships are shown in<A href="6.html#5"> Figure 4.</a> When a property is created, its name</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:477"><nobr><span class="ft10">and value are fixed. However, values are mutable and their behav-<br>ior may be changed at any time. There are four kinds of behaviors<br>for each type of properties: <i>constant</i> (do not vary over time),<br><i>synchronous</i> (follow a programmed set of <i>requests</i>, such as "move<br>from A to B starting at time t=1 and taking 2 seconds"), <i>asynchro-<br>nous</i> (execute an arbitrary time-dependent function to compute the<br>value) and <i>dependent</i> (asynchronous properties that depend on<br>other properties). Synchronous properties are linked to <i>animation<br>handles</i> and do not start satisfying their requests until the anima-<br>tion handle is signalled. By linking multiple properties to the same<br>handle, a set of property value changes can be synchronized.</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:486"><nobr><span class="ft4">Associated with each GO <i>g</i> is a partial mapping of property</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:477"><nobr><span class="ft11">names to values determined by the properties that have been asso-<br>ciated with <i>g</i>. A property associated with <i>g</i> affects not only <i>g</i> but<br>all the descendants of <i>g</i> that do not override the property. A single<br>property may be associated with any number of GOs. It is perfectly<br>legal to associate a property with a GO that is not affected by it; for<br>example, attaching a "Surface Color" property to a GroupGO does<br>not affect the group node itself, but could potentially affect the<br>surface color of any GO contained in that group. A RootGO sets an<br>initial default value for each named property.</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:486"><nobr><span class="ft4">There are three types of input event callbacks in Anim-3D, corre-</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:477"><nobr><span class="ft10">sponding to the three kinds of interactive events they handle:<br><i>mouse</i> callbacks (triggered by mouse button events), <i>motion</i> call-<br>backs (triggered by mouse motion events) and <i>keyboard</i> callbacks<br>(triggered by key press events). Each object has three callback<br>stacks, and the interactive behavior of an object can be redefined<br>by pushing a new callback onto the appropriate stack. Any event<br>that occurs within a root window associated with a RootGO <i>r</i> will<br>be delivered to the top handler on <i>r</i>'s callback stack. The handler<br>could delegate the event to one of <i>r</i>'s children, or it may handle it<br>itself, perhaps changing the graphical scene in some way.</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:486"><nobr><span class="ft4">DistAnim-3D is a direct descendant of Anim-3D. In addition to</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:477"><nobr><span class="ft11">the objects being distributed, it has many additional facilities that<br>are needed for general-purpose 3D graphical applications, such as<br>texture mapping, indexed line and polygon sets, choice groups,<br>projection and transformation callbacks, and picking. Since<br>DistAnim-3D is embedded in Repo instead of Obliq (see<br><A href="6.html#5">Section 4.3</a>), the resulting library is called Repo-3D.</span></nobr></DIV>
<DIV style="position:absolute;top:683;left:477"><nobr><span class="ft3"><b>4.3  Obliq and Repo</b></span></nobr></DIV>
<DIV style="position:absolute;top:711;left:477"><nobr><span class="ft10">Obliq [8] is a lexically-scoped, untyped, interpreted language for<br>distributed object-oriented computation. It is implemented in, and<br>tightly integrated with, Modula-3. An Obliq computation may<br>involve multiple threads of control within an address space, multi-<br>ple address spaces on a machine, heterogeneous machines over a<br>local network, and multiple networks over the Internet. Obliq uses,<br>and supports, the Modula-3 thread, exception, and garbage-collec-<br>tion facilities. Its distributed-computation mechanism is based on<br>Network Objects, allowing transparent support for multiple<br>processes on heterogeneous machines. Objects are local to a site,<br>while computations can roam over the network. Repo [23] is a<br>descendant of Obliq that extends the Obliq object model to include<br>replicated objects. Therefore, Repo objects have state that may be<br>local to a site (as in Obliq) or replicated across multiple sites.</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:477"><nobr><span class="ft3"><b>5  DESIGN OF REPO-3D</b></span></nobr></DIV>
<DIV style="position:absolute;top:964;left:477"><nobr><span class="ft10">Repo-3D's design has two logical parts: the <i>basic design</i> and <i>local<br>variations</i>. The <i>basic design</i> encompasses the changes to Obliq-3D<br>to carry it into a distributed context, and additional enhancements<br>that are not particular to distributed graphics (and are therefore not<br>discussed here). <i>Local variations</i> are introduced to handle two<br>issues mentioned in<A href="6.html#1"> Section 1</a>: transient local changes and respon-<br>sive local editing.</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:91"><nobr><span class="ft8"><b>Figure 3: </b></span></nobr></DIV>
<DIV style="position:absolute;top:381;left:147"><nobr><span class="ft2">The Repo-3D GO class hierarchy. Most of the classes are</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:91"><nobr><span class="ft2">also in Obliq-3D; the italicized ones were added to Repo-3D.</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:128"><nobr><span class="ft22">GroupGO</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:91"><nobr><span class="ft22">GO</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:128"><nobr><span class="ft22">CameraGO</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:128"><nobr><span class="ft22">LightGO</span></nobr></DIV>
<DIV style="position:absolute;top:227;left:128"><nobr><span class="ft22">NonSurfaceGO</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:128"><nobr><span class="ft22">SurfaceGO</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:231"><nobr><span class="ft22">RootGO</span></nobr></DIV>
<DIV style="position:absolute;top:103;left:231"><nobr><span class="ft23">ChoiceGroupGO</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:231"><nobr><span class="ft26">OrthoCameraGO<br>PerspCameraGO</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:231"><nobr><span class="ft26">AmbientLightGO<br>VectorLightGO<br>PointLightGO<br>SpotLightGO</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:231"><nobr><span class="ft26">LineGO<br>MarkerGO</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:231"><nobr><span class="ft23">TextGO</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:231"><nobr><span class="ft27">PolygonGO<br>BoxGO<br>SphereGO<br>CylinderGO<br>DiskGO<br>TorusGO<br>QuadMeshGO</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:231"><nobr><span class="ft23">IndexedPolygonSetGO</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:334"><nobr><span class="ft23">Text2DGO</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:334"><nobr><span class="ft23">IndexedLineSetGO</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:93"><nobr><span class="ft8"><b>Figure 4: </b></span></nobr></DIV>
<DIV style="position:absolute;top:555;left:152"><nobr><span class="ft2">The relationship between properties, names, values, and</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:93"><nobr><span class="ft14">behaviors. Each oval represents an object and arrows show contain-<br>ment. </span></nobr></DIV>
<DIV style="position:absolute;top:493;left:199"><nobr><span class="ft24">Value</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:274"><nobr><span class="ft24">Behavior</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:137"><nobr><span class="ft24">Property</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:110"><nobr><span class="ft24">Name</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:368"><nobr><span class="ft23">Request</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:368"><nobr><span class="ft23">Request</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:366"><nobr><span class="ft25"><b>. . .</b></span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft28{font-size:12px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="6006.png" alt="background image">
<DIV style="position:absolute;top:80;left:81"><nobr><span class="ft3"><b>5.1  Basic Repo-3D Design</b></span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft10">The Anim-3D scene-graph model is well suited for adaptation to a<br>distributed environment. First, in Anim-3D, properties are attached<br>to nodes, not inserted into the graph, and the property and child<br>lists are unordered (i.e., the order in which properties are assigned<br>to a node, or children are added to a group, does not affect the final<br>result). In libraries that insert properties and nodes in the graph and<br>execute the graph in a well-defined order (such as Inventor), the<br><i>siblings</i> of a node (or subtree) can affect the attributes of that node<br>(or subtree). In Anim-3D, and similar libraries (such as Java 3D),<br>properties are only inherited <i>down</i> the graph, so a node's properties<br>are a function of the node itself and its ancestors--its siblings do<br>not affect it. Therefore, subtrees can be added to different scene<br>graphs, perhaps in different processes, with predictable results. </span></nobr></DIV>
<DIV style="position:absolute;top:303;left:90"><nobr><span class="ft4">Second, the interface (both compiled Anim-3D and interpreted</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:81"><nobr><span class="ft10">Obliq-3D) is programmatical and declarative. There is no "graphi-<br>cal scene" file format per se: graphical scenes are created as the<br>side effect of executing programs that explicitly create objects and<br>manipulate them via the object methods. Thus, all graphical<br>objects are stored as the Repo-3D programs that are executed to<br>create them. This is significant, because by using the Replicated<br>Object library described in<A href="6.html#3"> Section 4.1</a> to make the graphical<br>objects distributed, the "file format" (i.e., a Repo-3D program) is<br>updated for free.</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:90"><nobr><span class="ft4">Converting Anim-3D objects to Replicated Objects involved</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:81"><nobr><span class="ft10">three choices: what objects to replicate, what methods update the<br>object state, and what the global, replicated state of each object is.<br>Since replicated objects have more overhead (e.g., method execu-<br>tion time, memory usage, and latency when passed between<br>processes), not every category of object in Repo-3D is replicated.<br>We will consider each of the object categories described in<br><A href="6.html#5">Figure 4.2</a> in turn: graphical objects (GOs), properties (values,<br>names, behaviors, animation handles) and callbacks. For each of<br>these objects, the obvious methods are designated as update meth-<br>ods, and, as discussed in<A href="6.html#3"> Section 4.1</a>, the global state of each object<br>is implicitly determined by those update methods. Therefore, we<br>will not go into excessive detail about either the methods or the<br>state. Finally, Repo-3D's support for change notification will be<br>discussed.</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:81"><nobr><span class="ft28"><b>5.1.1  Graphical Objects</b></span></nobr></DIV>
<DIV style="position:absolute;top:718;left:81"><nobr><span class="ft11">GOs are the most straightforward. There are currently twenty-one<br>different types of GOs, and all but the RootGOs are replicated.<br>Since RootGOs are associated with an onscreen window, they are<br>not replicated--window creation remains an active decision of the<br>local process. Furthermore, if replicated windows are needed, the<br>general-purpose programming facilities of Repo can be used to<br>support this in a relatively straightforward manner, outside the<br>scope of Repo-3D. A GO's state is comprised of the properties<br>attached to the object, its name, and some other non-inherited<br>property attributes.</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:184"><nobr><span class="ft16">5</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:189"><nobr><span class="ft4"> The methods that modify the property list are</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:81"><nobr><span class="ft10">update methods. Group GOs also contain a set of child nodes, and<br>have update methods that modify that set.</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:81"><nobr><span class="ft28"><b>5.1.2  Properties</b></span></nobr></DIV>
<DIV style="position:absolute;top:939;left:81"><nobr><span class="ft11">Properties are more complex. There are far more properties in a<br>graphical scene than there are graphical objects, they change much<br>more rapidly, and each property is constructed from a set of<br>Modula-3 objects. There are currently 101 different properties of</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:477"><nobr><span class="ft10">seventeen different types in Repo-3D, and any of them can be<br>attached to any GO. A typical GO would have anywhere from two<br>or three (e.g., a BoxGO would have at least two properties to<br>define its corners) to a dozen or more. And, each of these proper-<br>ties could be complex: in the example in <A href="6.html#8">Section 6</a>, a single<br>synchronous property for a long animation could have hundreds of<br>requests enqueued within it. </span></nobr></DIV>
<DIV style="position:absolute;top:186;left:486"><nobr><span class="ft4">Consider again the object structure illustrated<A href="6.html#5"> in Figure 4</a>. A</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:477"><nobr><span class="ft10">property is defined by a name and a value, with the value being a<br>container for a behavior. Only one of the Modula-3 objects is<br>replicated, the property <i>value. </i>Property values serve as the repli-<br>cated containers for property behaviors. To change a property, a<br>new behavior is assigned to its value. The state of the value is the<br>current behavior.</span></nobr></DIV>
<DIV style="position:absolute;top:291;left:486"><nobr><span class="ft4">Animation handles are also replicated. They tie groups of related</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:477"><nobr><span class="ft10">synchronous properties together, and are the basis for the interac-<br>tion in the example in<A href="6.html#8"> Section 6.</a> In Anim-3D, handles have one</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:477"><nobr><span class="ft21">animate</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:534"><nobr><span class="ft4"> method, which starts an animation and blocks until it</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:477"><nobr><span class="ft11">finishes. Since update methods are executed everywhere, and block<br>access to the object while they are being executed, they should not<br>take an extended period of time. In creating Repo-3D, the</span></nobr></DIV>
<DIV style="position:absolute;top:397;left:477"><nobr><span class="ft21">animate</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:534"><nobr><span class="ft4"> method was changed to call two new methods: an update</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:477"><nobr><span class="ft10">method that starts the animation, and a non-update method that<br>waits for the animation to finish. We also added methods to pause<br>and resume an animation, to retrieve and change the current rela-<br>tive time of an animation handle, and to stop an animation early.<br>The state of an Animation handle is a boolean value that says if it is<br>active or not, plus the start, end, and current time (if the handle is<br>paused).</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:486"><nobr><span class="ft4">Most of the Modula-3 objects that comprise a property are not</span></nobr></DIV>
<DIV style="position:absolute;top:531;left:477"><nobr><span class="ft4">replicated, for a variety of reasons:</span></nobr></DIV>
<DIV style="position:absolute;top:544;left:477"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:546;left:498"><nobr><span class="ft10"><i>Properties  </i>represent a permanent binding between a property<br>value and a name. Since they are immutable, they have no syn-<br>chronization requirements and can simply be copied between<br>processes.</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:477"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:498"><nobr><span class="ft10"><i>Names</i> represent simple constant identifiers, and are therefore<br>not replicated either.</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:477"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:636;left:498"><nobr><span class="ft10"><i>Behaviors</i> and <i>requests</i> are not replicated. While they can be<br>modified after being created, they are treated as immutable<br>data types for two reasons. First, the vast majority of behaviors,<br>even complex synchronous ones, are not changed once they<br>have been created and initialized. Thus, there is some justifica-<br>tion for classifying the method calls that modify them as part<br>of their initialization process. The second reason is practical<br>and much more significant. Once a scene has been created and<br>is being "used" by the application, the bulk of the time-critical<br>changes to it tend to be assignments of new behaviors to the<br>existing property values. For example, an object is moved by<br>assigning a new (often constant) behavior to its</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:498"><nobr><span class="ft21">GO_Transform</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:595"><nobr><span class="ft4"> property value. Therefore, the overall perfor-</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:498"><nobr><span class="ft10">mance of the system depends heavily on the performance of<br>property value behavior changes. By treating behaviors as<br>immutable objects, they can simply be copied between<br>processes without incurring the overhead of the replicated<br>object system.</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:477"><nobr><span class="ft28"><b>5.1.3  Input Callbacks</b></span></nobr></DIV>
<DIV style="position:absolute;top:946;left:477"><nobr><span class="ft10">In Repo-3D, input event callbacks are not replicated. As discussed<br>in<A href="6.html#5"> Section 4.2</a>, input events are delivered to the callback stacks of a<br>RootGO. Callbacks attached to any other object receive input<br>events only if they are delivered to that object by the programmer,<br>perhaps recursively from another input event callback (such as the<br>one attached to the RootGO). Therefore, the interactive behavior of<br>a root window is defined not only by the callbacks attached to its<br>RootGO, but also by the set of callbacks associated with the graph<br>rooted at that RootGO. Since the RootGOs are not replicated, the</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:81"><nobr><span class="ft2">5. Some attributes of a GO, such as the arrays of Point3D properties that</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:99"><nobr><span class="ft18">define the vertices of a polygon set, are not attached to the object, but<br>are manipulated through method calls.</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="6007.png" alt="background image">
<DIV style="position:absolute;top:810;left:81"><nobr><span class="ft10">callbacks that they delegate event handling to are not replicated<br>either. If a programmer wants to associate callbacks with objects as<br>they travel between processes, Repo's general-purpose program-<br>ming facilities can be used to accomplish this in a straightforward<br>manner.</span></nobr></DIV>
<DIV style="position:absolute;top:899;left:81"><nobr><span class="ft28"><b>5.1.4  Change Notification</b></span></nobr></DIV>
<DIV style="position:absolute;top:925;left:81"><nobr><span class="ft10">The final component of the basic design is support for notification<br>of changes to distributed objects. For example, when an object's<br>position changes or a new child is added to a group, some of the<br>processes containing replicas may wish to react in some way. For-<br>tunately, as discussed in<A href="6.html#3"> Section 4.1</a>, the Replicated Object<br>package automatically generates Notification Object types for all<br>replicated object types, which provide exactly the required<br>behavior. The Notification Objects for property values allow a<br>programmer to be notified of changes to the behavior of a property,</span></nobr></DIV>
<DIV style="position:absolute;top:810;left:477"><nobr><span class="ft10">and the Notification Objects for the various GOs likewise allow<br>notification of updates to them. </span></nobr></DIV>
<DIV style="position:absolute;top:857;left:477"><nobr><span class="ft3"><b>5.2  Local Variations</b></span></nobr></DIV>
<DIV style="position:absolute;top:885;left:477"><nobr><span class="ft10">Repo-3D's <i>local variations</i> solve a set of problems particular to the<br>distributed context in which Repo-3D lives: maintaining interactiv-<br>ity and supporting local modifications to the shared scene graph.</span></nobr></DIV>
<DIV style="position:absolute;top:930;left:486"><nobr><span class="ft4">If the graphical objects and their properties were always strictly</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:477"><nobr><span class="ft10">replicated, programmers would have to create local variations by<br>copying the objects to be modified, creating a set of Notification<br>Objects on the original objects, the copies of those objects, and all<br>their properties (to be notified when either change), and reflecting<br>the appropriate changes between the instances. Unfortunately,<br>while this process could be automated somewhat, it would still be<br>extremely tedious and error prone. More seriously, the overhead of<br>creating this vast array of objects and links between them would</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:287"><nobr><span class="ft22">(a)</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:614"><nobr><span class="ft22">(b)</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:287"><nobr><span class="ft22">(c)</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:614"><nobr><span class="ft22">(d)</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:142"><nobr><span class="ft8"><b>Figure 5: </b></span></nobr></DIV>
<DIV style="position:absolute;top:754;left:197"><nobr><span class="ft2">Simultaneous images from a session with the distributed CATHI animation viewer, running on four machines, showing an anima-</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:142"><nobr><span class="ft14">tion of an engine. (a) Plain animation viewer, running on Windows NT. (b) Overview window, running on Windows 95. (c) Animation viewer<br>with local animation meter, running on IRIX. (d) Animation viewer with local transparency to expose hidden parts, running on Solaris.</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft29{font-size:9px;line-height:12px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="6008.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft10">make this approach impractical for short transient changes, such as<br>highlighting an object under the mouse.</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:90"><nobr><span class="ft4">To overcome this problem, Repo-3D allows the two major</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:81"><nobr><span class="ft10">elements of the shared state of the graphical object scene--the<br>properties attached to a GO and the children of a group--to have<br><i>local variations </i>applied to them. (Local variations on property<br>values or animation handles are not supported, although we are<br>considering adding support for the latter.) </span></nobr></DIV>
<DIV style="position:absolute;top:201;left:90"><nobr><span class="ft4">Conceptually, local state is the state added to each object (the</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:81"><nobr><span class="ft11">additions, deletions, and replacements to the properties or<br>children) that is only accessible to the local copies and is not<br>passed to remote processes when the object is copied to create a<br>new replica. The existence of local state is possible because, as<br>discussed in<A href="6.html#3"> Section 4.1</a>, the <i>shared state</i> of a replicated object is<br>implicitly defined by the methods that update it</span></nobr></DIV>
<DIV style="position:absolute;top:287;left:349"><nobr><span class="ft16">6</span></nobr></DIV>
<DIV style="position:absolute;top:291;left:354"><nobr><span class="ft4">. Therefore, the</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:81"><nobr><span class="ft10">new methods that manipulate the local variations are added to the<br>GOs as <i>non-update</i> methods. Repo-3D combines both the global<br>and local state when creating the graphical scene using the under-<br>lying graphics package.</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:90"><nobr><span class="ft4">As mentioned above, local variations come in two flavors:</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:381;left:102"><nobr><span class="ft10"><i>Property variations.</i> There are three methods to set, unset, and<br>get the global property list attached to a GO. We added the<br>following methods to manipulate local variations: add or<br>remove local properties (overriding the value normally used for<br>the object), hide or reveal properties (causing the property<br>value of the parent node to be inherited), and flush the set of<br>local variations (removing them in one step) or atomically<br>apply them to the global state of the object.</span></nobr></DIV>
<DIV style="position:absolute;top:499;left:81"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:501;left:102"><nobr><span class="ft10"><i>Child variations.</i> There are five methods to add, remove,<br>replace, retrieve, and flush the set of children contained in a<br>group node. We added the following ones: add a local node,<br>remove a global node locally, replace a global node with some<br>other node locally, remove each of these local variations, flush<br>the local variations (remove them all in one step), and atomi-<br>cally apply the local variations to the global state.</span></nobr></DIV>
<DIV style="position:absolute;top:606;left:90"><nobr><span class="ft4">This set of local operations supports the problems local variations</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:81"><nobr><span class="ft10">were designed to solve, although some possible enhancements are<br>discussed in<A href="6.html#8"> Section 7</a>. </span></nobr></DIV>
<DIV style="position:absolute;top:668;left:81"><nobr><span class="ft3"><b>6  EXAMPLE: AN ANIMATION EXAMINER</b></span></nobr></DIV>
<DIV style="position:absolute;top:694;left:81"><nobr><span class="ft10">As an example of the ease of prototyping distributed applications<br>with Repo-3D, we created a distributed animation examiner for the<br>CATHI [6] animation generation system. CATHI generates short<br>informational animation clips to explain the operation of technical<br>devices. It generates full-featured animation scripts, including<br>camera and object motion, color and opacity effects, and lighting<br>setup.</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:90"><nobr><span class="ft4">It was reasonably straightforward to modify CATHI to generate</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:81"><nobr><span class="ft10">Repo-3D program files, in addition to the GeomView and Render-<br>Man script files it already generated. The resulting output is a<br>Repo-3D program that creates two scene DAGs: a camera graph<br>and a scene graph. The objects in these DAGs have <i>synchronous<br>behaviors</i> specified for their surface and transformation properties.<br>An entire animation is enqueued in the requests of these behaviors,<br>lasting anywhere from a few seconds to a few minutes. </span></nobr></DIV>
<DIV style="position:absolute;top:919;left:90"><nobr><span class="ft4">We built a distributed, multi-user examiner over the course of a</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:81"><nobr><span class="ft10">weekend. The examiner allows multiple users to view the same<br>animation while discussing it (e.g., via electronic chat or on the<br>phone)<A href="6.html#7">. Figure 5 sh</a>ows images of the examiner running on four</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:477"><nobr><span class="ft11">machines, each with a different view of the scene. The first step<br>was to build a simple "loader" that reads the animation file, creates<br>a window, adds the animation scene and camera to it, and exports<br>the animation on the network, requiring less than a dozen lines of<br>Repo-3D code. A "network" version, that imports the animation<br>from the network instead of reading it from disk, replaced the lines<br>of code to read and export the animation with a single line to<br>import it. <A href="6.html#7">Figure 5</a>(a) shows an animation being viewed by one of<br>these clients.</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:486"><nobr><span class="ft4">The examiner program is loaded by both these simple clients, and</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:477"><nobr><span class="ft4">is about 450 lines long. The examiner supports:</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:477"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:246;left:498"><nobr><span class="ft10">Pausing and continuing the animation, and changing the<br>current animation time using the mouse. Since this is done by<br>operating on the shared animation handle, changes performed<br>by any viewer are seen by all. Because of the consistency guar-<br>antees, all users can freely attempt to change the time, and the<br>system will maintain all views consistently.</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:477"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:498"><nobr><span class="ft10">A second "overview" window<A href="6.html#7"> (Figure 5</a>(b)), where a new<br>camera watches the animation scene and camera from a distant<br>view. A local graphical child (representing a portion of the<br>animation camera's frustum) was added to the shared anima-<br>tion camera group to let the attributes of the animation camera<br>be seen in the overview window.</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:477"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:426;left:498"><nobr><span class="ft11">A local animation meter (bottom of<A href="6.html#7"> Figure 5(c</a>)), that can be<br>added to any window by pressing a key, and which shows the<br>current time offset into the animation both graphically and<br>numerically. It was added in front of the camera in the anima-<br>tion viewer window, as a local child of a GO in the camera<br>graph, so that it would be fixed to the screen in the animation<br>viewer.</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:477"><nobr><span class="ft15"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:531;left:498"><nobr><span class="ft10">Local editin<A href="6.html#7">g (Figure 5</a>(d)), so that users can select objects and<br>make them transparent (to better see what was happening in the<br>animation) or hide them completely (useful on slow machines,<br>to speed up rendering). Assorted local feedback (highlighting<br>the object under the mouse and flashing the selected object)<br>was done with local property changes to the shared GOs in the<br>scene graph. </span></nobr></DIV>
<DIV style="position:absolute;top:636;left:486"><nobr><span class="ft4">Given the attention paid to the design of Repo-3D, it was not</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:477"><nobr><span class="ft10">necessary to be overly concerned with the distributed behavior of<br>the application (we spent no more than an hour or so). Most of that<br>time was spent deciding if a given operation should be global or a<br>local variation. The bulk of programming and debugging time was<br>spent implementing application code. For example, in the overview<br>window, the representation of the camera moves dynamically,<br>based on the bounding values of the animation's scene and camera<br>graphs. In editing mode, the property that flashes the selected node<br>bases its local color on the current global color (allowing a user<br>who is editing while an animation is in progress to see any color<br>changes to the selected node.)</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:477"><nobr><span class="ft3"><b>7  CONCLUSIONS AND FUTURE WORK</b></span></nobr></DIV>
<DIV style="position:absolute;top:859;left:477"><nobr><span class="ft10">We have presented the rationale for, and design of, Repo-3D, a<br>general-purpose, object-oriented library for developing distributed,<br>interactive 3D graphics applications across a range of heteroge-<br>neous workstations. By presenting the programmer with the<br>illusion of a large shared memory, using the Shared Data-Object<br>model of DSM, Repo-3D makes it easy for programmers to rapidly<br>prototype distributed 3D graphics applications using a familiar<br>object-oriented programming paradigm. Both graphical and<br>general-purpose, non-graphical data can be shared, since Repo-3D<br>is embedded in Repo, a general-purpose, lexically-scoped, distrib-<br>uted programming language. </span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:486"><nobr><span class="ft4">Repo-3D is designed to directly support the distribution of graph-</span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:477"><nobr><span class="ft10">ical objects, circumventing the "duplicate database" problem and<br>allowing programmers to concentrate on the application function-</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:81"><nobr><span class="ft2">6. The local state is not copied when a replicated object is first passed to a</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:99"><nobr><span class="ft18">new process because the Repo-3D objects have custom <i>serialization<br></i>routines (or Picklers, in Modula-3 parlance). These routines only pass<br>the global state, and initialize the local state on the receiving side to<br>reasonable default values corresponding to the empty local state.</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft30{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
	.ft31{font-size:9px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="6009.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft11">ality of a system, rather than its communication or synchronization<br>components. We have introduced a number of issues that must be<br>considered when building a distributed 3D graphics library, espe-<br>cially concerning efficient and clean support for data distribution<br>and local variations of shared graphical scenes, and discussed how<br>Repo-3D addresses them.</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:90"><nobr><span class="ft4">There are a number of ways in which Repo-3D could be</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:81"><nobr><span class="ft10">improved. The most important is the way the library deals with<br>time. By default, the library assumes all machines are running a<br>time-synchronization protocol, such as NTP, and uses an internal<br>animation time offset</span></nobr></DIV>
<DIV style="position:absolute;top:227;left:198"><nobr><span class="ft16">7</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:203"><nobr><span class="ft4"> (instead of the system-specific time offset)</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:81"><nobr><span class="ft11">because different OSs (e.g., NT vs. UNIX) start counting time at<br>different dates. Hooks have been provided to allow a programmer<br>to specify their own function to compute the "current" animation<br>time offset within a process. Using this facility, it is possible to<br>build inter-process time synchronization protocols (which we do),<br>but this approach is not entirely satisfactory given our stated goal<br>of relieving the programmer of such tedious chores. Future<br>systems should integrate more advanced solutions, such as adjust-<br>ing time values as they travel between machines, so that users of<br>computers with unsynchronized clocks can collaborate</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:380"><nobr><span class="ft16">8</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:385"><nobr><span class="ft4">. This will</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:81"><nobr><span class="ft10">become more important as mobile computers increase in popular-<br>ity, as it may not be practical to keep their clocks synchronized.</span></nobr></DIV>
<DIV style="position:absolute;top:426;left:90"><nobr><span class="ft4">The specification of local variations in Repo-3D could benefit</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:81"><nobr><span class="ft10">from adopting the notion of <i>paths</i> (as used in Java 3D and Inventor,<br>for example). A path is an array of objects leading from the root of<br>the graph to an object; when an object occurs in multiple places in<br>one or more scene graphs, paths allow these instances to be differ-<br>entiated. By specifying local variations using paths, nodes in the<br>shared scene graphs could have variations <i>within</i> a process as well<br>as  <i>between</i> processes. One other limitation of Repo-3D, arising<br>from our use of the Replicated Object package, is that there is no<br>way to be notified when local variations are applied to an object.<br>Recall that the methods of an automatically generated Notification<br>Object correspond to the update methods of the corresponding<br>Replicated Object. Since the methods that manipulate the local<br>variations are non-update methods (i.e., they do not modify the<br>replicated state), there are no corresponding methods for them in<br>the Notification Objects. Of course, it would be relatively straight-<br>forward to modify the Replicated Object package to support this,<br>but we have not yet found a need for these notifiers. </span></nobr></DIV>
<DIV style="position:absolute;top:696;left:90"><nobr><span class="ft4">A more advanced replicated object system would also improve</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:81"><nobr><span class="ft11">the library. Most importantly, support for different consistency<br>semantics would be extremely useful. If we could specify<br>semantics such as "all updates completely define the state of an<br>object, and only the last update is of interest," the efficiency of the<br>distribution of property values would improve significantly; in this<br>case, updates could be applied (or discarded) when they arrive,<br>without waiting for all previous updates to be applied, and could be<br>applied locally without waiting for the round trip to the sequencer.<br>There are also times when it would be useful to have support for<br>consistency across multiple objects, either using <i>causal ordering<br></i>(as provided by systems such as ISIS and Visual-Obliq)<i>,</i> or some<br>kind of transaction protocol to allow large groups of changes to be<br>applied either as a unit, or not at all. It is not clear how one would<br>provide these features with a replicated object system such as the<br>one used here.</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:90"><nobr><span class="ft4">While a library such as Repo-3D could be built using a variety of</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:81"><nobr><span class="ft10">underlying platforms, the most likely one for future work is Java.<br>Java shares many of the advantages of Modula-3 (e.g., threads and<br>garbage collection are common across all architectures) and the</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:477"><nobr><span class="ft10">packages needed to create a Repo-3D-like toolkit are beginning to<br>appear. While Java does not yet have a replicated object system as<br>powerful as the Replicated Object package, a package such as<br>JSDT [36] (which focuses more on data communication than high-<br>level object semantics) may be a good starting point. Work is also<br>being done on interpreted, distributed programming languages on<br>top of Java (e.g., Ambit [9]). Finally, Java 3D is very similar to<br>Anim-3D, even though its design leans toward efficiency instead of<br>generality when there are trade-offs to be made. For example, the<br>designers chose to forgo Anim-3D's general property inheritance<br>mechanism because it imposes computational overhead. By com-<br>bining packages such as Java 3D, JSDT, and Ambit, it should be<br>possible to build a distributed graphics library such as Repo-3D in<br>Java.</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:477"><nobr><span class="ft3"><b>Acknowledgments</b></span></nobr></DIV>
<DIV style="position:absolute;top:334;left:477"><nobr><span class="ft10">We would like to thank the reviewers for their helpful comments,<br>as well as the many other people who have contributed to this<br>project. Andreas Butz ported CATHI to use Repo-3D and helped<br>with the examples and the video. Clifford Beshers participated in<br>many lively discussions about the gamut of issues dealing with<br>language-level support for 3D graphics. Tobias Höllerer and<br>Steven Dossick took part in many other lively discussions. Xinshi<br>Sha implemented many of the extensions to Obliq-3D that went<br>into Repo-3D. Luca Cardelli and Marc Najork of DEC SRC<br>created Obliq and Obliq-3D, and provided ongoing help and<br>encouragement over the years that Repo and Repo-3D have been<br>evolving. </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:486"><nobr><span class="ft4">This research was funded in part by the Office of Naval Research</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:477"><nobr><span class="ft10">under Contract N00014-97-1-0838 and the National Tele-Immer-<br>sion Initiative, and by gifts of software from Critical Mass and<br>Microsoft.</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:477"><nobr><span class="ft3"><b>References</b></span></nobr></DIV>
<DIV style="position:absolute;top:618;left:477"><nobr><span class="ft2">[1] </span></nobr></DIV>
<DIV style="position:absolute;top:618;left:510"><nobr><span class="ft14">D. B. Anderson, J. W. Barrus, J. H. Howard, C. Rich, C. Shen, and<br>R. C. Waters. Building Multi-User Interactive Multimedia Environ-<br>ments at MERL. Technical Report Research Report TR95-17, Mit-<br>subishi Electric Research Laboratory, November 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:477"><nobr><span class="ft2">[2] </span></nobr></DIV>
<DIV style="position:absolute;top:676;left:509"><nobr><span class="ft30">H. Bal, M. Kaashoek, and A. Tanenbaum. Orca: A Language for<br>Parallel Programming of Distributed Systems. <i>IEEE Transactions on<br>Software Engineering</i></span></nobr></DIV>
<DIV style="position:absolute;top:703;left:614"><nobr><span class="ft2">, 18(3):190­205, March 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:477"><nobr><span class="ft2">[3]</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:509"><nobr><span class="ft14">K. Bharat and L. Cardelli. Migratory Applications. In <i>ACM UIST '95</i>,<br>pages 133-142, November 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:477"><nobr><span class="ft2">[4] </span></nobr></DIV>
<DIV style="position:absolute;top:753;left:509"><nobr><span class="ft14">K. P. Birman. The Process Group Approach to Reliable Distributed<br>Computing. <i>CACM</i>, 36(12):36­53, Dec 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:477"><nobr><span class="ft2">[5] </span></nobr></DIV>
<DIV style="position:absolute;top:784;left:510"><nobr><span class="ft14">A. Birrell, G. Nelson, S. Owicki, and E. Wobber. Network Objects.<br>In <i>Proc. 14th ACM Symp. on Operating Systems Principles</i>, 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:477"><nobr><span class="ft2">[6]</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:509"><nobr><span class="ft14">A Butz, Animation with CATHI, In <i>Proceedings of AAAI/IAAI '97</i>,<br>pages 957­962, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:477"><nobr><span class="ft2">[7]  J. Calvin, A. Dickens, B. Gaines, P. Metzger, D. Miller, and</span></nobr></DIV>
<DIV style="position:absolute;top:861;left:509"><nobr><span class="ft30">D. Owen. The SIMNET Virtual World Architecture. In <i>Proc. IEEE<br>VRAIS '93</i></span></nobr></DIV>
<DIV style="position:absolute;top:874;left:560"><nobr><span class="ft2">, pages 450­455, Sept 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:477"><nobr><span class="ft2">[8] </span></nobr></DIV>
<DIV style="position:absolute;top:892;left:509"><nobr><span class="ft30">L. Cardelli. A Language with Distributed Scope. <i>Computing Sys-<br>tems</i></span></nobr></DIV>
<DIV style="position:absolute;top:906;left:531"><nobr><span class="ft2">, 8(1):27­59, Jan 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:477"><nobr><span class="ft2">[9]</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:509"><nobr><span class="ft30">L. Cardelli and A. Gordon. Mobile Ambients. In <i>Foundations of<br>Software Science and Computational Structures</i></span></nobr></DIV>
<DIV style="position:absolute;top:937;left:754"><nobr><span class="ft2">, Maurice Nivat</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:509"><nobr><span class="ft2">(Ed.), LNCE 1378, Springer, 140­155. 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:477"><nobr><span class="ft2">[10]</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:509"><nobr><span class="ft14">R. Carey and G. Bell. The Annotated VRML 2.0 Reference Manual.<br>Addison-Wesley, Reading, MA, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:1000;left:477"><nobr><span class="ft2">[11]  C. Carlsson and O. Hagsand. DIVE--A Multi-User Virtual Reality</span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:509"><nobr><span class="ft2">System. In <i>Proc. IEEE VRAIS '93</i>, pages 394­400, Sept 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:477"><nobr><span class="ft2">[12]  C. F. Codella, R. Jalili, L. Koved, and J. B. Lewis. A Toolkit for</span></nobr></DIV>
<DIV style="position:absolute;top:1045;left:509"><nobr><span class="ft30">Developing Multi-User, Distributed Virtual Environments. In <i>Proc.<br>IEEE VRAIS '93</i></span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:589"><nobr><span class="ft2">, pages 401­407, Sept 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:81"><nobr><span class="ft31">7. Computed as an offset from January 1, 1997.<br>8. Implementation details of the combination of Network and Replicated</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:99"><nobr><span class="ft2">Objects made it difficult for us to adopt a more advanced solution.</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="6010.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft2">[13]</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:114"><nobr><span class="ft14">C. Elliott, G. Schechter, R. Yeung and S. Abi-Ezzi. TBAG: A High<br>Level Framework for Interactive, Animated 3D Graphics<br>Applications, In <i>Proc. ACM SIGGRAPH 94</i>, pages 421­434, August,<br>1994.</span></nobr></DIV>
<DIV style="position:absolute;top:139;left:81"><nobr><span class="ft2">[14]</span></nobr></DIV>
<DIV style="position:absolute;top:139;left:113"><nobr><span class="ft30">M. Fairen and A. Vinacua, ATLAS, A Platform for Distributed<br>Graphics Applications, In <i>Proc. VI Eurographics Workshop on Pro-<br>gramming Paradigms in Graphics</i>, pages 91­102, September, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:81"><nobr><span class="ft2">[15]  S. Feiner, B. MacIntyre, M. Haupt, and E. Solomon. Windows on the</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:113"><nobr><span class="ft30">World: 2D Windows for 3D Augmented Reality. In <i>Proc. ACM UIST<br>'93</i>, pages 145­155, 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:81"><nobr><span class="ft2">[16]  T. A. Funkhouser. RING: A Client-Server System for Multi-User</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:113"><nobr><span class="ft30">Virtual Environments. In <i>Proc. 1995 ACM Symp. on Interactive 3D<br>Graphics</i>, pages 85­92, March 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:81"><nobr><span class="ft2">[17]  G. Grimsdale. dVS--Distributed Virtual Environment System. In</span></nobr></DIV>
<DIV style="position:absolute;top:288;left:113"><nobr><span class="ft9"><i>Proc. Computer Graphics '91 Conference</i>, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:81"><nobr><span class="ft2">[18]  S. P. Harbison. <i>Modula-3</i>. Prentice-Hall, 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:81"><nobr><span class="ft2">[19]</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:113"><nobr><span class="ft14">H.W. Holbrook, S.K. Singhal and D.R. Cheriton, Log-Based<br>Receiver-Reliable Multicast for Distributed Interactive Simulation,<br><i>Proc. ACM SIGCOMM '95</i>, pages 328­341, 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:81"><nobr><span class="ft2">[20]  W. Levelt, M. Kaashoek, H. Bal, and A. Tanenbaum. A Comparison</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:113"><nobr><span class="ft30">of Two Paradigms for Distributed Shared Memory. <i>Software<br>Practice and Experience</i>, 22(11):985­1010, Nov 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:81"><nobr><span class="ft2">[21]</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:113"><nobr><span class="ft30">B. Lucas. A Scientific Visualization Renderer. In <i>Proc. IEEE<br>Visualization '92</i>, pp. 227-233, October 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:81"><nobr><span class="ft2">[22]</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:113"><nobr><span class="ft14">V. Machiraju, A Framework for Migrating Objects in Distributed<br>Graphics Applications, Masters Thesis, University of Utah, Depart-<br>ment of Computer Science, Salt Lake City, UT, June, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:81"><nobr><span class="ft2">[23]</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:113"><nobr><span class="ft14">B. MacIntyre. Repo: Obliq with Replicated Objects. Programmers<br>Guide and Reference Manual. Columbia University Computer<br>Science Department Research Report CUCS-023-97, 1997.}</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:81"><nobr><span class="ft2">[24]</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:113"><nobr><span class="ft30">B. MacIntyre, and S. Feiner. Language-level Support for Exploratory<br>Programming of Distributed Virtual Environments. In <i>Proc. ACM<br>UIST '96</i>, pages<i> </i>83­94, Seattle, WA, November 6­8, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:81"><nobr><span class="ft2">[25]  M. A. Najork and M. H. Brown. Obliq-3D: A High-level, Fast-turn-</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:113"><nobr><span class="ft30">around 3D Animation System. <i>IEEE Transactions on Visualization<br>and Computer Graphics</i>, 1(2):175­145, June 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:81"><nobr><span class="ft2">[26]</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:113"><nobr><span class="ft14">R. Ben-Natan. CORBA: A Guide to the Common Object Request<br>Broker Architecture, McGraw Hill, 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:81"><nobr><span class="ft2">[27]</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:113"><nobr><span class="ft14">D. Phillips, M. Pique, C. Moler, J. Torborg, D. Greenberg. Distribut-<br>ed Graphics: Where to Draw the Lines? Panel Transcript,<br>SIGGRAPH 89, available at:<br>http://www.siggraph.org:443/publications/panels/siggraphi89/</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:477"><nobr><span class="ft2">[28]  A. Prakash and H. S. Shim. DistView: Support for Building Efficient</span></nobr></DIV>
<DIV style="position:absolute;top:94;left:509"><nobr><span class="ft30">Collaborative Applications Using Replicated Objects. In <i>Proc. ACM<br>CSCW '94</i>, pages 153­162, October 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:477"><nobr><span class="ft2">[29]</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:509"><nobr><span class="ft30">J. Rohlf and J. Helman, IRIS Performer: A High Performance<br>Multiprocessing Toolkit for Real-Time {3D} Graphics, In <i>Proc.<br>ACM SIGGRAPH 94</i>, pages 381­394, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:477"><nobr><span class="ft2">[30]  M. Roseman and S. Greenberg. Building Real-Time Groupware with</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:509"><nobr><span class="ft30">GroupKit, a Groupware Toolkit. <i>ACM Transactions on Computer-<br>Human Interaction</i>, 3(1):66­106, March 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:477"><nobr><span class="ft2">[31]  C. Shaw and M. Green. The MR Toolkit Peers Package and</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:509"><nobr><span class="ft2">Experiment. In <i>Proc. IEEE VRAIS '93</i>, pages 18­22, Sept 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:477"><nobr><span class="ft2">[32]  G. Singh, L. Serra, W. Png, A. Wong, and H. Ng. BrickNet: Sharing</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:509"><nobr><span class="ft14">Object Behaviors on the Net. In <i>Proc. IEEE VRAIS '95</i>, pages 19­25,<br>1995.</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:477"><nobr><span class="ft2">[33]</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:509"><nobr><span class="ft14">H. Sowizral, K. Rushforth, and M. Deering. The Java 3D API<br>Specification, Addison-Wesley, Reading, MA, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:477"><nobr><span class="ft2">[34]  M. Stefik, G. Foster, D. G. Bobrow, K. Kahn, S. Lanning, and</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:509"><nobr><span class="ft14">L. Suchman. Beyond The Chalkboard: Computer Support for<br>Collaboration and Problem Solving in Meetings. <i>CACM</i>, 30(1):32­<br>47, January 1987.</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:477"><nobr><span class="ft2">[35]</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:509"><nobr><span class="ft14">P. S. Strauss and R. Carey, An Object-Oriented 3D Graphics Toolkit,<br>In <i>Computer Graphics (Proc. ACM SIGGRAPH 92)</i>, pages 341­349,<br>Aug, 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:477"><nobr><span class="ft2">[36]</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:509"><nobr><span class="ft14">Sun Microsystems, Inc. The Java Shared Data Toolkit, 1998. <br>Unsupported software, available at:<br>http://developer.javasoft.com/developer/earlyAccess/jsdt/</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:477"><nobr><span class="ft2">[37]  I. Tou, S. Berson, G. Estrin, Y. Eterovic, and E. Wu. Prototyping</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:509"><nobr><span class="ft14">Synchronous Group Applications. <i>IEEE Computer</i>, 27(5):48­56,<br>May 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:477"><nobr><span class="ft2">[38]</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:509"><nobr><span class="ft14">R. Waters and D. Anderson. The Java Open Community Version 0.9<br>Application Program Interface. Feb, 1997. Available online at:<br>http://www.merl.com/opencom/opencom-java-api.html</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:477"><nobr><span class="ft2">[39]</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:509"><nobr><span class="ft14">A. Wollrath, R. Riggs, and J. Waldo. A Distributed Object Model for<br>the Java System, In <i>Proc. USENIX COOTS '96</i>, pages 219­231, July<br>1996.</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:477"><nobr><span class="ft2">[40]</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:509"><nobr><span class="ft30">R. Zeleznik, D. Conner, M. Wloka, D. Aliaga, N. Huang,<br>P. Hubbard, B. Knep, H. Kaufman, J. Hughes, and A. van Dam. An<br>Object-oriented Framework for the Integration of Interactive<br>Animation Techniques. In <i>Computer Graphics (SIGGRAPH '91<br>Proceedings)</i>, pages 105­112, July, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:679;left:477"><nobr><span class="ft2">[41]  M. J. Zyda, D. R. Pratt, J. G. Monahan, and K. P. Wilson. NPSNET:</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:509"><nobr><span class="ft30">Constructing a 3D Virtual World. In <i>Proc. 1992 ACM Symp. on<br>Interactive 3D Graphics</i>, pages 147­156, Mar. 1992.</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
