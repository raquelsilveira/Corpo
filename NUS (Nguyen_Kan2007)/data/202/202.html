<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>f11-oliveira.dvi</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2005-09-13T17:27:08+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Times;color:#000000;}
	.ft1{font-size:14px;font-family:Times;color:#000000;}
	.ft2{font-size:11px;font-family:Times;color:#000000;}
	.ft3{font-size:11px;font-family:Times;color:#000000;}
	.ft4{font-size:14px;font-family:Times;color:#000000;}
	.ft5{font-size:11px;font-family:Times;color:#000000;}
	.ft6{font-size:11px;font-family:Times;color:#000000;}
	.ft7{font-size:8px;font-family:Times;color:#000000;}
	.ft8{font-size:8px;font-family:Times;color:#000000;}
	.ft9{font-size:11px;font-family:Times;color:#000000;}
	.ft10{font-size:16px;font-family:Courier;color:#000000;}
	.ft11{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft12{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft13{font-size:8px;line-height:11px;font-family:Times;color:#000000;}
	.ft14{font-size:8px;line-height:12px;font-family:Times;color:#000000;}
	.ft15{font-size:8px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="202001.png" alt="background image">
<DIV style="position:absolute;top:117;left:133"><nobr><span class="ft0"><b>TypeCase: A Design Pattern for Type-Indexed Functions</b></span></nobr></DIV>
<DIV style="position:absolute;top:179;left:312"><nobr><span class="ft1">Bruno C. d. S. Oliveira and Jeremy Gibbons</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:345"><nobr><span class="ft2">Oxford University Computing Laboratory</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:311"><nobr><span class="ft2">Wolfson Building, Parks Road, Oxford OX1 3QD, UK</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:376"><nobr><span class="ft3">{bruno,jg}@comlab.ox.ac.uk</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:81"><nobr><span class="ft4"><b>Abstract</b></span></nobr></DIV>
<DIV style="position:absolute;top:344;left:81"><nobr><span class="ft11">A <i>type-indexed function </i>is a function that is defined for each<br>member of some family of types. Haskell's type class mechan-<br>ism provides collections of <i>open type-indexed functions</i>, in which<br>the indexing family can be extended by defining a new type class<br>instance but the collection of functions is fixed. The purpose of this<br>paper is to present <i>TypeCase</i>: a design pattern that allows the defin-<br>ition of <i>closed type-indexed functions</i>, in which the index family<br>is fixed but the collection of functions is extensible. It is inspired<br>by Cheney and Hinze's work on lightweight approaches to gen-<br>eric programming. We generalise their techniques as a <i>design pat-<br>tern</i>. Furthermore, we show that <i>type-indexed functions </i>with <i>type-<br>indexed types</i>, and consequently <i>generic functions </i>with <i>generic<br>types</i>, can also be encoded in a lightweight manner, thereby over-<br>coming one of the main limitations of the lightweight approaches.</span></nobr></DIV>
<DIV style="position:absolute;top:564;left:81"><nobr><span class="ft4"><i><b>Categories and Subject Descriptors</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:564;left:295"><nobr><span class="ft2">D.3.3 [<i>Programming Lan-</i></span></nobr></DIV>
<DIV style="position:absolute;top:579;left:81"><nobr><span class="ft5"><i>guages</i>]: Language Constructs and Features</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:81"><nobr><span class="ft4"><i><b>General Terms</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:604;left:177"><nobr><span class="ft2">Languages</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:81"><nobr><span class="ft6"><i><b>Keywords</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:148"><nobr><span class="ft2">Generic programming, type classes, type-indexed func-</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:81"><nobr><span class="ft2">tions</span></nobr></DIV>
<DIV style="position:absolute;top:678;left:81"><nobr><span class="ft4"><b>1. Introduction</b></span></nobr></DIV>
<DIV style="position:absolute;top:701;left:81"><nobr><span class="ft11">A <i>type-indexed function </i>is a function that is defined for each mem-<br>ber of a family of types. One of the most popular mechanisms<br>implementing this notion is the Haskell [31] <i>type class </i>system. A<br>type class consists of a collection of related type-indexed functions;<br>the family of index types is the set of instances of the type class.<br>Type classes provide just one possible interpretation of the notion<br>of type-indexed functions. In particular, they assume an <i>open-world<br></i>perspective: the family of index types is extensible, by defining a<br>new type class instance for that type, but the collection of type-<br>indexed functions is fixed in the type class interface so needs to<br>be known in advance. For some applications -- particularly when<br>providing a framework for generic programming -- the family of<br>index types is fixed (albeit large) and the collection of type-indexed<br>functions is not known in advance, so a closed-world perspective<br>would make more sense.</span></nobr></DIV>
<DIV style="position:absolute;top:990;left:81"><nobr><span class="ft15">Permission to make digital or hard copies of all or part of this work for personal or<br>classroom use is granted without fee provided that copies are not made or distributed<br>for profit or commercial advantage and that copies bear this notice and the full citation<br>on the first page. To copy otherwise, to republish, to post on servers or to redistribute<br>to lists, requires prior specific permission and/or a fee.<br>Haskell'05</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:138"><nobr><span class="ft7">September 30, 2005, Tallinn, Estonia.</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:81"><nobr><span class="ft7">Copyright c 2005 ACM 1-59593-071-X/05/0009. . . $5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:323;left:493"><nobr><span class="ft2">The original concept of a <i>design pattern </i>has its origins in Chris-</span></nobr></DIV>
<DIV style="position:absolute;top:338;left:476"><nobr><span class="ft11">topher Alexander's work in architecture, but it has been picked up<br>with enthusiasm by the object-oriented programming community.<br>The idea of design patterns is to capture, abstract and record bene-<br>ficial recurring patterns in software design. Sometimes those pat-<br>terns can be captured formally, as programming language con-<br>structs or software library fragments. Often, however, the appro-<br>priate abstraction cannot be directly stated, either because of a lack<br>of expressiveness in the language, or because there is inherent am-<br>biguity in the pattern -- Alexander describes a pattern as a solution<br>`you can use [. . . ] a million times over, without ever doing it the<br>same way twice' [1]. In this case, one must resort to an informal<br>description. Even if the abstraction itself can be captured formally,<br>one might argue that a complete description of the pattern includes<br>necessarily informal information: a name, motivation, examples,<br>consequences, implementation trade-offs, and so on.</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:493"><nobr><span class="ft2">In this paper, we present a technique that allows the definition of</span></nobr></DIV>
<DIV style="position:absolute;top:577;left:476"><nobr><span class="ft11">closed type-indexed functions, as opposed to the open type-indexed<br>functions provided by type classes; we do so in the format of a<br>design pattern. Our inspiration comes from previous research on<br>lightweight approaches to generic programming (LAGP). In partic-<br>ular, Hinze's two papers "A Lightweight Implementation of Gener-<br>ics and Dynamics" [4] (LIGD, with James Cheney) and "Generics<br>for the Masses" [19] (GM) provide our motivation and basis.</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:493"><nobr><span class="ft2">Those two papers focus on the particular context of generic</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:476"><nobr><span class="ft11">programming, and provide a number of techniques that can be used<br>to encode first-class generic functions in Haskell. However, those<br>techniques have a wider applicability, not addressed by Hinze. We<br>propose a generalisation of the technique, and demonstrate its use<br>in a variety of applications. Our specific contributions are:<br><b>Generalisation of the lightweight approaches. </b>We provide tem-</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:495"><nobr><span class="ft11">plates for designing closed type-indexed functions, abstracting<br>away from generic programming. The techniques in LIGD and<br>GM are instances of these templates.</span></nobr></DIV>
<DIV style="position:absolute;top:834;left:476"><nobr><span class="ft9"><b>A design pattern for type-indexed functions. </b>We document this</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:495"><nobr><span class="ft2">generalisation as a design pattern.</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:476"><nobr><span class="ft9"><b>Type-indexed functions with type-indexed types. </b>We show that</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:495"><nobr><span class="ft11">with our more general interpretation of the design pattern, type-<br>indexed functions with type-indexed types are also instances of<br>the design pattern. As a consequence, generic functions with<br>generic types can also be encoded in a lightweight manner.<br>Thus, we remove one of the main limitations of the lightweight<br>approaches.</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:476"><nobr><span class="ft9"><b>Other applications. </b>We present two other interesting applications</span></nobr></DIV>
<DIV style="position:absolute;top:990;left:495"><nobr><span class="ft12">of the pattern: PolyP in Haskell 98, and a very flexible <i>printf<br></i>function.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:493"><nobr><span class="ft2">The remainder of this paper is structured as follows. In Section 2</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:476"><nobr><span class="ft11">we review the lightweight approaches to generic programming. In<br>Section 3 we abstract the essence of the technique as a design pat-<br>tern. Section 4 presents two other small applications of the design</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft2">98</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft16{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft17{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="202002.png" alt="background image">
<DIV style="position:absolute;top:110;left:81"><nobr><span class="ft11">pattern, and Section 5 uses it to model type-indexed functions with<br>type-indexed types. Section 6 concludes.</span></nobr></DIV>
<DIV style="position:absolute;top:154;left:81"><nobr><span class="ft4"><b>2. Lightweight generic programming</b></span></nobr></DIV>
<DIV style="position:absolute;top:178;left:81"><nobr><span class="ft11">We start by summarising the earlier work on lightweight ap-<br>proaches to generic programming underlying our generalisation.</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:81"><nobr><span class="ft9"><b>2.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:217;left:111"><nobr><span class="ft16"><b>"A Lightweight Implementation of Generics and<br>Dynamics"</b></span></nobr></DIV>
<DIV style="position:absolute;top:253;left:81"><nobr><span class="ft11">Cheney and Hinze [4] show how to do a kind of generic program-<br>ming, using only the standard Hindley-Milner type system exten-<br>ded with existential types. The index family consists of hierarchical<br>sums and products of integers and characters. This family is enough<br>to represent a large subset of Haskell 98 datatypes (including mu-<br>tually recursive and nested datatypes).</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:100"><nobr><span class="ft9"><b>data </b><i>Sum a b</i></span></nobr></DIV>
<DIV style="position:absolute;top:340;left:178"><nobr><span class="ft3">= <i>Inl a </i>| <i>Inr b</i></span></nobr></DIV>
<DIV style="position:absolute;top:358;left:100"><nobr><span class="ft9"><b>data </b><i>Prod a b</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:178"><nobr><span class="ft3">= <i>Prod a b</i></span></nobr></DIV>
<DIV style="position:absolute;top:374;left:100"><nobr><span class="ft9"><b>data </b><i>Unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:371;left:178"><nobr><span class="ft3">= <i>Unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:389;left:99"><nobr><span class="ft2">This style of generic programming requires a representation of</span></nobr></DIV>
<DIV style="position:absolute;top:404;left:81"><nobr><span class="ft11">types as values in order to support typecase analysis. The key idea<br>of the LIGD paper is to use a parametrised type as the type rep-<br>resentation, ensuring that the type parameter reflects the type being<br>represented. Some Haskell implementations have recently been ex-<br>tended with <i>generalised algebraic datatypes </i>(GADTs) [32], which<br>can be used for this purpose; but LIGD predates that extension, and<br>depends only on existential quantification.</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:100"><nobr><span class="ft9"><b>data </b><i>Rep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:160"><nobr><span class="ft3">=</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:124"><nobr><span class="ft5"><i>RUnit</i></span></nobr></DIV>
<DIV style="position:absolute;top:521;left:283"><nobr><span class="ft3">(<i>t </i> <i>Unit</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:117"><nobr><span class="ft3">| <i>RInt</i></span></nobr></DIV>
<DIV style="position:absolute;top:537;left:283"><nobr><span class="ft3">(<i>t </i> <i>Int</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:117"><nobr><span class="ft3">| <i>RChar</i></span></nobr></DIV>
<DIV style="position:absolute;top:553;left:283"><nobr><span class="ft3">(<i>t </i> <i>Char</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:117"><nobr><span class="ft3">|  <i>a b</i>. <i>RSum </i>(<i>Rep a</i>) (<i>Rep b</i>) (<i>t </i> (<i>Sum a b</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:117"><nobr><span class="ft3">|  <i>a b</i>. <i>RProd </i>(<i>Rep a</i>) (<i>Rep b</i>) (<i>t </i> (<i>Prod a b</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:603;left:100"><nobr><span class="ft9"><b>data </b><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:600;left:139"><nobr><span class="ft3"> <i>b </i>= <i>EP</i>{<i>from </i>:: <i>a </i> <i>b</i>,<i>to </i>:: <i>b </i> <i>a</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:81"><nobr><span class="ft11">(Note that the universal quantifications are in contravariant posi-<br>tions, so act existentially.)</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:99"><nobr><span class="ft2">The intention is that the equivalence type <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:645;left:335"><nobr><span class="ft3"> <i>b </i>represents em-</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:81"><nobr><span class="ft11">bedding/projection pairs witnessing to an isomorphism between<br>types <i>a </i>and <i>b</i>, thereby enforcing a correspondence between types <i>t<br></i>and <i>Rep t</i>. Of course, within Haskell, it is not possible to automatic-<br>ally verify the isomorphisms (<i>from</i></span></nobr></DIV>
<DIV style="position:absolute;top:704;left:271"><nobr><span class="ft3"> <i>to </i>= <i>id </i>and <i>to </i> <i>from </i>= <i>id</i>), so</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:81"><nobr><span class="ft11">these laws should be externally checked. Furthermore, we follow<br>the convention of ignoring the `ugly fact' of bottom values destroy-<br>ing the `beautiful theory' of many such isomorphisms [8].</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:99"><nobr><span class="ft2">A common case is with the trivial embedding/projections.</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:100"><nobr><span class="ft5"><i>self </i>:: <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:779;left:142"><nobr><span class="ft3"> <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:797;left:100"><nobr><span class="ft5"><i>self</i></span></nobr></DIV>
<DIV style="position:absolute;top:795;left:124"><nobr><span class="ft3">= <i>EP</i>{<i>from </i>= <i>id</i>,<i>to </i>= <i>id</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:81"><nobr><span class="ft12">Using <i>self </i>, we can provide a set of smart constructors for the <i>Rep<br></i>type, yielding representations of types by themselves.</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:100"><nobr><span class="ft17"><i>rUnit </i>:: <i>Rep Unit<br>rUnit</i></span></nobr></DIV>
<DIV style="position:absolute;top:855;left:133"><nobr><span class="ft3">= <i>RUnit self</i></span></nobr></DIV>
<DIV style="position:absolute;top:878;left:100"><nobr><span class="ft17"><i>rInt </i>:: <i>Rep Int<br>rInt</i></span></nobr></DIV>
<DIV style="position:absolute;top:891;left:124"><nobr><span class="ft3">= <i>RInt self</i></span></nobr></DIV>
<DIV style="position:absolute;top:914;left:100"><nobr><span class="ft17"><i>rChar </i>:: <i>Rep Char<br>rChar</i></span></nobr></DIV>
<DIV style="position:absolute;top:927;left:137"><nobr><span class="ft3">= <i>RChar self</i></span></nobr></DIV>
<DIV style="position:absolute;top:949;left:100"><nobr><span class="ft5"><i>rSum </i>:: <i>Rep a</i></span></nobr></DIV>
<DIV style="position:absolute;top:947;left:174"><nobr><span class="ft3"> <i>Rep b </i> <i>Rep </i>(<i>Sum a b</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:100"><nobr><span class="ft5"><i>rSum ra rb</i></span></nobr></DIV>
<DIV style="position:absolute;top:962;left:162"><nobr><span class="ft3">= <i>RSum ra rb self</i></span></nobr></DIV>
<DIV style="position:absolute;top:985;left:100"><nobr><span class="ft5"><i>rProd </i>:: <i>Rep a</i></span></nobr></DIV>
<DIV style="position:absolute;top:982;left:177"><nobr><span class="ft3"> <i>Rep b </i> <i>Rep </i>(<i>Prod a b</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:100"><nobr><span class="ft5"><i>rProd ra rb</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:165"><nobr><span class="ft3">= <i>RProd ra rb self</i></span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:81"><nobr><span class="ft11">Using these smart constructors, we can build representations for<br>recursive datatypes, by making explicit the structure isomorphism<br>of the datatype. For instance, the isomorphism defining lists is</span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:81"><nobr><span class="ft3">[<i>a</i>] </span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:101"><nobr><span class="ft3">= 1 + <i>a </i>× [<i>a</i>], and so the corresponding type representation is</span></nobr></DIV>
<DIV style="position:absolute;top:1075;left:81"><nobr><span class="ft2">as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:495"><nobr><span class="ft5"><i>rList </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:532"><nobr><span class="ft3"> <i>a</i>. <i>Rep a </i> <i>Rep </i>[<i>a</i>]</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:495"><nobr><span class="ft5"><i>rList ra</i></span></nobr></DIV>
<DIV style="position:absolute;top:123;left:538"><nobr><span class="ft3">= <i>RSum rUnit </i>(<i>rProd ra </i>(<i>rList ra</i>)) (<i>EP from to</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:508"><nobr><span class="ft9"><b>where </b><i>from</i></span></nobr></DIV>
<DIV style="position:absolute;top:139;left:574"><nobr><span class="ft3">[ ]</span></nobr></DIV>
<DIV style="position:absolute;top:139;left:667"><nobr><span class="ft3">= <i>Inl Unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:157;left:546"><nobr><span class="ft5"><i>from</i></span></nobr></DIV>
<DIV style="position:absolute;top:154;left:574"><nobr><span class="ft3">(<i>x </i>: <i>xs</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:154;left:668"><nobr><span class="ft3">= <i>Inr </i>(<i>Prod x xs</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:546"><nobr><span class="ft5"><i>to</i></span></nobr></DIV>
<DIV style="position:absolute;top:170;left:574"><nobr><span class="ft3">(<i>Inl Unit</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:667"><nobr><span class="ft3">= [ ]</span></nobr></DIV>
<DIV style="position:absolute;top:188;left:546"><nobr><span class="ft5"><i>to</i></span></nobr></DIV>
<DIV style="position:absolute;top:186;left:574"><nobr><span class="ft3">(<i>Inr </i>(<i>Prod x xs</i>)) = <i>x </i>: <i>xs</i></span></nobr></DIV>
<DIV style="position:absolute;top:203;left:476"><nobr><span class="ft11">Note that the representation of a recursive datatype is an infinite<br>value; but, because of laziness, this poses no problem.</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:493"><nobr><span class="ft2">Having constructed representation values for arbitrary types, the</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:476"><nobr><span class="ft11">final step is to define generic functions. Using the representation<br>as a basis for structural case analysis, it is possible to simulate a<br>typecase [16]. For example, here is a definition of generic equality:</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:495"><nobr><span class="ft5"><i>eq </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:519"><nobr><span class="ft3"> <i>t</i>. <i>Rep t </i> <i>t </i> <i>t </i> <i>Bool</i></span></nobr></DIV>
<DIV style="position:absolute;top:309;left:495"><nobr><span class="ft5"><i>eq</i></span></nobr></DIV>
<DIV style="position:absolute;top:306;left:511"><nobr><span class="ft3">(<i>RInt ep</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:604"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:313;left:608"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:617"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:313;left:621"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:630"><nobr><span class="ft3">= <i>from ep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:313;left:690"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:714"><nobr><span class="ft5"><i>from ep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:313;left:761"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:495"><nobr><span class="ft5"><i>eq</i></span></nobr></DIV>
<DIV style="position:absolute;top:322;left:511"><nobr><span class="ft3">(<i>RChar ep</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:604"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:329;left:608"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:617"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:329;left:621"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:630"><nobr><span class="ft3">= <i>from ep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:329;left:690"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:714"><nobr><span class="ft5"><i>from ep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:329;left:761"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:495"><nobr><span class="ft5"><i>eq</i></span></nobr></DIV>
<DIV style="position:absolute;top:337;left:511"><nobr><span class="ft3">(<i>RUnit ep</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:630"><nobr><span class="ft3">= <i>True</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:495"><nobr><span class="ft5"><i>eq</i></span></nobr></DIV>
<DIV style="position:absolute;top:353;left:511"><nobr><span class="ft3">(<i>RSum ra rb ep</i>) <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:360;left:608"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:617"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:360;left:621"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:630"><nobr><span class="ft3">= <b>case </b>(<i>from ep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:360;left:723"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:728"><nobr><span class="ft3">,<i>from ep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:360;left:781"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:787"><nobr><span class="ft3">) <b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:369;left:670"><nobr><span class="ft3">(<i>Inl x</i>,<i>Inl y</i>)  <i>eq ra x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:384;left:670"><nobr><span class="ft3">(<i>Inr x</i>,<i>Inr y</i>)  <i>eq rb x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:400;left:740"><nobr><span class="ft3"> <i>False</i></span></nobr></DIV>
<DIV style="position:absolute;top:419;left:495"><nobr><span class="ft5"><i>eq</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:511"><nobr><span class="ft3">(<i>RProd ra rb ep</i>) <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:608"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:617"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:621"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:630"><nobr><span class="ft3">= <b>case </b>(<i>from ep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:723"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:728"><nobr><span class="ft3">,<i>from ep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:781"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:787"><nobr><span class="ft3">) <b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:432;left:670"><nobr><span class="ft3">(<i>Prod x y</i>,<i>Prod x y </i>) </span></nobr></DIV>
<DIV style="position:absolute;top:450;left:683"><nobr><span class="ft5"><i>eq ra x x</i></span></nobr></DIV>
<DIV style="position:absolute;top:448;left:735"><nobr><span class="ft3"> <i>eq rb y y</i></span></nobr></DIV>
<DIV style="position:absolute;top:465;left:476"><nobr><span class="ft11">Using Haskell type classes, it is possible to make the use of generic<br>functions even more convenient: the class <i>TypeRep </i>can be used to<br>build values of type <i>Rep t </i>implicitly.</span></nobr></DIV>
<DIV style="position:absolute;top:510;left:495"><nobr><span class="ft9"><b>class </b><i>TypeRep t </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:508"><nobr><span class="ft5"><i>rep </i>:: <i>Rep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:546;left:495"><nobr><span class="ft9"><b>instance </b><i>TypeRep Unit </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:561;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:559;left:529"><nobr><span class="ft3">= <i>rUnit</i></span></nobr></DIV>
<DIV style="position:absolute;top:581;left:495"><nobr><span class="ft9"><b>instance </b><i>TypeRep Int </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:597;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:594;left:529"><nobr><span class="ft3">= <i>rInt</i></span></nobr></DIV>
<DIV style="position:absolute;top:617;left:495"><nobr><span class="ft9"><b>instance </b><i>TypeRep Char </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:633;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:630;left:529"><nobr><span class="ft3">= <i>rChar</i></span></nobr></DIV>
<DIV style="position:absolute;top:653;left:495"><nobr><span class="ft9"><b>instance</b></span></nobr></DIV>
<DIV style="position:absolute;top:650;left:545"><nobr><span class="ft3">(<i>TypeRep a</i>,<i>TypeRep b</i>)  <i>TypeRep </i>(<i>Sum a b</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:668;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:666;left:529"><nobr><span class="ft3">= <i>rSum rep rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:688;left:495"><nobr><span class="ft9"><b>instance</b></span></nobr></DIV>
<DIV style="position:absolute;top:686;left:545"><nobr><span class="ft3">(<i>TypeRep a</i>,<i>TypeRep b</i>)  <i>TypeRep </i>(<i>Prod a b</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:704;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:701;left:529"><nobr><span class="ft3">= <i>rProd rep rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:724;left:495"><nobr><span class="ft9"><b>instance </b><i>TypeRep a</i></span></nobr></DIV>
<DIV style="position:absolute;top:721;left:604"><nobr><span class="ft3"> <i>TypeRep </i>[<i>a</i>] <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:740;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:737;left:529"><nobr><span class="ft3">= <i>rList rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:754;left:476"><nobr><span class="ft11">For example, we can now express generic equality with an implicit<br>rather than explicit dependence on the representation.</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:495"><nobr><span class="ft5"><i>ceq </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:525"><nobr><span class="ft3"> <i>t</i>. <i>TypeRep t </i> <i>t </i> <i>t </i> <i>Bool</i></span></nobr></DIV>
<DIV style="position:absolute;top:800;left:495"><nobr><span class="ft5"><i>ceq t</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:520"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:529"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:533"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:542"><nobr><span class="ft3">= <i>eq rep t</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:595"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:604"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:608"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:476"><nobr><span class="ft9"><b>2.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:827;left:506"><nobr><span class="ft9"><b>"Generics for the Masses"</b></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:476"><nobr><span class="ft11">Hinze's later GM approach [19] has a very similar flavour to LIGD;<br>however, somewhat surprisingly, Hinze shows how to do generic<br>programming strictly within Haskell 98, which does not support<br>rank-<i>n </i>types or even existential types. Nevertheless, there is a close<br>relationship between type classes and polymorphic records (for<br>example, one possible translation of type classes into System F uses<br>polymorphic records), and these require something like existential<br>types for their encoding. Thus, type class instances can be seen<br>as implicitly-passed records. Hinze uses this observation to deliver<br>two implementations of generics.</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:476"><nobr><span class="ft9"><b>2.2.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:516"><nobr><span class="ft9"><b>Generic functions on types</b></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:476"><nobr><span class="ft11">The first implementation of generics in GM ("GM1", from now<br>on) can be seen as a direct descendent of LIGD. Instead of using a<br>datatype with an existential quantification, Hinze uses a type class<br><i>Generic</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft2">99</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft18{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="202003.png" alt="background image">
<DIV style="position:absolute;top:110;left:100"><nobr><span class="ft9"><b>class </b><i>Generic g </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:114"><nobr><span class="ft5"><i>unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:162"><nobr><span class="ft2">:: <i>g Unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:114"><nobr><span class="ft5"><i>sum</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:162"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:139;left:171"><nobr><span class="ft3">(<i>TypeRep a</i>,<i>TypeRep b</i>)  <i>g </i>(<i>Sum a b</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:115"><nobr><span class="ft5"><i>prod</i></span></nobr></DIV>
<DIV style="position:absolute;top:157;left:162"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:154;left:171"><nobr><span class="ft3">(<i>TypeRep a</i>,<i>TypeRep b</i>)  <i>g </i>(<i>Prod a b</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:114"><nobr><span class="ft5"><i>datatype </i>:: <i>TypeRep a</i></span></nobr></DIV>
<DIV style="position:absolute;top:170;left:230"><nobr><span class="ft3"> (<i>b </i> <i>a</i>)  <i>g b</i></span></nobr></DIV>
<DIV style="position:absolute;top:188;left:114"><nobr><span class="ft5"><i>char</i></span></nobr></DIV>
<DIV style="position:absolute;top:188;left:162"><nobr><span class="ft2">:: <i>g Char</i></span></nobr></DIV>
<DIV style="position:absolute;top:204;left:114"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:204;left:162"><nobr><span class="ft2">:: <i>g Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:219;left:81"><nobr><span class="ft11">The parameter <i>g </i>of the type class represents the generic function,<br>and each of the member functions of the type class encodes the<br>behaviour of that generic function for one structural case. Generic<br>functions over user-defined types can also be defined using the<br><i>datatype </i>type case. In this case, the isomorphism between the<br>datatype and its structural representation must be provided.</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:99"><nobr><span class="ft2">The type class <i>TypeRep </i>is used to select the appropriate beha-</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:81"><nobr><span class="ft11">viour of the generic function, based on the type structure of its ar-<br>gument. The role of this type class is somewhat analogous to the<br>synonymous one in Section 2.1. One contrast with LIGD is that<br><i>TypeRep </i>for GM1 is not optional, because the type representations<br>are always implicitly passed.</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:100"><nobr><span class="ft9"><b>class </b><i>TypeRep a </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:414;left:114"><nobr><span class="ft5"><i>typeRep </i>:: <i>Generic g</i></span></nobr></DIV>
<DIV style="position:absolute;top:411;left:225"><nobr><span class="ft3"> <i>g a</i></span></nobr></DIV>
<DIV style="position:absolute;top:434;left:100"><nobr><span class="ft9"><b>instance </b><i>TypeRep Unit </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:450;left:114"><nobr><span class="ft5"><i>typeRep</i></span></nobr></DIV>
<DIV style="position:absolute;top:447;left:160"><nobr><span class="ft3">= <i>unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:470;left:100"><nobr><span class="ft9"><b>instance</b></span></nobr></DIV>
<DIV style="position:absolute;top:467;left:150"><nobr><span class="ft3">(<i>TypeRep a</i>,<i>TypeRep b</i>)  <i>TypeRep </i>(<i>Sum a b</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:485;left:114"><nobr><span class="ft5"><i>typeRep</i></span></nobr></DIV>
<DIV style="position:absolute;top:483;left:160"><nobr><span class="ft3">= <i>sum</i></span></nobr></DIV>
<DIV style="position:absolute;top:505;left:100"><nobr><span class="ft9"><b>instance</b></span></nobr></DIV>
<DIV style="position:absolute;top:503;left:150"><nobr><span class="ft3">(<i>TypeRep a</i>,<i>TypeRep b</i>)  <i>TypeRep </i>(<i>Prod a b</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:521;left:114"><nobr><span class="ft5"><i>typeRep</i></span></nobr></DIV>
<DIV style="position:absolute;top:518;left:160"><nobr><span class="ft3">= <i>prod</i></span></nobr></DIV>
<DIV style="position:absolute;top:541;left:100"><nobr><span class="ft9"><b>instance </b><i>TypeRep Char </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:557;left:114"><nobr><span class="ft5"><i>typeRep</i></span></nobr></DIV>
<DIV style="position:absolute;top:554;left:160"><nobr><span class="ft3">= <i>char</i></span></nobr></DIV>
<DIV style="position:absolute;top:577;left:100"><nobr><span class="ft9"><b>instance </b><i>TypeRep Int </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:592;left:114"><nobr><span class="ft5"><i>typeRep</i></span></nobr></DIV>
<DIV style="position:absolute;top:590;left:160"><nobr><span class="ft3">= <i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:607;left:81"><nobr><span class="ft11">For GM, the type class <i>TypeRep </i>directly selects the appropriate<br>behaviour for a particular structural case from the generic function.<br>In contrast, for LIGD, the corresponding type class <i>TypeRep </i>builds<br>a value as a type representation for a particular structural case,<br>and this representation is then used by a generic function to select<br>the appropriate behaviour. The effect is the same, but GM is more<br>direct.</span></nobr></DIV>
<DIV style="position:absolute;top:712;left:99"><nobr><span class="ft2">A new generic function is defined via an instance of <i>Generic</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:81"><nobr><span class="ft12">providing an implementation for each structural case. For instance,<br>the generic function <i>gSize </i>that counts all the elements of type <i>Int<br></i>and <i>Char </i>in some structure could be encoded as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:100"><nobr><span class="ft9"><b>newtype </b><i>GSize a</i></span></nobr></DIV>
<DIV style="position:absolute;top:769;left:195"><nobr><span class="ft3">= <i>GSize</i>{<i>appGSize </i>:: <i>a </i> <i>Int</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:100"><nobr><span class="ft9"><b>instance </b><i>Generic GSize </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:807;left:114"><nobr><span class="ft5"><i>unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:182"><nobr><span class="ft3">= <i>GSize </i>(  0)</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:114"><nobr><span class="ft5"><i>sum</i></span></nobr></DIV>
<DIV style="position:absolute;top:820;left:182"><nobr><span class="ft3">= <i>GSize </i>(<i>t </i> <b>case </b><i>t </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:230"><nobr><span class="ft5"><i>Inl x</i></span></nobr></DIV>
<DIV style="position:absolute;top:836;left:257"><nobr><span class="ft3"> <i>gSize x</i></span></nobr></DIV>
<DIV style="position:absolute;top:854;left:230"><nobr><span class="ft5"><i>Inr y</i></span></nobr></DIV>
<DIV style="position:absolute;top:852;left:258"><nobr><span class="ft3"> <i>gSize y</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:115"><nobr><span class="ft5"><i>prod</i></span></nobr></DIV>
<DIV style="position:absolute;top:867;left:182"><nobr><span class="ft3">= <i>GSize </i>(<i>t </i> <b>case </b><i>t </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:886;left:230"><nobr><span class="ft5"><i>Prod x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:883;left:277"><nobr><span class="ft3"> <i>gSize x </i>+ <i>gSize y</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:901;left:114"><nobr><span class="ft5"><i>datatype iso</i></span></nobr></DIV>
<DIV style="position:absolute;top:899;left:182"><nobr><span class="ft3">= <i>GSize </i>(<i>t </i> <i>gSize </i>(<i>from iso t</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:114"><nobr><span class="ft5"><i>char</i></span></nobr></DIV>
<DIV style="position:absolute;top:914;left:182"><nobr><span class="ft3">= <i>GSize </i>(  1)</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:114"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:930;left:182"><nobr><span class="ft3">= <i>GSize </i>(  1)</span></nobr></DIV>
<DIV style="position:absolute;top:953;left:100"><nobr><span class="ft5"><i>gSize </i>:: <i>TypeRep a</i></span></nobr></DIV>
<DIV style="position:absolute;top:950;left:199"><nobr><span class="ft3"> <i>a </i> <i>Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:968;left:100"><nobr><span class="ft5"><i>gSize</i></span></nobr></DIV>
<DIV style="position:absolute;top:966;left:132"><nobr><span class="ft3">= <i>appGSize typeRep</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:81"><nobr><span class="ft11">A record of type <i>GSize a </i>contains a single function <i>appGSize </i>of<br>type <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:995;left:116"><nobr><span class="ft3"> <i>Int</i>, which can be used to compute the number of elements</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:81"><nobr><span class="ft11">in some structure of type <i>a</i>. The function <i>gSize</i>, which is the actual<br>generic function, simply extracts the sole <i>appGSize </i>field from a<br>record of the appropriate type, built automatically by <i>typeRep</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:476"><nobr><span class="ft9"><b>2.2.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:110;left:516"><nobr><span class="ft9"><b>Generic functions on type constructors</b></span></nobr></DIV>
<DIV style="position:absolute;top:131;left:476"><nobr><span class="ft11">The second implementation of generics in GM ("GM2") permits<br>parametrisation by type constructors rather than by types. For ex-<br>ample, whereas the generic function <i>gSize </i>of the previous section<br>has type <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:173;left:532"><nobr><span class="ft3"> <i>Int </i>for all first-order types <i>a </i>in the type class <i>TypeRep</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:476"><nobr><span class="ft2">in this section we show a generic function <i>gSize </i>with type <i>f a</i></span></nobr></DIV>
<DIV style="position:absolute;top:188;left:804"><nobr><span class="ft3"> <i>Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:206;left:476"><nobr><span class="ft2">for all type constructors <i>f </i>in the constructor class <i>FunctorRep</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:493"><nobr><span class="ft2">Lifting in this fashion introduces the possibility of ambiguity:</span></nobr></DIV>
<DIV style="position:absolute;top:236;left:476"><nobr><span class="ft2">a type <i>g</i></span></nobr></DIV>
<DIV style="position:absolute;top:233;left:528"><nobr><span class="ft3">(<i>f a</i>) may be considered a type constructor <i>g </i>applied</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:476"><nobr><span class="ft12">to a type <i>f a</i>, or the composition of constructors <i>g </i>and <i>f </i>applied<br>to type <i>a</i>. Therefore we must explicitly pass type representations,<br>increasing flexibility but decreasing brevity. This is reflected in the<br>analogous type class <i>Generic</i>, where the implicitly-passed <i>TypeRep<br></i>contexts are now changed to explicitly-passed functions.</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:495"><nobr><span class="ft9"><b>class </b><i>Generic g </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:341;left:508"><nobr><span class="ft5"><i>unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:341;left:557"><nobr><span class="ft2">:: <i>g Unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:508"><nobr><span class="ft5"><i>sum</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:557"><nobr><span class="ft2">:: <i>g a</i></span></nobr></DIV>
<DIV style="position:absolute;top:354;left:585"><nobr><span class="ft3"> <i>g b </i> <i>g </i>(<i>Sum a b</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:509"><nobr><span class="ft5"><i>prod</i></span></nobr></DIV>
<DIV style="position:absolute;top:372;left:557"><nobr><span class="ft2">:: <i>g a</i></span></nobr></DIV>
<DIV style="position:absolute;top:369;left:586"><nobr><span class="ft3"> <i>g b </i> <i>g </i>(<i>Prod a b</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:508"><nobr><span class="ft5"><i>datatype </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:566"><nobr><span class="ft3">(<i>b </i> <i>a</i>)  <i>g a </i> <i>g b</i></span></nobr></DIV>
<DIV style="position:absolute;top:404;left:508"><nobr><span class="ft5"><i>char</i></span></nobr></DIV>
<DIV style="position:absolute;top:404;left:557"><nobr><span class="ft2">:: <i>g Char</i></span></nobr></DIV>
<DIV style="position:absolute;top:419;left:508"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:419;left:557"><nobr><span class="ft2">:: <i>g Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:434;left:476"><nobr><span class="ft11">However, this modification of the type class restricts expressivity,<br>since the only generic function we can call is the one being defined,<br>recursively. Consequently, generic functions that perform calls to<br>other generic functions (as when defining generic membership in<br>terms of generic equality) become harder to define.</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:493"><nobr><span class="ft2">With the new <i>Generic </i>class it is also possible to build the</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:476"><nobr><span class="ft11">values for type representations automatically, using another type<br>class <i>TypeRep</i>. Just as with LIGD, this class now becomes optional.<br>Alternatively, we can use a type class <i>FunctorRep </i>to capture the<br>notion of unary type constructor or <i>functor</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:495"><nobr><span class="ft9"><b>class </b><i>FunctorRep f </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:599;left:508"><nobr><span class="ft5"><i>functorRep </i>:: <i>Generic g</i></span></nobr></DIV>
<DIV style="position:absolute;top:597;left:636"><nobr><span class="ft3"> <i>g a </i> <i>g </i>(<i>f a</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:476"><nobr><span class="ft2">We have to define similar classes for each arity of type constructor.</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:493"><nobr><span class="ft2">Generic functions are defined in a very similar fashion to GM1.</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:476"><nobr><span class="ft12">For instance, the type <i>Count a </i>below represents a generic function<br>that counts zero for each occurrence of a value of type <i>Int </i>or <i>Char<br></i>in some structure of type <i>a</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:495"><nobr><span class="ft9"><b>newtype </b><i>Count a</i></span></nobr></DIV>
<DIV style="position:absolute;top:686;left:592"><nobr><span class="ft3">= <i>Count</i>{<i>applyCount </i>:: <i>a </i> <i>Int</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:709;left:495"><nobr><span class="ft9"><b>instance </b><i>Generic Count </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:725;left:508"><nobr><span class="ft5"><i>unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:722;left:586"><nobr><span class="ft3">= <i>Count </i>(  0)</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:508"><nobr><span class="ft5"><i>sum a b</i></span></nobr></DIV>
<DIV style="position:absolute;top:738;left:586"><nobr><span class="ft3">= <i>Count </i>(<i>x </i> <b>case </b><i>x </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:756;left:522"><nobr><span class="ft5"><i>Inl l</i></span></nobr></DIV>
<DIV style="position:absolute;top:753;left:550"><nobr><span class="ft3"> <i>applyCount a l</i></span></nobr></DIV>
<DIV style="position:absolute;top:772;left:522"><nobr><span class="ft5"><i>Inr r</i></span></nobr></DIV>
<DIV style="position:absolute;top:769;left:550"><nobr><span class="ft3"> <i>applyCount b r</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:509"><nobr><span class="ft5"><i>prod a b</i></span></nobr></DIV>
<DIV style="position:absolute;top:785;left:586"><nobr><span class="ft3">= <i>Count </i>((<i>Prod x y</i>) </span></nobr></DIV>
<DIV style="position:absolute;top:803;left:522"><nobr><span class="ft5"><i>applyCount a x</i></span></nobr></DIV>
<DIV style="position:absolute;top:800;left:606"><nobr><span class="ft3">+ <i>applyCount b y</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:508"><nobr><span class="ft5"><i>datatype iso a</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:586"><nobr><span class="ft3">= <i>Count </i>(<i>x </i></span></nobr></DIV>
<DIV style="position:absolute;top:835;left:522"><nobr><span class="ft5"><i>applyCount a</i></span></nobr></DIV>
<DIV style="position:absolute;top:832;left:598"><nobr><span class="ft3">(<i>from iso x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:508"><nobr><span class="ft5"><i>char</i></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:586"><nobr><span class="ft3">= <i>Count </i>(  0)</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:508"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:863;left:586"><nobr><span class="ft3">= <i>Count </i>(  0)</span></nobr></DIV>
<DIV style="position:absolute;top:881;left:476"><nobr><span class="ft11">While this function by itself approximates <i>const </i>0, it is the basis<br>for other more useful functions that really count the number of ele-<br>ments in some structure in some way, by overriding the behaviour<br>of the basic generic function for occurrences of the type parameter:</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:495"><nobr><span class="ft5"><i>gSize </i>:: <i>FunctorRep f</i></span></nobr></DIV>
<DIV style="position:absolute;top:938;left:611"><nobr><span class="ft3"> <i>f a </i> <i>Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:956;left:495"><nobr><span class="ft5"><i>gSize</i></span></nobr></DIV>
<DIV style="position:absolute;top:954;left:526"><nobr><span class="ft3">= <i>applyCount </i>(<i>functorRep </i>(<i>Count </i>(  1)))</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:493"><nobr><span class="ft2">The payback of using <i>FunctorRep </i>is that we can define the</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:476"><nobr><span class="ft11">behaviour of the generic function for its parameters. For instance,<br>we could sum all the integers in some integer-parametrised datatype<br>by using the identity function to define the behaviour of the generic<br>function for the type parameter.</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:495"><nobr><span class="ft5"><i>gSum </i>:: <i>FunctorRep f</i></span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:612"><nobr><span class="ft3"> <i>f Int </i> <i>Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:1062;left:495"><nobr><span class="ft5"><i>gSum</i></span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:528"><nobr><span class="ft3">= <i>applyCount </i>(<i>functorRep </i>(<i>Count id</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">100</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft19{font-size:9px;font-family:Times;color:#000000;}
	.ft20{font-size:8px;font-family:Times;color:#000000;}
	.ft21{font-size:5px;font-family:Times;color:#000000;}
	.ft22{font-size:5px;font-family:Times;color:#000000;}
	.ft23{font-size:11px;line-height:5px;font-family:Times;color:#000000;}
	.ft24{font-size:11px;line-height:6px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="202004.png" alt="background image">
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft4"><b>3. Closed type-indexed functions</b></span></nobr></DIV>
<DIV style="position:absolute;top:131;left:81"><nobr><span class="ft11">In LIGD and GM, we are shown three methods for implementing<br>closed type-indexed functions. Those three variations give us dif-<br>ferent expressive power, and impose different constraints on the<br>type system. A choice of implementation techniques, together with<br>technical trade-offs making no one method superior in all circum-<br>stances, is characteristic of design patterns.</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:99"><nobr><span class="ft2">In this section, we introduce the TypeCase design pattern,</span></nobr></DIV>
<DIV style="position:absolute;top:236;left:81"><nobr><span class="ft11">capturing the different techniques for implementing closed type-<br>indexed functions.</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:81"><nobr><span class="ft9"><b>The TypeCase design pattern</b></span></nobr></DIV>
<DIV style="position:absolute;top:296;left:81"><nobr><span class="ft6"><i><b>Intent:</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:296;left:135"><nobr><span class="ft2">Allowing the definition of <i>closed type-indexed functions</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:81"><nobr><span class="ft6"><i><b>Motivation:</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:317;left:160"><nobr><span class="ft2">The <i>typecase </i>design pattern captures a closed-world</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:81"><nobr><span class="ft11">view of <i>ad-hoc polymorphism</i>. In Haskell, the type class system<br>is a mechanism that supports ad-hoc polymorphism, but from an<br>open-world point of view: they can be extended with cases for<br>new datatypes, at the cost of a non-extensible set of functions.<br>Under the closed-world assumption, there is a fixed set of type-<br>structural cases but arbitrarily many type-indexed functions ranging<br>over those cases. An example where the closed-world perpective<br>works better than the open-world one is <i>generic programming</i>, in<br>which we take a structural perspective on types as opposed to the<br>more traditional nominal one. Using just a few operations on types,<br>it is possible to represent the whole family of structural definitions<br>of interest. For instance, here is a possible definition for a generic<br>function that counts all the elements of some structure <i>t</i>:</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:100"><nobr><span class="ft5"><i>gsize t </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:249"><nobr><span class="ft2">:: <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:524;left:268"><nobr><span class="ft3"> <i>Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:542;left:100"><nobr><span class="ft5"><i>gsize Unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:539;left:248"><nobr><span class="ft3">= 0</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:100"><nobr><span class="ft5"><i>gsize Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:555;left:248"><nobr><span class="ft3">= 1</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:100"><nobr><span class="ft5"><i>gsize Sum </i> </span></nobr></DIV>
<DIV style="position:absolute;top:571;left:190"><nobr><span class="ft3">(<i>Inl x</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:248"><nobr><span class="ft3">= <i>gsize </i> <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:589;left:100"><nobr><span class="ft5"><i>gsize Sum </i> </span></nobr></DIV>
<DIV style="position:absolute;top:587;left:190"><nobr><span class="ft3">(<i>Inr y</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:248"><nobr><span class="ft3">= <i>gsize </i> <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:605;left:100"><nobr><span class="ft5"><i>gsize Prod </i> </span></nobr></DIV>
<DIV style="position:absolute;top:602;left:190"><nobr><span class="ft3">(<i>Prod x y</i>) = <i>gsize </i> <i>x </i>+ <i>gsize </i> <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:620;left:81"><nobr><span class="ft11">With an open-world perspective, we can present a fixed number<br>of type-indexed definitions that range over those few cases; but<br>we cannot easily introduce new definitions. This is clearly not<br>appropriate for generic programming. In fact, what we expect from<br>a generic programming facility is the ability to a introduce new<br>generic definition without affecting the surrounding context. This<br>is precisely what the closed-world perspective provides us.</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:81"><nobr><span class="ft6"><i><b>Applicability:</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:169"><nobr><span class="ft2">Use this pattern:</span></nobr></DIV>
<DIV style="position:absolute;top:752;left:89"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:100"><nobr><span class="ft11">to encode collections of definitions that are <i>indexed by some<br>fixed family of types</i>, while allowing new definitions to be added<br>to the collection without affecting modularity;</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:89"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:100"><nobr><span class="ft11">when a definition is <i>variadic</i>, that is, it has a variable number of<br>arguments (see Section 4.2 for an example);</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:89"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:100"><nobr><span class="ft11">to try to avoid <i>type-class trickery</i>, such as multiple-parameter<br>type classes, functional dependencies, overlapping instances or<br>even duplicate instances (just consider a direct encoding of the<br>examples presented in the paper into type classes [30]);</span></nobr></DIV>
<DIV style="position:absolute;top:895;left:89"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:100"><nobr><span class="ft11">to capture some <i>shape invariants</i>, like the ones captured by<br>some nested types or phantom types [29, 18].</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:81"><nobr><span class="ft6"><i><b>Structure:</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:936;left:154"><nobr><span class="ft2">See Figure 1.</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:81"><nobr><span class="ft6"><i><b>Participants:</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:977;left:89"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:100"><nobr><span class="ft11"><i>Structural Cases</i>: a set of datatypes which represent the possible<br>structural cases for the type-indexed function;</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:89"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:100"><nobr><span class="ft5"><i>Typecase</i>: representing the structure of a type-indexed function;</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:89"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:100"><nobr><span class="ft11"><i>Dispatcher</i>: a type class, containing a single function, that is<br>responsible for dispatching a value of one of the structural cases<br>into the corresponding branch of the <i>typecase</i>, based on the type<br>of the value;</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:483"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:495"><nobr><span class="ft11"><i>Type-indexed function</i>: defining the type-indexed function using<br>an instance of the <i>typecase</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:148;left:476"><nobr><span class="ft6"><i><b>Collaborations:</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:168;left:483"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:495"><nobr><span class="ft11">The <i>typecase </i>uses the <i>structural cases </i>in order to create a<br>corresponding number of cases that can be used to define the<br><i>type-indexed function</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:483"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:495"><nobr><span class="ft11">The <i>dispatcher </i>uses the <i>structural cases </i>in order to create<br>a corresponding number of instances that will forward some<br>value of that family of structural cases into the corresponding<br>case in the <i>typecase </i>component.</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:483"><nobr><span class="ft19">·</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:495"><nobr><span class="ft11">The <i>type-indexed function </i>(TIF) uses an instance of the <i>typecase<br></i>in order to implement the desired functionality for the type-<br>indexed function.</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:476"><nobr><span class="ft6"><i><b>Implementation:</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:334;left:585"><nobr><span class="ft2">Typically, a <i>typecase </i>component is created us-</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:476"><nobr><span class="ft11">ing the <i>structural cases</i>. There are three main variations for the im-<br>plementation of a <i>typecase</i>: two of them are based on type classes<br>and the other one on a <i>smart datatype</i>. A smart datatype is a para-<br>metrised type where the type parameters are dependent on the con-<br>structors. The idea of a smart datatype can be represented in various<br>forms: <i>existential </i>datatypes with an equivalence type (à la LIGD),<br><i>GADTs</i>, <i>phantom types</i>, among others.</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:493"><nobr><span class="ft2">The goal of this design pattern is to simulate a closed type-</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:476"><nobr><span class="ft11">indexed function. In general, a type-indexed function <i>f </i>has the<br>following structure.</span></nobr></DIV>
<DIV style="position:absolute;top:499;left:495"><nobr><span class="ft5"><i>f t </i>:: </span></nobr></DIV>
<DIV style="position:absolute;top:496;left:531"><nobr><span class="ft3">| <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:503;left:545"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:555"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:503;left:581"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:499;left:593"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:495"><nobr><span class="ft5"><i>f t</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:510"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:521"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:528"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:538"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:563"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:511;left:575"><nobr><span class="ft3">=  <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:605"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:623"><nobr><span class="ft3">... <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:648"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:511;left:664"><nobr><span class="ft3"> <i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:687"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:522"><nobr><span class="ft24">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:495"><nobr><span class="ft5"><i>f t</i></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:510"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:557;left:521"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:526"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:538"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:562"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:555;left:575"><nobr><span class="ft3">=  <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:605"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:623"><nobr><span class="ft3">... <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:648"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:555;left:664"><nobr><span class="ft3"> <i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:687"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:572;left:493"><nobr><span class="ft2">The type signature tells us that <i>f </i>has one type parameter <i>t </i>and</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:476"><nobr><span class="ft2">optional type parameters <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:592;left:617"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:627"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:592;left:652"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:587;left:661"><nobr><span class="ft2">with the same structure and kind</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:476"><nobr><span class="ft2">as <i>t</i>. The type  of the TIF may depend on <i>t </i>and <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:607;left:744"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:755"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:607;left:780"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:602;left:786"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:493"><nobr><span class="ft2">We should note that this is not the same as having a TIF with</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:476"><nobr><span class="ft11">multiple type arguments. There is no problem, in principle, in hav-<br>ing multiple-parameter type arguments, but it would lead to an ex-<br>plosion in the number of typecases. This would be a generalisation<br>of this design pattern. For simplicity, we will only consider type<br>parameters with the same structure. The usefulness of this simpler<br>case is reflected in applications such as <i>generic map </i>where the in-<br>put and output structures of the generic map function are the same.</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:493"><nobr><span class="ft2">The body of <i>f </i>contains (at least) <i>m </i>branches, providing the</span></nobr></DIV>
<DIV style="position:absolute;top:752;left:476"><nobr><span class="ft12">behaviour of the TIF for each member of the family of types <i>t<br></i>(that is, <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:771;left:528"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:539"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:771;left:545"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:557"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:771;left:584"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:764;left:588"><nobr><span class="ft3">,...,<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:771;left:618"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:767;left:630"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:771;left:636"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:647"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:771;left:673"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:767;left:676"><nobr><span class="ft2">). This family of types cor-</span></nobr></DIV>
<DIV style="position:absolute;top:781;left:476"><nobr><span class="ft11">responds to the <i>structural cases </i>participant of the design pat-<br>tern. For each branch of the definition, we bind possible variables<br><i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:482"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:499"><nobr><span class="ft3">... <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:525"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:809;left:536"><nobr><span class="ft3">,...,<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:568"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:588"><nobr><span class="ft3">... <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:614"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:811;left:633"><nobr><span class="ft2">and define each typecase of <i>f </i>with</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:476"><nobr><span class="ft5"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:831;left:482"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:487"><nobr><span class="ft3">,...,<i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:831;left:519"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:826;left:528"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:493"><nobr><span class="ft2">We now discuss the three main variations of the design pattern.</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:480"><nobr><span class="ft2">1. <i>Smart datatypes: </i>This variation is inspired by the LIGD ap-</span></nobr></DIV>
<DIV style="position:absolute;top:881;left:495"><nobr><span class="ft11">proach. Hindley-Milner typing extended with existential data-<br>types (supported in most Haskell compilers) is enough to en-<br>code it. However, with extensions such as GADTs (supported<br>by GHC 6.4) the encoding becomes much more direct. Unfortu-<br>nately, neither of those extensions conforms to Haskell 98. We<br>will present this version of the design pattern using a GADT<br>syntax for simplicity.</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:513"><nobr><span class="ft2">Using the <i>structural cases </i>given by <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:705"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:714"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:720"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:730"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:755"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:758"><nobr><span class="ft3">,...,<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:788"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:986;left:799"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:804"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:814"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:837"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:986;left:840"><nobr><span class="ft2">,</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:495"><nobr><span class="ft11">we can derive the <i>typecase </i>and <i>dispatcher </i>seen in Figure 1.<br>Since there are <i>m </i>structural cases in a standard instance of the<br>design pattern, one would create <i>m </i>constructors <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:761"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:764"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:770"><nobr><span class="ft3">,...,<i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:802"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:804"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:815"><nobr><span class="ft2">and</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:495"><nobr><span class="ft2">also <i>m </i>instances for <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:1052;left:625"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:632"><nobr><span class="ft2">. TIFs can now be defined using those</span></nobr></DIV>
<DIV style="position:absolute;top:1060;left:495"><nobr><span class="ft11">components, by creating some function <i>f </i>that takes a first argu-<br>ment of type <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:1081;left:587"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:1075;left:598"><nobr><span class="ft2">and returns a value of type .</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">101</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="202005.png" alt="background image">
<DIV style="position:absolute;top:108;left:278"><nobr><span class="ft5"><i>Smart Datatype</i></span></nobr></DIV>
<DIV style="position:absolute;top:108;left:543"><nobr><span class="ft5"><i>Implicit/Explicit Representations</i></span></nobr></DIV>
<DIV style="position:absolute;top:159;left:81"><nobr><span class="ft5"><i>Typecase</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:190"><nobr><span class="ft9"><b>data </b> <i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:130;left:244"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:254"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:130;left:280"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:288"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:144;left:204"><nobr><span class="ft5"><i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:210"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:152;left:213"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:222"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:147;left:239"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:248"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:147;left:255"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:271"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:147;left:274"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:305"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:316"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:325"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:334"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:340"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:351"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:376"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:380"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:395"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:413"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:438"><nobr><span class="ft7">1<i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:161;left:231"><nobr><span class="ft24">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:204"><nobr><span class="ft5"><i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:195;left:210"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:199;left:213"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:191;left:222"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:195;left:239"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:247"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:254"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:269"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:195;left:272"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:192;left:305"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:189;left:316"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:195;left:325"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:191;left:336"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:196;left:341"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:352"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:196;left:375"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:189;left:379"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:196;left:395"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:413"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:196;left:438"><nobr><span class="ft20"><i>mk</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:507"><nobr><span class="ft9"><b>class </b></span></nobr></DIV>
<DIV style="position:absolute;top:123;left:548"><nobr><span class="ft3">(<i>g </i>:: </span></nobr></DIV>
<DIV style="position:absolute;top:123;left:578"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:121;left:583"><nobr><span class="ft8">+1</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:600"><nobr><span class="ft3"> ) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:144;left:520"><nobr><span class="ft5"><i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:544"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:152;left:547"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:556"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:147;left:573"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:582"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:147;left:589"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:605"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:147;left:608"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:639"><nobr><span class="ft5"><i>g</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:649"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:658"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:666"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:673"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:684"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:709"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:713"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:727"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:746"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:771"><nobr><span class="ft7">1<i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:161;left:547"><nobr><span class="ft24">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:520"><nobr><span class="ft5"><i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:195;left:544"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:199;left:547"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:191;left:556"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:195;left:573"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:581"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:588"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:603"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:195;left:606"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:639"><nobr><span class="ft5"><i>g</i></span></nobr></DIV>
<DIV style="position:absolute;top:189;left:649"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:195;left:658"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:191;left:669"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:196;left:674"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:684"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:196;left:708"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:189;left:712"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:196;left:727"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:746"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:196;left:771"><nobr><span class="ft20"><i>mk</i></span></nobr></DIV>
<DIV style="position:absolute;top:288;left:81"><nobr><span class="ft5"><i>Dispatcher</i></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:190"><nobr><span class="ft9"><b>class </b><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:242"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:252"><nobr><span class="ft5"><i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:266"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:276"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:302"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:311"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:228;left:204"><nobr><span class="ft5"><i>rep </i>:: <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:233;left:255"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:228;left:265"><nobr><span class="ft5"><i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:233;left:278"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:289"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:233;left:314"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:190"><nobr><span class="ft9"><b>instance </b></span></nobr></DIV>
<DIV style="position:absolute;top:252;left:251"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:258;left:260"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:267"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:258;left:283"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:252;left:286"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:294"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:267;left:204"><nobr><span class="ft5"><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:272;left:226"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:236"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:245"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:254"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:260"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:271"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:296"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:300"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:315"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:333"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:358"><nobr><span class="ft7">1<i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:267;left:372"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:217"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:282;left:238"><nobr><span class="ft3">= <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:289;left:257"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:292;left:260"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:268"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:282;left:286"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:301;left:217"><nobr><span class="ft23">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:190"><nobr><span class="ft9"><b>instance </b></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:251"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:338;left:259"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:266"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:338;left:281"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:284"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:292"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:204"><nobr><span class="ft5"><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:226"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:345;left:236"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:245"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:256"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:261"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:272"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:296"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:345;left:299"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:315"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:333"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:358"><nobr><span class="ft20"><i>mk</i></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:375"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:365;left:217"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:238"><nobr><span class="ft3">= <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:370;left:257"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:373;left:260"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:365;left:270"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:287"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:507"><nobr><span class="ft9"><b>class </b><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:559"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:569"><nobr><span class="ft5"><i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:582"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:593"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:618"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:627"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:228;left:520"><nobr><span class="ft5"><i>rep </i>::  <i>g</i></span></nobr></DIV>
<DIV style="position:absolute;top:225;left:570"><nobr><span class="ft3"> <i>g t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:233;left:609"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:620"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:233;left:645"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:507"><nobr><span class="ft9"><b>instance </b></span></nobr></DIV>
<DIV style="position:absolute;top:252;left:567"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:258;left:576"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:583"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:258;left:599"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:252;left:602"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:610"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:267;left:520"><nobr><span class="ft5"><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:272;left:542"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:552"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:561"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:570"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:577"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:587"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:613"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:616"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:631"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:649"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:674"><nobr><span class="ft7">1<i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:267;left:691"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:552"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:282;left:573"><nobr><span class="ft3">= <i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:289;left:610"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:292;left:613"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:282;left:618"><nobr><span class="ft3">{<i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:282;left:643"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:282;left:648"><nobr><span class="ft3">}</span></nobr></DIV>
<DIV style="position:absolute;top:301;left:534"><nobr><span class="ft23">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:507"><nobr><span class="ft9"><b>instance </b></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:567"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:338;left:575"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:582"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:338;left:597"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:600"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:608"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:520"><nobr><span class="ft5"><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:542"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:345;left:552"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:561"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:572"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:578"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:588"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:612"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:345;left:616"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:631"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:649"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:674"><nobr><span class="ft20"><i>mk</i></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:691"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:365;left:552"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:573"><nobr><span class="ft3">= <i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:370;left:610"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:373;left:613"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:620"><nobr><span class="ft3">{<i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:645"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:650"><nobr><span class="ft3">}</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:81"><nobr><span class="ft12"><i>Type-indexed<br>function</i></span></nobr></DIV>
<DIV style="position:absolute;top:390;left:190"><nobr><span class="ft5"><i>f </i>::  <i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:395;left:232"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:243"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:395;left:268"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:387;left:284"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:408;left:190"><nobr><span class="ft5"><i>f</i></span></nobr></DIV>
<DIV style="position:absolute;top:405;left:199"><nobr><span class="ft3">(<i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:412;left:210"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:213"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:223"><nobr><span class="ft5"><i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:412;left:228"><nobr><span class="ft20"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:234"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:243"><nobr><span class="ft3">... <i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:412;left:267"><nobr><span class="ft20"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:273"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:405;left:276"><nobr><span class="ft3">) =  <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:413;left:314"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:332"><nobr><span class="ft3">... <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:413;left:357"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:405;left:373"><nobr><span class="ft3"> [[<i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:413;left:402"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:408"><nobr><span class="ft3">]]</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:217"><nobr><span class="ft23">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:190"><nobr><span class="ft5"><i>f</i></span></nobr></DIV>
<DIV style="position:absolute;top:450;left:199"><nobr><span class="ft3">(<i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:210"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:461;left:213"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:453;left:223"><nobr><span class="ft5"><i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:228"><nobr><span class="ft20"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:461;left:233"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:243"><nobr><span class="ft3">... <i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:267"><nobr><span class="ft20"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:461;left:271"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:450;left:275"><nobr><span class="ft3">) =  <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:314"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:332"><nobr><span class="ft3">... <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:357"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:450;left:373"><nobr><span class="ft3"> [[<i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:402"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:450;left:410"><nobr><span class="ft3">]]</span></nobr></DIV>
<DIV style="position:absolute;top:474;left:190"><nobr><span class="ft5"><i>f </i>:: <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:479;left:233"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:474;left:243"><nobr><span class="ft5"><i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:479;left:257"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:267"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:479;left:293"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:471;left:301"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:492;left:190"><nobr><span class="ft5"><i>f</i></span></nobr></DIV>
<DIV style="position:absolute;top:490;left:203"><nobr><span class="ft3">= <i>f rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:384;left:507"><nobr><span class="ft9"><b>newtype </b><i>F t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:389;left:583"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:593"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:389;left:619"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:381;left:627"><nobr><span class="ft3">= <i>F</i>{<i>f </i>:: }</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:507"><nobr><span class="ft5"><i>f </i>:: <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:407;left:549"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:402;left:559"><nobr><span class="ft5"><i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:407;left:573"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:583"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:407;left:609"><nobr><span class="ft20"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:400;left:617"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:419;left:507"><nobr><span class="ft5"><i>f</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:519"><nobr><span class="ft3">= <i>f rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:435;left:507"><nobr><span class="ft9"><b>instance </b><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:440;left:579"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:435;left:589"><nobr><span class="ft5"><i>F </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:452;left:520"><nobr><span class="ft5"><i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:544"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:547"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:554"><nobr><span class="ft3">{<i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:567"><nobr><span class="ft20"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:572"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:582"><nobr><span class="ft3">... <i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:606"><nobr><span class="ft20"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:611"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:616"><nobr><span class="ft3">} =  <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:655"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:673"><nobr><span class="ft3">... <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:698"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:714"><nobr><span class="ft3"> [[<i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:743"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:749"><nobr><span class="ft3">]]</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:534"><nobr><span class="ft23">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:520"><nobr><span class="ft5"><i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:544"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:547"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:495;left:554"><nobr><span class="ft3">{<i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:567"><nobr><span class="ft20"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:571"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:495;left:582"><nobr><span class="ft3">... <i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:606"><nobr><span class="ft20"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:610"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:495;left:615"><nobr><span class="ft3">} =  <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:503;left:655"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:495;left:673"><nobr><span class="ft3">... <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:698"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:495;left:714"><nobr><span class="ft3"> [[<i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:743"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:495;left:751"><nobr><span class="ft3">]]</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:307"><nobr><span class="ft9"><b>Figure 1. </b>The structure of the <i>TypeCase </i>design pattern.</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:118"><nobr><span class="ft2">The <i>dispatcher </i>component is optional in this variation. The</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:100"><nobr><span class="ft11">TIFs created with this variation are fully closed to extension;<br>no customisation is possible. This means that if we want to add<br>extra functionality we need to modify the smart datatype (and<br>the dispatcher if we have one). However, TIFs that call other<br>TIFs are trivial to achieve; there is no need for tupling.</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:85"><nobr><span class="ft2">2. <i>Implicit representations: </i>The implicit representation version</span></nobr></DIV>
<DIV style="position:absolute;top:678;left:100"><nobr><span class="ft11">of the design pattern is inspired by GM1. Perhaps surprisingly,<br>some implementations of this instance require only Haskell 98.<br>However, if we need to have structurally-dependent variables,<br>then we also require multiple-parameter type classes.</span></nobr></DIV>
<DIV style="position:absolute;top:738;left:118"><nobr><span class="ft2">Proceeding in a similar fashion to the <i>smart datatype </i>ap-</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:100"><nobr><span class="ft11">proach, we use the <i>structural cases </i>to derive the <i>typecase </i>and<br><i>dispatcher </i>seen in Figure 1. Again, because we have <i>m </i>struc-<br>tural cases, we create <i>m </i>functions <i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:787;left:314"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:791;left:317"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:323"><nobr><span class="ft3">,...,<i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:787;left:373"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:791;left:375"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:783;left:387"><nobr><span class="ft2">and <i>m </i>in-</span></nobr></DIV>
<DIV style="position:absolute;top:798;left:100"><nobr><span class="ft2">stances of <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:804;left:178"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:798;left:185"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:118"><nobr><span class="ft2">The <i>dispatcher </i>is not an optional component: it always</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:100"><nobr><span class="ft11">needs to be defined in this variation. As with the smart datatype<br>variation, TIFs defined in this way are fully closed to extension,<br>and calls to other TIFs are trivial.</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:85"><nobr><span class="ft2">3. <i>Explicit representations: </i>The explicit representation variation</span></nobr></DIV>
<DIV style="position:absolute;top:890;left:100"><nobr><span class="ft12">of the design pattern is inspired by GM2. Like the implicit<br>approach, Haskell 98 is enough to handle the simpler forms<br>(one type parameter). However, if we discard the optional <i>dis-<br>patcher</i>, then Haskell 98 can handle all forms.</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:118"><nobr><span class="ft2">Using the <i>structural cases </i>to derive the <i>typecase </i>and <i>dis-</i></span></nobr></DIV>
<DIV style="position:absolute;top:965;left:100"><nobr><span class="ft11"><i>patcher </i>seen in Figure 1, we would obtain a very similar struc-<br>ture to the implicit representation version. The most noticeable<br>difference is that, with the explicit representation, the definition<br>of <i>rep </i>needs to provide the corresponding <i>case </i>function with<br>the representations for each of its type parameters. The second<br>difference is that , which corresponds to the representations<br>of the type parameters, reflects the fact that we are providing<br>explicit representations. Thus,  corresponds in this instance</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:495"><nobr><span class="ft11">to explicit arguments of the function, while with the implicit<br>representation it corresponds to (implicitly passed) type class<br>constraints. The dispatcher is an optional component.</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:513"><nobr><span class="ft2">Variations of this instance of the design pattern can also be</span></nobr></DIV>
<DIV style="position:absolute;top:630;left:495"><nobr><span class="ft11">found in the literature [10, 37], as described in Section 4.2. TIFs<br>defined in this fashion are not fully closed to extension: it is pos-<br>sible to override default behaviour. However, the extra flexibil-<br>ity comes at a cost: recursive calls to other TIFs are not possible.<br>One common solution for this problem is to <i>tuple </i>together into<br>a record the mutually-dependent functions. Another possibility<br>would be to have a notion of dependencies: if a TIF <i>f </i>requires<br>calls to another TIF <i>g</i>, then the record that defines <i>f </i>has a field<br>that is an instance of <i>g</i>. Although this work is quite tedious, Löh<br>[26] shows how a type system can lighten the burden.</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:513"><nobr><span class="ft2">An associated problem for TIFs in this setting is the issue</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:495"><nobr><span class="ft11">of <i>composability</i>. If two TIFs are defined using different in-<br>stances (this is, they are not tupled together), then we cannot, in<br>a straightforward manner, use the same representation to com-<br>pose them. To illustrate the problem, consider:</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:514"><nobr><span class="ft9"><b>newtype </b><i>F v</i></span></nobr></DIV>
<DIV style="position:absolute;top:859;left:583"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:593"><nobr><span class="ft3">... <i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:859;left:618"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:852;left:628"><nobr><span class="ft3">= <i>F</i>{<i>f </i>:: }</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:514"><nobr><span class="ft9"><b>newtype </b><i>G v</i></span></nobr></DIV>
<DIV style="position:absolute;top:875;left:584"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:594"><nobr><span class="ft3">... <i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:874;left:619"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:868;left:628"><nobr><span class="ft3">= <i>G</i>{<i>g </i>:: }</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:514"><nobr><span class="ft9"><b>instance </b><i>Generic F </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:883;left:662"><nobr><span class="ft3">...</span></nobr></DIV>
<DIV style="position:absolute;top:902;left:514"><nobr><span class="ft9"><b>instance </b><i>Generic G </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:899;left:663"><nobr><span class="ft3">...</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:495"><nobr><span class="ft11">Now let us suppose that we define a <i>type-indexed abstraction<br></i>(that is, a function that uses one or more TIFs and is not defined<br>over the structure of types):</span></nobr></DIV>
<DIV style="position:absolute;top:961;left:514"><nobr><span class="ft5"><i>h rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:959;left:545"><nobr><span class="ft3">= ... <i>f rep </i>... <i>g rep </i>...</span></nobr></DIV>
<DIV style="position:absolute;top:976;left:495"><nobr><span class="ft11">The interpretation of this definition as a type-indexed function<br>could be thought of as: <i>h a</i></span></nobr></DIV>
<DIV style="position:absolute;top:988;left:654"><nobr><span class="ft3">= ... <i>f a </i>... <i>g a </i>.... While this</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:495"><nobr><span class="ft11">is a perfectly reasonable interpretation, in practice <i>f </i>requires<br>inconsistent types <i>F v</i></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:616"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:1018;left:627"><nobr><span class="ft3">... <i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:653"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:663"><nobr><span class="ft2">and <i>G v</i></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:707"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:1018;left:718"><nobr><span class="ft3">... <i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:744"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:755"><nobr><span class="ft2">for <i>rep</i>: <i>F </i>and</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:495"><nobr><span class="ft12"><i>G </i>are two different type constructors, so in a Hindley-Milner<br>type system, unification obviously fails. However, <i>F </i>and <i>G<br></i>do have something in common. In particular, they are both</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">102</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="202006.png" alt="background image">
<DIV style="position:absolute;top:110;left:100"><nobr><span class="ft11">instances of <i>Generic</i>. So, in Haskell extended with higher-<br>order polymorphism, we can capture this relation with a rank-<br>2 type, thus providing a possible solution for the problem of<br>composability.</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:120"><nobr><span class="ft5"><i>h </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:138"><nobr><span class="ft3">( <i>g</i>. <i>Generic g </i> <i>g v</i></span></nobr></DIV>
<DIV style="position:absolute;top:174;left:255"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:266"><nobr><span class="ft3">... <i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:174;left:291"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:167;left:296"><nobr><span class="ft3">)  </span></nobr></DIV>
<DIV style="position:absolute;top:185;left:120"><nobr><span class="ft5"><i>h rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:183;left:150"><nobr><span class="ft3">= ... <i>f rep </i>... <i>g rep </i>...</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:99"><nobr><span class="ft2">We should note that even though we have presented three main</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:81"><nobr><span class="ft11">variations of the design pattern, the concept of a design pattern is,<br>by itself, quite informal and thus prone to different interpretations.<br>For instance, as we will see later, applications of the pattern (such<br>as GM) can have more type cases than there are datatype variants,<br>because some cases overlap. It is important to note that, depending<br>on the context of a problem, a design pattern can be adapted to<br>better fit that problem.</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:81"><nobr><span class="ft4"><b>4. Applications</b></span></nobr></DIV>
<DIV style="position:absolute;top:361;left:81"><nobr><span class="ft11">We present two applications of the design pattern. In Section 4.1,<br>still within the context of generic programming, we show how<br>one can build a library inspired by PolyP [21, 22] but working in<br>Haskell 98. In Section 4.2, we present a very flexible version of a<br>C-style <i>printf </i>function.</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:81"><nobr><span class="ft9"><b>4.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:111"><nobr><span class="ft9"><b>Light PolyP</b></span></nobr></DIV>
<DIV style="position:absolute;top:467;left:81"><nobr><span class="ft11">It probably comes as no surprise to the reader that the technique<br>introduced in GM and LIGD can be applied to other generic pro-<br>gramming approaches as well. <i>PolyP </i>was one of the first attempts to<br>produce a generic programming language. It is a simpler language<br>than Generic Haskell, working in a much more restricted family<br>of datatypes, namely one-parameter regular types. But this restric-<br>tion allows stronger properties to be stated: its simplicity and strong<br>theoretical background make it an appropriate language for teach-<br>ing both the theory [3] and practice of generic programming. Our<br>proposal <i>Light PolyP </i>encourages this, because no external PolyP<br>compiler is required (although one might still be desirable, for a<br>more convenient syntax).</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:99"><nobr><span class="ft2">Norell [30] shows how to use the Haskell type class system (ex-</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:81"><nobr><span class="ft11">tended with multiple-parameter type classes and functional depend-<br>encies) to obtain first-class PolyP generic functions in Haskell. In<br>this section, we will present a "lighter" version of PolyP, requir-<br>ing only Haskell 98 (without extensions such as multiple-parameter<br>type classes and functional dependencies) but with the same ex-<br>pressive power.</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:99"><nobr><span class="ft2">Instead of using sums of products like LAGP or Generic</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:81"><nobr><span class="ft11">Haskell, PolyP uses lifted <i>pattern functors </i>as <i>structural cases</i>. The<br>pattern functors <i>Empty</i>, <i>Plus </i>and <i>Prod </i>have counterparts in LAGP.<br>The pattern functors <i>Rep </i>and <i>Par </i>correspond respectively to the re-<br>cursive argument and the parameter of the unary regular datatype.<br>The pattern functor <i>Const t </i>for some type <i>t </i>represents the constant<br>functor, and <i>Comp </i>handles the composition of functors required<br>for regular types.</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:100"><nobr><span class="ft9"><b>data </b><i>Empty p r</i></span></nobr></DIV>
<DIV style="position:absolute;top:867;left:225"><nobr><span class="ft3">= <i>Empty</i></span></nobr></DIV>
<DIV style="position:absolute;top:886;left:100"><nobr><span class="ft9"><b>data </b><i>Plus g h p r</i></span></nobr></DIV>
<DIV style="position:absolute;top:883;left:225"><nobr><span class="ft3">= <i>Inl </i>(<i>g p r</i>) | <i>Inr </i>(<i>h p r</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:902;left:100"><nobr><span class="ft9"><b>data </b><i>Prod g h p r</i></span></nobr></DIV>
<DIV style="position:absolute;top:899;left:225"><nobr><span class="ft3">= <i>Prod </i>(<i>g p r</i>) (<i>h p r</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:100"><nobr><span class="ft9"><b>newtype </b><i>Par p r</i></span></nobr></DIV>
<DIV style="position:absolute;top:914;left:224"><nobr><span class="ft3">= <i>Par</i>{<i>unPar </i>::<i>p</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:100"><nobr><span class="ft9"><b>newtype </b><i>Rec p r</i></span></nobr></DIV>
<DIV style="position:absolute;top:930;left:224"><nobr><span class="ft3">= <i>Rec</i>{<i>unRec </i>:: <i>r</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:100"><nobr><span class="ft9"><b>newtype </b><i>Comp d h p r</i></span></nobr></DIV>
<DIV style="position:absolute;top:946;left:225"><nobr><span class="ft3">= <i>Comp</i>{<i>unComp </i>:: <i>d </i>(<i>h p r</i>)}</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:100"><nobr><span class="ft9"><b>newtype </b><i>Const t p r</i></span></nobr></DIV>
<DIV style="position:absolute;top:961;left:225"><nobr><span class="ft3">= <i>Const</i>{<i>unConst </i>:: <i>t</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:99"><nobr><span class="ft2">The equivalence type is used to establish the isomorphism</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:81"><nobr><span class="ft11">between a regular datatype and its top-level structure. The em-<br>bedding/projection functions are traditionally called <i>inn </i>and <i>out</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:100"><nobr><span class="ft9"><b>data </b><i>Iso a b</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:168"><nobr><span class="ft3">= <i>Iso</i>{<i>inn </i>:: <i>a </i> <i>b</i>,<i>out </i>:: <i>b </i> <i>a</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:1044;left:100"><nobr><span class="ft5"><i>listIso</i></span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:136"><nobr><span class="ft3">= <i>Iso inL outL</i></span></nobr></DIV>
<DIV style="position:absolute;top:1060;left:114"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:1075;left:127"><nobr><span class="ft5"><i>inL</i></span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:155"><nobr><span class="ft3">(<i>Inl Empty</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:315"><nobr><span class="ft3">= [ ]</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:522"><nobr><span class="ft5"><i>inL</i></span></nobr></DIV>
<DIV style="position:absolute;top:107;left:549"><nobr><span class="ft3">(<i>Inr </i>(<i>Prod </i>(<i>Par x</i>) (<i>Rec xs</i>))) = <i>x </i>: <i>xs</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:522"><nobr><span class="ft5"><i>outL</i></span></nobr></DIV>
<DIV style="position:absolute;top:123;left:550"><nobr><span class="ft3">[ ]</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:588"><nobr><span class="ft3">= <i>Inl Empty</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:522"><nobr><span class="ft5"><i>outL</i></span></nobr></DIV>
<DIV style="position:absolute;top:139;left:550"><nobr><span class="ft3">(<i>x </i>: <i>xs</i>) = <i>Inr </i>(<i>Prod </i>(<i>Par x</i>) (<i>Rec xs</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:493"><nobr><span class="ft2">In PolyP no generic customisation is allowed, thus we can use</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:476"><nobr><span class="ft11">an implicit representation version of the design pattern and con-<br>sequently, it is possible for one generic function to use other generic<br>functions in its definition. The <i>typecase </i>component corresponds to:</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:495"><nobr><span class="ft9"><b>class </b><i>Generic f </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:232;left:508"><nobr><span class="ft5"><i>empty</i></span></nobr></DIV>
<DIV style="position:absolute;top:232;left:556"><nobr><span class="ft2">:: <i>f Empty</i></span></nobr></DIV>
<DIV style="position:absolute;top:247;left:508"><nobr><span class="ft5"><i>plus</i></span></nobr></DIV>
<DIV style="position:absolute;top:247;left:556"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:565"><nobr><span class="ft3">(<i>Rep g</i>,<i>Rep h</i>)  <i>f </i>(<i>Plus g h</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:508"><nobr><span class="ft5"><i>prod</i></span></nobr></DIV>
<DIV style="position:absolute;top:263;left:556"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:260;left:566"><nobr><span class="ft3">(<i>Rep g</i>,<i>Rep h</i>)  <i>f </i>(<i>Prod g h</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:508"><nobr><span class="ft5"><i>par</i></span></nobr></DIV>
<DIV style="position:absolute;top:279;left:556"><nobr><span class="ft2">:: <i>f Par</i></span></nobr></DIV>
<DIV style="position:absolute;top:295;left:508"><nobr><span class="ft5"><i>rec</i></span></nobr></DIV>
<DIV style="position:absolute;top:295;left:556"><nobr><span class="ft2">:: <i>f Rec</i></span></nobr></DIV>
<DIV style="position:absolute;top:310;left:508"><nobr><span class="ft5"><i>comp</i></span></nobr></DIV>
<DIV style="position:absolute;top:310;left:556"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:565"><nobr><span class="ft3">(<i>Functor d</i>,<i>Rep h</i>)  <i>f </i>(<i>Comp d h</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:508"><nobr><span class="ft5"><i>constant </i>:: <i>f</i></span></nobr></DIV>
<DIV style="position:absolute;top:323;left:574"><nobr><span class="ft3">(<i>Const t</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:493"><nobr><span class="ft2">The <i>dispatcher </i>simply selects the corresponding case based on</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:476"><nobr><span class="ft2">the type of the argument of the generic function <i>g</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:495"><nobr><span class="ft9"><b>class </b><i>Rep g </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:386;left:508"><nobr><span class="ft5"><i>rep </i>:: <i>Generic f</i></span></nobr></DIV>
<DIV style="position:absolute;top:384;left:592"><nobr><span class="ft3"> <i>f g</i></span></nobr></DIV>
<DIV style="position:absolute;top:402;left:495"><nobr><span class="ft9"><b>instance </b><i>Rep Empty </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:418;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:415;left:529"><nobr><span class="ft3">= <i>empty</i></span></nobr></DIV>
<DIV style="position:absolute;top:434;left:495"><nobr><span class="ft9"><b>instance</b></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:545"><nobr><span class="ft3">(<i>Rep g</i>,<i>Rep h</i>)  <i>Rep </i>(<i>Plus g h</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:529"><nobr><span class="ft3">= <i>plus</i></span></nobr></DIV>
<DIV style="position:absolute;top:465;left:495"><nobr><span class="ft9"><b>instance</b></span></nobr></DIV>
<DIV style="position:absolute;top:462;left:545"><nobr><span class="ft3">(<i>Rep g</i>,<i>Rep h</i>)  <i>Rep </i>(<i>Prod g h</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:481;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:478;left:529"><nobr><span class="ft3">= <i>prod</i></span></nobr></DIV>
<DIV style="position:absolute;top:496;left:495"><nobr><span class="ft9"><b>instance </b><i>Rep Par </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:512;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:509;left:529"><nobr><span class="ft3">= <i>par</i></span></nobr></DIV>
<DIV style="position:absolute;top:528;left:495"><nobr><span class="ft9"><b>instance </b><i>Rep Rec </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:543;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:541;left:529"><nobr><span class="ft3">= <i>rec</i></span></nobr></DIV>
<DIV style="position:absolute;top:559;left:495"><nobr><span class="ft9"><b>instance</b></span></nobr></DIV>
<DIV style="position:absolute;top:556;left:545"><nobr><span class="ft3">(<i>Functor d</i>,<i>Rep h</i>)  <i>Rep </i>(<i>Comp d h</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:575;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:572;left:529"><nobr><span class="ft3">= <i>comp</i></span></nobr></DIV>
<DIV style="position:absolute;top:590;left:495"><nobr><span class="ft9"><b>instance </b><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:569"><nobr><span class="ft3">(<i>Const t</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:603;left:529"><nobr><span class="ft3">= <i>constant</i></span></nobr></DIV>
<DIV style="position:absolute;top:621;left:493"><nobr><span class="ft2">Like GM, defining a generic function is a matter of declaring</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:476"><nobr><span class="ft11">a record with a single field, a function of the appropriate type. As<br>an example, we could define <i>fmap2</i>, the map operation for binary<br>functors, as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:495"><nobr><span class="ft9"><b>newtype </b><i>FMap2 a b c d f</i></span></nobr></DIV>
<DIV style="position:absolute;top:678;left:636"><nobr><span class="ft3">= <i>FMap2</i>{</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:508"><nobr><span class="ft5"><i>appFMap2 </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:580"><nobr><span class="ft3">(<i>a </i> <i>c</i>)  (<i>b </i> <i>d</i>)  <i>f a b </i> <i>f c d</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:495"><nobr><span class="ft9"><b>instance </b><i>Generic</i></span></nobr></DIV>
<DIV style="position:absolute;top:714;left:591"><nobr><span class="ft3">(<i>FMap2 a b c d</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:732;left:508"><nobr><span class="ft5"><i>empty</i></span></nobr></DIV>
<DIV style="position:absolute;top:729;left:557"><nobr><span class="ft3">= <i>FMap2 </i>(</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:658"><nobr><span class="ft3"> <i>Empty</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:508"><nobr><span class="ft5"><i>plus</i></span></nobr></DIV>
<DIV style="position:absolute;top:745;left:557"><nobr><span class="ft3">= <i>FMap2 </i>(<i>f g t </i> <b>case </b><i>t </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:763;left:584"><nobr><span class="ft5"><i>Inl x</i></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:632"><nobr><span class="ft3"> <i>Inl </i>(<i>fmap2 f g x</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:584"><nobr><span class="ft5"><i>Inr y</i></span></nobr></DIV>
<DIV style="position:absolute;top:777;left:632"><nobr><span class="ft3"> <i>Inr </i>(<i>fmap2 f g y</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:508"><nobr><span class="ft5"><i>prod</i></span></nobr></DIV>
<DIV style="position:absolute;top:792;left:557"><nobr><span class="ft3">= <i>FMap2 </i>(<i>f g t </i> <b>case </b><i>t </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:811;left:584"><nobr><span class="ft5"><i>Prod x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:808;left:632"><nobr><span class="ft3"> <i>Prod </i>(<i>fmap2 f g x</i>) (<i>fmap2 f g y</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:508"><nobr><span class="ft5"><i>par</i></span></nobr></DIV>
<DIV style="position:absolute;top:824;left:557"><nobr><span class="ft3">= <i>FMap2 </i>(<i>f g </i>(<i>Par t</i>)  <i>Par </i>(<i>f t</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:508"><nobr><span class="ft5"><i>rec</i></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:557"><nobr><span class="ft3">= <i>FMap2 </i>(<i>f g </i>(<i>Rec t</i>)  <i>Rec </i>(<i>g t</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:508"><nobr><span class="ft5"><i>comp</i></span></nobr></DIV>
<DIV style="position:absolute;top:855;left:557"><nobr><span class="ft3">= <i>FMap2 </i>(<i>f g </i>(<i>Comp t</i>) </span></nobr></DIV>
<DIV style="position:absolute;top:873;left:584"><nobr><span class="ft5"><i>Comp</i></span></nobr></DIV>
<DIV style="position:absolute;top:871;left:619"><nobr><span class="ft3">(<i>fmap </i>(<i>fmap2 f g</i>) <i>t</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:508"><nobr><span class="ft5"><i>constant</i></span></nobr></DIV>
<DIV style="position:absolute;top:886;left:557"><nobr><span class="ft3">= <i>FMap2 </i>(</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:647"><nobr><span class="ft3">(<i>Const t</i>)  (<i>Const t</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:495"><nobr><span class="ft5"><i>fmap2 </i>:: <i>Rep f</i></span></nobr></DIV>
<DIV style="position:absolute;top:906;left:572"><nobr><span class="ft3"> (<i>a </i> <i>c</i>)  (<i>b </i> <i>d</i>)  <i>f a b </i> <i>f c d</i></span></nobr></DIV>
<DIV style="position:absolute;top:925;left:495"><nobr><span class="ft5"><i>fmap2</i></span></nobr></DIV>
<DIV style="position:absolute;top:922;left:532"><nobr><span class="ft3">= <i>appFMap2 rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:940;left:493"><nobr><span class="ft2">With <i>fmap2 </i>it is now possible to define several widely-applicable</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:476"><nobr><span class="ft12">recursion operators [28, 14] using PolyP. For example, the <i>cata-<br>morphism </i>operator could be defined as:</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:495"><nobr><span class="ft5"><i>cata iso f</i></span></nobr></DIV>
<DIV style="position:absolute;top:982;left:549"><nobr><span class="ft3">= <i>f </i> <i>fmap2 id </i>(<i>cata iso f </i>)  <i>out iso</i></span></nobr></DIV>
<DIV style="position:absolute;top:999;left:493"><nobr><span class="ft2">Note that one must give explicitly the isomorphism that con-</span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:476"><nobr><span class="ft11">verts between the datatype and its representation. This contrasts<br>with the original PolyP approach, in which that translation is in-<br>ferred. This is the common trade-off of brevity for flexibility; being<br>forced to state the isomorphism allows the programmer to choose a<br>different one, giving something analogous to Wadler's ideas about</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">103</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="202007.png" alt="background image">
<DIV style="position:absolute;top:110;left:81"><nobr><span class="ft11"><i>views </i>[34]. We might say that this style of generic programming is<br><i>isomorphism-parametrised </i>instead of <i>datatype-parametrised</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:99"><nobr><span class="ft2">In the original PolyP, the <i>polytypic </i>construct provides a conveni-</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:81"><nobr><span class="ft11">ent syntax for encoding generic functions. Furthermore, combinat-<br>ors for pointfree programming may be provided, making generic<br>definitions even more compact. These combinators are just normal<br>Haskell functions, and so there is no problem in implementing them<br>in pure Haskell; but to keep the example short, we have stuck with<br>pointwise definitions.</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:99"><nobr><span class="ft2">The advantages of this translation when compared with the one</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:81"><nobr><span class="ft12">proposed in [30] are that it requires only Haskell 98, and that the<br>types of the generic functions are much closer to what one would<br>expect. In Norell's translation, the type class constraints posed<br>some problems because both the two-parameter class <i>FunctorOf<br></i>and the classes for the generic functions propagated throughout<br>the code. With the Light PolyP approach, only instances of <i>Rep<br></i>propagate, leading usually to just one type class constraint.</span></nobr></DIV>
<DIV style="position:absolute;top:374;left:81"><nobr><span class="ft9"><b>4.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:374;left:111"><nobr><span class="ft9"><b>Printf</b></span></nobr></DIV>
<DIV style="position:absolute;top:395;left:81"><nobr><span class="ft11">The C-style <i>printf </i>function, which takes a variable number of<br>parameters, has always been a challenge for programmers using<br>strongly and statically typed languages. The problem with <i>printf </i>is<br>that, in its true essence, it requires dependent types. This happens<br>because the value of the format string determines the type of the<br>function. However, it has been shown by Danvy [10] that by chan-<br>ging the representation of the control string it is possible to encode<br><i>printf </i>in any language supporting a standard Hindley-Milner type<br>system.</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:81"><nobr><span class="ft9"><b>4.2.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:539;left:121"><nobr><span class="ft9"><b>A solution using explicit representations</b></span></nobr></DIV>
<DIV style="position:absolute;top:560;left:81"><nobr><span class="ft11">In this section, we will demonstrate that Danvy's solution is another<br>instance of the TypeCase design pattern, using an explicit repres-<br>entation. Furthermore, we will show a new use of the <i>printf </i>func-<br>tion by making use of the fact that we can (in some cases) infer the<br>format string.</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:99"><nobr><span class="ft2">Danvy's original solution had the following combinators:</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:100"><nobr><span class="ft5"><i>lit</i></span></nobr></DIV>
<DIV style="position:absolute;top:649;left:146"><nobr><span class="ft2">:: <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:647;left:194"><nobr><span class="ft3"> (<i>String </i> <i>a</i>)  <i>String </i> <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:665;left:100"><nobr><span class="ft5"><i>lit x k s</i></span></nobr></DIV>
<DIV style="position:absolute;top:662;left:144"><nobr><span class="ft3">= <i>k </i>(<i>s </i>++ <i>x</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:100"><nobr><span class="ft5"><i>eol</i></span></nobr></DIV>
<DIV style="position:absolute;top:685;left:146"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:158"><nobr><span class="ft3">(<i>String </i> <i>a</i>)  <i>String </i> <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:701;left:100"><nobr><span class="ft5"><i>eol k s</i></span></nobr></DIV>
<DIV style="position:absolute;top:698;left:144"><nobr><span class="ft3">= <i>k </i>(<i>s </i>++ &quot;\n&quot;)</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:100"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:721;left:146"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:718;left:158"><nobr><span class="ft3">(<i>String </i> <i>a</i>)  <i>String </i> <i>Int </i> <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:736;left:100"><nobr><span class="ft5"><i>int k s x</i></span></nobr></DIV>
<DIV style="position:absolute;top:734;left:144"><nobr><span class="ft3">= <i>k </i>(<i>s </i>++ <i>show x</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:100"><nobr><span class="ft5"><i>str</i></span></nobr></DIV>
<DIV style="position:absolute;top:756;left:146"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:158"><nobr><span class="ft3">(<i>String </i> <i>a</i>)  <i>String </i> <i>String </i> <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:772;left:100"><nobr><span class="ft5"><i>str k s x</i></span></nobr></DIV>
<DIV style="position:absolute;top:769;left:144"><nobr><span class="ft3">= <i>k </i>(<i>s </i>++ <i>x</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:100"><nobr><span class="ft5"><i>eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:792;left:146"><nobr><span class="ft2">:: <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:789;left:194"><nobr><span class="ft3"> <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:808;left:100"><nobr><span class="ft5"><i>eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:145"><nobr><span class="ft3">= <i>id</i></span></nobr></DIV>
<DIV style="position:absolute;top:823;left:99"><nobr><span class="ft2">If we capture all the occurrences of the form <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:820;left:382"><nobr><span class="ft3"> <i>t </i>with a</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:81"><nobr><span class="ft11">newtype <i>Printf </i>, and modify the definitions in order to reflect this<br>newtype, we obtain the following code.</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:100"><nobr><span class="ft9"><b>newtype </b><i>Printf t</i></span></nobr></DIV>
<DIV style="position:absolute;top:865;left:194"><nobr><span class="ft3">= <i>Printf </i>{<i>printfApp </i>:: <i>String </i> <i>t</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:100"><nobr><span class="ft5"><i>lit</i></span></nobr></DIV>
<DIV style="position:absolute;top:887;left:135"><nobr><span class="ft2">:: <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:885;left:182"><nobr><span class="ft3"> <i>Printf a </i> <i>Printf a</i></span></nobr></DIV>
<DIV style="position:absolute;top:903;left:100"><nobr><span class="ft5"><i>lit x k</i></span></nobr></DIV>
<DIV style="position:absolute;top:900;left:133"><nobr><span class="ft3">= <i>Printf </i>(<i>s </i> <i>printfApp k </i>(<i>s </i>++ <i>x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:100"><nobr><span class="ft5"><i>eol</i></span></nobr></DIV>
<DIV style="position:absolute;top:923;left:135"><nobr><span class="ft2">:: <i>Printf a</i></span></nobr></DIV>
<DIV style="position:absolute;top:920;left:193"><nobr><span class="ft3"> <i>Printf a</i></span></nobr></DIV>
<DIV style="position:absolute;top:939;left:100"><nobr><span class="ft5"><i>eol k</i></span></nobr></DIV>
<DIV style="position:absolute;top:936;left:133"><nobr><span class="ft3">= <i>Printf </i>(<i>s </i> <i>printfApp k </i>(<i>s </i>++ &quot;\n&quot;))</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:100"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:958;left:135"><nobr><span class="ft2">:: <i>Printf a</i></span></nobr></DIV>
<DIV style="position:absolute;top:956;left:192"><nobr><span class="ft3"> <i>Printf </i>(<i>Int </i> <i>a</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:100"><nobr><span class="ft5"><i>int k</i></span></nobr></DIV>
<DIV style="position:absolute;top:972;left:133"><nobr><span class="ft3">= <i>Printf </i>(<i>s x </i> <i>printfApp k </i>(<i>s </i>++ <i>show x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:100"><nobr><span class="ft5"><i>str</i></span></nobr></DIV>
<DIV style="position:absolute;top:994;left:135"><nobr><span class="ft2">:: <i>Printf a</i></span></nobr></DIV>
<DIV style="position:absolute;top:991;left:192"><nobr><span class="ft3"> <i>Printf </i>(<i>String </i> <i>a</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:100"><nobr><span class="ft5"><i>str k</i></span></nobr></DIV>
<DIV style="position:absolute;top:1007;left:133"><nobr><span class="ft3">= <i>Printf </i>(<i>s x </i> <i>printfApp k </i>(<i>s </i>++ <i>x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:100"><nobr><span class="ft5"><i>eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:135"><nobr><span class="ft2">:: <i>Printf String</i></span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:100"><nobr><span class="ft5"><i>eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:133"><nobr><span class="ft3">= <i>Printf id</i></span></nobr></DIV>
<DIV style="position:absolute;top:1060;left:99"><nobr><span class="ft2">Taking one step further, we can now abstract over <i>Printf </i>and</span></nobr></DIV>
<DIV style="position:absolute;top:1075;left:81"><nobr><span class="ft2">create a type class that replaces it with some functor <i>f </i>.</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:495"><nobr><span class="ft9"><b>class </b><i>Format f </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:508"><nobr><span class="ft5"><i>lit </i>:: <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:123;left:575"><nobr><span class="ft3"> <i>f r </i> <i>f r</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:508"><nobr><span class="ft5"><i>eol </i>:: <i>f r</i></span></nobr></DIV>
<DIV style="position:absolute;top:139;left:556"><nobr><span class="ft3"> <i>f r</i></span></nobr></DIV>
<DIV style="position:absolute;top:157;left:508"><nobr><span class="ft5"><i>int </i>:: <i>f r</i></span></nobr></DIV>
<DIV style="position:absolute;top:154;left:556"><nobr><span class="ft3"> <i>f </i>(<i>Int </i> <i>r</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:508"><nobr><span class="ft5"><i>str </i>:: <i>f r</i></span></nobr></DIV>
<DIV style="position:absolute;top:170;left:556"><nobr><span class="ft3"> <i>f </i>(<i>String </i> <i>r</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:188;left:508"><nobr><span class="ft5"><i>eod </i>:: <i>f String</i></span></nobr></DIV>
<DIV style="position:absolute;top:203;left:476"><nobr><span class="ft11">With this last transformation, we can start seeing an instance of the<br>TypeCase design pattern. The <i>structural cases </i>participant consists<br>of functions of the form <i>Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:230;left:632"><nobr><span class="ft3"> <i>r </i>or <i>String </i> <i>r</i>, or a <i>String </i>-- <i>lit</i></span></nobr></DIV>
<DIV style="position:absolute;top:248;left:476"><nobr><span class="ft12">and <i>eol </i>are overlapping cases. The class <i>Format </i>constitutes the<br><i>typecase </i>participant. Because the <i>dispatcher </i>is optional in explicit<br>versions of the design pattern, there is no obligation to define it.<br>Now, using the newtype <i>Printf </i>, we can define an instance of <i>Format<br></i>that implements the functionality of <i>printf </i>.</span></nobr></DIV>
<DIV style="position:absolute;top:323;left:495"><nobr><span class="ft9"><b>instance </b><i>Format Printf </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:339;left:508"><nobr><span class="ft5"><i>lit x k</i></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:541"><nobr><span class="ft3">= <i>Printf </i>(<i>s </i> <i>printfApp k </i>(<i>s </i>++ <i>x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:508"><nobr><span class="ft5"><i>eol k</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:541"><nobr><span class="ft3">= <i>Printf </i>(<i>s </i> <i>printfApp k </i>(<i>s </i>++ &quot;\n&quot;))</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:508"><nobr><span class="ft5"><i>int k</i></span></nobr></DIV>
<DIV style="position:absolute;top:367;left:541"><nobr><span class="ft3">= <i>Printf </i>(<i>s x </i> <i>printfApp k </i>(<i>s </i>++ <i>show x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:386;left:508"><nobr><span class="ft5"><i>str k</i></span></nobr></DIV>
<DIV style="position:absolute;top:383;left:541"><nobr><span class="ft3">= <i>Printf </i>(<i>s x </i> <i>printfApp k </i>(<i>s </i>++ <i>x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:508"><nobr><span class="ft5"><i>eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:399;left:541"><nobr><span class="ft3">= <i>Printf id</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:476"><nobr><span class="ft11">The final touch is provided by the definition of <i>printf </i>in terms of<br><i>printfApp</i>. The <i>printf </i>function is expected to receive the formatting<br>argument of type <i>Printf t </i>as its first parameter. The parameter <i>t<br></i>defines the type of <i>printf </i>, which can involve a variable number of<br>arguments. Analysing the type of <i>printfApp</i>, we see that the first<br>parameter is the formatting argument, the resulting type is the type<br>that we expect for <i>printf </i>, and there is a second argument which is a<br><i>String</i>. Now, what does that <i>String </i>represent? Danvy's solution uses<br>a continuation-passing style and the second argument of <i>printfApp<br></i>corresponds to the value fed to the initial continuation. Thus using<br>the string &quot;&quot; for that argument does the trick.</span></nobr></DIV>
<DIV style="position:absolute;top:581;left:495"><nobr><span class="ft5"><i>printf</i></span></nobr></DIV>
<DIV style="position:absolute;top:581;left:541"><nobr><span class="ft2">:: <i>Printf t</i></span></nobr></DIV>
<DIV style="position:absolute;top:578;left:596"><nobr><span class="ft3"> <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:596;left:495"><nobr><span class="ft5"><i>printf p</i></span></nobr></DIV>
<DIV style="position:absolute;top:594;left:540"><nobr><span class="ft3">= <i>printfApp p </i>&quot;&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:611;left:493"><nobr><span class="ft2">We have shown, informally, that Danvy's solution is indeed an</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:476"><nobr><span class="ft11">instance of the TypeCase design pattern. However, some questions<br>might be asked at this point. Do we really need to create a class in<br>order to implement <i>printf </i>? What other instances of the class would<br>we be able to provide? In fact there are not many other uses for the<br>type class; <i>printf </i>seems to be the only natural instance. Perhaps we<br>could consider <i>scanf </i>, another C function that uses the same format<br>string; but the derived type for <i>scanf </i>would be different, and so<br>it is not possible to reuse the same type class. Another possibility<br>would be considering other versions of <i>printf </i>, such as one for the<br><i>IO </i>monad. However, if we think that <i>printf </i>is really the only useful<br>instance of the type class, why not get rid of the type class all<br>together?</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:493"><nobr><span class="ft2">A design pattern is a flexible design, and depending on the con-</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:476"><nobr><span class="ft11">text of the problem, it can be adapted to fit the problem. If a type-<br>indexed function is used at <i>just one type index</i>, it is reasonable to<br>simplify the pattern and <i>eliminate the type class</i>. The result would<br>be the specialised solution using the newtype <i>Printf t </i>presented be-<br>fore. We could go even further and argue that Danvy's original solu-<br>tion is already an instance of the design pattern, corresponding to<br>one further simplification of the design pattern, namely getting rid<br>of the newtype.</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:476"><nobr><span class="ft9"><b>4.2.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:950;left:516"><nobr><span class="ft9"><b>An alternative solution using smart datatypes</b></span></nobr></DIV>
<DIV style="position:absolute;top:971;left:476"><nobr><span class="ft12">In the previous section, we have argued that Danvy's version of<br><i>printf </i>is an instance of the TypeCase design pattern. However,<br>Danvy's solution and explanation for <i>printf </i>is not, perhaps, very<br>intuitive to understand. In this section, we take a different perpect-<br>ive and will look at the formatting parameter of <i>printf </i>as a spe-<br>cial kind of list. This perpective corresponds to an instance of the<br>design pattern using a <i>smart datatype</i>. The datatype (the <i>typecase<br></i>participant) encodes a list, which has an empty case that corres-</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">104</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="202008.png" alt="background image">
<DIV style="position:absolute;top:110;left:81"><nobr><span class="ft11">ponds to the combinator <i>eod</i>, and a number of recursive cases that<br>correspond to <i>lit</i>, <i>eol</i>, <i>int </i>and <i>str</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:100"><nobr><span class="ft9"><b>data </b><i>Printf t </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:156;left:114"><nobr><span class="ft5"><i>Lit </i>:: <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:183"><nobr><span class="ft3"> <i>Printf t </i> <i>Printf t</i></span></nobr></DIV>
<DIV style="position:absolute;top:171;left:114"><nobr><span class="ft5"><i>Eol </i>:: <i>Printf t</i></span></nobr></DIV>
<DIV style="position:absolute;top:169;left:190"><nobr><span class="ft3"> <i>Printf t</i></span></nobr></DIV>
<DIV style="position:absolute;top:187;left:114"><nobr><span class="ft5"><i>Int </i>:: <i>Printf t</i></span></nobr></DIV>
<DIV style="position:absolute;top:184;left:190"><nobr><span class="ft3"> <i>Printf </i>(<i>Int </i> <i>t</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:114"><nobr><span class="ft5"><i>Str </i>:: <i>Printf t</i></span></nobr></DIV>
<DIV style="position:absolute;top:200;left:190"><nobr><span class="ft3"> <i>Printf </i>(<i>String </i> <i>t</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:114"><nobr><span class="ft5"><i>Eod </i>:: <i>Printf String</i></span></nobr></DIV>
<DIV style="position:absolute;top:233;left:81"><nobr><span class="ft11">Informally speaking, we have reused the types from the newtype<br>solution and lifted the functions to constructors. However, using<br>a datatype instead of a number of functions makes it easier to<br>view the format parameter of <i>printf </i>as a list. For instance, the <i>Lit<br></i>constructor takes the literal string that we wish to print and also the<br>list corresponding to the rest of the format parameter of <i>printf </i>.</span></nobr></DIV>
<DIV style="position:absolute;top:323;left:99"><nobr><span class="ft2">The <i>printfApp </i>from the previous section would, in this setting,</span></nobr></DIV>
<DIV style="position:absolute;top:338;left:81"><nobr><span class="ft11">correspond to a dependently-typed function (in the sense that the<br>types of its branches are determined by the constructors used to<br>perform pattern matching).</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:100"><nobr><span class="ft5"><i>printfApp</i></span></nobr></DIV>
<DIV style="position:absolute;top:383;left:212"><nobr><span class="ft2">:: <i>Printf t</i></span></nobr></DIV>
<DIV style="position:absolute;top:380;left:267"><nobr><span class="ft3"> <i>String </i> <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:398;left:100"><nobr><span class="ft5"><i>printfApp</i></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:155"><nobr><span class="ft3">(<i>Lit x k</i>) <i>s </i>= <i>printfApp k </i>(<i>s </i>++ <i>x</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:100"><nobr><span class="ft5"><i>printfApp</i></span></nobr></DIV>
<DIV style="position:absolute;top:411;left:155"><nobr><span class="ft3">(<i>Eol k</i>) <i>s </i>= <i>printfApp k </i>(<i>s </i>++ &quot;\n&quot;)</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:100"><nobr><span class="ft5"><i>printfApp</i></span></nobr></DIV>
<DIV style="position:absolute;top:427;left:155"><nobr><span class="ft3">(<i>Int k</i>) <i>s </i>= (<i>x </i> <i>printfApp k </i>(<i>s </i>++ <i>show x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:100"><nobr><span class="ft5"><i>printfApp</i></span></nobr></DIV>
<DIV style="position:absolute;top:443;left:155"><nobr><span class="ft3">(<i>Str k</i>) <i>s </i>= (<i>x </i> <i>printfApp k </i>(<i>s </i>++ <i>x</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:100"><nobr><span class="ft5"><i>printfApp Eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:461;left:196"><nobr><span class="ft5"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:458;left:210"><nobr><span class="ft3">= <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:476;left:81"><nobr><span class="ft11">The final step is to define <i>printf </i>. Little effort is required; we just<br>need to copy the definition of <i>printf </i>from the previous section. The<br>only apparent difference between the two versions is that, where<br>the first version uses functions like <i>lit </i>and <i>int</i>, this version uses<br>constructors like <i>Lit </i>and <i>Int</i>. However, despite the similarity of the<br>two solutions, their expressive power is not the same. The smart<br>datatype solution in this section is fully closed to extension. That<br>is, in order to add another case in the formatting list, such as a<br>constructor <i>Chr </i>that handles characters, we would need to modify<br>the GADT itself. On the other hand, the solution in the previous<br>section using the explicit version of the design pattern allows some<br>form of extensibility. Adding a new case for <i>printf </i>that handles<br>characters corresponds to adding a new function, which could even<br>be in a different module.</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:81"><nobr><span class="ft9"><b>4.2.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:703;left:121"><nobr><span class="ft9"><b>Making use of a dispatcher</b></span></nobr></DIV>
<DIV style="position:absolute;top:724;left:81"><nobr><span class="ft11">The two solutions that we presented did not make any use of a<br><i>dispatcher</i>. In this section we will show how the dispatcher can<br>be useful. The version of the dispatcher presented here is for the<br>explicit representation solution in Section 4.2.1, but could be easily<br>adapted to the smart datatype solution in Section 4.2.2.</span></nobr></DIV>
<DIV style="position:absolute;top:798;left:99"><nobr><span class="ft2">Suppose that we want to define a function that prints a pair of</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:81"><nobr><span class="ft11">integers. Equipped with <i>printf </i>, we could try to encode that with<br>either one of the following two functions.</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:100"><nobr><span class="ft5"><i>printPair x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:841;left:171"><nobr><span class="ft3">= <i>printf fmt </i>&quot;(&quot; <i>x </i>&quot;, &quot; <i>y </i>&quot;)&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:114"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:875;left:127"><nobr><span class="ft5"><i>fmt</i></span></nobr></DIV>
<DIV style="position:absolute;top:872;left:148"><nobr><span class="ft3">= <i>str </i>$ <i>int </i>$ <i>str </i>$ <i>int </i>$ <i>str </i>$ <i>eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:894;left:100"><nobr><span class="ft5"><i>printPair2 x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:892;left:177"><nobr><span class="ft3">= <i>printf fmt x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:910;left:114"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:926;left:127"><nobr><span class="ft5"><i>fmt</i></span></nobr></DIV>
<DIV style="position:absolute;top:923;left:148"><nobr><span class="ft3">= <i>lit </i>&quot;(&quot; $ <i>int </i>$ <i>lit </i>&quot;, &quot; $ <i>int </i>$ <i>lit </i>&quot;)&quot; $ <i>eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:941;left:81"><nobr><span class="ft11">The function <i>printPair </i>tackles the problem using a <i>printf </i>that takes<br>a format argument expecting five arguments: three strings and two<br>integers. The function <i>printPair2</i>, on the other hand, makes use of<br>the fact that the string arguments are constants, and uses <i>lit </i>instead.<br>Thus, in this case, <i>printf </i>takes the format argument and two integer<br>arguments. Although relatively compact, the format argument is not<br>as convenient to use as it would be in C, where one would write<br>something like &quot;(%d, %d)&quot;.</span></nobr></DIV>
<DIV style="position:absolute;top:1060;left:99"><nobr><span class="ft2">The role of the dispatcher is to infer automatically the corres-</span></nobr></DIV>
<DIV style="position:absolute;top:1075;left:81"><nobr><span class="ft2">ponding type representation for some type <i>t</i>. In the case of <i>printf </i>,</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:476"><nobr><span class="ft11">it is not possible to infer all possible representations. Consider, for<br>instance, the end of line case <i>eol </i>::<i>f r</i></span></nobr></DIV>
<DIV style="position:absolute;top:122;left:674"><nobr><span class="ft3"> <i>f r</i>, which takes an existing</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:476"><nobr><span class="ft11">format with some type <i>r</i>, adds a newline and returns a format of the<br>same type. Clearly, there is no way to deduce that there is an occur-<br>rence of <i>eol </i>based on the type alone. Similarly, the <i>lit </i>case has no<br>effect on the type. Nevertheless, the other, more type-informative,<br>cases of <i>printf </i>can be inferred.</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:495"><nobr><span class="ft9"><b>class </b><i>Rep t </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:230;left:508"><nobr><span class="ft5"><i>rep </i>:: <i>Format f</i></span></nobr></DIV>
<DIV style="position:absolute;top:228;left:588"><nobr><span class="ft3"> <i>f t</i></span></nobr></DIV>
<DIV style="position:absolute;top:250;left:495"><nobr><span class="ft9"><b>instance </b><i>Rep String </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:266;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:263;left:529"><nobr><span class="ft3">= <i>eod</i></span></nobr></DIV>
<DIV style="position:absolute;top:286;left:495"><nobr><span class="ft9"><b>instance </b><i>Rep r</i></span></nobr></DIV>
<DIV style="position:absolute;top:283;left:577"><nobr><span class="ft3"> <i>Rep </i>(<i>Int </i> <i>r</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:302;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:299;left:529"><nobr><span class="ft3">= <i>int rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:321;left:495"><nobr><span class="ft9"><b>instance </b><i>Rep r</i></span></nobr></DIV>
<DIV style="position:absolute;top:319;left:577"><nobr><span class="ft3"> <i>Rep </i>(<i>String </i> <i>r</i>) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:337;left:508"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:335;left:529"><nobr><span class="ft3">= <i>str rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:476"><nobr><span class="ft11">We should note that these instance declarations are outside the<br>scope of Haskell 98 -- types are used where type variables should<br>occur. However, this is a quite mild extension, and is supported by<br>most Haskell compilers.</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:493"><nobr><span class="ft2">Making use of the fact that now we can infer some cases of the</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:476"><nobr><span class="ft2">string format, we could define:</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:495"><nobr><span class="ft5"><i>printPair </i>:: <i>Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:439;left:574"><nobr><span class="ft3"> <i>Int </i> <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:495"><nobr><span class="ft5"><i>printPair x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:455;left:565"><nobr><span class="ft3">= <i>printf rep </i>&quot;(&quot; <i>x </i>&quot;, &quot; <i>y </i>&quot;)&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:495"><nobr><span class="ft5"><i>printTrio </i>:: <i>Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:573"><nobr><span class="ft3"> <i>Int </i> <i>Int </i> <i>String</i></span></nobr></DIV>
<DIV style="position:absolute;top:493;left:495"><nobr><span class="ft5"><i>printTrio x y z</i></span></nobr></DIV>
<DIV style="position:absolute;top:490;left:573"><nobr><span class="ft3">= <i>printf rep </i>&quot;(&quot; <i>x </i>&quot;, &quot; <i>y </i>&quot;, &quot; <i>z </i>&quot;)&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:476"><nobr><span class="ft11">The function <i>printPair </i>does the same as before. However, with<br>this new definition, the format directive is automatically inferred.<br>The function <i>printTrio </i>is doing the same as <i>printPair</i>, except that<br>it does it for triples. We should emphasise that the occurrences of<br><i>printf </i>in those two functions use different numbers of arguments.<br>We should also mention that, in some situations, we will need to<br>provide explicit types, otherwise the type checker would not be able<br>to infer the correct instances of the type class <i>Rep</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:493"><nobr><span class="ft2">This use of <i>printf </i>seems to be practical, and for this simple</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:476"><nobr><span class="ft12">version of it we might even argue that everything that we could<br>do with a manually-provided parameter could be done with an<br>automatically-inferred one. We simply do not need <i>lit </i>and <i>eol</i>,<br>because those can be simulated using <i>str </i>(with, of course, extra<br><i>String </i>arguments). Nevertheless, if we decided to go for a more<br>powerful version of <i>printf </i>, this might not be the case. Consider, for<br>instance, the formatting directive &quot;%2d&quot;. In this case the number 2<br>is specifying the minimum width of the string that represents that<br>number. If we wanted to allow this kind of behaviour, we could<br>add an extra parameter of type <i>Int </i>to the <i>int </i>case. However, the<br>problem now is to choose a value for that parameter when we<br>automatically build the format directive. In this case we need to<br>use some default value (for instance 1). However we are no longer<br>able, for all possible cases, to simulate the functionality of <i>printf<br></i>with manual format strings using only automatically-built ones.</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:476"><nobr><span class="ft4"><b>5. Type-indexed types</b></span></nobr></DIV>
<DIV style="position:absolute;top:941;left:476"><nobr><span class="ft11">Until now we have been discussing <i>type-indexed functions</i>, that<br>is, families of functions indexed by types. We turn now to <i>type-<br>indexed types</i>, that is, families of types indexed by types. In the<br>context of generic programming, we call these <i>generic types</i>. Gen-<br>eric functions with generic types are functions that have different<br>result types for each structural case.</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:493"><nobr><span class="ft2">In this section, we will show how to implement type-indexed</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:476"><nobr><span class="ft11">types as another variation of the <i>TypeCase </i>design pattern. We do<br>this by translating a standard example of Generic Haskell [20],<br>namely generic tries [17], into our approach.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">105</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft25{font-size:5px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="202009.png" alt="background image">
<DIV style="position:absolute;top:110;left:81"><nobr><span class="ft9"><b>5.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:110;left:111"><nobr><span class="ft9"><b>Encoding type-indexed types</b></span></nobr></DIV>
<DIV style="position:absolute;top:131;left:81"><nobr><span class="ft11">Section 3 presents templates for encoding type-indexed functions.<br>In this section, we show how to translate a type-indexed type into<br>an instance of the TypeCase design pattern.</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:99"><nobr><span class="ft2">In general, a type-indexed type has the form</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:100"><nobr><span class="ft3"> <i>t </i>:: </span></nobr></DIV>
<DIV style="position:absolute;top:191;left:185"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:207;left:100"><nobr><span class="ft3"> <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:211;left:118"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:206;left:129"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:211;left:135"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:146"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:211;left:171"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:204;left:183"><nobr><span class="ft3">=  <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:211;left:215"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:234"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:211;left:259"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:204;left:275"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:211;left:299"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:187"><nobr><span class="ft23">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:100"><nobr><span class="ft3"> <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:254;left:118"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:250;left:129"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:254;left:134"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:146"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:254;left:170"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:247;left:183"><nobr><span class="ft3">=  <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:254;left:215"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:234"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:254;left:259"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:247;left:275"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:254;left:299"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:265;left:81"><nobr><span class="ft11">where  is the type-level function that defines the type-indexed<br>type; <i>t </i>is the family of types (or type constructors)</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:348"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:357"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:365"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:372"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:381"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:406"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:277;left:410"><nobr><span class="ft3">),...,</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:81"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:299;left:90"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:294;left:102"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:299;left:108"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:119"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:299;left:144"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:292;left:148"><nobr><span class="ft3">) of kind  that corresponds to the <i>structural cases</i></span></nobr></DIV>
<DIV style="position:absolute;top:310;left:81"><nobr><span class="ft11">of the design pattern; and, finally,  is the kind of  <i>t </i>::  . For<br>each type that is member of that family, we have a corresponding<br>branch for . The type-level lambda abstraction on the right side of<br>each branch is optional, and corresponds to possible parametrically<br>polymorphic variables <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:374;left:213"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:225"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:373;left:251"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:369;left:261"><nobr><span class="ft2">that the type-indexed type might</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:81"><nobr><span class="ft2">depend on. Finally, </span></nobr></DIV>
<DIV style="position:absolute;top:389;left:193"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:203"><nobr><span class="ft3">... </span></nobr></DIV>
<DIV style="position:absolute;top:388;left:229"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:384;left:240"><nobr><span class="ft2">corresponds to the family of types (or</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:81"><nobr><span class="ft2">type constructors) that defines the type-indexed type.</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:81"><nobr><span class="ft9"><b>5.1.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:121"><nobr><span class="ft9"><b>Type class translation</b></span></nobr></DIV>
<DIV style="position:absolute;top:452;left:81"><nobr><span class="ft11">We can now derive an instance of the TypeCase design pattern<br>to capture type-indexed functions with type-indexed types. The<br><i>typecase </i>participant, for instances of the design pattern using either<br>implicit or explicit representations, could be defined as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:100"><nobr><span class="ft9"><b>class </b></span></nobr></DIV>
<DIV style="position:absolute;top:509;left:142"><nobr><span class="ft3">(<i>g </i>::     ) <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:527;left:114"><nobr><span class="ft5"><i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:531;left:138"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:535;left:141"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:149"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:530;left:167"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:536;left:176"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:183"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:536;left:199"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:530;left:202"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:233"><nobr><span class="ft5"><i>g</i></span></nobr></DIV>
<DIV style="position:absolute;top:524;left:242"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:532;left:251"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:260"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:532;left:267"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:277"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:531;left:303"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:524;left:306"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:532;left:321"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:337"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:532;left:362"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:528;left:377"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:532;left:384"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:544;left:148"><nobr><span class="ft23">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:114"><nobr><span class="ft5"><i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:576;left:138"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:579;left:141"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:571;left:149"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:575;left:167"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:581;left:175"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:182"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:581;left:197"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:575;left:200"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:230"><nobr><span class="ft5"><i>g</i></span></nobr></DIV>
<DIV style="position:absolute;top:569;left:240"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:576;left:249"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:571;left:260"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:576;left:265"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:276"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:576;left:300"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:569;left:303"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:576;left:318"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:336"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:576;left:362"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:572;left:378"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:576;left:385"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:81"><nobr><span class="ft11">We reuse the name  for the name of the type class that en-<br>codes the <i>typecase </i>component. The parameter <i>g </i>is a type con-<br>structor with kind </span></nobr></DIV>
<DIV style="position:absolute;top:615;left:203"><nobr><span class="ft3">   , where  is the literal occur-</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:81"><nobr><span class="ft11">rence of  (if we were to use  instead of its literal occur-<br>rence, we would obtain the wrong kind). There are <i>m </i>functions<br><i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:667;left:105"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:670;left:108"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:113"><nobr><span class="ft3">,...,<i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:667;left:163"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:670;left:166"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:662;left:178"><nobr><span class="ft2">that correspond to the typecases for each type</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:81"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:90"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:100"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:107"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:118"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:145"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:675;left:149"><nobr><span class="ft3">),...,(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:189"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:677;left:201"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:206"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:218"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:243"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:675;left:247"><nobr><span class="ft3">). Each case of the typecase func-</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:81"><nobr><span class="ft11">tion is defined by providing the type constructor <i>g </i>with the corre-<br>ponding types. Finally, </span></nobr></DIV>
<DIV style="position:absolute;top:710;left:221"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:716;left:230"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:237"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:716;left:253"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:710;left:256"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:261"><nobr><span class="ft3">,...,</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:295"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:716;left:303"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:310"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:716;left:325"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:710;left:328"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:338"><nobr><span class="ft2">corresponds to the</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:81"><nobr><span class="ft2">representations for the types</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:237"><nobr><span class="ft3">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:729;left:248"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:259"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:729;left:284"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:722;left:288"><nobr><span class="ft3">),...,(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:729;left:330"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:340"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:729;left:364"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:722;left:368"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:99"><nobr><span class="ft2">The only difference between explicit and implicit versions of the</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:81"><nobr><span class="ft11">design pattern for the typecase component is that in the explicit ver-<br>sion the occurrences of  are expanded into explicitly-passed rep-<br>resentations of the form <i>g a</i></span></nobr></DIV>
<DIV style="position:absolute;top:789;left:230"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:781;left:241"><nobr><span class="ft3">..., whereas with the implicit repres-</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:81"><nobr><span class="ft11">entations those occurrences are replaced by type class constraints<br>of the form <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:820;left:166"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:814;left:176"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:819;left:183"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:811;left:194"><nobr><span class="ft3">....</span></nobr></DIV>
<DIV style="position:absolute;top:829;left:99"><nobr><span class="ft2">The <i>dispatcher </i>can also be derived; but to do so requires exten-</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:81"><nobr><span class="ft11">sions to Haskell 98 -- specifically, multiple-parameter type classes<br>with functional dependencies. The problem is that, even in its<br>simplest form, a type-indexed type requires at least two type ar-<br>guments: the first one corresponding to the index type, and the<br>second one that is the resulting type-indexed type for that index,<br>and thus depending on the index. This problem is not too serious if<br>we use the explicit representations variant of the pattern, since the<br>dispatcher is optional, but using implicit representations forces us<br>outside Haskell 98.</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:100"><nobr><span class="ft9"><b>class </b><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:984;left:151"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:978;left:161"><nobr><span class="ft5"><i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:175"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:976;left:185"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:982;left:211"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:979;left:220"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:976;left:230"><nobr><span class="ft3">| <i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:250"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:976;left:261"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:982;left:286"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:976;left:295"><nobr><span class="ft3">  <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:994;left:127"><nobr><span class="ft5"><i>rep </i>::  <i>g</i></span></nobr></DIV>
<DIV style="position:absolute;top:991;left:177"><nobr><span class="ft3"> <i>g t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:217"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:227"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:252"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:995;left:261"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:100"><nobr><span class="ft9"><b>instance </b></span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:161"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:170"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:177"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:193"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:196"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:204"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:114"><nobr><span class="ft5"><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:135"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:145"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:154"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:163"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:169"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:180"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:205"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:209"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:224"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:242"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:267"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:284"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:291"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:300"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:1048;left:158"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:1045;left:179"><nobr><span class="ft3">= <i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:1052;left:216"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:219"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:1045;left:224"><nobr><span class="ft3">{<i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:1045;left:249"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:1045;left:254"><nobr><span class="ft3">}</span></nobr></DIV>
<DIV style="position:absolute;top:1063;left:127"><nobr><span class="ft24">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:495"><nobr><span class="ft9"><b>instance </b></span></nobr></DIV>
<DIV style="position:absolute;top:113;left:555"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:119;left:564"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:570"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:119;left:585"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:113;left:588"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:596"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:508"><nobr><span class="ft5"><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:134;left:529"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:125;left:539"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:548"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:560"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:565"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:575"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:599"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:125;left:603"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:618"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:636"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:662"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:128;left:678"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:685"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:697"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:144;left:553"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:142;left:573"><nobr><span class="ft3">= <i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:149;left:610"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:613"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:142;left:620"><nobr><span class="ft3">{<i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:142;left:646"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:142;left:650"><nobr><span class="ft3">}</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:476"><nobr><span class="ft2">The type class <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:165;left:581"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:159;left:593"><nobr><span class="ft2">has at least two type arguments: <i>t </i>and . If</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:476"><nobr><span class="ft11">there are parametric types that  depends on, then the type class<br>also needs to account for those types (<i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:194;left:685"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:695"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:193;left:719"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:189;left:726"><nobr><span class="ft2">). The class contains</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:476"><nobr><span class="ft12">just one member function, <i>rep</i>, used to build representations for<br>. The function <i>rep </i>has a type class constraint ensuring that <i>g<br></i>is an instance of . There are, at least, <i>m </i>instances of <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:240;left:800"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:234;left:807"><nobr><span class="ft2">, and</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:476"><nobr><span class="ft2">those instances define <i>rep </i>with the corresponding <i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:253;left:773"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:257;left:776"><nobr><span class="ft25"></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:786"><nobr><span class="ft2">function.</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:476"><nobr><span class="ft11">If we are implementing an implicit version of the design pattern,<br>then the definition of <i>rep </i>is complete; otherwise, for an explicit<br>version, we need to apply <i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:298;left:649"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:302;left:652"><nobr><span class="ft25"></span></nobr></DIV>
<DIV style="position:absolute;top:294;left:663"><nobr><span class="ft2">to a number <i>i </i>of <i>rep </i>functions</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:476"><nobr><span class="ft2">(where <i>i </i>is the number of type parameters of <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:314;left:732"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:309;left:738"><nobr><span class="ft2">). The constraints</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:476"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:327;left:486"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:333;left:495"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:502"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:333;left:518"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:327;left:521"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:526"><nobr><span class="ft3">,...,</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:562"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:333;left:570"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:577"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:333;left:592"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:327;left:595"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:603"><nobr><span class="ft2">are very similar to the constraints , and in</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:476"><nobr><span class="ft18">fact for implicit representations they coincide: they correspond to<br>representations for the types <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:359;left:638"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:352;left:648"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:359;left:673"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:677"><nobr><span class="ft3">,...,<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:359;left:708"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:352;left:719"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:359;left:743"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:355;left:749"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:476"><nobr><span class="ft9"><b>5.1.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:395;left:516"><nobr><span class="ft9"><b>Smart datatype translations</b></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:476"><nobr><span class="ft11">Encoding type-indexed functions with <i>smart datatypes </i>proceeds<br>in a similar fashion to the encoding with type classes. We will<br>demonstrate how to do this translation using a GADT syntax (as<br>found in the new GHC 6.4 Haskell compiler).</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:493"><nobr><span class="ft2">A type-indexed type generates a smart datatype of the following</span></nobr></DIV>
<DIV style="position:absolute;top:491;left:476"><nobr><span class="ft2">form.</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:495"><nobr><span class="ft9"><b>data </b> <i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:510;left:548"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:503;left:559"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:510;left:584"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:593"><nobr><span class="ft3"> <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:521;left:508"><nobr><span class="ft5"><i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:514"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:529;left:517"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:526"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:525;left:543"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:531;left:553"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:559"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:531;left:576"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:525;left:579"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:609"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:620"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:629"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:638"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:645"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:655"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:681"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:684"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:699"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:717"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:743"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:522;left:759"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:766"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:508"><nobr><span class="ft18">.<br>.<br>.<br><i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:514"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:574;left:517"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:566;left:526"><nobr><span class="ft2">:: </span></nobr></DIV>
<DIV style="position:absolute;top:569;left:543"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:575;left:552"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:558"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:575;left:573"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:569;left:576"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:609"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:563;left:620"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:629"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:566;left:640"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:646"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:656"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:680"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:563;left:684"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:699"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:717"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:743"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:566;left:759"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:766"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:582;left:476"><nobr><span class="ft11">Instead of being parametrised by a "function" (like the type class<br>approach), a smart datatype is parametrised by all the types on<br>which it depends. Another difference from the type class approach<br>is that the functions that represent each case are now replaced<br>by constructors <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:646;left:570"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:650;left:573"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:579"><nobr><span class="ft3">,...,<i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:646;left:611"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:650;left:613"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:642;left:625"><nobr><span class="ft2">that can just be pattern matched (in a</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:476"><nobr><span class="ft11">dependent manner) by functions defined over those datatypes. A<br>final difference is that </span></nobr></DIV>
<DIV style="position:absolute;top:675;left:602"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:611"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:618"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:635"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:675;left:637"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:669;left:642"><nobr><span class="ft3">,...,</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:676"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:685"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:691"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:706"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:675;left:709"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:717"><nobr><span class="ft2">need to reflect the fact</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:476"><nobr><span class="ft2">that we are now using a smart datatype.</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:493"><nobr><span class="ft2">The changes to <i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:709;left:601"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:703;left:612"><nobr><span class="ft2">are minimal; the only change to the type</span></nobr></DIV>
<DIV style="position:absolute;top:718;left:476"><nobr><span class="ft11">class version is that in the definition of <i>rep </i>we now use the con-<br>structors <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:737;left:531"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:741;left:534"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:539"><nobr><span class="ft3">,...,<i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:737;left:571"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:741;left:574"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:733;left:584"><nobr><span class="ft2">instead of the functions <i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:737;left:738"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:741;left:741"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:746"><nobr><span class="ft3">,...,<i>case</i></span></nobr></DIV>
<DIV style="position:absolute;top:737;left:796"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:741;left:798"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:733;left:806"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:747;left:495"><nobr><span class="ft9"><b>class </b><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:753;left:546"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:747;left:556"><nobr><span class="ft5"><i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:752;left:569"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:580"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:752;left:605"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:748;left:614"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:745;left:624"><nobr><span class="ft3">| <i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:752;left:645"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:655"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:752;left:680"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:745;left:690"><nobr><span class="ft3">  <b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:763;left:508"><nobr><span class="ft5"><i>rep </i>::  <i>t d</i></span></nobr></DIV>
<DIV style="position:absolute;top:768;left:562"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:572"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:767;left:598"><nobr><span class="ft20"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:764;left:607"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:783;left:495"><nobr><span class="ft9"><b>instance </b></span></nobr></DIV>
<DIV style="position:absolute;top:786;left:555"><nobr><span class="ft8">(<i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:792;left:565"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:572"><nobr><span class="ft8">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:792;left:588"><nobr><span class="ft22"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:786;left:591"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:598"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:800;left:508"><nobr><span class="ft5"><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:806;left:529"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:797;left:539"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:548"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:557"><nobr><span class="ft5"><i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:564"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:574"><nobr><span class="ft3">... <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:804;left:600"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:797;left:604"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:618"><nobr><span class="ft7">11</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:636"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:662"><nobr><span class="ft7">1<i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:801;left:678"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:685"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:694"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:817;left:553"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:814;left:573"><nobr><span class="ft3">= <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:821;left:593"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:825;left:595"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:604"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:814;left:621"><nobr><span class="ft20"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:833;left:508"><nobr><span class="ft23">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:495"><nobr><span class="ft9"><b>instance </b></span></nobr></DIV>
<DIV style="position:absolute;top:864;left:555"><nobr><span class="ft8">(<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:869;left:564"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:864;left:570"><nobr><span class="ft8">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:869;left:585"><nobr><span class="ft22"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:864;left:588"><nobr><span class="ft8">)</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:596"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:878;left:508"><nobr><span class="ft5"><i>Rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:884;left:529"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:875;left:539"><nobr><span class="ft3">(<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:882;left:548"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:878;left:560"><nobr><span class="ft5"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:882;left:565"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:575"><nobr><span class="ft3">... <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:882;left:599"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:875;left:603"><nobr><span class="ft3">) <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:882;left:618"><nobr><span class="ft20"><i>m</i>1</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:636"><nobr><span class="ft3">... <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:882;left:662"><nobr><span class="ft20"><i>mn</i></span></nobr></DIV>
<DIV style="position:absolute;top:878;left:678"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:882;left:685"><nobr><span class="ft20"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:878;left:697"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:895;left:553"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:892;left:573"><nobr><span class="ft3">= <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:899;left:593"><nobr><span class="ft20"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:903;left:595"><nobr><span class="ft22"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:895;left:605"><nobr><span class="ft5"><i>rep</i></span></nobr></DIV>
<DIV style="position:absolute;top:892;left:623"><nobr><span class="ft20"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:935;left:476"><nobr><span class="ft9"><b>5.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:935;left:506"><nobr><span class="ft9"><b>Tries</b></span></nobr></DIV>
<DIV style="position:absolute;top:956;left:476"><nobr><span class="ft11"><i>Tries </i>or <i>digital search trees </i>are a traditional example of a gen-<br>eric type. Tries make use of the structure of search keys in order<br>to organise information, which can then be efficiently queried. In<br>this section we will show how to implement generic tries using a<br>variation of the LAGP type representations. For a more theoret-<br>ical presentation of tries, see [20, 17]; the implementation of tries<br>presented here follows closely the implementations found in those<br>papers.</span></nobr></DIV>
<DIV style="position:absolute;top:1075;left:493"><nobr><span class="ft2">In [20], the generic type for tries is given as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">106</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft26{font-size:11px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="202010.png" alt="background image">
<DIV style="position:absolute;top:110;left:100"><nobr><span class="ft5"><i>FMap t </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:209"><nobr><span class="ft2">::</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:230"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:100"><nobr><span class="ft5"><i>FMap Unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:199"><nobr><span class="ft5"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:123;left:208"><nobr><span class="ft3">= <i>Maybe v</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:100"><nobr><span class="ft5"><i>FMap Int</i></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:199"><nobr><span class="ft5"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:139;left:208"><nobr><span class="ft3">= <i>MapInt v</i></span></nobr></DIV>
<DIV style="position:absolute;top:157;left:100"><nobr><span class="ft5"><i>FMap Plus t</i></span></nobr></DIV>
<DIV style="position:absolute;top:162;left:169"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:177"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:162;left:181"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:199"><nobr><span class="ft5"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:154;left:208"><nobr><span class="ft3">= <i>OptPair </i>(<i>FMap t</i></span></nobr></DIV>
<DIV style="position:absolute;top:162;left:314"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:329"><nobr><span class="ft5"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:154;left:334"><nobr><span class="ft3">) (<i>FMap t</i></span></nobr></DIV>
<DIV style="position:absolute;top:162;left:389"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:404"><nobr><span class="ft5"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:154;left:410"><nobr><span class="ft3">)</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:100"><nobr><span class="ft5"><i>FMap Prod t</i></span></nobr></DIV>
<DIV style="position:absolute;top:177;left:172"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:180"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:177;left:184"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:199"><nobr><span class="ft5"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:170;left:208"><nobr><span class="ft3">= <i>FMap t</i></span></nobr></DIV>
<DIV style="position:absolute;top:177;left:262"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:277"><nobr><span class="ft3">(<i>FMap t</i></span></nobr></DIV>
<DIV style="position:absolute;top:177;left:324"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:338"><nobr><span class="ft5"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:170;left:344"><nobr><span class="ft3">)</span></nobr></DIV>
<DIV style="position:absolute;top:188;left:99"><nobr><span class="ft2">It is clear that the type-indexed function <i>FMap </i>takes a type</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:81"><nobr><span class="ft2">parameter <i>t </i>:: and another type of kind</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:310"><nobr><span class="ft2">and returns another type</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:81"><nobr><span class="ft11">of kind . Only the shape of parameter <i>t </i>is analysed; the other<br>parameter <i>v </i>needs to be used in the definition because the resulting<br>type is parametrically polymorphic in relation to <i>v</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:99"><nobr><span class="ft2">We encode this characterisation of <i>FMap </i>as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:100"><nobr><span class="ft9"><b>class </b><i>FMap g </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:293;left:114"><nobr><span class="ft17"><i>unit </i>:: <i>g Unit v Maybe<br>plus </i>:: <i>g a v c</i></span></nobr></DIV>
<DIV style="position:absolute;top:306;left:188"><nobr><span class="ft3"> <i>g b v d </i> <i>g </i>(<i>Plus a b</i>) <i>v </i>(<i>PlusCase c d</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:114"><nobr><span class="ft5"><i>prod </i>:: <i>g a</i></span></nobr></DIV>
<DIV style="position:absolute;top:322;left:170"><nobr><span class="ft3">(<i>d v</i>) <i>c </i> <i>g b v d </i> <i>g </i>(<i>Prod a b</i>) <i>v </i>(<i>ProdCase c d</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:114"><nobr><span class="ft5"><i>data </i>:: <i>g a v c</i></span></nobr></DIV>
<DIV style="position:absolute;top:337;left:188"><nobr><span class="ft3"> <i>Iso b a </i> <i>Iso </i>(<i>d v</i>) (<i>c v</i>)  <i>g b v d</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:114"><nobr><span class="ft5"><i>int </i>:: <i>g Int v MapInt</i></span></nobr></DIV>
<DIV style="position:absolute;top:371;left:81"><nobr><span class="ft11">This class forms the <i>typecase </i>participant of an explicit representa-<br>tion variant of the TypeCase pattern. The class <i>FMap </i>is a variation<br>of the <i>Generic </i>class from Section 2.2.2. The functor <i>g </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:400"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:413;left:81"><nobr><span class="ft11">(  )  takes the necessary information to rebuild the type-<br>indexed type. The three parameters of the functor correspond, re-<br>spectively, to the type parameter <i>t</i>, the second parameter and the<br>resulting type of <i>FMap</i>. (The kind of the resulting type is now</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:91"><nobr><span class="ft3"> . We could have used kind as in <i>FMap</i>, but we believe this</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:81"><nobr><span class="ft11">version is slightly more readable.) The function <i>unit </i>just reflects the<br>change of the functor <i>g </i>and adds the information for the parametric<br>type <i>v </i>and the functor <i>Maybe </i>that is used to define the trie for the<br><i>Unit </i>case. The cases for <i>plus </i>and <i>prod </i>have explicit arguments that<br>correspond to the recursive calls of the function; and the functors<br><i>PlusCase c d </i>and <i>ProdCase c d </i>correspond to the respective cases<br>of the type-indexed type. The <i>data </i>function handles user-defined<br>datatypes, having a recursive case and two isomorphisms: the first<br>between the structural cases and a second between the tries corres-<br>ponding to those cases. Finally, we could also define some extra<br>base cases to handle primitive types such as <i>Int </i>and <i>Char</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:99"><nobr><span class="ft2">The auxiliary definitions for the newtypes <i>PlusCase a b v </i>and</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:81"><nobr><span class="ft5"><i>ProdCase a b v </i>are defined as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:100"><nobr><span class="ft9"><b>data </b><i>OptPair a b</i></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:195"><nobr><span class="ft3">= <i>Null </i>| <i>Pair a b</i></span></nobr></DIV>
<DIV style="position:absolute;top:700;left:100"><nobr><span class="ft9"><b>newtype </b><i>PlusCase a b v</i></span></nobr></DIV>
<DIV style="position:absolute;top:698;left:234"><nobr><span class="ft3">=</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:151"><nobr><span class="ft5"><i>PlusCase</i></span></nobr></DIV>
<DIV style="position:absolute;top:713;left:202"><nobr><span class="ft3">{<i>unPlus </i>:: <i>OptPair </i>(<i>a v</i>) (<i>b v</i>)}</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:100"><nobr><span class="ft9"><b>newtype </b><i>ProdCase a b v</i></span></nobr></DIV>
<DIV style="position:absolute;top:733;left:236"><nobr><span class="ft3">=</span></nobr></DIV>
<DIV style="position:absolute;top:752;left:151"><nobr><span class="ft5"><i>ProdCase</i></span></nobr></DIV>
<DIV style="position:absolute;top:749;left:205"><nobr><span class="ft3">{<i>unProd </i>:: <i>a </i>(<i>b v</i>)}</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:81"><nobr><span class="ft2">The introduction of <i>OptPair a b </i>is for efficiency reasons [20].</span></nobr></DIV>
<DIV style="position:absolute;top:781;left:99"><nobr><span class="ft2">In order to use a user-defined type (or a built-in type that does</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:81"><nobr><span class="ft11">not have a special case for it), we need to do much the same work<br>as for GM2 in Section 2.2.2. As an example, we show what to do<br>for Haskell's built-in lists.</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:100"><nobr><span class="ft5"><i>list </i>:: <i>FMap g</i></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:174"><nobr><span class="ft3"> <i>g a </i>(<i>FList c v</i>) <i>c </i> <i>g </i>[<i>a</i>] <i>v </i>(<i>FList c</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:100"><nobr><span class="ft5"><i>list ra</i></span></nobr></DIV>
<DIV style="position:absolute;top:854;left:135"><nobr><span class="ft3">= <i>data </i>(<i>plus unit </i>(<i>prod ra </i>(<i>list ra</i>))) <i>listEP</i></span></nobr></DIV>
<DIV style="position:absolute;top:870;left:175"><nobr><span class="ft3">(<i>Iso unFList FList</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:100"><nobr><span class="ft5"><i>listEP </i>:: <i>Iso</i></span></nobr></DIV>
<DIV style="position:absolute;top:886;left:164"><nobr><span class="ft3">[<i>a</i>] (<i>Plus Unit </i>(<i>Prod a </i>[<i>a</i>]))</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:100"><nobr><span class="ft5"><i>listEP</i></span></nobr></DIV>
<DIV style="position:absolute;top:901;left:136"><nobr><span class="ft3">= <i>Iso fromList toList</i></span></nobr></DIV>
<DIV style="position:absolute;top:920;left:114"><nobr><span class="ft9"><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:935;left:127"><nobr><span class="ft5"><i>fromList</i></span></nobr></DIV>
<DIV style="position:absolute;top:933;left:175"><nobr><span class="ft3">[ ]</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:255"><nobr><span class="ft3">= <i>Inl Unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:951;left:127"><nobr><span class="ft5"><i>fromList</i></span></nobr></DIV>
<DIV style="position:absolute;top:948;left:175"><nobr><span class="ft3">(<i>x </i>: <i>xs</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:255"><nobr><span class="ft3">= <i>Inr </i>(<i>Prod x xs</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:127"><nobr><span class="ft5"><i>toList</i></span></nobr></DIV>
<DIV style="position:absolute;top:964;left:161"><nobr><span class="ft3">(<i>Inl Unit</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:255"><nobr><span class="ft3">= [ ]</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:127"><nobr><span class="ft5"><i>toList</i></span></nobr></DIV>
<DIV style="position:absolute;top:980;left:161"><nobr><span class="ft3">(<i>Inr </i>(<i>Prod x xs</i>)) = <i>x </i>: <i>xs</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:100"><nobr><span class="ft9"><b>newtype </b><i>FList c v</i></span></nobr></DIV>
<DIV style="position:absolute;top:995;left:200"><nobr><span class="ft3">= <i>FList</i>{</span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:114"><nobr><span class="ft5"><i>unFList </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:167"><nobr><span class="ft3">(<i>PlusCase Maybe </i>(<i>ProdCase c </i>(<i>FList c</i>))) <i>v</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:81"><nobr><span class="ft11">The function <i>list </i>defines the encoding for the representation of <i>lists</i>.<br>Because lists are a parametrised datatype with one type parameter,<br><i>list </i>is a function that takes one argument; this argument corresponds<br>to the representation of the list type argument, and <i>list </i>returns the</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:476"><nobr><span class="ft18">representation for lists. The definition is nearly the same as the<br>equivalent for GM, but it takes an extra isomorphism describing<br>the mapping between the structural representation of a list trie and<br>a newtype <i>FList c v </i>that is introduced to represent the resulting list<br>trie. The function <i>listEP </i>is just the isomorphism</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:739"><nobr><span class="ft3">[<i>a</i>] </span></nobr></DIV>
<DIV style="position:absolute;top:168;left:759"><nobr><span class="ft3">= 1 + <i>a </i>× [<i>a</i>].</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:476"><nobr><span class="ft11">This means that <i>listEP </i>can be shared with other versions of generics<br>that use the same structural cases. However, <i>list </i>and <i>FList c v </i>still<br>have to be introduced for each type-indexed datatype. Nevertheless,<br>that is boilerplate code, and, with compiler support, it is should be<br>possible to avoid writing it.</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:493"><nobr><span class="ft2">Having set up the main components of the design pattern, we</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:476"><nobr><span class="ft11">can now move on to define our first function over tries. The function<br><i>empty </i>creates a new empty trie and can be defined as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:495"><nobr><span class="ft9"><b>newtype </b><i>EmptyTrie a v t</i></span></nobr></DIV>
<DIV style="position:absolute;top:302;left:630"><nobr><span class="ft3">= <i>EmptyTrie</i>{<i>empty </i>:: <i>t v</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:495"><nobr><span class="ft9"><b>instance </b><i>FMap EmptyTrie </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:508"><nobr><span class="ft5"><i>unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:333;left:594"><nobr><span class="ft3">= <i>EmptyTrie Nothing</i></span></nobr></DIV>
<DIV style="position:absolute;top:351;left:508"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:349;left:594"><nobr><span class="ft3">= <i>EmptyTrie </i>(<i>MapInt </i>[ ])</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:508"><nobr><span class="ft5"><i>plus ra rb</i></span></nobr></DIV>
<DIV style="position:absolute;top:364;left:594"><nobr><span class="ft3">= <i>EmptyTrie </i>(<i>PlusCase Null</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:508"><nobr><span class="ft5"><i>prod ra rb</i></span></nobr></DIV>
<DIV style="position:absolute;top:380;left:595"><nobr><span class="ft3">= <i>EmptyTrie </i>(<i>ProdCase </i>(<i>empty ra</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:508"><nobr><span class="ft5"><i>data ra iso iso2</i></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:595"><nobr><span class="ft3">= <i>EmptyTrie </i>(<i>to iso2 </i>(<i>empty ra</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:476"><nobr><span class="ft11">This function is very simple but, nonetheless, it has a type-indexed<br>type: the <i>unit </i>case returns <i>Nothing</i>; the <i>int </i>case returns a value of<br>a user-defined type for integer tries; the cases for <i>prod </i>and <i>plus<br></i>return, respectively, values for the previously defined <i>ProdCase </i>and<br><i>PlusCase </i>types; finally, the <i>data </i>returns a value of the newtype used<br>to represent the trie of some user-defined datatype.</span></nobr></DIV>
<DIV style="position:absolute;top:503;left:493"><nobr><span class="ft2">Another function that we will probably want to have in a library</span></nobr></DIV>
<DIV style="position:absolute;top:518;left:476"><nobr><span class="ft11">for tries is the <i>lookUp </i>function which, given a key, returns the<br>corresponding value stored in the trie.</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:495"><nobr><span class="ft9"><b>newtype </b><i>LUp a v t</i></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:598"><nobr><span class="ft3">= <i>LUp</i>{<i>lookUp </i>:: <i>a </i> <i>t v </i> <i>Maybe v</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:495"><nobr><span class="ft9"><b>instance </b><i>FMap LUp </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:579;left:508"><nobr><span class="ft5"><i>unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:576;left:594"><nobr><span class="ft3">= <i>LUp </i>( <i>fm </i> <i>fm</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:508"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:592;left:594"><nobr><span class="ft3">= <i>LUp </i>(<i>i fm </i> <i>lookUpInt i fm</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:611;left:508"><nobr><span class="ft5"><i>plus ra rb</i></span></nobr></DIV>
<DIV style="position:absolute;top:608;left:594"><nobr><span class="ft3">= <i>LUp </i>(<i>t fm </i></span></nobr></DIV>
<DIV style="position:absolute;top:626;left:522"><nobr><span class="ft9"><b>case</b></span></nobr></DIV>
<DIV style="position:absolute;top:624;left:549"><nobr><span class="ft3">(<i>unPlus fm</i>) <b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:642;left:535"><nobr><span class="ft5"><i>Null</i></span></nobr></DIV>
<DIV style="position:absolute;top:639;left:618"><nobr><span class="ft3"> <i>Nothing</i></span></nobr></DIV>
<DIV style="position:absolute;top:655;left:535"><nobr><span class="ft3">(<i>Pair fma fmb</i>)  <b>case </b><i>t </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:671;left:629"><nobr><span class="ft3">(<i>Inl l</i>)  <i>lookUp ra l fma</i></span></nobr></DIV>
<DIV style="position:absolute;top:686;left:629"><nobr><span class="ft3">(<i>Inr r</i>)  <i>lookUp rb r fmb</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:508"><nobr><span class="ft5"><i>prod ra rb</i></span></nobr></DIV>
<DIV style="position:absolute;top:702;left:595"><nobr><span class="ft3">= <i>LUp </i>(<i>t </i>(<i>ProdCase fma</i>) </span></nobr></DIV>
<DIV style="position:absolute;top:720;left:522"><nobr><span class="ft9"><b>case </b><i>t </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:733;left:535"><nobr><span class="ft3">(<i>Prod x y</i>)  (<i>lookUp ra x lookUp rb y</i>) <i>fma</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:752;left:508"><nobr><span class="ft5"><i>data ra iso iso2</i></span></nobr></DIV>
<DIV style="position:absolute;top:749;left:595"><nobr><span class="ft3">=</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:522"><nobr><span class="ft5"><i>LUp</i></span></nobr></DIV>
<DIV style="position:absolute;top:765;left:549"><nobr><span class="ft3">(<i>t r </i> <i>lookUp ra </i>(<i>from iso t</i>) (<i>from iso2 r</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:476"><nobr><span class="ft2">(The operator</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:568"><nobr><span class="ft2">represents monadic composition.) The functions</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:476"><nobr><span class="ft11"><i>empty </i>and <i>lookUp </i>have definitions that only have generic function<br>calls to themselves. However, that is not the case for all generic<br>functions. One such function is the generic function that creates a<br>trie containing a single element; a possible definition makes use of<br>the generic function <i>empty</i>. We discussed in Section 3 that, using<br>an explicit version of the design pattern, there are some issues with<br>generic functions calling generic functions other than themselves.<br>One solution for this problem is using tupling. Just as one does<br>with a type class, we would choose a fixed set of functions and<br>group them together in a record. For instance, in the case of tries,<br>we could have the following.</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:495"><nobr><span class="ft9"><b>data </b><i>Tries a v t</i></span></nobr></DIV>
<DIV style="position:absolute;top:959;left:579"><nobr><span class="ft3">= <i>Tries</i>{</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:508"><nobr><span class="ft5"><i>empty </i>:: <i>t v</i></span></nobr></DIV>
<DIV style="position:absolute;top:975;left:574"><nobr><span class="ft3">,</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:508"><nobr><span class="ft5"><i>isempty </i>:: <i>t v</i></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:576"><nobr><span class="ft3"> <i>Bool</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:508"><nobr><span class="ft5"><i>single </i>:: <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:570"><nobr><span class="ft3"> <i>v </i> <i>t v</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:508"><nobr><span class="ft5"><i>lookup </i>:: <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:1022;left:571"><nobr><span class="ft3"> <i>t v </i> <i>Maybe v</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:1040;left:508"><nobr><span class="ft5"><i>insert </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:561"><nobr><span class="ft3">(<i>v </i> <i>v </i> <i>v</i>)  <i>a </i> <i>v </i> <i>t v </i> <i>t v</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:508"><nobr><span class="ft5"><i>merge </i>::</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:561"><nobr><span class="ft3">(<i>v </i> <i>v </i> <i>v</i>)  <i>t v </i> <i>t v </i> <i>t v</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:1072;left:508"><nobr><span class="ft5"><i>delete </i>:: <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:1069;left:570"><nobr><span class="ft3"> <i>t v </i> <i>t v</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">107</span></nobr></DIV>
</DIV>
<!-- Page 11 -->
<a name="11"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="202011.png" alt="background image">
<DIV style="position:absolute;top:110;left:81"><nobr><span class="ft11">With our definition we could, for any function in the record, make<br>mutual generic calls.</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:99"><nobr><span class="ft2">Whilst we could have used a multiple-parameter type class</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:81"><nobr><span class="ft11">with functional dependencies in order to implement this library of<br>functions over tries, there would be one important disadvantage in<br>doing so (apart from the fact that we need to leave Haskell 98):<br>we can only have functions on types of kind . With type classes,<br>contexts are implicitly passed, and there is no way to redefine those<br>implicit behaviours. In other words, type classes have the same<br>limitation as implicit representations as a version of the TypeCase<br>design pattern, in that they can only work on types. On the other<br>hand, derived from the fact that we use external representations,<br>with this implementation we can define generic functions over type<br>constructors.</span></nobr></DIV>
<DIV style="position:absolute;top:319;left:99"><nobr><span class="ft2">Tupling is not the only option to solve the problem of generic</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:81"><nobr><span class="ft11">function calls. Another possibility is to have the notion of <i>depend-<br>encies</i>: instead of tupling all functions together, we can, for each<br>generic function that we need to use, include one instance of that<br>function. Here is a possible definition of <i>single </i>using this strategy.</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:100"><nobr><span class="ft9"><b>data </b><i>Single a v t</i></span></nobr></DIV>
<DIV style="position:absolute;top:391;left:191"><nobr><span class="ft3">= <i>Single</i>{</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:114"><nobr><span class="ft5"><i>emptyT </i>:: <i>EmptyTrie a v t</i></span></nobr></DIV>
<DIV style="position:absolute;top:407;left:247"><nobr><span class="ft3">,</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:114"><nobr><span class="ft5"><i>single </i>:: <i>a</i></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:176"><nobr><span class="ft3"> <i>v </i> <i>t v</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:100"><nobr><span class="ft9"><b>instance </b><i>FMap Single </i><b>where</b></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:114"><nobr><span class="ft5"><i>unit</i></span></nobr></DIV>
<DIV style="position:absolute;top:454;left:172"><nobr><span class="ft3">= <i>Single unit </i>( <i>v </i> <i>Just v</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:114"><nobr><span class="ft5"><i>int</i></span></nobr></DIV>
<DIV style="position:absolute;top:470;left:172"><nobr><span class="ft3">= <i>Single int </i>(<i>i v </i> <i>MapInt </i>[(<i>i</i>,<i>v</i>)])</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:114"><nobr><span class="ft5"><i>plus ra rb</i></span></nobr></DIV>
<DIV style="position:absolute;top:485;left:172"><nobr><span class="ft3">= <i>Single </i>(<i>plus </i>(<i>emptyT ra</i>) (<i>emptyT rb</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:127"><nobr><span class="ft3">(<i>i v </i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:141"><nobr><span class="ft9"><b>case </b><i>i </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:535;left:154"><nobr><span class="ft5"><i>Inl l</i></span></nobr></DIV>
<DIV style="position:absolute;top:532;left:179"><nobr><span class="ft3"> <i>PlusCase </i>(<i>Pair </i>(<i>single ra l v</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:284"><nobr><span class="ft3">(<i>empty </i>(<i>emptyT rb</i>)))</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:154"><nobr><span class="ft5"><i>Inr r</i></span></nobr></DIV>
<DIV style="position:absolute;top:564;left:183"><nobr><span class="ft3"> <i>PlusCase </i>(<i>Pair </i>(<i>empty </i>(<i>emptyT ra</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:284"><nobr><span class="ft3">(<i>single rb r v</i>)))</span></nobr></DIV>
<DIV style="position:absolute;top:598;left:114"><nobr><span class="ft5"><i>prod ra rb</i></span></nobr></DIV>
<DIV style="position:absolute;top:595;left:172"><nobr><span class="ft3">= <i>Single </i>(<i>prod </i>(<i>emptyT ra</i>) (<i>emptyT rb</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:611;left:127"><nobr><span class="ft3">(<i>i v </i></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:141"><nobr><span class="ft9"><b>case </b><i>i </i><b>of</b></span></nobr></DIV>
<DIV style="position:absolute;top:645;left:154"><nobr><span class="ft5"><i>Prod x y</i></span></nobr></DIV>
<DIV style="position:absolute;top:642;left:202"><nobr><span class="ft3"> <i>ProdCase </i>(<i>single ra x </i>(<i>single rb y v</i>)))</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:114"><nobr><span class="ft5"><i>data ra iso iso2</i></span></nobr></DIV>
<DIV style="position:absolute;top:658;left:200"><nobr><span class="ft3">= <i>Single </i>(<i>data </i>(<i>emptyT ra</i>) <i>iso iso2</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:127"><nobr><span class="ft3">(<i>i v </i> <i>to iso2 </i>(<i>single ra </i>(<i>from iso i</i>) <i>v</i>))</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:81"><nobr><span class="ft11">The idea of dependencies is motivated by Dependency-Style Gen-<br>eric Haskell [26, 27]. In this version of Generic Haskell, the type<br>system reflects the uses of generic functions in the definitions by<br>keeping track of constraints that identify such uses. With this defin-<br>ition, we have to manually introduce those dependencies by adding<br>extra fields to the record that keep track of all the functions on<br>which the definition depends. That change is also reflected in the<br>instance that defines the generic function, where we need to provide<br>values for the extra fields; the values for those fields just reconstruct<br>the dependent functions with their values for those fields.</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:81"><nobr><span class="ft4"><b>6. Discussion and conclusions</b></span></nobr></DIV>
<DIV style="position:absolute;top:880;left:81"><nobr><span class="ft11">The goal of design patterns is not to come up with a miraculous<br>solution for a problem. Instead, design patterns capture good tech-<br>niques that appear in the literature or in practice, in a variety of<br>contexts, and document them to make them easier to identify and<br>implement. In this paper we have generalised the technique found<br>in LIGD and GM to a design pattern, and presented a number of<br>applications of the pattern. Furthermore, we have identified other<br>occurrences of the design pattern in the literature.</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:81"><nobr><span class="ft9"><b>6.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:111"><nobr><span class="ft9"><b>Related work</b></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:81"><nobr><span class="ft11">The technique used by Danvy [10] and generalised by Yang [37]<br>allows us to encode <i>type-indexed values </i>in a Hindley-Milner type<br>system. This encoding is directly related to the explicit represent-<br>ation version of the TypeCase pattern. This technique influenced</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:476"><nobr><span class="ft11">many other works, ranging from type-directed partial evaluation<br>[37, 9, 12], through embedded interpreters [2], to a generalisation<br>of families of functions like <i>zipWith </i>[13] -- these are all possible<br>applications of the TypeCase design pattern. Our paper revises that<br>technique and shows how slightly richer type systems can be used<br>to improve it. In particular, the use of a <i>dispatcher </i>makes it pos-<br>sible to automatically built the values encoding types. Moreover,<br>the issue of <i>composability </i>(identified by Yang), while still a prob-<br>lem, can benefit from stronger type systems: the use of rank-two<br>types combined with type classes provides a good solution.</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:493"><nobr><span class="ft2">The work on <i>extensional polymorphism </i>[11] presents an ap-</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:476"><nobr><span class="ft11">proach that allows functions to implicitly bind the types of their<br>arguments in a modified version of ML. Furthermore, using a<br><i>typecase </i>construct it is possible to support generic programming.<br>Harper and Morrisett's work on <i>intensional type analysis </i>[16]<br>presents an intermediate language where run-time type analysis is<br>permitted, using <i>typecase </i>and <i>Typecase </i>constructs to define type-<br>indexed functions and type-indexed types, respectively. However,<br>approaches based on run-time type analysis have important draw-<br>backs; for instance, they cannot support abstract datatypes, and<br>they do not respect the parametricity theorem [35, 33]. Subsequent<br>approaches to intensional type analysis by Crary and others [7, 6]<br>use a type-erasure semantics that does not suffer from those prob-<br>lems. Still, those approaches were limited to first-order type ana-<br>lysis. More recently, Weirich [36] proposed a version of intensional<br>type analysis covering higher-order types with a type-erasure se-<br>mantics. Furthermore, she presented an implementation in Haskell<br>(augmented with rank-two types). This work inspired Hinze's im-<br>plementation of GM, which shows, in essence, how to avoid rank-<br>two types by using Haskell's class system. Our work makes use<br>of those results and explains how to simulate <i>typecase </i>constructs.<br>Furthermore, we show that the limitation of GM that generic func-<br>tions with generic types cannot be defined can be lifted with our<br>more general interpretation.</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:493"><nobr><span class="ft2">Generic programming (or perhaps datatype-generic program-</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:476"><nobr><span class="ft11">ming [15]) is about defining functions and types that depend on<br>the structure of other types. One of the first attempts to produce<br>a generic programming language was PolyP [21]. This language<br>allowed the definition of generic functions over regular datatypes<br>with one type parameter. In Section 4.1 we show that, using our<br>design pattern, it is possible to define PolyP-like generic functions<br>just using Haskell 98. A previous attempt [30] to define first-class<br>PolyP functions in Haskell required extensions to the language.<br>The Generic Haskell [26, 5] project is more ambitious than PolyP,<br>and aims at defining generic functions for nearly all types defin-<br>able in Haskell 98. Furthermore, Generic Haskell features generic<br>types and generic function customisation (which were not present<br>in PolyP). Dependency-Style Generic Haskell [26, 27] introduces<br>a rather complex type system that keeps track of dependencies on<br>generic function calls. The need for this sophisticated type system<br>is a consequence of a model for generic programming that allows<br>generic function customisation. The approach presented in [24] is<br>another kind of lightweight approach to generic programming, re-<br>lying on a run-time type-safe cast operator. With that operator it is<br>possible to define a number of traversals that allow a very interest-<br>ing model of generic programming based on nominal typing. Our<br>design pattern can be used to encode many of the generic defini-<br>tions that these generic programming techniques allow. However,<br>it can be less practical than approaches providing a special-purpose<br>compiler. Nevertheless, the advantage of our technique is that we<br>do not need to commit in advance to a model of generic program-<br>ming: we have the freedom to choose our own model of generic<br>programming.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:493"><nobr><span class="ft2">Design patterns in the object-oriented programming community</span></nobr></DIV>
<DIV style="position:absolute;top:1066;left:476"><nobr><span class="ft2">have been given a great deal of attention. Whilst amongst the</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">108</span></nobr></DIV>
</DIV>
<!-- Page 12 -->
<a name="12"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft27{font-size:9px;font-family:Times;color:#000000;}
	.ft28{font-size:9px;font-family:Times;color:#000000;}
	.ft29{font-size:9px;line-height:16px;font-family:Times;color:#000000;}
	.ft30{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
	.ft31{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
	.ft32{font-size:9px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="202012.png" alt="background image">
<DIV style="position:absolute;top:110;left:81"><nobr><span class="ft11">functional programming community there has been some work<br>on -- or, at least, involving the concept of -- design patterns<br>[24, 23, 25], the concept is still much less popular than in the object-<br>oriented community. Moreover, most of this work presents patterns<br>that are really more like algorithmic patterns rather than design<br>patterns. Perhaps the reason why this happens is that functional<br>languages are very expressive, and often natural features of those<br>languages, such as laziness or higher-order functions, can be used<br>to remove the need for complex designs. Nevertheless, we believe<br>that our design pattern is more related to the OO concept of a design<br>pattern with type classes/datatypes taking the role of OO interfaces<br>and class instances taking the role of OO concrete classes. One<br>difficulty found in this work had to do with the fact that, unlike<br>OO design patterns which are documented using informal notations<br>such as UML, we do not have a notation to "talk" about the design<br>of Haskell programs. The notation that we used is quite ad-hoc and<br>it can be difficult to read.</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:81"><nobr><span class="ft9"><b>6.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:375;left:111"><nobr><span class="ft9"><b>Future work</b></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:81"><nobr><span class="ft11">We mentioned that this design pattern seems to be very similar to<br>OO design patterns. It would be interesting to explore the applic-<br>ability of this design pattern in an OO environment.</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:99"><nobr><span class="ft2">Design patterns are useful to overcome the lack of certain fea-</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:81"><nobr><span class="ft11">tures in programming languages. In our case, we overcome the<br>lack of a <i>typecase </i>construct. The work on intensional type analysis<br>investigates the possibility of languages supporting <i>typecase </i>con-<br>structs directly in the language. Combining these results in order to<br>extend Haskell with a more natural support for <i>typecase </i>program-<br>ming is something we would like to try in the future.</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:99"><nobr><span class="ft2">Problems that use multiple instances of the design pattern are</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:81"><nobr><span class="ft11">not composable. For instance, in a generic programming context,<br>we could have a class <i>Generic </i>that allowed us to define generic<br>functions with one type parameter; and we could also have a class<br><i>FMap </i>for working with tries. Although, those classes are structured<br>in a similar way, they require two distinct representations of types,<br>one for each of the classes; we hope to address this impracticality.</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:81"><nobr><span class="ft9"><b>Acknowledgements</b></span></nobr></DIV>
<DIV style="position:absolute;top:683;left:81"><nobr><span class="ft11">We would like to thank Ralf Hinze for the discussion that inspired<br>this paper. Stefan Holdermans, the anonymous referees and the<br>members of the <i>Algebra of Programming </i>group at Oxford and<br>the EPSRC-funded <i>Datatype-Generic Programming </i>project made<br>a number of helpful suggestions.</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:81"><nobr><span class="ft4"><b>References</b></span></nobr></DIV>
<DIV style="position:absolute;top:797;left:89"><nobr><span class="ft29">[1] C. Alexander. <i>A Pattern Language</i>. Oxford University Press, 1977.<br>[2] N. Benton. Embedded interpreters. Microsoft Research, Cambridge,</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:109"><nobr><span class="ft27">Jan. 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:89"><nobr><span class="ft27">[3] R. Bird and O. de Moor. <i>Algebra of Programming</i>. International</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:109"><nobr><span class="ft27">Series in Computer Science. Prentice Hall, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:873;left:89"><nobr><span class="ft27">[4] J. Cheney and R. Hinze. A lightweight implementation of generics</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:109"><nobr><span class="ft27">and dynamics. In <i>Haskell Workshop</i>, pages 90­104, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:89"><nobr><span class="ft27">[5] D. Clarke and A. Löh. Generic Haskell, specifically. In <i>Generic</i></span></nobr></DIV>
<DIV style="position:absolute;top:917;left:109"><nobr><span class="ft28"><i>Programming</i>, pages 21­47. Kluwer, B.V., 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:89"><nobr><span class="ft27">[6] K. Crary and S. Weirich. Flexible type analysis. In <i>International</i></span></nobr></DIV>
<DIV style="position:absolute;top:946;left:109"><nobr><span class="ft28"><i>Conference on Functional Programming</i>, pages 233­248, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:89"><nobr><span class="ft27">[7] K. Crary, S. Weirich, and J. G. Morrisett. Intensional polymorphism</span></nobr></DIV>
<DIV style="position:absolute;top:976;left:109"><nobr><span class="ft30">in type-erasure semantics. In <i>International Conference on Functional<br>Programming</i>, pages 301­312, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:89"><nobr><span class="ft27">[8] N. A. Danielsson and P. Jansson. Chasing bottoms: A case study in</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:109"><nobr><span class="ft31">program verification in the presence of partial and infinite values. In<br>D. Kozen, editor, <i>LNCS 3125: Mathematics of Program Construction</i>,<br>pages 85­109. Springer-Verlag, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:1063;left:89"><nobr><span class="ft27">[9] O. Danvy. Type-directed partial evaluation.</span></nobr></DIV>
<DIV style="position:absolute;top:1063;left:343"><nobr><span class="ft27">In <i>Principles of</i></span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:109"><nobr><span class="ft28"><i>Programming Languages</i>, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:478"><nobr><span class="ft27">[10] O. Danvy. Functional unparsing. <i>Journal of Functional Program-</i></span></nobr></DIV>
<DIV style="position:absolute;top:125;left:503"><nobr><span class="ft28"><i>ming</i>, 8(6):621­625, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:478"><nobr><span class="ft27">[11] C. Dubois, F. Rouaix, and P. Weis. Extensional polymorphism. In</span></nobr></DIV>
<DIV style="position:absolute;top:154;left:503"><nobr><span class="ft28"><i>Principles of Programming Languages</i>, pages 118­129, 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:478"><nobr><span class="ft27">[12] P. Dybjer and A. Filinski. Normalization and partial evaluation. In</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:503"><nobr><span class="ft28"><i>LNCS 2395: Applied Semantics</i>, pages 137­192. Springer, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:478"><nobr><span class="ft27">[13] D. Fridlender and M. Indrika. Do we need dependent types? <i>Journal</i></span></nobr></DIV>
<DIV style="position:absolute;top:214;left:503"><nobr><span class="ft28"><i>of Functional Programming</i>, 10(4):409­415, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:478"><nobr><span class="ft27">[14] J. Gibbons. Calculating functional programs. In <i>Algebraic and</i></span></nobr></DIV>
<DIV style="position:absolute;top:244;left:503"><nobr><span class="ft31"><i>Coalgebraic Methods in the Mathematics of Program Construction</i>,<br>pages 149­202, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:478"><nobr><span class="ft27">[15] J. Gibbons. Patterns in datatype-generic programming. In <i>Declarative</i></span></nobr></DIV>
<DIV style="position:absolute;top:287;left:503"><nobr><span class="ft28"><i>Programming in the Context of Object-Oriented Languages</i>, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:478"><nobr><span class="ft27">[16] R. Harper and G. Morrisett.</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:658"><nobr><span class="ft27">Compiling polymorphism using</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:503"><nobr><span class="ft31">intensional type analysis. In <i>Principles of Programming Languages</i>,<br>pages 130­141, San Francisco, California, 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:478"><nobr><span class="ft27">[17] R. Hinze. Generalizing generalized tries. <i>Journal of Functional</i></span></nobr></DIV>
<DIV style="position:absolute;top:361;left:503"><nobr><span class="ft28"><i>Programming</i>, 10(4):327­351, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:478"><nobr><span class="ft27">[18] R. Hinze. Fun with phantom types. In J. Gibbons and O. de Moor,</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:503"><nobr><span class="ft27">editors, <i>The Fun of Programming</i>, pages 245­262. Palgrave, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:478"><nobr><span class="ft27">[19] R. Hinze. Generics for the masses. In <i>International Conference on</i></span></nobr></DIV>
<DIV style="position:absolute;top:420;left:503"><nobr><span class="ft28"><i>Functional Programming</i>, pages 236­243. ACM Press, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:478"><nobr><span class="ft27">[20] R. Hinze, J. Jeuring, and A. Löh. Type-indexed data types. <i>Science</i></span></nobr></DIV>
<DIV style="position:absolute;top:450;left:503"><nobr><span class="ft28"><i>of Computer Programming</i>, 51(1-2):117­151, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:478"><nobr><span class="ft27">[21] P. Jansson. <i>Functional Polytypic Programming</i>. PhD thesis, Chalmers</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:503"><nobr><span class="ft27">University of Technology, May 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:497;left:478"><nobr><span class="ft27">[22] J. Jeuring and P. Jansson. Polytypic programming. In J. Launchbury,</span></nobr></DIV>
<DIV style="position:absolute;top:510;left:503"><nobr><span class="ft30">E. Meijer, and T. Sheard, editors, <i>LNCS 1129: Advanced Functional<br>Programming</i>, pages 68­114. Springer-Verlag, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:478"><nobr><span class="ft27">[23] T. Kühne. <i>A Functional Pattern System for Object-Oriented Design</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:503"><nobr><span class="ft27">Verlag Dr. Kovac, ISBN 3-86064-770-9, Hamburg, Germany, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:478"><nobr><span class="ft27">[24] R. Lämmel and S. Peyton Jones. Scrap your boilerplate: a practical</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:503"><nobr><span class="ft30">design pattern for generic programming. In <i>Types in Language Design<br>and Implementation</i>, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:478"><nobr><span class="ft27">[25] R. Lämmel and J. Visser. Design patterns for functional strategic</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:503"><nobr><span class="ft27">programming. In <i>Workshop on Rule-Based Programming</i>, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:478"><nobr><span class="ft27">[26] A. Löh. <i>Exploring Generic Haskell</i>. PhD thesis, Utrecht University,</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:503"><nobr><span class="ft27">2004.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:478"><nobr><span class="ft27">[27] A. Löh, D. Clarke, and J. Jeuring. Dependency-style Generic Haskell.</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:503"><nobr><span class="ft31">In <i>International Conference on Functional Programming</i>, pages 141­<br>152, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:478"><nobr><span class="ft27">[28] E. Meijer, M. Fokkinga, and R. Paterson. Functional programming</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:503"><nobr><span class="ft31">with bananas, lenses, envelopes and barbed wire. In <i>LNCS 523:<br>Functional Programming Languages and Computer Architecture</i>,<br>pages 124­144. Springer-Verlag, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:478"><nobr><span class="ft27">[29] D. Menendez. Fixed-length vectors in Haskell. http://www.</span></nobr></DIV>
<DIV style="position:absolute;top:788;left:503"><nobr><span class="ft19">haskell.org/pipermail/haskell/2005-May/015815.html</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:820"><nobr><span class="ft27">.</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:478"><nobr><span class="ft27">[30] U. Norell and P. Jansson. Polytypic programming in Haskell. In</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:503"><nobr><span class="ft28"><i>Implementing Functional Languages</i>, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:478"><nobr><span class="ft27">[31] S. Peyton Jones, editor. <i>Haskell 98 Language and Libraries: The</i></span></nobr></DIV>
<DIV style="position:absolute;top:846;left:503"><nobr><span class="ft28"><i>Revised Report</i>. Cambridge University Press, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:478"><nobr><span class="ft27">[32] S. Peyton Jones, G. Washburn, and S. Weirich. Wobbly types: Type</span></nobr></DIV>
<DIV style="position:absolute;top:876;left:503"><nobr><span class="ft31">inference for generalised algebraic data types. Microsoft Research,<br>Cambridge, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:906;left:478"><nobr><span class="ft27">[33] J. C. Reynolds. Types, abstraction and parametric polymorphism. In</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:503"><nobr><span class="ft28"><i>Information Processing 83</i>, pages 513­523. Elsevier, 1983.</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:478"><nobr><span class="ft27">[34] P. Wadler. Views: a way for pattern matching to cohabit with data</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:503"><nobr><span class="ft31">abstraction. In <i>Principles of Programming Languages</i>, pages 307­<br>313. ACM Press, 1987.</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:478"><nobr><span class="ft27">[35] P. Wadler. Theorems for free! In <i>Functional Programming and</i></span></nobr></DIV>
<DIV style="position:absolute;top:993;left:503"><nobr><span class="ft28"><i>Computer Architecture</i>, 1989.</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:478"><nobr><span class="ft27">[36] S. Weirich. Higher-order intensional type analysis in type-erasure</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:503"><nobr><span class="ft32">semantics. http://www.cis.upenn.edu/~sweirich/papers/<br>erasure/erasure-paper-july03.pdf</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:707"><nobr><span class="ft27">, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:478"><nobr><span class="ft27">[37] Z. Yang. Encoding types in ML-like languages. In <i>International</i></span></nobr></DIV>
<DIV style="position:absolute;top:1066;left:503"><nobr><span class="ft28"><i>Conference on Functional Programming</i>, pages 289­300, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft2">109</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
