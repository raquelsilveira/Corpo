<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>paper.dvi</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2004-08-26T20:07:47+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:22px;font-family:Helvetica;color:#000000;}
	.ft1{font-size:14px;font-family:Helvetica;color:#000000;}
	.ft2{font-size:11px;font-family:Helvetica;color:#000000;}
	.ft3{font-size:15px;font-family:Times;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:11px;font-family:Times;color:#000000;}
	.ft6{font-size:11px;font-family:Times;color:#000000;}
	.ft7{font-size:11px;font-family:Courier;color:#000000;}
	.ft8{font-size:8px;font-family:Times;color:#000000;}
	.ft9{font-size:11px;font-family:Times;color:#000000;}
	.ft10{font-size:16px;font-family:Courier;color:#000000;}
	.ft11{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft12{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft13{font-size:8px;line-height:11px;font-family:Times;color:#000000;}
	.ft14{font-size:8px;line-height:12px;font-family:Times;color:#000000;}
	.ft15{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft16{font-size:11px;line-height:14px;font-family:Courier;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="107001.png" alt="background image">
<DIV style="position:absolute;top:135;left:143"><nobr><span class="ft0"><b>Improving the Static Analysis of Embedded Languages</b></span></nobr></DIV>
<DIV style="position:absolute;top:162;left:338"><nobr><span class="ft0"><b>via Partial Evaluation</b></span></nobr></DIV>
<DIV style="position:absolute;top:223;left:236"><nobr><span class="ft1">David Herman</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:204"><nobr><span class="ft1">dherman@ccs.neu.edu</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:570"><nobr><span class="ft1">Philippe Meunier</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:549"><nobr><span class="ft1">meunier@ccs.neu.edu</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:323"><nobr><span class="ft2">College of Computer and Information Science</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:388"><nobr><span class="ft2">Northeastern University</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:366"><nobr><span class="ft2">360 Huntington Ave #202 WVH</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:404"><nobr><span class="ft2">Boston, MA 02115</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:81"><nobr><span class="ft3"><b>Abstract</b></span></nobr></DIV>
<DIV style="position:absolute;top:399;left:81"><nobr><span class="ft11">Programs in embedded languages contain invariants that are not au-<br>tomatically detected or enforced by their host language. We show<br>how to use macros to easily implement partial evaluation of embed-<br>ded interpreters in order to capture invariants encoded in embedded<br>programs and render them explicit in the terms of their host lan-<br>guage. We demonstrate the effectiveness of this technique in im-<br>proving the results of a value flow analysis.</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:81"><nobr><span class="ft3"><b>Categories and Subject Descriptors</b></span></nobr></DIV>
<DIV style="position:absolute;top:555;left:81"><nobr><span class="ft11">D.2.5 [<b>Software Engineering</b>]: Testing and Debugging--<i>debug-<br>ging aids</i>; D.3.3 [<b>Programming Languages</b>]: Language Con-<br>structs and Features--<i>macros</i>; D.3.4 [<b>Programming Languages</b>]:<br>Processors--<i>code generation, debuggers, interpreters</i></span></nobr></DIV>
<DIV style="position:absolute;top:633;left:81"><nobr><span class="ft3"><b>General Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:666;left:81"><nobr><span class="ft4">Reliability, Languages</span></nobr></DIV>
<DIV style="position:absolute;top:699;left:81"><nobr><span class="ft3"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:732;left:81"><nobr><span class="ft11">Partial evaluation, macros, embedded languages, value flow analy-<br>sis</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:81"><nobr><span class="ft3"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:780;left:108"><nobr><span class="ft3"><b>One Language, Many Languages</b></span></nobr></DIV>
<DIV style="position:absolute;top:813;left:81"><nobr><span class="ft11">Every practical programming language contains small program-<br>ming languages. For example, C's</span></nobr></DIV>
<DIV style="position:absolute;top:829;left:274"><nobr><span class="ft7">printf</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:320"><nobr><span class="ft4">[18] supports a string-</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:81"><nobr><span class="ft11">based output formatting language, and Java [3] supports a declara-<br>tive sub-language for laying out GUI elements in a window. PLT<br>Scheme [9] offers at least five such languages: one for formatting<br>console output; two for regular expression matching; one for send-<br>ing queries to a SQL server; and one for laying out HTML pages.</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:81"><nobr><span class="ft14">Permission to make digital or hard copies of all or part of this work for personal or<br>classroom use is granted without fee provided that copies are not made or distributed<br>for profit or commercial advantage and that copies bear this notice and the full citation<br>on the first page. To copy otherwise, to republish, to post on servers or to redistribute<br>to lists, requires prior specific permission and/or a fee.<br>ICFP'04, September 19­21, 2004, Snowbird, Utah, USA.<br>Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:477"><nobr><span class="ft11">In many cases, though not always, programs in these embedded<br>special-purpose programming languages are encoded as strings. Li-<br>brary functions consume these strings and interpret them. Often the<br>interpreters consume additional arguments, which they use as in-<br>puts to the little programs.</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:477"><nobr><span class="ft4">Take a look at this expression in PLT Scheme:</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:491"><nobr><span class="ft7">(regexp-match &quot;http://([a-z.]*)/([a-z]*)/&quot; line)</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:477"><nobr><span class="ft4">The function</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:553"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:640"><nobr><span class="ft4">is an <i>interpreter </i>for the regular ex-</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:477"><nobr><span class="ft11">pression language. It consumes two arguments: a string in the regu-<br>lar expression language, which we consider a program, and another<br>string, which is that program's input. A typical use looks like the<br>example above. The first string is actually specified at the call site,<br>while the second string is often given by a variable or an expression<br>that reads from an input port. The interpreter attempts to match the<br>regular expression and the second string.</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:477"><nobr><span class="ft15">In PLT Scheme, the regular expression language allows program-<br>mers to specify subpatterns via parentheses. Our running example<br>contains two such subexpressions:</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:671"><nobr><span class="ft7">([a-z.]*)</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:738"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:762"><nobr><span class="ft7">([a-z]*)</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:816"><nobr><span class="ft4">. If</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:477"><nobr><span class="ft11">the regular expression interpreter fails to match the regular expres-<br>sion and the string, it produces false (</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:684"><nobr><span class="ft7">#f</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:697"><nobr><span class="ft4">); otherwise it produces a</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:477"><nobr><span class="ft4">list with <i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:717;left:532"><nobr><span class="ft9">+ 1 elements: the first one for the overall match plus one</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:477"><nobr><span class="ft4">per subexpression. Say</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:604"><nobr><span class="ft7">line</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:635"><nobr><span class="ft4">stands for</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:491"><nobr><span class="ft7">&quot;http://aaa.bbb.edu/zzz/&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:477"><nobr><span class="ft4">In this case, the regular expression matches the string, and</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:477"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:562"><nobr><span class="ft4">produces the list</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:491"><nobr><span class="ft7">(list &quot;http://aaa.bbb.edu/zzz/&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:846;left:532"><nobr><span class="ft16">&quot;aaa.bbb.edu&quot;<br>&quot;zzz&quot;)</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:477"><nobr><span class="ft11">The rest of the Scheme program extracts the pieces from this list<br>and computes with them.</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:477"><nobr><span class="ft4">The</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:502"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:588"><nobr><span class="ft4">expression above is a simplified excerpt from</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:477"><nobr><span class="ft4">the PLT Web Server [12]. Here is a slightly larger fragment:</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:491"><nobr><span class="ft7">(let ([r (regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:989;left:580"><nobr><span class="ft7">&quot;http://([a-z.]*)/([a-z]*)/&quot; line)])</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:497"><nobr><span class="ft7">(if r</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:511"><nobr><span class="ft16">(process-url (third r) (dispatch (second r)))<br>(log-error line)))</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:477"><nobr><span class="ft4">Notice how the then-clause of the</span></nobr></DIV>
<DIV style="position:absolute;top:1060;left:657"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:671"><nobr><span class="ft4">-expression extracts the second</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">16</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107002.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft4">and third elements from</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:212"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:222"><nobr><span class="ft4">without any checks to confirm the length</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:81"><nobr><span class="ft4">of the list. After all, the programmer knows that if</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:366"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:377"><nobr><span class="ft4">is not false,</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:81"><nobr><span class="ft11">then it is a list of three elements. The embedded program says so;<br>it is a regular expression and contains two subexpressions.</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:81"><nobr><span class="ft11">Unfortunately, the static analysis tools for PLT Scheme cannot<br>reason on both levels.</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:224"><nobr><span class="ft4">MrFlow [20], a static debugger, uses</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:81"><nobr><span class="ft11">a constraint-based analysis [22], a version of set-based analy-<br>sis [2, 13, 10], to analyze the program and discover potential er-<br>rors. If it finds one it can draw a flow graph from the source of the<br>bad value to the faulty primitive operation. For the</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:358"><nobr><span class="ft7">let</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:379"><nobr><span class="ft4">-expression</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:81"><nobr><span class="ft4">above, MrFlow finds that both</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:254"><nobr><span class="ft7">(second r)</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:327"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:351"><nobr><span class="ft7">(third r)</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:418"><nobr><span class="ft4">may</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:81"><nobr><span class="ft4">raise runtime errors because</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:236"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:246"><nobr><span class="ft4">may not contain enough elements.</span></nobr></DIV>
<DIV style="position:absolute;top:323;left:81"><nobr><span class="ft11">In this paper, we show how using Scheme macros to partially eval-<br>uate calls to embedded interpreters such as</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:318"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:338;left:404"><nobr><span class="ft4">greatly</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:81"><nobr><span class="ft11">increases the precision of the static analysis. Since we use macros,<br>library designers can easily implement the partial evaluation, rather<br>than relying on the host language implementor as they must for ad-<br>hoc solutions.</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:81"><nobr><span class="ft11">In Section 2 we give a brief overview of set-based analysis and Mr-<br>Flow. In the next section we explain three examples of embedded<br>languages and the problems they cause for MrFlow's static anal-<br>ysis. We then present in Section 4 our general approach to solv-<br>ing those problems, based on macros. An overview of the macro<br>system we use is given in Section 5. Section 6 then presents a gen-<br>eral technique for translating embedded interpreters into macros. In<br>Section 7, we explain the properties of the static analysis that en-<br>able it to find more results in partially evaluated code. Finally, in<br>Section 8, we show how partially evaluating Scheme programs that<br>contain embedded programs helps MrFlow in our three examples.<br>Section 9 presents related work and we conclude in Section 10.</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:81"><nobr><span class="ft3"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:635;left:108"><nobr><span class="ft3"><b>Set-Based Analysis</b></span></nobr></DIV>
<DIV style="position:absolute;top:667;left:81"><nobr><span class="ft11">To explain how the results of a static analysis can be improved by<br>using partial evaluation of embedded languages, we first need to<br>describe such an analysis. MrFlow, a static analyzer for DrScheme,<br>uses a set-based value flow analysis to compute an approximation<br>of the values that each subexpression of a program might evaluate to<br>at runtime [22]. The approximation computed for each expression<br>is a set of abstract values that can be displayed on demand. The<br>debugger can also draw arrows showing the flow of values through<br>the program.</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:81"><nobr><span class="ft11">Figure 1 displays an example of analyzing a simple program.<br>In the box next to the term</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:239"><nobr><span class="ft7">3</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:251"><nobr><span class="ft4">is the abstract value for that term,</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:81"><nobr><span class="ft4">meaning that at runtime the term</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:266"><nobr><span class="ft7">3</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:278"><nobr><span class="ft4">might evaluate to the value 3.</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:81"><nobr><span class="ft4">The arrow starting from the term</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:262"><nobr><span class="ft7">3</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:273"><nobr><span class="ft4">shows that at runtime the value</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:81"><nobr><span class="ft4">3 might flow into the argument</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:254"><nobr><span class="ft7">x</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:265"><nobr><span class="ft4">of the function</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:349"><nobr><span class="ft7">f</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:360"><nobr><span class="ft4">and from there</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:81"><nobr><span class="ft4">flow into the reference to the variable</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:295"><nobr><span class="ft7">x</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:307"><nobr><span class="ft4">in the body of</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:391"><nobr><span class="ft7">f</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:397"><nobr><span class="ft4">. There</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:81"><nobr><span class="ft4">is a second reference to</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:221"><nobr><span class="ft7">x</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:233"><nobr><span class="ft4">in</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:249"><nobr><span class="ft7">f</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:256"><nobr><span class="ft4">--the corresponding arrow is not</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:81"><nobr><span class="ft11">shown in this example. In the box next to the call to the Scheme<br>primitive</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:133"><nobr><span class="ft7">gcd</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:158"><nobr><span class="ft4">is the abstract value for the result of that call. Since</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:81"><nobr><span class="ft11">the analysis never tries to evaluate expressions, it uses the abstract<br>value <i>integer </i>to represent the result of the primitive call, if any,<br>which is a conservative approximation of the actual value that that<br>call might compute at runtime.</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:81"><nobr><span class="ft4">The biggest box displays the type of the adjacent</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:362"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:376"><nobr><span class="ft4">-expression,</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:81"><nobr><span class="ft4">which is the union of the <i>integer </i>abstract value computed by the</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:420"><nobr><span class="ft7">gcd</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:81"><nobr><span class="ft11">primitive and of the string <i>"hello"</i>. Arrows show that the result of<br>the</span></nobr></DIV>
<DIV style="position:absolute;top:1072;left:101"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:114"><nobr><span class="ft4">-expression can come from both the then- and else-branches:</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft4">the analysis does not attempt to apply the</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:702"><nobr><span class="ft7">number?</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:754"><nobr><span class="ft4">predicate to the</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:477"><nobr><span class="ft4">variable</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:524"><nobr><span class="ft7">x</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:531"><nobr><span class="ft4">, so it conservatively assumes that both branches of the</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:477"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:490"><nobr><span class="ft4">-expression may be evaluated at runtime.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:477"><nobr><span class="ft3"><b>3</b></span></nobr></DIV>
<DIV style="position:absolute;top:212;left:504"><nobr><span class="ft3"><b>Three Embedded Languages</b></span></nobr></DIV>
<DIV style="position:absolute;top:245;left:477"><nobr><span class="ft11">We now turn to embedded languages, which are a useful technique<br>for establishing abstraction layers for a particular design space.<br>Functional languages are well-suited to writing interpreters for em-<br>bedded languages, in which the higher-level embedded language is<br>implemented as a set of functions in the general purpose host lan-<br>guage and has access to all of its features [15, 16, 24]. But these<br>abstractions come at a cost for program analysis. In particular, tools<br>built to examine programs of the host language cannot derive infor-<br>mation for the programs in the embedded languages because they<br>do not understand the semantics of those languages.</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:477"><nobr><span class="ft11">In this section we demonstrate three examples of practical embed-<br>ded languages for Scheme and show their negative effects on static<br>analysis. In the first example, properties of the embedded language<br>create the possibility of errors that can go undetected by the analy-<br>sis. In the next two examples, undetected properties lead to analyses<br>that are too conservative, resulting in many false positives; that is,<br>the analysis reports errors that can never actually occur.</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:477"><nobr><span class="ft3"><b>3.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:567;left:517"><nobr><span class="ft3"><b>Format Strings</b></span></nobr></DIV>
<DIV style="position:absolute;top:599;left:477"><nobr><span class="ft4">The PLT Scheme library provides a</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:669"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:714"><nobr><span class="ft4">function, similar to C's</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:477"><nobr><span class="ft7">sprintf</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:525"><nobr><span class="ft4">, which generates a string given a format specifier and a</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:477"><nobr><span class="ft15">variable number of additional arguments. The format specifier is<br>a string containing some combination of literal text and formatting<br>tags. These tags are interpreted along with the remaining arguments<br>to construct a formatted string. The</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:686"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:732"><nobr><span class="ft4">function is thus an</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:477"><nobr><span class="ft11">interpreter for the format specifier language. The format specifier<br>is a program in this language and the additional arguments are its<br>inputs.</span></nobr></DIV>
<DIV style="position:absolute;top:749;left:477"><nobr><span class="ft4">To construct its output, the</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:631"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:749;left:677"><nobr><span class="ft4">function requires the number</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:477"><nobr><span class="ft11">of extra arguments to match the number of format tags, and these<br>arguments must be of the appropriate type. Consider the example<br>of displaying an ASCII character and its encoding in hexadecimal:</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:491"><nobr><span class="ft7">(format &quot;~c = 0x~x&quot; c n)</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:477"><nobr><span class="ft4">In this example, the format specifier, which contains the format tags</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:477"><nobr><span class="ft7">&quot;~c&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:509"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:533"><nobr><span class="ft7">&quot;~x&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:565"><nobr><span class="ft4">and some literal text, expects to consume exactly</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:477"><nobr><span class="ft15">two arguments. These arguments must be a character and an in-<br>teger, respectively. An incorrect number of arguments or a type<br>mismatch results in a runtime error.</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:477"><nobr><span class="ft11">Unfortunately analysis tools for Scheme such as MrFlow have no<br><i>a priori </i>knowledge of the semantics of embedded languages. The<br>analysis cannot infer any information about the dependencies be-<br>tween the contents of the format string and the rest of the arguments<br>without knowledge of the syntax and semantics of the</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:771"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:816"><nobr><span class="ft4">lan-</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:477"><nobr><span class="ft11">guage. As a result the analysis cannot predict certain categories of<br>runtime errors, as shown in Figure 2. The application of</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:783"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:828"><nobr><span class="ft4">is</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:477"><nobr><span class="ft11">not underlined as an error, even though its arguments appear in the<br>wrong order and the analysis correctly computes the types of both</span></nobr></DIV>
<DIV style="position:absolute;top:1072;left:477"><nobr><span class="ft7">c</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:487"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:1072;left:510"><nobr><span class="ft7">n</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:517"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">17</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107003.png" alt="background image">
<DIV style="position:absolute;top:375;left:309"><nobr><span class="ft5"><b>Figure 1. Analyzing a simple program with MrFlow.</b></span></nobr></DIV>
<DIV style="position:absolute;top:420;left:81"><nobr><span class="ft3"><b>3.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:420;left:121"><nobr><span class="ft3"><b>Regular Expressions</b></span></nobr></DIV>
<DIV style="position:absolute;top:452;left:81"><nobr><span class="ft15">Regular expressions are used in all kinds of Scheme programs. The<br>language of regular expression patterns is embedded in Scheme as<br>strings. A library of functions interpret these strings as programs<br>that consume additional arguments as input strings and return either<br>a list of matched subpatterns or</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:253"><nobr><span class="ft7">#f</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:270"><nobr><span class="ft4">to indicate failure.</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:81"><nobr><span class="ft11">Consider again the excerpt from the PLT Web Server from Sec-<br>tion 1. Programmers know that if the match succeeds, then the<br>result list contains exactly three elements: the result of the entire<br>match, and the results of the two subpattern matches. Again the<br>analysis is unable to discover this invariant on its own. Figure 3<br>shows the results of analyzing the sample code with MrFlow. The<br>list accessors</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:156"><nobr><span class="ft7">second</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:201"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:224"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:262"><nobr><span class="ft4">are underlined in red because the</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:81"><nobr><span class="ft4">analysis cannot prove that their arguments are sufficiently long lists.</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:81"><nobr><span class="ft11">Programmers then must either go through each of these false pos-<br>itives and prove for themselves that the errors can never occur, or<br>else learn to ignore some results of MrFlow. Neither option is de-<br>sirable. The former creates <i>more </i>work for the programmer, rather<br>than less; the latter is unsafe and easily leads to overlooked errors.</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:81"><nobr><span class="ft3"><b>3.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:783;left:121"><nobr><span class="ft3"><b>SchemeQL</b></span></nobr></DIV>
<DIV style="position:absolute;top:815;left:81"><nobr><span class="ft11">SchemeQL [28] is an embedded language for manipulating rela-<br>tional databases in Scheme. Unlike the string-based</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:374"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:830;left:420"><nobr><span class="ft4">lan-</span></nobr></DIV>
<DIV style="position:absolute;top:845;left:81"><nobr><span class="ft11">guage, SchemeQL programs consist of special forms directly em-<br>bedded inside Scheme. The SchemeQL implementation provides<br>a set of macros that recognize these forms and expand them into<br>Scheme code. A typical database query in SchemeQL might look<br>like this:</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:95"><nobr><span class="ft7">(direct-query (name age phone) directory)</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:81"><nobr><span class="ft4">corresponding to the SQL statement</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:95"><nobr><span class="ft7">SELECT name, age, phone FROM directory</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:81"><nobr><span class="ft11">The result of executing a query is a lazy stream representing a cur-<br>sor over the result set from the database server. Each element in the<br>stream is a list of values representing a single row of the result set.<br>The cursor computes the rows by need when a program selects the<br>next sub-stream.</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:477"><nobr><span class="ft11">Programmers know that the number of elements in each row of a<br>cursor is equal to the number of columns in the original request.<br>Our analysis, however, cannot discover this fact automatically. Fig-<br>ure 4 shows the results of an analysis of a SchemeQL query in the<br>context of a trivial Scheme program. The example query consists of<br>exactly three columns, and the code references the third element of<br>the first row. This operation can never fail, but the analysis is unable<br>to prove this. Instead, it conservatively computes that</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:773"><nobr><span class="ft7">row</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:797"><nobr><span class="ft4">is a list</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:477"><nobr><span class="ft11">of unknown length: <i>rec-type </i>describes a recursive abstract value,<br>which in the present case is the union of</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:695"><nobr><span class="ft7">null</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:726"><nobr><span class="ft4">and a pair consisting</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:477"><nobr><span class="ft11">of any value (<i>top</i>) and the abstract value itself, creating a loop in the<br>abstract value that simulates all possible list lengths. MrFlow there-<br>fore mistakenly reports an error by underlining the primitive</span></nobr></DIV>
<DIV style="position:absolute;top:603;left:802"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:477"><nobr><span class="ft4">in red, since, according to the analysis,</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:692"><nobr><span class="ft7">row</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:716"><nobr><span class="ft4">might have fewer than</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:477"><nobr><span class="ft4">three elements at runtime.</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:477"><nobr><span class="ft3"><b>4</b></span></nobr></DIV>
<DIV style="position:absolute;top:664;left:504"><nobr><span class="ft3"><b>Macros for Partial Evaluation</b></span></nobr></DIV>
<DIV style="position:absolute;top:697;left:477"><nobr><span class="ft11">All the embedded languages presented in the previous section have<br>one thing in common: they can encode invariants that are not vis-<br>ible to any analysis of the general purpose language in which they<br>are embedded. These invariants can be exposed to analyses in two<br>ways:</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:492"><nobr><span class="ft9">· by extending the analyses in an ad-hoc manner for each em-</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:507"><nobr><span class="ft4">bedded language so that they understand its semantics, or</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:492"><nobr><span class="ft9">· by partially evaluating the embedded interpreters with regard</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:507"><nobr><span class="ft11">to the embedded programs to make the invariants in the em-<br>bedded programs explicit as invariants in the host language,<br>whenever possible.</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:477"><nobr><span class="ft11">The first solution requires modifying each analysis to support each<br>embedded language. The second solution can simply be imple-<br>mented from within the host language through the old Lisp trick of<br>using "compiler macros" [25] as a light-weight partial evaluation<br>mechanism. In the present case, instead of using partial evaluation<br>to optimize programs for speed, we use it to increase the precision<br>of program analyses.</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:477"><nobr><span class="ft11">While Lisp's compiler macros are different from regular Lisp<br>macros, Scheme's macro system is powerful enough that the equiv-<br>alent of Lisp's compiler macros can be implemented as regular<br>Scheme macros. The partial evaluation of embedded interpreters<br>then simply involves replacing the libraries of functions imple-</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">18</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107004.png" alt="background image">
<DIV style="position:absolute;top:334;left:309"><nobr><span class="ft5"><b>Figure 2. Imprecise analysis of the</b></span></nobr></DIV>
<DIV style="position:absolute;top:334;left:509"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:553"><nobr><span class="ft5"><b>primitive.</b></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:327"><nobr><span class="ft5"><b>Figure 3. Imprecise analysis of</b></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:506"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:588"><nobr><span class="ft5"><b>.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1050;left:313"><nobr><span class="ft5"><b>Figure 4. Imprecise analysis of a SchemeQL query.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">19</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107005.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft11">menting the interpreters with libraries of semantically equivalent<br>macros</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:120"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:126"><nobr><span class="ft4">. This has the additional advantage that it can be done by</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:81"><nobr><span class="ft11">the author of the library of functions, as opposed to the compiler's<br>or analyzer's implementor in the case of ad-hoc extensions.</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:81"><nobr><span class="ft11">Of course, the partial evaluation of embedded interpreters is only<br>possible when their input programs are known statically. For ex-<br>ample, it is not possible to expand a call to</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:322"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:367"><nobr><span class="ft4">if the format-</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:81"><nobr><span class="ft11">ting string given as its first argument is computed at runtime. The<br>programmer therefore makes a trade-off between the precision of<br>analyses and how dynamic the code can be. In practice, though,<br>the embedded programs are often specified statically in user code.<br>Combined with the simplicity of implementing partial evaluation<br>with macros, this makes for a useful technique for improving the<br>precision of analyses at a low cost.</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:81"><nobr><span class="ft11">In the next two sections, we describe some of the important features<br>of the Scheme macro system and then explain how we make use of<br>this system to partially evaluate the interpreters of these embedded<br>languages to improve the results of static analysis.</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:81"><nobr><span class="ft3"><b>5</b></span></nobr></DIV>
<DIV style="position:absolute;top:430;left:108"><nobr><span class="ft3"><b>Macros in Scheme</b></span></nobr></DIV>
<DIV style="position:absolute;top:463;left:81"><nobr><span class="ft11">Scheme has a powerful macro system for extending the language<br>with derived expression forms that can be rewritten as expressions<br>in the core language. Macros serve as a means of syntactic abstrac-<br>tion. Programmers can generalize syntactic patterns in ways that<br>are not possible with functional abstraction. This technology also<br>provides a hook into the standard compiler tool chain by allowing<br>programmers to implement additional program transformations be-<br>fore compilation. In this section we describe the basics of standard<br>Scheme macros and introduce identifier macros, a generalization of<br>the contexts in which macros can be matched.</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:81"><nobr><span class="ft3"><b>5.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:121"><nobr><span class="ft3"><b>Rule-Based Macros</b></span></nobr></DIV>
<DIV style="position:absolute;top:662;left:81"><nobr><span class="ft4">The</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:105"><nobr><span class="ft7">define-syntax</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:197"><nobr><span class="ft4">special form allows the programmer to extend</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:81"><nobr><span class="ft11">Scheme with derived expression forms. Before compilation or exe-<br>cution of a Scheme program, all occurrences of these derived forms<br>are replaced with their specified expansions.</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:81"><nobr><span class="ft4">The</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:108"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:196"><nobr><span class="ft4">form specifies macro expansions as rewrite</span></nobr></DIV>
<DIV style="position:absolute;top:751;left:81"><nobr><span class="ft11">rules. Consider the following simple macro, which defines a short-<br>circuit logical</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:158"><nobr><span class="ft7">or</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:176"><nobr><span class="ft4">as a derived form:</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:95"><nobr><span class="ft7">(define-syntax or</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:108"><nobr><span class="ft7">(syntax-rules ()</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:122"><nobr><span class="ft7">[(or e1 e2)</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:129"><nobr><span class="ft7">(let ([tmp e1])</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:143"><nobr><span class="ft7">(if tmp tmp e2))]))</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:81"><nobr><span class="ft11">The macro defines a single rewrite rule, consisting of a <i>pattern </i>and<br>a <i>template</i>. The pattern matches the</span></nobr></DIV>
<DIV style="position:absolute;top:895;left:282"><nobr><span class="ft7">or</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:300"><nobr><span class="ft4">keyword in operator posi-</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:81"><nobr><span class="ft4">tion followed by two pattern variables</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:296"><nobr><span class="ft7">e1</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:315"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:339"><nobr><span class="ft7">e2</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:353"><nobr><span class="ft4">, each matching</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:81"><nobr><span class="ft11">an arbitrary subexpression in argument position. The template di-<br>rects the macro expansion to replace occurrences of the matched<br>pattern with a</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:157"><nobr><span class="ft7">let</span></nobr></DIV>
<DIV style="position:absolute;top:954;left:178"><nobr><span class="ft4">-expression constructed from the matched subex-</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:81"><nobr><span class="ft4">pressions.</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:99"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:105"><nobr><span class="ft4">The transformation is not strictly speaking partial evaluation:</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:81"><nobr><span class="ft11">the reductions performed by the macros are not exactly the ones per-<br>formed by the embedded interpreters. However, the macros share<br>the techniques and issues of partial evaluation since they simulate<br>parts of the interpreters, and it is therefore useful to describe them<br>as such.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft4">Notice that this</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:568"><nobr><span class="ft7">or</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:586"><nobr><span class="ft4">form cannot be defined as a regular function</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:477"><nobr><span class="ft11">in Scheme. The second argument is only evaluated if the first ar-<br>gument evaluates to false. Since Scheme has a strict evaluation<br>semantics, a functional</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:609"><nobr><span class="ft7">or</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:627"><nobr><span class="ft4">would necessarily evaluate both of its</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:477"><nobr><span class="ft11">arguments before computing a result. Controlling the evaluation of<br>expressions is an important use of Scheme macros. Macros can also<br>abstract over other syntactic forms in ways that functions cannot by<br>expanding into second-class language constructs such as</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:784"><nobr><span class="ft7">define</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:825"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:477"><nobr><span class="ft3"><b>5.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:517"><nobr><span class="ft3"><b>Lexical Scope</b></span></nobr></DIV>
<DIV style="position:absolute;top:297;left:477"><nobr><span class="ft4">Macros written with the standard Scheme</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:716"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:803"><nobr><span class="ft4">mech-</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:477"><nobr><span class="ft11">anism are both <i>hygienic </i>and <i>referentially transparent</i>. Hygienic<br>macro expansion guarantees that binding forms inside the defini-<br>tion of the macro template do not capture free variables in macro<br>arguments. Consider the following use of our</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:724"><nobr><span class="ft7">or</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:741"><nobr><span class="ft4">macro:</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:779"><nobr><span class="ft8">2</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:511"><nobr><span class="ft7">(or other tmp)</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:491"><nobr><span class="ft9"></span></nobr></DIV>
<DIV style="position:absolute;top:399;left:511"><nobr><span class="ft7">(let ([tmp</span></nobr></DIV>
<DIV style="position:absolute;top:403;left:579"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:592"><nobr><span class="ft7">other])</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:525"><nobr><span class="ft7">(if tmp</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:573"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:586"><nobr><span class="ft7">tmp</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:606"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:619"><nobr><span class="ft7">tmp))</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:477"><nobr><span class="ft11">Hygienic expansion automatically renames the variable bound in-<br>side the expanded macro template to avoid capturing the free vari-<br>able in the macro argument.</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:477"><nobr><span class="ft11">Referential transparency complements hygiene by ensuring that<br>free variables inside the macro template cannot be captured by the<br>context of the macro call site. For example, if the context that in-<br>vokes</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:511"><nobr><span class="ft7">or</span></nobr></DIV>
<DIV style="position:absolute;top:544;left:527"><nobr><span class="ft4">rebinds the</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:589"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:544;left:606"><nobr><span class="ft4">name, the expansion algorithm renames the</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:477"><nobr><span class="ft11">binding in the <i>caller's </i>context to avoid capturing the variable used<br>in the template body:</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:511"><nobr><span class="ft7">(let ([if 3])</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:525"><nobr><span class="ft7">(or if #f))</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:491"><nobr><span class="ft9"></span></nobr></DIV>
<DIV style="position:absolute;top:632;left:511"><nobr><span class="ft7">(let ([if</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:572"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:585"><nobr><span class="ft7">3])</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:525"><nobr><span class="ft7">(let ([tmp if</span></nobr></DIV>
<DIV style="position:absolute;top:650;left:614"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:620"><nobr><span class="ft7">])</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:539"><nobr><span class="ft7">(if tmp tmp #f)))</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:477"><nobr><span class="ft11">The combination of hygiene and referential transparency produces<br>macros that are consistent with Scheme's rules of lexical scope and<br>can be invoked anywhere in a program without the danger of unex-<br>pected variable capture.</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:605"><nobr><span class="ft8">3</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:477"><nobr><span class="ft3"><b>5.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:778;left:517"><nobr><span class="ft3"><b>Identifier Macros</b></span></nobr></DIV>
<DIV style="position:absolute;top:811;left:477"><nobr><span class="ft4">The</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:503"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:590"><nobr><span class="ft4">form only matches expressions in which the</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:477"><nobr><span class="ft11">macro name occurs in "application position," i.e., as the operator in<br>an application expression. References to a</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:705"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:790"><nobr><span class="ft4">macro in</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:477"><nobr><span class="ft4">other contexts result in syntax errors:</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:511"><nobr><span class="ft7">(fold or #f ls)</span></nobr></DIV>
<DIV style="position:absolute;top:893;left:491"><nobr><span class="ft9"> <i>syntax error</i></span></nobr></DIV>
<DIV style="position:absolute;top:923;left:477"><nobr><span class="ft4">PLT</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:516"><nobr><span class="ft4">Scheme's</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:585"><nobr><span class="ft7">syntax-id-rules</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:704"><nobr><span class="ft4">form</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:747"><nobr><span class="ft4">is</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:773"><nobr><span class="ft4">similar</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:827"><nobr><span class="ft4">to</span></nobr></DIV>
<DIV style="position:absolute;top:939;left:477"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:569"><nobr><span class="ft4">but matches occurrences of the macro key-</span></nobr></DIV>
<DIV style="position:absolute;top:953;left:477"><nobr><span class="ft11">word in arbitrary expression contexts: in operator position, operand<br>position, or as the target of an assignment.</span></nobr></DIV>
<DIV style="position:absolute;top:1007;left:495"><nobr><span class="ft8">2</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:501"><nobr><span class="ft4">We use the convention of representing macro expansion with a</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:477"><nobr><span class="ft4">double-arrow (</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:557"><nobr><span class="ft9">) and ordinary (runtime) evaluation with a single-</span></nobr></DIV>
<DIV style="position:absolute;top:1040;left:477"><nobr><span class="ft4">arrow (</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:516"><nobr><span class="ft9">).</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:495"><nobr><span class="ft8">3</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:501"><nobr><span class="ft4">Macros can also be defined in and exported from modules in</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:477"><nobr><span class="ft4">PLT Scheme [11].</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">20</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107006.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft4">The following macro demonstrates a hypothetical use of</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:81"><nobr><span class="ft7">syntax-id-rules</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:184"><nobr><span class="ft4">:</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:95"><nobr><span class="ft7">(define-syntax clock</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:108"><nobr><span class="ft7">(syntax-id-rules (set!)</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:122"><nobr><span class="ft16">[(set! clock e) (set-clock! e)]<br>[(clock e) (make-time-stamp (get-clock) e)]<br>[clock (get-clock)]))</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:81"><nobr><span class="ft4">The list of identifiers following</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:267"><nobr><span class="ft7">syntax-id-rules</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:370"><nobr><span class="ft4">, which was</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:81"><nobr><span class="ft4">empty in our previous examples, now includes the</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:369"><nobr><span class="ft7">set!</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:406"><nobr><span class="ft4">identi-</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:81"><nobr><span class="ft4">fier, indicating that</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:186"><nobr><span class="ft7">set!</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:217"><nobr><span class="ft4">is to be treated as a keyword rather than a</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:81"><nobr><span class="ft11">pattern variable. The first rewrite rule matches expressions in which<br>the</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:101"><nobr><span class="ft7">clock</span></nobr></DIV>
<DIV style="position:absolute;top:301;left:139"><nobr><span class="ft4">name occurs as the target of an assignment. The second</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:81"><nobr><span class="ft11">rule is familiar, matching the macro in application position. The fi-<br>nal rule matches the identifier</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:243"><nobr><span class="ft7">clock</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:280"><nobr><span class="ft4">in any context not matched by</span></nobr></DIV>
<DIV style="position:absolute;top:346;left:81"><nobr><span class="ft11">the previous two rules. In addition to the usual application context,<br>we can use the</span></nobr></DIV>
<DIV style="position:absolute;top:362;left:163"><nobr><span class="ft7">clock</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:201"><nobr><span class="ft4">macro in an argument position:</span></nobr></DIV>
<DIV style="position:absolute;top:389;left:115"><nobr><span class="ft7">(+ clock 10)</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:95"><nobr><span class="ft9"></span></nobr></DIV>
<DIV style="position:absolute;top:403;left:115"><nobr><span class="ft7">(+ (get-clock) 10)</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:81"><nobr><span class="ft4">or as a</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:119"><nobr><span class="ft7">set!</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:151"><nobr><span class="ft4">target:</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:115"><nobr><span class="ft7">(set! clock 5)</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:95"><nobr><span class="ft9"></span></nobr></DIV>
<DIV style="position:absolute;top:471;left:115"><nobr><span class="ft7">(set-clock! 5)</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:81"><nobr><span class="ft3"><b>5.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:507;left:121"><nobr><span class="ft3"><b>Programmatic Macros</b></span></nobr></DIV>
<DIV style="position:absolute;top:540;left:81"><nobr><span class="ft4">The</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:115"><nobr><span class="ft4">language</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:177"><nobr><span class="ft4">of</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:202"><nobr><span class="ft4">patterns</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:258"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:290"><nobr><span class="ft4">templates</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:355"><nobr><span class="ft4">recognized</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:428"><nobr><span class="ft4">by</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:81"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:173"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:203"><nobr><span class="ft7">syntax-id-rules</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:316"><nobr><span class="ft4">is actually a special</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:81"><nobr><span class="ft4">case of Scheme macros.</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:231"><nobr><span class="ft4">In general, the</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:320"><nobr><span class="ft7">define-syntax</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:415"><nobr><span class="ft4">form</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:81"><nobr><span class="ft4">binds a transformer procedure</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:95"><nobr><span class="ft7">(define-syntax</span></nobr></DIV>
<DIV style="position:absolute;top:611;left:198"><nobr><span class="ft6"><i>name</i></span></nobr></DIV>
<DIV style="position:absolute;top:627;left:108"><nobr><span class="ft7">(lambda (stx)</span></nobr></DIV>
<DIV style="position:absolute;top:641;left:122"><nobr><span class="ft6"><i>etc</i></span></nobr></DIV>
<DIV style="position:absolute;top:637;left:138"><nobr><span class="ft9">.</span></nobr></DIV>
<DIV style="position:absolute;top:667;left:81"><nobr><span class="ft11">The argument to the transformer procedure is a <i>syntax object</i>, which<br>is similar to an S-expression representing quoted code, but which<br>also encapsulates information about the lexical context of the code,<br>such as source file location and variable bindings. This context<br>information is essential in allowing DrScheme's language tools to<br>trace errors and binding relationships back to the original source lo-<br>cation in the user's code where a macro is invoked. Because syntax<br>objects are so similar to quoted data, the standard library includes<br>the</span></nobr></DIV>
<DIV style="position:absolute;top:788;left:100"><nobr><span class="ft7">syntax-object-&gt;datum</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:240"><nobr><span class="ft4">procedure, which strips the lexical in-</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:81"><nobr><span class="ft11">formation from a syntax object and returns its corresponding datum.<br>For example, the datum corresponding to a syntax object represent-<br>ing a literal number is its numeric value, the datum corresponding<br>to an identifier is a symbol representing the identifier's name, and<br>so on.</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:81"><nobr><span class="ft11">A syntax transformer procedure accepts as its argument a syn-<br>tax object representing the expression that invoked the macro,<br>and produces a new syntax object, which the macro expansion<br>algorithm uses to replace the original expression.</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:375"><nobr><span class="ft4">All Scheme</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:81"><nobr><span class="ft4">macros are syntax transformers; although the</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:335"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:421"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:81"><nobr><span class="ft7">syntax-id-rules</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:188"><nobr><span class="ft4">forms do not use the</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:302"><nobr><span class="ft7">lambda</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:347"><nobr><span class="ft4">notation, they are</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:81"><nobr><span class="ft11">themselves implemented as macros that expand to syntax trans-<br>former procedures.</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:81"><nobr><span class="ft4">The</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:106"><nobr><span class="ft7">syntax-case</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:186"><nobr><span class="ft4">facility allows the construction of macros with</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:81"><nobr><span class="ft4">pattern matching, as with</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:224"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:311"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:335"><nobr><span class="ft7">syntax-id-rules</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:437"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:81"><nobr><span class="ft11">but with arbitrary expressions in place of templates for the result<br>expressions. For example, the above</span></nobr></DIV>
<DIV style="position:absolute;top:1072;left:278"><nobr><span class="ft7">or</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:295"><nobr><span class="ft4">macro would be defined as:</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:491"><nobr><span class="ft7">(define-syntax or</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:504"><nobr><span class="ft7">(lambda (stx)</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:518"><nobr><span class="ft7">(syntax-case stx ()</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:532"><nobr><span class="ft7">[(or e1 e2)</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:539"><nobr><span class="ft7">#'(let ([tmp e1])</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:566"><nobr><span class="ft7">(if tmp tmp e2))])))</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:477"><nobr><span class="ft11">The macro is almost the same as before, but for two refinements.<br>First, the</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:533"><nobr><span class="ft7">syntax-case</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:614"><nobr><span class="ft4">form takes the argument</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:757"><nobr><span class="ft7">stx</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:784"><nobr><span class="ft4">explicitly,</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:477"><nobr><span class="ft4">whereas</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:524"><nobr><span class="ft7">syntax-rules</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:610"><nobr><span class="ft4">implicitly defines a transformer procedure</span></nobr></DIV>
<DIV style="position:absolute;top:260;left:477"><nobr><span class="ft11">and operates on the procedure argument. Second, the result ex-<br>pression is prefixed by the syntax-quoting</span></nobr></DIV>
<DIV style="position:absolute;top:276;left:717"><nobr><span class="ft7">#'</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:736"><nobr><span class="ft4">operator, which is</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:477"><nobr><span class="ft4">analogous to Scheme's</span></nobr></DIV>
<DIV style="position:absolute;top:291;left:606"><nobr><span class="ft7">quote</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:645"><nobr><span class="ft4">operator</span></nobr></DIV>
<DIV style="position:absolute;top:291;left:694"><nobr><span class="ft7">'</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:701"><nobr><span class="ft4">. Whereas an expression</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:477"><nobr><span class="ft4">prefixed with</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:551"><nobr><span class="ft7">'</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:561"><nobr><span class="ft4">evaluates to a quoted S-expression, a</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:762"><nobr><span class="ft7">#'</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:779"><nobr><span class="ft4">expression</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:477"><nobr><span class="ft11">becomes a quoted syntax object that also includes lexical informa-<br>tion. Similarly, the quasisyntax operator</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:699"><nobr><span class="ft7">#`</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:716"><nobr><span class="ft4">and unsyntax operator</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:477"><nobr><span class="ft7">#,</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:494"><nobr><span class="ft4">behave for syntax objects like the quasiquote and unquote oper-</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:477"><nobr><span class="ft4">ators for S-expressions, respectively.</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:477"><nobr><span class="ft11">The use of arbitrary computations in the result expression allows<br>macros to expand differently based on the results of actual compu-<br>tations:</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:491"><nobr><span class="ft7">(define-syntax swap</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:504"><nobr><span class="ft7">(lambda (stx)</span></nobr></DIV>
<DIV style="position:absolute;top:481;left:518"><nobr><span class="ft7">(syntax-case stx ()</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:532"><nobr><span class="ft7">[(swap a b)</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:539"><nobr><span class="ft7">(if (and (identifier? #'a)</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:600"><nobr><span class="ft7">(identifier? #'b))</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:566"><nobr><span class="ft7">#'(let ([tmp b])</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:593"><nobr><span class="ft16">(set! b a)<br>(set! a tmp))</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:566"><nobr><span class="ft7">(raise-syntax-error</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:573"><nobr><span class="ft16">'swap &quot;expects identifiers&quot;<br>stx))])))</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:477"><nobr><span class="ft4">In this example, if</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:582"><nobr><span class="ft7">swap</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:614"><nobr><span class="ft4">is not given identifiers as arguments, the</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:477"><nobr><span class="ft7">raise-syntax-error</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:604"><nobr><span class="ft4">function uses the lexical information in the</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:477"><nobr><span class="ft7">stx</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:502"><nobr><span class="ft4">syntax object to highlight the original</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:712"><nobr><span class="ft7">swap</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:743"><nobr><span class="ft4">expression in the</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:477"><nobr><span class="ft4">user's code.</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:477"><nobr><span class="ft11">Conditional matching can also be achieved using <i>pattern guards</i>,<br>which can inspect a matched expression and determine whether to<br>accept a match:</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:491"><nobr><span class="ft7">(define-syntax swap</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:504"><nobr><span class="ft7">(lambda (stx)</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:518"><nobr><span class="ft7">(syntax-case stx ()</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:532"><nobr><span class="ft7">[(swap a b)</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:539"><nobr><span class="ft7">(and (identifier? #'a)</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:573"><nobr><span class="ft7">(identifier? #'b))</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:539"><nobr><span class="ft7">#'(let ([tmp b])</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:566"><nobr><span class="ft16">(set! b a)<br>(set! a tmp))])))</span></nobr></DIV>
<DIV style="position:absolute;top:919;left:477"><nobr><span class="ft11">The pattern guard is a new expression, inserted between the pattern<br>and the result expressions. A guarded match only succeeds if its<br>guard does not evaluate to false; when a guard fails, the pattern<br>matcher falls through to attempt the next pattern in the list.</span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:477"><nobr><span class="ft3"><b>6</b></span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:504"><nobr><span class="ft3"><b>Macros for Interpreters</b></span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:477"><nobr><span class="ft11">In this section, we present a general technique for specializing em-<br>bedded interpreters with macros, and explain how we apply this<br>technique to the three embedded languages described in Section 3.</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">21</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107007.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft4">The technique can be summarized in the following steps:</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:93"><nobr><span class="ft4">1. Write the interpreter compositionally as a module of library</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:111"><nobr><span class="ft4">functions.</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:93"><nobr><span class="ft4">2. Replace the interpreter's main function with a macro that un-</span></nobr></DIV>
<DIV style="position:absolute;top:192;left:111"><nobr><span class="ft11">folds the case dispatch on the input (the embedded program)<br>when it is known statically.</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:93"><nobr><span class="ft4">3. Default to the original function when the input is not known</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:111"><nobr><span class="ft4">at compile time.</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:81"><nobr><span class="ft15">Writing the interpreters compositionally serves two purposes. First,<br>by delegating the interpretation of the program constructs that make<br>up an embedded program to separate functions, it becomes possi-<br>ble to share code between the original interpreter and the macro<br>that replaces it. This effectively limits the macro's responsibility<br>to a simple dispatch. Second, compositionality makes it easier to<br>guarantee that unfolding terminates, since the recursive macro calls<br>always operate on smaller terms.</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:81"><nobr><span class="ft3"><b>6.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:420;left:121"><nobr><span class="ft3"><b>Format Strings</b></span></nobr></DIV>
<DIV style="position:absolute;top:453;left:81"><nobr><span class="ft11">The implementation of a string formatter involves a number of sim-<br>ple library functions to convert each possible type of argument to<br>strings. Each formatting tag corresponds to one of these combi-<br>nators. For example, the</span></nobr></DIV>
<DIV style="position:absolute;top:499;left:226"><nobr><span class="ft7">&quot;~c&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:259"><nobr><span class="ft4">tag corresponds to a combinator,</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:81"><nobr><span class="ft7">format/char</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:156"><nobr><span class="ft4">, which accepts a character and converts it to a string,</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:81"><nobr><span class="ft4">the</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:101"><nobr><span class="ft7">&quot;~x&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:133"><nobr><span class="ft4">tag corresponds to</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:237"><nobr><span class="ft7">format/hex</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:305"><nobr><span class="ft4">, which converts integers</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:81"><nobr><span class="ft11">to their hexadecimal representation, and so forth. The string for-<br>matter then simply dispatches to these combinators based on the<br>content of the formatting string:</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:95"><nobr><span class="ft7">(define (format s . args)</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:108"><nobr><span class="ft7">(cond</span></nobr></DIV>
<DIV style="position:absolute;top:630;left:122"><nobr><span class="ft16">[(string=? s &quot;&quot;) &quot;&quot;]<br>[(string=? (substring s 0 2) &quot;~c&quot;)</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:129"><nobr><span class="ft7">(string-append (format/char (car args))</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:232"><nobr><span class="ft7">(apply format</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:280"><nobr><span class="ft16">(substring s 2)<br>(cdr args)))]</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:122"><nobr><span class="ft6"><i>etc</i></span></nobr></DIV>
<DIV style="position:absolute;top:715;left:138"><nobr><span class="ft9">.</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:155"><nobr><span class="ft7">))</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:81"><nobr><span class="ft4">The interpreter accepts the formatting string</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:329"><nobr><span class="ft7">s</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:340"><nobr><span class="ft4">and, based on for-</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:81"><nobr><span class="ft4">matting tags like</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:178"><nobr><span class="ft7">&quot;~c&quot;</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:210"><nobr><span class="ft4">that it finds, decomposes the string into a</span></nobr></DIV>
<DIV style="position:absolute;top:775;left:81"><nobr><span class="ft15">series of applications of the corresponding combinators to succes-<br>sive arguments of</span></nobr></DIV>
<DIV style="position:absolute;top:791;left:184"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:230"><nobr><span class="ft4">(represented by</span></nobr></DIV>
<DIV style="position:absolute;top:791;left:319"><nobr><span class="ft7">args</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:346"><nobr><span class="ft4">). It reassembles</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:81"><nobr><span class="ft4">the transformed pieces with the standard</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:300"><nobr><span class="ft7">string-append</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:393"><nobr><span class="ft4">function.</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:81"><nobr><span class="ft4">In order to specialize the</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:222"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:268"><nobr><span class="ft4">interpreter, we replace it with a</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:81"><nobr><span class="ft4">macro that re-uses its associated combinators:</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:95"><nobr><span class="ft7">(define (format/dynamic s . args)</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:115"><nobr><span class="ft6"><i>as before</i></span></nobr></DIV>
<DIV style="position:absolute;top:892;left:175"><nobr><span class="ft7">)</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:95"><nobr><span class="ft7">(define-syntax format</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:108"><nobr><span class="ft7">(lambda (stx)</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:122"><nobr><span class="ft7">(syntax-case stx ()</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:136"><nobr><span class="ft7">[(format s-exp a1 a2 ...)</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:143"><nobr><span class="ft16">(string? (syntax-object-&gt;datum #'s-exp))<br>(let ([s (syntax-object-&gt;datum #'s-exp)])</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:156"><nobr><span class="ft7">(cond</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:170"><nobr><span class="ft16">[(string=? s &quot;&quot;) #'&quot;&quot;]<br>[(string=? (substring s 0 2) &quot;~c&quot;)</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:177"><nobr><span class="ft7">#`(string-append</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:198"><nobr><span class="ft16">(format/char a1)<br>(format #,(substring s 2) a2 ...))]</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:566"><nobr><span class="ft6"><i>etc</i></span></nobr></DIV>
<DIV style="position:absolute;top:110;left:582"><nobr><span class="ft9">.</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:592"><nobr><span class="ft7">))]</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:532"><nobr><span class="ft7">[(format s-exp a1 a2 ...)</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:539"><nobr><span class="ft7">#'(format/dynamic s-exp a1 a2 ...)]</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:532"><nobr><span class="ft7">[format</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:539"><nobr><span class="ft16">(identifier? #'format)<br>#'format/dynamic])))</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:477"><nobr><span class="ft11">The partial evaluation works by unfolding the interpreter's top-level<br>case dispatch on the program text. Rather than delaying the inspec-<br>tion of the string to runtime, the macro precomputes the result of the<br>decomposition statically whenever the string is given as a literal.<br>We can identify literal strings through the use of a pattern guard.<br>More precisely, the macro can inspect the syntax object</span></nobr></DIV>
<DIV style="position:absolute;top:291;left:799"><nobr><span class="ft7">s-exp</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:833"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:477"><nobr><span class="ft4">corresponding to</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:573"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:614"><nobr><span class="ft4">'s first argument, and determine whether</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:477"><nobr><span class="ft4">it can be converted to a string via</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:659"><nobr><span class="ft7">syntax-object-&gt;datum</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:796"><nobr><span class="ft4">. When</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:477"><nobr><span class="ft11">the conversion succeeds, the pattern guard allows the match to suc-<br>ceed, and partial evaluation proceeds.</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:477"><nobr><span class="ft15">After the macro expansion, the resulting program text consists of<br>the application of</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:576"><nobr><span class="ft7">string-append</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:670"><nobr><span class="ft4">to the calls to the library func-</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:477"><nobr><span class="ft4">tions, with no references to the interpreter:</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:511"><nobr><span class="ft7">(format &quot;~c = 0x~x&quot; c n)</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:491"><nobr><span class="ft9"></span></nobr></DIV>
<DIV style="position:absolute;top:452;left:511"><nobr><span class="ft7">(string-append (format/char c)</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:614"><nobr><span class="ft16">&quot; = 0x&quot;<br>(format/hex n))</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:477"><nobr><span class="ft11">In order for the replacement of the original function with a macro<br>to be unobservable, the macro must behave exactly like the origi-<br>nal function in all contexts. When</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:666"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:710"><nobr><span class="ft4">is applied to a dynamic</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:477"><nobr><span class="ft11">formatting string, the macro defaults to the original functional im-<br>plementation. Similarly, when</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:644"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:689"><nobr><span class="ft4">is passed as an argument to</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:477"><nobr><span class="ft11">a higher-order function, we use the technique of identifier macros<br>to refer to the original function.</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:647"><nobr><span class="ft8">4</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:477"><nobr><span class="ft3"><b>6.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:633;left:517"><nobr><span class="ft3"><b>Regular Expressions</b></span></nobr></DIV>
<DIV style="position:absolute;top:666;left:477"><nobr><span class="ft11">One of PLT Scheme's regular expression engines uses the two-<br>continuation model of backtracking [1].</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:718"><nobr><span class="ft4">A regular expression</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:477"><nobr><span class="ft11">"matcher" is represented as a function that accepts a success con-<br>tinuation and a failure continuation. When a matcher succeeds in<br>matching its input, it applies its success continuation to the accepted<br>input, and when it fails to match, it invokes its failure continuation.<br>This allows the interpretation of the alternation operator "</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:790"><nobr><span class="ft7">|</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:797"><nobr><span class="ft4">" to try</span></nobr></DIV>
<DIV style="position:absolute;top:770;left:477"><nobr><span class="ft11">each alternate pattern sequentially: an alternation matcher tries to<br>match its first pattern with a failure continuation to try the second<br>pattern. Thus if the first pattern fails, the matcher invokes the failure<br>continuation, which tries the second pattern. Otherwise, the failure<br>continuation is disregarded and the matcher applies its success con-<br>tinuation, which skips the second pattern and returns the result of<br>the first match.</span></nobr></DIV>
<DIV style="position:absolute;top:890;left:477"><nobr><span class="ft15">Each of the regular expression constructions corresponds to a func-<br>tional combinator that produces a matcher.</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:732"><nobr><span class="ft4">These combinators</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:477"><nobr><span class="ft11">can express the standard operators of regular expressions: suc-<br>cess, failure, alternation, concatenation, and repetition (i.e., Kleene<br>star).</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:518"><nobr><span class="ft4">There is also a</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:612"><nobr><span class="ft7">submatch</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:673"><nobr><span class="ft4">combinator for the parenthe-</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:477"><nobr><span class="ft4">sized subpatterns in the original regular expression. A successful</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:477"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:565"><nobr><span class="ft4">returns a list with the entire matched string fol-</span></nobr></DIV>
<DIV style="position:absolute;top:995;left:477"><nobr><span class="ft11">lowed by each submatch corresponding to a parenthesized subpat-<br>tern. Any subpattern that does not match corresponds to an entry of<br>false (</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:511"><nobr><span class="ft7">#f</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:524"><nobr><span class="ft4">) in the result list. For example, the following successful</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:495"><nobr><span class="ft8">4</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:501"><nobr><span class="ft4">The case of</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:564"><nobr><span class="ft7">set!</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:596"><nobr><span class="ft4">is not critical since, in PLT Scheme, imported</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:477"><nobr><span class="ft4">module references cannot be the target of an assignment.</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">22</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft17{font-size:8px;font-family:Times;color:#000000;}
	.ft18{font-size:11px;font-family:Symbol;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="107008.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft4">match contains a failed submatch:</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:115"><nobr><span class="ft7">(regexp-match &quot;a((b)|(c))&quot; &quot;ac&quot;)</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:95"><nobr><span class="ft9"></span></nobr></DIV>
<DIV style="position:absolute;top:156;left:115"><nobr><span class="ft7">(list &quot;ac&quot; &quot;c&quot; #f &quot;c&quot;)</span></nobr></DIV>
<DIV style="position:absolute;top:182;left:81"><nobr><span class="ft11">Regardless of the contents of the second argument, there is always<br>exactly one element in the result list for each parenthesized sub-<br>pattern in the regular expression. The</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:293"><nobr><span class="ft7">submatch</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:352"><nobr><span class="ft4">operator accom-</span></nobr></DIV>
<DIV style="position:absolute;top:227;left:81"><nobr><span class="ft11">plishes this by wrapping a given matcher with continuations that<br>add either the result of a successful match or false to a list of in-<br>dexed submatches accumulated during the match. The initial (suc-<br>cess) continuation for</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:202"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:288"><nobr><span class="ft4">sorts the accumulated list of</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:81"><nobr><span class="ft11">indexed submatches, adding false entries for all submatches that<br>were never reached because of backtracking.</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:81"><nobr><span class="ft11">Partial evaluation of the regular expression library works by un-<br>folding the definitions of the combinators as well as the contents of<br>the initial continuation. Each application of a combinator gets re-<br>placed by an application of a copy of the body of the combinator's<br>definition.</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:136"><nobr><span class="ft8">5</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:147"><nobr><span class="ft4">The recursive code that constructs the result list in the</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:81"><nobr><span class="ft4">success continuation gets expanded into an explicit chain of</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:413"><nobr><span class="ft7">cons</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:81"><nobr><span class="ft4">expressions:</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:115"><nobr><span class="ft7">(regexp-match &quot;a((b)|(c))&quot; input)</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:95"><nobr><span class="ft9"></span></nobr></DIV>
<DIV style="position:absolute;top:463;left:115"><nobr><span class="ft7">((build-matcher input)</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:122"><nobr><span class="ft7">(lambda (subs)</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:136"><nobr><span class="ft7">(cons (lookup subs 0)</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:143"><nobr><span class="ft7">(cons (lookup subs 1)</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:150"><nobr><span class="ft7">(cons (lookup subs 2)</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:156"><nobr><span class="ft7">(cons (lookup subs 3) null)))))</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:122"><nobr><span class="ft7">(lambda () #f))</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:81"><nobr><span class="ft11">Since the size of the result list is known, it is possible to unfold<br>recursive definitions, such as the initial continuation that constructs<br>the match result, to make the structure of the result explicit.</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:81"><nobr><span class="ft11">Finally, in the cases where the embedded program is not known stat-<br>ically, or when</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:164"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:250"><nobr><span class="ft4">is used in non-application contexts,</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:81"><nobr><span class="ft4">the macro expands to the original functional definition.</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:81"><nobr><span class="ft3"><b>6.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:706;left:121"><nobr><span class="ft3"><b>SchemeQL</b></span></nobr></DIV>
<DIV style="position:absolute;top:739;left:81"><nobr><span class="ft11">The SchemeQL language differs from the other examples in that its<br>programs are not embedded as strings but rather as special forms<br>recognized by a library of macros. This means that for queries<br>that select from a fixed set of columns, the length of cursor rows<br>is always known statically; the column names are specified as a<br>sequence of identifiers in the syntax of the query form.</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:81"><nobr><span class="ft11">Just as the interpreters for the string-based embedded programs<br>perform a case dispatch on the contents of program strings, the<br>SchemeQL macros dispatch on the shape of the query expressions.<br>The cases where partial evaluation is possible can be captured by<br>inserting additional rules into the original library's macros.</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:81"><nobr><span class="ft11">Partial evaluation of SchemeQL queries uses the same technique as<br>for the regular expression library: the recursive function that con-<br>structs a cursor row is unfolded into an explicit chain of</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:392"><nobr><span class="ft7">cons</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:423"><nobr><span class="ft4">ex-</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:81"><nobr><span class="ft11">pressions. Since we know the length of the cursor row statically,<br>the unfolding is guaranteed to terminate.</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:99"><nobr><span class="ft8">5</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:105"><nobr><span class="ft4">It is convenient to define the Kleene star operator recursively</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:81"><nobr><span class="ft4">by <i>p</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:106"><nobr><span class="ft17"></span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:114"><nobr><span class="ft9">= (<i>pp</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:149"><nobr><span class="ft17"></span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:155"><nobr><span class="ft9">)|</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:164"><nobr><span class="ft18"></span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:170"><nobr><span class="ft4">. However, this non-compositional definition leads</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:81"><nobr><span class="ft11">to an infinite macro expansion, so the macro must carefully avoid<br>unfolding such a definition.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft11">Since the SchemeQL library is implemented as macros, there is no<br>need to capture the cases where the query forms are used in non-<br>application contexts. Adding special cases to the existing macro<br>does not affect its set of allowable contexts. Similarly, the cases<br>where the row length is not known statically are already handled by<br>the existing SchemeQL macros.</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:477"><nobr><span class="ft3"><b>7</b></span></nobr></DIV>
<DIV style="position:absolute;top:221;left:504"><nobr><span class="ft3"><b>Static Analysis for Scheme</b></span></nobr></DIV>
<DIV style="position:absolute;top:254;left:477"><nobr><span class="ft11">MrFlow's value flow analysis is an extension of an ordinary set-<br>based closure analysis like Palsberg's [22]. For every expression in<br>a program, MrFlow statically computes a conservative approxima-<br>tion of the set of values to which the expression might evaluate at<br>runtime. From a given expression it creates a graph that simulates<br>the flow of values inside the expression. The analysis simulates<br>evaluation by propagating abstract values in this graph until reach-<br>ing a fixed point. From the set of abstract values that propagate to<br>a given node, the analysis reconstructs a type that is then displayed<br>to the user through DrScheme's graphical interface.</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:477"><nobr><span class="ft11">Extensions to the basic analysis include, among other things: an-<br>alyzing functions that can take any number of arguments, analyz-<br>ing assignments to variables (</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:637"><nobr><span class="ft7">set!</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:665"><nobr><span class="ft4">), and analyzing generative data</span></nobr></DIV>
<DIV style="position:absolute;top:463;left:477"><nobr><span class="ft11">structure definitions. MrFlow also supports all the primitives de-<br>fined in R</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:532"><nobr><span class="ft8">5</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:538"><nobr><span class="ft4">RS [17]. The vast majority of these primitives are de-</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:477"><nobr><span class="ft11">fined using a special, type-like language embedded inside the an-<br>alyzer. For a given primitive, the corresponding type translates to<br>a graph that simulates the primitive's internal flows. The analysis<br>then proceeds just like for any other expression. The few remaining<br>primitives need special handling because of their imperative nature<br>(</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:481"><nobr><span class="ft7">set-car!</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:540"><nobr><span class="ft4">or</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:555"><nobr><span class="ft7">vector-fill!</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:637"><nobr><span class="ft4">) and are analyzed in an ad-hoc man-</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:477"><nobr><span class="ft4">ner.</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:477"><nobr><span class="ft4">By default, MrFlow analyzes the</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:666"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:712"><nobr><span class="ft4">primitive based on the</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:477"><nobr><span class="ft4">following pseudo-type description:</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:491"><nobr><span class="ft7">(string top *-&gt; string)</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:477"><nobr><span class="ft4">The</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:502"><nobr><span class="ft7">*</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:512"><nobr><span class="ft4">in the</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:546"><nobr><span class="ft7">*-&gt;</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:571"><nobr><span class="ft4">constructor means that the primitive is a function</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:477"><nobr><span class="ft11">that can take any number of arguments as input beyond the ones<br>explicitly specified. In the present case, the function must receive<br>a string as its first argument, followed by any number of arguments<br>of any type (represented by the pseudo-type</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:729"><nobr><span class="ft7">top</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:750"><nobr><span class="ft4">), and returns a</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:477"><nobr><span class="ft11">string. Given such a description, the only errors MrFlow detects are<br>when the primitive is given something other than a string as first<br>argument, or if it is given no argument at all.</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:477"><nobr><span class="ft4">After partial evaluation, the application of</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:713"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:759"><nobr><span class="ft4">is replaced by</span></nobr></DIV>
<DIV style="position:absolute;top:830;left:477"><nobr><span class="ft4">calls to its individual library functions such as</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:737"><nobr><span class="ft7">format/char</span></nobr></DIV>
<DIV style="position:absolute;top:830;left:817"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:846;left:477"><nobr><span class="ft7">format/hex</span></nobr></DIV>
<DIV style="position:absolute;top:845;left:545"><nobr><span class="ft4">. These functions have respectively the pseudo-types</span></nobr></DIV>
<DIV style="position:absolute;top:873;left:491"><nobr><span class="ft7">(char -&gt; string)</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:477"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:491"><nobr><span class="ft7">(integer -&gt; string)</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:477"><nobr><span class="ft11">Using this more precise information, MrFlow can detect arguments<br>to the original</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:555"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:599"><nobr><span class="ft4">call that have the wrong type. Checking that</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:477"><nobr><span class="ft4">the</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:498"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:544"><nobr><span class="ft4">primitive receives the right number of arguments for</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:477"><nobr><span class="ft11">a given formatting string happens during partial evaluation, so the<br>analyzer never sees arity errors in the expanded code.</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:477"><nobr><span class="ft11">Since DrScheme's syntax object system keeps track of program<br>terms through the macro expansions [11], MrFlow is then able to<br>trace detected errors back to the original guilty terms in the user's</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">23</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107009.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft11">program and flag them graphically. Arrows representing the flow<br>of values can also be displayed interactively in terms of the original<br>program, allowing the user to track in the program the sources of<br>the values that triggered the errors. In essence, the only requirement<br>for MrFlow to analyze the partially evaluated code of</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:373"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:418"><nobr><span class="ft4">is to</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:81"><nobr><span class="ft11">specify the pseudo-types for the library functions introduced by the<br>transformations, like</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:195"><nobr><span class="ft7">format/char</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:271"><nobr><span class="ft8">6</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:277"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:81"><nobr><span class="ft11">Similarly, it is enough to define pseudo-types for the functions<br>used in the partially evaluated form of SchemeQL's</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:364"><nobr><span class="ft7">query</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:402"><nobr><span class="ft4">to have</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:81"><nobr><span class="ft15">MrFlow automatically compute precise results without any further<br>modifications.</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:81"><nobr><span class="ft11">The partial evaluation for regular expressions is more challenging.<br>Consider the example from Section 1:</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:95"><nobr><span class="ft7">(let ([r (regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:184"><nobr><span class="ft7">&quot;http://([a-z.]*)/([a-z]*)/&quot; line)])</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:102"><nobr><span class="ft7">(if r</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:115"><nobr><span class="ft16">(process-url (third r) (dispatch (second r)))<br>(log-error)))</span></nobr></DIV>
<DIV style="position:absolute;top:436;left:81"><nobr><span class="ft4">After the call to</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:172"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:436;left:254"><nobr><span class="ft4">, the variable</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:329"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:436;left:340"><nobr><span class="ft4">can be either a list</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:81"><nobr><span class="ft11">of three elements or false. Based on its conservative pseudo-type<br>specification for</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:174"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:256"><nobr><span class="ft4">, MrFlow computes that</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:393"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:405"><nobr><span class="ft4">can be</span></nobr></DIV>
<DIV style="position:absolute;top:481;left:81"><nobr><span class="ft11">either a list of unknown length or false. This in turn triggers two<br>errors for each of the</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:200"><nobr><span class="ft7">second</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:245"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:269"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:307"><nobr><span class="ft4">primitives: one error be-</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:81"><nobr><span class="ft11">cause the primitive might be applied to false when it expected a list,<br>and one error because it might be applied to a list that is too short.</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:81"><nobr><span class="ft11">The second kind of false positives can be removed by partially eval-<br>uating</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:118"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:205"><nobr><span class="ft4">to make the structure of the result more ex-</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:81"><nobr><span class="ft11">plicit to MrFlow, as described in Section 6.2. The analysis then<br>determines that the primitive returns either a list of three elements<br>or false and in turn checks that</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:251"><nobr><span class="ft7">second</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:296"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:319"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:357"><nobr><span class="ft4">are applied to a</span></nobr></DIV>
<DIV style="position:absolute;top:630;left:81"><nobr><span class="ft4">list with enough elements.</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:81"><nobr><span class="ft4">Still, the possible return values of</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:283"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:372"><nobr><span class="ft4">may contain</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:81"><nobr><span class="ft11">false. Indeed, false will be the value returned at runtime if the line<br>given to</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:128"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:214"><nobr><span class="ft4">does not match the pattern. The program-</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:81"><nobr><span class="ft11">mer has to test for such a condition explicitly before processing<br>the result any further. The only way for MrFlow not to show a false<br>positive for</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:144"><nobr><span class="ft7">second</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:188"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:210"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:245"><nobr><span class="ft4">, because of the presence of this false</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:81"><nobr><span class="ft11">value, is to make the analysis aware of the dependency between the<br>test of</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:119"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:130"><nobr><span class="ft4">and the two branches of the</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:286"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:300"><nobr><span class="ft4">-expression. This form of</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:81"><nobr><span class="ft4">flow-sensitive analysis for</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:226"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:239"><nobr><span class="ft4">-expressions is difficult to implement</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:81"><nobr><span class="ft11">in general since there is no bound to the complexity of the tested ex-<br>pression. In practice, however, an appreciable proportion of these<br>tests are simple enough that an ad-hoc solution is sufficient.</span></nobr></DIV>
<DIV style="position:absolute;top:854;left:81"><nobr><span class="ft11">In the case where the test is simply a variable reference it is enough<br>to create two corresponding ghost variables, one for each branch<br>of the</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:118"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:884;left:131"><nobr><span class="ft4">, establish <i>filtering flows </i>between the variable</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:389"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:884;left:400"><nobr><span class="ft4">and the</span></nobr></DIV>
<DIV style="position:absolute;top:899;left:81"><nobr><span class="ft4">two ghost variables, and make sure each ghost variable binds the</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:81"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:92"><nobr><span class="ft4">variable references in its respective branch of the</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:362"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:376"><nobr><span class="ft4">-expression.</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:81"><nobr><span class="ft11">The filtering flows prevent the false abstract value from flowing into<br>the then branch of the</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:200"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:944;left:214"><nobr><span class="ft4">-expression and prevent everything but the</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:81"><nobr><span class="ft11">false value from flowing into the else branch. Only the combination<br>of this flow sensitivity for</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:219"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:233"><nobr><span class="ft4">-expressions with the partial evaluation</span></nobr></DIV>
<DIV style="position:absolute;top:989;left:81"><nobr><span class="ft4">of</span></nobr></DIV>
<DIV style="position:absolute;top:990;left:96"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:989;left:181"><nobr><span class="ft4">gives analysis results with no false positives.</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:99"><nobr><span class="ft8">6</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:105"><nobr><span class="ft4">Specifying such pseudo-types will not even be necessary once</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:81"><nobr><span class="ft11">MrFlow knows how to analyze PLT Scheme contracts. This is the<br>subject of a forthcoming paper.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft4">Once flow-sensitive analysis of</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:669"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:683"><nobr><span class="ft4">-expressions is added and</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:477"><nobr><span class="ft11">pseudo-type descriptions of the necessary primitives are provided<br>to the analysis, partial evaluation makes all the false positives de-<br>scribed in Section 3 disappear, as we illustrate in the next section.</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:477"><nobr><span class="ft3"><b>8</b></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:504"><nobr><span class="ft3"><b>Improvement of Static Analysis</b></span></nobr></DIV>
<DIV style="position:absolute;top:234;left:477"><nobr><span class="ft4">Partially evaluating</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:588"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:634"><nobr><span class="ft4">eliminates the possibility of runtime</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:477"><nobr><span class="ft11">arity errors, since the macro transformations can statically check<br>such invariants. It also allows MrFlow to detect type errors that<br>it could not detect before, since the corresponding invariants were<br>described only in the embedded formatting language. These in-<br>variants are now explicit at the Scheme level in the transformed<br>program through the use of simpler primitives like</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:761"><nobr><span class="ft7">format/char</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:477"><nobr><span class="ft4">or</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:492"><nobr><span class="ft7">format/integer</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:588"><nobr><span class="ft4">. Figure 5 shows the same program as in Fig-</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:477"><nobr><span class="ft4">ure 2, but after applying partial evaluation. The</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:742"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:788"><nobr><span class="ft4">primitive</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:477"><nobr><span class="ft11">is now blamed for two type errors that before could be found only<br>at runtime. The error messages show that the user simply gave the<br>arguments</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:536"><nobr><span class="ft7">n</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:546"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:569"><nobr><span class="ft7">c</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:579"><nobr><span class="ft4">in the wrong order.</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:477"><nobr><span class="ft11">Similarly, specializing the regular expression engine with respect<br>to a pattern eliminates false positives. The length of the list re-<br>turned by</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:531"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:617"><nobr><span class="ft4">cannot be directly computed by the anal-</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:477"><nobr><span class="ft11">ysis since that information is hidden inside the regular expression<br>pattern. As a result, the applications of</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:693"><nobr><span class="ft7">second</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:738"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:762"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:800"><nobr><span class="ft4">in Fig-</span></nobr></DIV>
<DIV style="position:absolute;top:503;left:477"><nobr><span class="ft11">ure 3 are flagged as potential runtime errors (we have omitted the<br>fairly large error messages from the figure). After specialization,<br>the structure of the value returned by</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:680"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:766"><nobr><span class="ft4">is exposed to</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:477"><nobr><span class="ft4">the analysis and MrFlow can then prove that if</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:735"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:822"><nobr><span class="ft4">re-</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:477"><nobr><span class="ft4">turns a list, it must contain three elements. The false positives for</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:477"><nobr><span class="ft7">second</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:521"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:544"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:582"><nobr><span class="ft4">disappear in Figure 6.</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:477"><nobr><span class="ft4">Of course,</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:537"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:623"><nobr><span class="ft4">can also return false at runtime, and the</span></nobr></DIV>
<DIV style="position:absolute;top:623;left:477"><nobr><span class="ft11">analysis correctly predicts this regardless of whether partial eval-<br>uation is used or not. Adding flow sensitivity for</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:756"><nobr><span class="ft7">if</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:769"><nobr><span class="ft4">-expressions</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:477"><nobr><span class="ft11">as described in Section 7 removes these last spurious errors in Fig-<br>ure 6.</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:477"><nobr><span class="ft11">Partial evaluation now allows the precise analysis of SchemeQL<br>queries as well. Figure 7 shows the precise analysis of the same<br>program as in Figure 4, this time after partial evaluation. As with</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:477"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:742;left:559"><nobr><span class="ft4">, the analysis previously computed that</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:768"><nobr><span class="ft7">cursor-car</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:477"><nobr><span class="ft4">could return a list of any length, and therefore flagged the call to</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:477"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:514"><nobr><span class="ft4">as a potential runtime error. This call is now free of spurious</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:477"><nobr><span class="ft11">errors since the partial evaluation exposes enough structure of the<br>list returned by</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:567"><nobr><span class="ft7">cursor-car</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:641"><nobr><span class="ft4">that MrFlow can compute its exact</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:477"><nobr><span class="ft4">length and verify that</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:595"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:633"><nobr><span class="ft4">cannot fail at runtime.</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:477"><nobr><span class="ft11">While the results computed by the analysis become more precise,<br>partially evaluating the interpreters for any of the three embedded<br>languages we use in this paper results in code that is bigger than the<br>original program. Bigger code in turn means that analyses will take<br>more time to complete. There is therefore a trade-off between preci-<br>sion and efficiency of the analyses. We intend to turn that trade-off<br>into a user option in MrFlow. The user might also exercise full<br>control over which embedded languages are partially evaluated and<br>where by using either the functional or macro versions of the em-<br>bedded languages' interpreters, switching between the two through<br>the judicious use of a module system, for example [11].</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:477"><nobr><span class="ft11">Note that partial evaluation does not always benefit all analyses. In<br>the</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:498"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:584"><nobr><span class="ft4">example from Figure 6, spurious errors disap-</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:477"><nobr><span class="ft4">pear because MrFlow has been able to prove that the list</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:800"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:812"><nobr><span class="ft4">is of</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:477"><nobr><span class="ft4">length three and therefore that applying the primitives</span></nobr></DIV>
<DIV style="position:absolute;top:1072;left:779"><nobr><span class="ft7">second</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:825"><nobr><span class="ft4">or</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">24</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107010.png" alt="background image">
<DIV style="position:absolute;top:334;left:316"><nobr><span class="ft5"><b>Figure 5. Precise analysis of the</b></span></nobr></DIV>
<DIV style="position:absolute;top:334;left:501"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:545"><nobr><span class="ft5"><b>primitive.</b></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:335"><nobr><span class="ft5"><b>Figure 6. Precise analysis of</b></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:498"><nobr><span class="ft7">regexp-match</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:580"><nobr><span class="ft5"><b>.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1050;left:321"><nobr><span class="ft5"><b>Figure 7. Precise analysis of a SchemeQL query.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">25</span></nobr></DIV>
</DIV>
<!-- Page 11 -->
<a name="11"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107011.png" alt="background image">
<DIV style="position:absolute;top:115;left:81"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:119"><nobr><span class="ft4">to</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:134"><nobr><span class="ft7">r</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:145"><nobr><span class="ft4">cannot fail. If the analysis were a Hindley-Milner-like</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:81"><nobr><span class="ft11">type system, though, no difference would be seen whether partial<br>evaluation were used or not. Indeed, while such a type system could<br>statically prove that the arguments given to</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:324"><nobr><span class="ft7">second</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:370"><nobr><span class="ft4">or</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:385"><nobr><span class="ft7">third</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:424"><nobr><span class="ft4">are</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:81"><nobr><span class="ft11">lists, is would not attempt to prove that they are lists of the required<br>length and a runtime test would still be required. Using partial eval-<br>uation to expose such a property to the analysis would therefore be<br>useless. Simply put, making invariants from embedded programs<br>explicit in the host language only matters if the system analyzing<br>the host language cares about those invariants.</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:81"><nobr><span class="ft11">This does not mean partial evaluation is always useless when used<br>in conjunction with a Hindley-Milner type system, though. Par-<br>tially evaluating</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:170"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:211"><nobr><span class="ft4">, for example, would allow the type system</span></nobr></DIV>
<DIV style="position:absolute;top:323;left:81"><nobr><span class="ft11">to verify that the formatting string agrees with the types of the re-<br>maining arguments. This is in contrast to the ad-hoc solution used<br>in OCaml [19] to type check the</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:267"><nobr><span class="ft7">printf</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:313"><nobr><span class="ft4">primitive, or the use of</span></nobr></DIV>
<DIV style="position:absolute;top:368;left:81"><nobr><span class="ft4">dependent types in the case of Cayenne [4].</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:81"><nobr><span class="ft3"><b>9</b></span></nobr></DIV>
<DIV style="position:absolute;top:410;left:108"><nobr><span class="ft3"><b>Related Work</b></span></nobr></DIV>
<DIV style="position:absolute;top:443;left:81"><nobr><span class="ft11">Our work is analogous to designing type-safe embedded languages<br>such as the one for</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:195"><nobr><span class="ft7">printf</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:241"><nobr><span class="ft4">[21, 4]. Both problems involve de-</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:81"><nobr><span class="ft11">termining static information about programs based on the values<br>of embedded programs. In some cases, designers of typed lan-<br>guages simply extend the host language to include specific embed-<br>ded languages. The OCaml language, for example, contains a spe-<br>cial library for</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:165"><nobr><span class="ft7">printf</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:210"><nobr><span class="ft4">[19] and uses of</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:303"><nobr><span class="ft7">printf</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:349"><nobr><span class="ft4">are type-checked</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:81"><nobr><span class="ft15">in an ad-hoc manner. Similarly, the GCC compiler for the C lan-<br>guage uses ad-hoc checking to find errors in</span></nobr></DIV>
<DIV style="position:absolute;top:564;left:319"><nobr><span class="ft7">printf</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:363"><nobr><span class="ft4">format strings.</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:81"><nobr><span class="ft4">Danvy [7] and Hinze [14] suggest implementations of</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:384"><nobr><span class="ft7">printf</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:430"><nobr><span class="ft4">in</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:81"><nobr><span class="ft11">ML and Haskell, respectively, that obviate the need for dependent<br>types by recasting the library in terms of individual combinators.<br>In our system, those individual combinators are automatically in-<br>troduced during macro expansion. The C++ language [26] likewise<br>avoids the problem of checking invariants for</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:331"><nobr><span class="ft7">printf</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:376"><nobr><span class="ft4">by breaking</span></nobr></DIV>
<DIV style="position:absolute;top:667;left:81"><nobr><span class="ft11">its functionality into smaller operations that do not require the use<br>of an embedded formatting language.</span></nobr></DIV>
<DIV style="position:absolute;top:712;left:81"><nobr><span class="ft11">A work more closely related to ours is the Cayenne language [4].<br>Augustsson uses a form of partial evaluation to specialize depen-<br>dent types into regular Haskell-like types that can then be used by<br>the type system to check the user's program. Our macro system<br>uses macro-expansion time computation to specialize expressions<br>so that the subsequent flow analysis can compute precise value flow<br>results. Augustsson's dependent type system uses computation per-<br>formed at type-checking time to specialize dependent types so that<br>the rest of the type checking can compute precise type information.<br>The specialization is done in his system through the use of type-<br>computing functions that are specified by the user and evaluated by<br>the type system.</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:81"><nobr><span class="ft11">The main difference is that his system is used to compute special-<br>ized types and verify that the program is safe. Once the original<br>program has been typed it is just compiled as-is with type check-<br>ing turned off. This means that in the case of</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:325"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:366"><nobr><span class="ft4">, for example,</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:81"><nobr><span class="ft11">the formatting string is processed twice: once at type checking time<br>to prove the safety of the program, and once again at run time to<br>compute the actual result. Our system is used to compute special-<br>ized expressions. This means that the evaluation of the</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:391"><nobr><span class="ft7">format</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:432"><nobr><span class="ft4">'s</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:81"><nobr><span class="ft11">string needs to be done only once. Once specialized, the same pro-<br>gram can either be run or analyzed to prove its safety. In both cases<br>the format string will not have to be reprocessed since it has been<br>completely replaced by more specialized code.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft11">Another difference is that in our system, non-specialized programs<br>are still valid programs that can be analyzed, proved safe, and run<br>(though the result of the analysis will probably be more conser-<br>vative than when analyzing the corresponding partially evaluated<br>program, so proving safety might be more difficult). This is not<br>possible in Cayenne since programs with dependent types cannot<br>be run without going through the partial evaluation phase first.</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:477"><nobr><span class="ft11">Much work has gone into optimization of embedded languages.<br>Hudak [15], Elliott <i>et al </i>[8], Backhouse [5], Christensen [6], and<br>Veldhuizen [27] all discuss the use of partial evaluation to improve<br>the efficiency of embedded languages, although none makes the<br>connection between partial evaluation and static analysis. In Back-<br>house's thesis he discusses the need to improve error checking for<br>embedded languages, but he erroneously concludes that "<i>syntactic<br></i>analyses cannot be used due to the embedded nature of domain-<br>specific embedded languages."</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:477"><nobr><span class="ft11">The Lisp programming language ([25], Section 8.4) provides for<br>"compiler macros" that programmers can use to create optimized<br>versions of existing functions. The compiler is not required to use<br>them, though. To our knowledge, there is no literature showing<br>how to use these compiler macros to improve the results of static<br>analyses. Lisp also has support for inlining functions, which might<br>help monovariant analyses by duplicating the code of a function at<br>all its call sites, thereby simulating polyvariant analyses.</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:477"><nobr><span class="ft11">Bigloo [23] is a Scheme compiler that routinely implements em-<br>bedded languages via macros and thus probably provides some of<br>the benefits presented in this paper to the compiler's internal anal-<br>yses. The compiler has a switch to "enable optimization by macro<br>expansion," though there does not seem to be any documentation or<br>literature describing the exact effect of using that switch.</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:477"><nobr><span class="ft3"><b>10</b></span></nobr></DIV>
<DIV style="position:absolute;top:627;left:513"><nobr><span class="ft3"><b>Conclusion</b></span></nobr></DIV>
<DIV style="position:absolute;top:660;left:477"><nobr><span class="ft11">Programs in embedded languages contain invariants that are not au-<br>tomatically enforced by their host language. We have shown that<br>using macros to partially evaluate interpreters of little languages<br>embedded in Scheme with respect to their input programs can re-<br>capture these invariants and convey them to a flow analysis. Be-<br>cause it is based on macros, this technique does not require any<br>ad-hoc modification of either interpreters or analyses and is thus<br>readily available to programmers. This makes it a sweet spot in<br>the programming complexity versus precision landscape of pro-<br>gram analysis. We intend to investigate the relationship between<br>macros and other program analyses in a similar manner.</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:477"><nobr><span class="ft3"><b>Acknowledgments</b></span></nobr></DIV>
<DIV style="position:absolute;top:877;left:477"><nobr><span class="ft11">We thank Matthias Felleisen, Mitchell Wand, and Kenichi Asai for<br>the discussions that led to this work and for their helpful feed-<br>back. Thanks to Matthew Flatt for his help with the presentation<br>of Scheme macros. Thanks to Dale Vaillancourt for proofreading<br>the paper and to Ryan Culpepper for his macrological wizardry.</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:477"><nobr><span class="ft3"><b>11</b></span></nobr></DIV>
<DIV style="position:absolute;top:972;left:513"><nobr><span class="ft3"><b>References</b></span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:484"><nobr><span class="ft4">[1] H. Abelson and G. J. Sussman. <i>The Structure and Interpre-</i></span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:507"><nobr><span class="ft11"><i>tation of Computer Programs</i>. MIT Press, Cambridge, MA,<br>1985.</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:484"><nobr><span class="ft4">[2] A. Aiken. Introduction to set constraint-based program anal-</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:507"><nobr><span class="ft4">ysis. <i>Science of Computer Programming</i>, 35:79­111, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">26</span></nobr></DIV>
</DIV>
<!-- Page 12 -->
<a name="12"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="107012.png" alt="background image">
<DIV style="position:absolute;top:114;left:88"><nobr><span class="ft4">[3] K. Arnold, J. Gosling, and D. Holmes. <i>The Java Program-</i></span></nobr></DIV>
<DIV style="position:absolute;top:129;left:111"><nobr><span class="ft6"><i>ming Language</i>. Addison-Wesley, 3d edition, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:88"><nobr><span class="ft4">[4] L. Augustsson. Cayenne--a language with dependent types.</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:111"><nobr><span class="ft11">In <i>Proceedings of the third ACM SIGPLAN international con-<br>ference on Functional programming</i>, pages 239­250. ACM<br>Press, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:88"><nobr><span class="ft4">[5] K. Backhouse. <i>Abstract Interpretation of Domain-Specific</i></span></nobr></DIV>
<DIV style="position:absolute;top:232;left:111"><nobr><span class="ft6"><i>Embedded Languages</i>. PhD thesis, Oxford University, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:88"><nobr><span class="ft4">[6] N. H. Christensen. <i>Domain-specific languages in software de-</i></span></nobr></DIV>
<DIV style="position:absolute;top:269;left:111"><nobr><span class="ft11"><i>velopment ­ and the relation to partial evaluation</i>. PhD the-<br>sis, DIKU, Dept. of Computer Science, University of Copen-<br>hagen, Universitetsparken 1, DK-2100 Copenhagen East,<br>Denmark, July 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:88"><nobr><span class="ft4">[7] O. Danvy. Functional unparsing. <i>Journal of Functional Pro-</i></span></nobr></DIV>
<DIV style="position:absolute;top:350;left:111"><nobr><span class="ft6"><i>gramming</i>, 8(6):621­625, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:88"><nobr><span class="ft4">[8] C. Elliott, S. Finne, and O. de Moor. Compiling embedded</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:111"><nobr><span class="ft4">languages. In <i>SAIG</i>, pages 9­27, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:88"><nobr><span class="ft4">[9] R. B. Findler, J. Clements, M. F. Cormac Flanagan, S. Kr-</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:111"><nobr><span class="ft12">ishnamurthi, P. Steckler, and M. Felleisen. DrScheme: A<br>progamming environment for scheme. <i>Journal of Functional<br>Programming</i>, 12(2):159­182, March 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:81"><nobr><span class="ft4">[10] C. Flanagan and M. Felleisen. Componential set-based anal-</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:111"><nobr><span class="ft11">ysis. <i>ACM Trans. on Programming Languages and Systems</i>,<br>21(2):369­415, Feb. 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:81"><nobr><span class="ft4">[11] M. Flatt. Composable and compilable macros: you want it</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:111"><nobr><span class="ft11">when? In <i>Proceedings of the seventh ACM SIGPLAN interna-<br>tional conference on Functional programming</i>, pages 72­83.<br>ACM Press, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:81"><nobr><span class="ft4">[12] P. Graunke, S. Krishnamurthi, S. V. D. Hoeven, and</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:111"><nobr><span class="ft4">M. Felleisen.</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:198"><nobr><span class="ft4">Programming the web with high-level pro-</span></nobr></DIV>
<DIV style="position:absolute;top:623;left:111"><nobr><span class="ft11">gramming languages. In <i>Programming Languages and Sys-<br>tems, 10th European Symposium on Programming, ESOP<br>2001, Proceedings</i>, volume 2028 of <i>Lecture Notes in Com-<br>puter Science</i>, pages 122­136, Berlin, Heidelberg, and New<br>York, 2001. Springer-Verlag.</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:81"><nobr><span class="ft4">[13] N. Heintze.</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:193"><nobr><span class="ft6"><i>Set Based Program Analysis</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:376"><nobr><span class="ft4">PhD thesis,</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:111"><nobr><span class="ft4">Carnegie-Mellon Univ., Pittsburgh, PA, Oct. 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:81"><nobr><span class="ft4">[14] R. Hinze. Formatting: a class act. <i>Journal of Functional</i></span></nobr></DIV>
<DIV style="position:absolute;top:756;left:111"><nobr><span class="ft6"><i>Programming</i>, 13(5):935­944, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:81"><nobr><span class="ft4">[15] P. Hudak. Modular domain specific languages and tools. In</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:111"><nobr><span class="ft12"><i>Proceedings of Fifth International Conference on Software<br>Reuse</i>, pages 134­142, June 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft4">[16] S. N. Kamin. Research on domain-specific embedded lan-</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:507"><nobr><span class="ft12">guages and program generators. In R. Cleaveland, M. Mis-<br>love, and P. Mulry, editors, <i>Electronic Notes in Theoretical<br>Computer Science</i>, volume 14. Elsevier, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:477"><nobr><span class="ft4">[17] R. Kelsey, W. Clinger, and J. R. [editors]. Revised</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:794"><nobr><span class="ft8">5</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:805"><nobr><span class="ft4">report</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:507"><nobr><span class="ft11">on the algorithmic language Scheme. <i>Higher-Order and Sym-<br>bolic Computation</i>, 11(1):7­104, August 1998. Also appeared<br>in <i>SIGPLAN Notices </i>33:9, September 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:477"><nobr><span class="ft4">[18] B. W. Kernighan and D. M. Ritchie. <i>The C programming lan-</i></span></nobr></DIV>
<DIV style="position:absolute;top:262;left:507"><nobr><span class="ft6"><i>guage</i>. Prentice Hall Press, 1988.</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:477"><nobr><span class="ft4">[19] X. Leroy. The Objective Caml System, release 3.07, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:299;left:507"><nobr><span class="ft7">http://caml.inria.fr/ocaml/htmlman</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:739"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:477"><nobr><span class="ft4">[20] P. Meunier.</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:596"><nobr><span class="ft7">http://www.plt-scheme.org/software/</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:507"><nobr><span class="ft7">mrflow</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:548"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:477"><nobr><span class="ft4">[21] M. Neubauer, P. Thiemann, M. Gasbichler, and M. Sperber.</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:507"><nobr><span class="ft12">Functional logic overloading. In <i>Proceedings of the 29th ACM<br>SIGPLAN-SIGACT symposium on Principles of programming<br>languages</i>, pages 233­244. ACM Press, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:477"><nobr><span class="ft4">[22] J. Palsberg. Closure analysis in constraint form. <i>Proc. ACM</i></span></nobr></DIV>
<DIV style="position:absolute;top:438;left:507"><nobr><span class="ft11"><i>Trans. on Programming Languages and Systems</i>, 17(1):47­<br>62, Jan. 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:477"><nobr><span class="ft4">[23] M. Serrano and P. Weis. Bigloo: A portable and optimizing</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:507"><nobr><span class="ft12">compiler for strict functional languages. In <i>Static Analysis<br>Symposium</i>, pages 366­381, 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:477"><nobr><span class="ft4">[24] O. Shivers. A universal scripting framework, or Lambda: the</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:507"><nobr><span class="ft11">ultimate "little language". In <i>Proceedings of the Second Asian<br>Computing Science Conference on Concurrency and Paral-<br>lelism, Programming, Networking, and Security</i>, pages 254­<br>265. Springer-Verlag, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:477"><nobr><span class="ft4">[25] G. L. Steele. <i>COMMON LISP: the language</i>. Digital Press, 12</span></nobr></DIV>
<DIV style="position:absolute;top:623;left:507"><nobr><span class="ft11">Crosby Drive, Bedford, MA 01730, USA, 1984. With contri-<br>butions by Scott E. Fahlman and Richard P. Gabriel and David<br>A. Moon and Daniel L. Weinreb.</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:477"><nobr><span class="ft4">[26] B. Stroustrup. <i>The C++ Programming Language, Third Edi-</i></span></nobr></DIV>
<DIV style="position:absolute;top:689;left:507"><nobr><span class="ft6"><i>tion</i>. Addison-Wesley Longman Publishing Co., Inc., 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:477"><nobr><span class="ft4">[27] T. L. Veldhuizen. C++ templates as partial evaluation. In <i>Par-</i></span></nobr></DIV>
<DIV style="position:absolute;top:726;left:507"><nobr><span class="ft11"><i>tial Evaluation and Semantic-Based Program Manipulation</i>,<br>pages 13­18, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:477"><nobr><span class="ft4">[28] N. Welsh, F. Solsona, and I. Glover.</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:744"><nobr><span class="ft4">SchemeUnit and</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:507"><nobr><span class="ft12">SchemeQL: Two little languages. In <i>Proceedings of the Third<br>Workshop on Scheme and Functional Programming</i>, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1116;left:449"><nobr><span class="ft4">27</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
