<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Microsoft Word - ribeiro.doc</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="author" content="Ramon Puigjaner">
<META name="date" content="2006-10-17T14:42:23+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft0{font-size:11px;font-family:Times;color:#000000;}
	.ft1{font-size:24px;font-family:Helvetica;color:#000000;}
	.ft2{font-size:15px;font-family:Helvetica;color:#000000;}
	.ft3{font-size:7px;font-family:Helvetica;color:#000000;}
	.ft4{font-size:12px;font-family:Helvetica;color:#000000;}
	.ft5{font-size:15px;font-family:Times;color:#000000;}
	.ft6{font-size:11px;font-family:Times;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:15px;font-family:Helvetica;color:#000000;}
	.ft9{font-size:8px;font-family:Times;color:#000000;}
	.ft10{font-size:9px;font-family:Times;color:#000000;}
	.ft11{font-size:9px;font-family:Times;color:#000000;}
	.ft12{font-size:12px;line-height:16px;font-family:Helvetica;color:#000000;}
	.ft13{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft14{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="176001.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">1 </span></nobr></DIV>
<DIV style="position:absolute;top:160;left:116"><nobr><span class="ft1"><b>SensorBus: A Middleware Model for Wireless Sensor </b></span></nobr></DIV>
<DIV style="position:absolute;top:190;left:387"><nobr><span class="ft1"><b>Networks </b></span></nobr></DIV>
<DIV style="position:absolute;top:224;left:93"><nobr><span class="ft2">Admilson R. L. </span></nobr></DIV>
<DIV style="position:absolute;top:244;left:122"><nobr><span class="ft2">Ribeiro </span></nobr></DIV>
<DIV style="position:absolute;top:262;left:92"><nobr><span class="ft3"><i> </i></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:94"><nobr><span class="ft4">Dept. of Electrical </span></nobr></DIV>
<DIV style="position:absolute;top:281;left:97"><nobr><span class="ft4">Engineering and </span></nobr></DIV>
<DIV style="position:absolute;top:298;left:114"><nobr><span class="ft4">Computing </span></nobr></DIV>
<DIV style="position:absolute;top:315;left:84"><nobr><span class="ft4">Federal University of </span></nobr></DIV>
<DIV style="position:absolute;top:331;left:134"><nobr><span class="ft4">Pará </span></nobr></DIV>
<DIV style="position:absolute;top:348;left:87"><nobr><span class="ft4">01, Augusto Correa </span></nobr></DIV>
<DIV style="position:absolute;top:365;left:130"><nobr><span class="ft4">Street  </span></nobr></DIV>
<DIV style="position:absolute;top:388;left:98"><nobr><span class="ft4">P.O.Box 8619 ­ </span></nobr></DIV>
<DIV style="position:absolute;top:405;left:95"><nobr><span class="ft4">Belém PA, Brazil  </span></nobr></DIV>
<DIV style="position:absolute;top:427;left:102"><nobr><span class="ft4">ZIP 66075-900 </span></nobr></DIV>
<DIV style="position:absolute;top:444;left:90"><nobr><span class="ft4">+55-91-3183-1302 </span></nobr></DIV>
<DIV style="position:absolute;top:467;left:79"><nobr><span class="ft2">admilson@ufpa.br </span></nobr></DIV>
<DIV style="position:absolute;top:224;left:240"><nobr><span class="ft2">Fabio C.S. Silva </span></nobr></DIV>
<DIV style="position:absolute;top:244;left:246"><nobr><span class="ft4">IESAM Computer </span></nobr></DIV>
<DIV style="position:absolute;top:261;left:263"><nobr><span class="ft4">Engineering </span></nobr></DIV>
<DIV style="position:absolute;top:278;left:248"><nobr><span class="ft4">Belem PA, Brazil  </span></nobr></DIV>
<DIV style="position:absolute;top:294;left:239"><nobr><span class="ft4">1148, Jose Malcher </span></nobr></DIV>
<DIV style="position:absolute;top:311;left:291"><nobr><span class="ft4">Av. </span></nobr></DIV>
<DIV style="position:absolute;top:334;left:248"><nobr><span class="ft12">ZIP 66055-200 ­ <br>Belem PA, Brazil </span></nobr></DIV>
<DIV style="position:absolute;top:368;left:242"><nobr><span class="ft4">+55-91-4005-5480 </span></nobr></DIV>
<DIV style="position:absolute;top:390;left:239"><nobr><span class="ft2">fcs@prof.iesam-</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:265"><nobr><span class="ft2">pa.edu.br </span></nobr></DIV>
<DIV style="position:absolute;top:224;left:391"><nobr><span class="ft2">Lilian C. Freitas </span></nobr></DIV>
<DIV style="position:absolute;top:241;left:394"><nobr><span class="ft3"><i> </i></span></nobr></DIV>
<DIV style="position:absolute;top:244;left:396"><nobr><span class="ft4">Dept. of Electrical </span></nobr></DIV>
<DIV style="position:absolute;top:261;left:399"><nobr><span class="ft4">Engineering and </span></nobr></DIV>
<DIV style="position:absolute;top:278;left:416"><nobr><span class="ft4">Computing </span></nobr></DIV>
<DIV style="position:absolute;top:294;left:386"><nobr><span class="ft4">Federal University of </span></nobr></DIV>
<DIV style="position:absolute;top:311;left:436"><nobr><span class="ft4">Pará </span></nobr></DIV>
<DIV style="position:absolute;top:328;left:389"><nobr><span class="ft4">01, Augusto Correa </span></nobr></DIV>
<DIV style="position:absolute;top:345;left:432"><nobr><span class="ft4">Street  </span></nobr></DIV>
<DIV style="position:absolute;top:368;left:400"><nobr><span class="ft4">P.O.Box 8619 ­ </span></nobr></DIV>
<DIV style="position:absolute;top:384;left:397"><nobr><span class="ft4">Belém PA, Brazil  </span></nobr></DIV>
<DIV style="position:absolute;top:407;left:403"><nobr><span class="ft4">ZIP 66075-900 </span></nobr></DIV>
<DIV style="position:absolute;top:424;left:392"><nobr><span class="ft4">+55-91-3183-1302 </span></nobr></DIV>
<DIV style="position:absolute;top:447;left:392"><nobr><span class="ft2">liliancf@ufpa.br </span></nobr></DIV>
<DIV style="position:absolute;top:224;left:535"><nobr><span class="ft2">João Crisóstomo </span></nobr></DIV>
<DIV style="position:absolute;top:244;left:577"><nobr><span class="ft2">Costa </span></nobr></DIV>
<DIV style="position:absolute;top:264;left:544"><nobr><span class="ft4">Dept. of Electrical </span></nobr></DIV>
<DIV style="position:absolute;top:281;left:547"><nobr><span class="ft4">Engineering and </span></nobr></DIV>
<DIV style="position:absolute;top:298;left:565"><nobr><span class="ft4">Computing </span></nobr></DIV>
<DIV style="position:absolute;top:315;left:534"><nobr><span class="ft4">Federal University of </span></nobr></DIV>
<DIV style="position:absolute;top:331;left:584"><nobr><span class="ft4">Pará </span></nobr></DIV>
<DIV style="position:absolute;top:348;left:537"><nobr><span class="ft4">01, Augusto Correa </span></nobr></DIV>
<DIV style="position:absolute;top:365;left:580"><nobr><span class="ft4">Street  </span></nobr></DIV>
<DIV style="position:absolute;top:388;left:549"><nobr><span class="ft4">P.O.Box 8619 ­ </span></nobr></DIV>
<DIV style="position:absolute;top:405;left:546"><nobr><span class="ft4">Belém PA, Brazil </span></nobr></DIV>
<DIV style="position:absolute;top:421;left:552"><nobr><span class="ft4">ZIP 66075-900 </span></nobr></DIV>
<DIV style="position:absolute;top:438;left:540"><nobr><span class="ft4">+55-91-3183-1302 </span></nobr></DIV>
<DIV style="position:absolute;top:461;left:545"><nobr><span class="ft2">jweyl@ufpa.br </span></nobr></DIV>
<DIV style="position:absolute;top:224;left:712"><nobr><span class="ft2">Carlos R. </span></nobr></DIV>
<DIV style="position:absolute;top:244;left:716"><nobr><span class="ft2">Francês </span></nobr></DIV>
<DIV style="position:absolute;top:264;left:692"><nobr><span class="ft4">Dept. of Electrical </span></nobr></DIV>
<DIV style="position:absolute;top:281;left:695"><nobr><span class="ft4">Engineering and </span></nobr></DIV>
<DIV style="position:absolute;top:298;left:713"><nobr><span class="ft4">Computing </span></nobr></DIV>
<DIV style="position:absolute;top:315;left:682"><nobr><span class="ft4">Federal University of </span></nobr></DIV>
<DIV style="position:absolute;top:331;left:732"><nobr><span class="ft4">Pará </span></nobr></DIV>
<DIV style="position:absolute;top:348;left:686"><nobr><span class="ft4">01, Augusto Correa </span></nobr></DIV>
<DIV style="position:absolute;top:365;left:728"><nobr><span class="ft4">Street  </span></nobr></DIV>
<DIV style="position:absolute;top:388;left:697"><nobr><span class="ft4">P.O.Box 8619 ­ </span></nobr></DIV>
<DIV style="position:absolute;top:405;left:694"><nobr><span class="ft4">Belém PA, Brazil </span></nobr></DIV>
<DIV style="position:absolute;top:421;left:700"><nobr><span class="ft4">ZIP 66075-900 </span></nobr></DIV>
<DIV style="position:absolute;top:438;left:696"><nobr><span class="ft4">+55-91-31-1302 </span></nobr></DIV>
<DIV style="position:absolute;top:461;left:681"><nobr><span class="ft2">rfrances@ufpa.br</span></nobr></DIV>
<DIV style="position:absolute;top:491;left:446"><nobr><span class="ft2"> </span></nobr></DIV>
<DIV style="position:absolute;top:516;left:79"><nobr><span class="ft5"><b>ABSTRACT</b></span></nobr></DIV>
<DIV style="position:absolute;top:520;left:174"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:536;left:79"><nobr><span class="ft13">The use of middleware eases the development of distributed <br>applications by abstracting the intricacies (communication and <br>coordination among software components) of the distributed <br>network environment. In wireless sensor networks, this is even <br>trickier because of their specific issues such as addressing, <br>mobility, number of sensors and energy-limited nodes. This paper <br>describes SensorBus<i>,</i> a message-oriented middleware (MOM) <br>model for wireless sensor networks based on the publish-<br>subscribe paradigm and that allows the free exchange of the <br>communication mechanism among sensor nodes allowing as <br>result the capability of using more than one communication <br>mechanism to address the requirements of larger number of <br>applications.<b><i> </b></i>We intend to provide a platform which addresses the <br>main characteristics of wireless sensor networks and also allows <br>the development of energy-efficient applications. SensorBus <br>incorporates constraint and query languages which will aid the <br>development of interactive applications. It intends with the <br>utilization of filters reduces data movement minimizing the <br>energy consumption of nodes. </span></nobr></DIV>
<DIV style="position:absolute;top:847;left:79"><nobr><span class="ft5"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:867;left:79"><nobr><span class="ft13">Middleware, wireless sensor networks, publish-subscribe <br>paradigm. </span></nobr></DIV>
<DIV style="position:absolute;top:916;left:79"><nobr><span class="ft5"><b>1.</b></span></nobr></DIV>
<DIV style="position:absolute;top:916;left:92"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:916;left:102"><nobr><span class="ft5"><b>INTRODUCTION </b></span></nobr></DIV>
<DIV style="position:absolute;top:936;left:79"><nobr><span class="ft13">Recent advances in wireless networking technology, low-power <br>digital circuits, sensing materials and Micro Electro-Mechanical </span></nobr></DIV>
<DIV style="position:absolute;top:516;left:464"><nobr><span class="ft13">Systems (MEMS) opened up the possibility of building small <br>sensor devices capable of data processing, remote sensing and <br>wireless communication. When several small sensors are scattered <br>and linked over an area we may call this arrangement a "Sensor <br>Network". These networks can be used for collecting and <br>analyzing data from the physical environment. More specifically, <br>sensor networks are comprised of hundreds or even thousands of <br>heterogeneous sensor nodes exchanging information to perform <br>distributed sensing and collaborative data processing [1].      </span></nobr></DIV>
<DIV style="position:absolute;top:663;left:464"><nobr><span class="ft13">From a functional perspective sensor networks behave like <br>distributed systems with many different types of sensor nodes. <br>Given the diversity of node functionality and the size of these <br>networks it is important for a user to be able to program and <br>manage the distributed applications that perform the information <br>gathering. A programmer may develop these applications using <br>operating system primitives. This kind of procedure, however, <br>brings another level of complexity to the programmer, in which <br>he not only has to deal with low-level primitives but he will also <br>have to treat issues concerning communication and coordination <br>among software components distributed over the network. A <br>much friendlier approach is the utilization of a middleware in <br>order to provide higher-level primitives to hide issues concerning <br>the distributed environment.  </span></nobr></DIV>
<DIV style="position:absolute;top:888;left:464"><nobr><span class="ft13">Traditional middleware is not suited to this task because of the <br>characteristics of wireless networks. For example, conventional <br>middleware designed for wired networks raises exceptions when <br>they do not find a specific component, but this situation is much <br>more like the standard than the exception in wireless <br>environments. The lower bandwidth available for wireless <br>networks requires optimizing the transport of data and this is not <br>considered in conventional middleware. The coordination <br>primitives of these middleware products do not take into account <br>the frequent disconnections that happen in wireless networks. <br>Another problem is the size and computing requirements of these <br>middleware products; they are often too large and too heavy to be <br>running in a device with so few resources. Finally, the <br>transparency level provided is not sufficient enough because the </span></nobr></DIV>
<DIV style="position:absolute;top:973;left:84"><nobr><span class="ft9"> </span></nobr></DIV>
<DIV style="position:absolute;top:985;left:84"><nobr><span class="ft14">Permission to make digital or hard copies of all or part of this work for <br>personal or classroom use is granted without fee provided that copies are <br>not made or distributed for profit or commercial advantage and that <br>copies bear this notice and the full citation on the first page. To copy <br>otherwise, or republish, to post on servers or to redistribute to lists, <br>requires prior specific permission and/or a fee. <br><i>LANC'05</i>, October 10-12, 2005, Cali, Colombia <br>(c) 2005 ACM 1-59593-008-6/05/0010..$5.00 </span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1263" src="176002.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">2 </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:79"><nobr><span class="ft13">application running in such devices needs information about the <br>execution context to better adapt itself. </span></nobr></DIV>
<DIV style="position:absolute;top:199;left:79"><nobr><span class="ft13">A series of new middleware environments were proposed to deal <br>with the requirements imposed by the wireless environment [2]. <br>Middleware products based on computing reflection are designed <br>to be light (concerning the computing power required to run) and <br>easily configurable. Middleware based on tuple space were <br>proposed to address the problem of frequent disconnections, and <br>present a more natural way to deal with asynchronous <br>communication. Context-aware middleware includes the ability of <br>an application to access its information context (context-<br>awareness). These proposals addressed adequately the issues <br>brought by the mobile networks, but are not well suited to support <br>the specific requirements of the target applications used or to be <br>used in wireless sensor networks because they are designed to <br>support traditional client-server applications used in regular <br>(wired) environments. </span></nobr></DIV>
<DIV style="position:absolute;top:439;left:79"><nobr><span class="ft13">Wireless sensor networks are very similar to conventional <br>wireless networks; including energy-limited nodes, low <br>bandwidth and communication channels more prone to errors. <br>However, communication in wireless sensor nets differs from the <br>end-to-end connections often necessary in usual networks [1]. In <br>other words, the function of the network is to report information <br>considering the phenomenon to the observer who is not <br>necessarily aware that the sensor infrastructure is being used as a <br>means of communication. In addition, energy is much more <br>limited in sensor networks than in other types of wireless nets due <br>to the nature of the sensor devices and the difficulty of reloading <br>batteries in hostile regions. Some works have shown that the <br>execution of 3000 instructions costs the same amount of energy <br>necessary to send 1-bit of data over 100 meters via radio [3]. <br>Those studies indicate that we must prioritize computing over <br>communications.  </span></nobr></DIV>
<DIV style="position:absolute;top:694;left:79"><nobr><span class="ft13">The communication issues are addressed in the several routing <br>protocols proposed for wireless sensor nets. The communication <br>model allows other ways of addressing the sensor nodes besides <br>single addressing. The sensor nodes can be addressed by their <br>own attributes or by attributes extracted from the physical <br>environment (attribute-based naming). The sharp limitation of <br>energy demands that sensor nodes actively take part in the <br>processing and dissemination of information in order to save as <br>much energy as possible. Although the majority of the protocols <br>reviewed are efficient in saving energy, they differ in addressing <br>capabilities. Some of them utilize single addressing [4] while <br>others utilize attribute-based naming [5]. Thus, each type of <br>application requires an adaptation of the communication <br>mechanism to address specific application issues.  </span></nobr></DIV>
<DIV style="position:absolute;top:918;left:79"><nobr><span class="ft13">Trying to overcome these problems this paper proposes <br>SensorBus<i>,<b>  </b></i>a message oriented middleware for sensor networks <br>allowing the free exchanging of the communication mechanism <br>among sensor nodes. We propose a platform that provides <br>facilities for the development of energy-efficient applications and <br>that also addresses the key characteristics of sensor networks. <br>This type of middleware should be suited to perform <br>environmental monitoring where single addressing is demanded <br>(small areas) as well as where attribute-based naming is necessary <br>(large areas). </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:464"><nobr><span class="ft13">The remainder of this paper is organized as follows: Section 2 <br>describes the type of sensor networks considered in this research; <br>Section 3 presents the target application and explains its <br>requirements; Section 4 broaches the abstractions and <br>mechanisms needed to address the requirements listed on the <br>previous section; Section 5 describes the components of the <br>SensorBus architecture; Section 6 presents the communication <br>architecture and explains the steps needed to develop an <br>application using SensorBus; Section 7 broaches implementing <br>and coding issue; Section 8 presents the related works, and finally <br>Section 9 concludes the paper. </span></nobr></DIV>
<DIV style="position:absolute;top:347;left:464"><nobr><span class="ft5"><b>2.</b></span></nobr></DIV>
<DIV style="position:absolute;top:346;left:477"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:487"><nobr><span class="ft5"><b>ASSUMPTIONS </b></span></nobr></DIV>
<DIV style="position:absolute;top:367;left:464"><nobr><span class="ft13">Most of the algorithms catalogued in the sensor networks <br>literature are hypothetical [1], i.e., they were proposed as an <br>experiment and were not tested in real networks (although many <br>of them were deployed in <i>testbed</i> environments). This research is <br>no different. When we speak about wireless sensor networks, we <br>are referring to the projected and experimental designs and <br>deployments discussed in the literature and not to actual instances <br>of wireless sensor networks deployed in the field. </span></nobr></DIV>
<DIV style="position:absolute;top:499;left:464"><nobr><span class="ft13">Differently from the real settings, the <i>testbed</i> environments are <br>built and organized focusing on the network features one wants to <br>observe and test. This organization involves three main <br>components: infrastructure, network protocols and applications <br>[6]. The infrastructure is formed of sensor nodes and their <br>topology ­ the way they were scattered over a determined region. <br>The network protocol is responsible for the creation and <br>maintenance of communication links between sensor nodes and <br>the applications. The applications extract information about a <br>determined phenomenon through the sensor nodes. The following <br>topics introduce in more details the assumptions made considering <br>those aspects. </span></nobr></DIV>
<DIV style="position:absolute;top:702;left:464"><nobr><span class="ft5"><b>2.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:701;left:486"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:702;left:496"><nobr><span class="ft5"><b>Applications </b></span></nobr></DIV>
<DIV style="position:absolute;top:722;left:464"><nobr><span class="ft13">The way in which the applications gather data from the sensor <br>nodes depends on the network design. In the literature, we found <br>that there are four data transfer modes between sensor nodes and <br>applications: continuous, event-oriented, query-oriented and <br>hybrid [6]. In the continuous model, sensor nodes transfer their <br>data continuously at a predefined rate. In the event-oriented <br>model, nodes transfer data only when an event of interest occurs. <br>In the query-oriented model the application is responsible for <br>deciding which events are of interest, thus requesting data about a <br>phenomenon. Lastly, in the hybrid model, the three approaches <br>may coexist together. In this research, we adopt a hybrid approach <br>in the way that it utilizes the query and the event-oriented model <br>as will be shown in the target application presented in Section 3. </span></nobr></DIV>
<DIV style="position:absolute;top:940;left:464"><nobr><span class="ft5"><b>2.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:940;left:486"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:940;left:496"><nobr><span class="ft5"><b>Network Protocol </b></span></nobr></DIV>
<DIV style="position:absolute;top:960;left:464"><nobr><span class="ft13">The performance of the network protocol is influenced by the <br>communications model adopted, the packet data transfer mode <br>and the network mobility.  In order to evaluate how a network <br>protocol behaves it is important to take into account these aspects. </span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:464"><nobr><span class="ft13">Communication in sensor networks is classified in two major <br>categories [6]: application and infrastructure. Application <br>communication consists of the transfer of data obtained by the <br>sensor nodes to the observer. This kind of communication is of </span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1263" src="176003.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">3 </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:79"><nobr><span class="ft13">two types: cooperative and non-cooperative. In cooperative mode <br>sensor nodes exchange data among themselves before <br>transmitting the data gathered. In non-cooperative mode, <br>however, sensor nodes do not exchange any kind of information; <br>each one is solely responsible for reporting its collected data. The <br>infrastructure data refers to the information needed to set, <br>maintain and optimize the running network. As the network <br>protocol must support both categories, the SensorBus architecture <br>will not address those issues.   </span></nobr></DIV>
<DIV style="position:absolute;top:307;left:79"><nobr><span class="ft13"> The packet data transfer is a routing issue concerning the network <br>protocol. This routing is divided into three types:  flooding, <br>unicast and multicast<i>  </i>[6]. In the flooding approach, the sensor <br>node broadcasts its information to neighboring nodes that, in turn, <br>broadcast this information to their neighboring nodes until the <br>information reaches the destination node. Alternatively, the sensor <br>node may transmit its data directly to the observer using unicast <br>multi-hop routing and also might use a cluster-head through one-<br>to-one unicast. Lastly, the multicast approach casts information to <br>predefined groups of nodes. The routing protocol is responsible <br>for treating packet data transfer relieving SensorBus of these <br>issues.  </span></nobr></DIV>
<DIV style="position:absolute;top:500;left:79"><nobr><span class="ft13">Regarding mobility, sensor networks are divided into static and <br>dynamic [6]. In static nets there is no movement by sensor nodes, <br>the observers or the phenomenon to be studied. Conversely, in <br>dynamic networks the nodes, observers and the phenomenon <br>might well change their locations. This kind of network is further <br>classified by the mobility of its components in dynamic nets with <br>mobile observer, dynamic nets with mobile sensors<i> </i>and dynamic <br>nets with mobile phenomena respectively. In the first, the <br>observer is mobile in relation to the sensors and phenomena; in <br>the second; the sensors are moving with respect to each other and <br>the observer; and in the later; the phenomenon itself is in motion. <br>The routing protocol is also responsible for treating mobility <br>issues, relieving SensorBus of these concerns.  </span></nobr></DIV>
<DIV style="position:absolute;top:719;left:79"><nobr><span class="ft5"><b>2.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:718;left:101"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:719;left:111"><nobr><span class="ft5"><b>Infrastructure </b></span></nobr></DIV>
<DIV style="position:absolute;top:738;left:79"><nobr><span class="ft13">As for the infrastructure, the issues to take into consideration are <br>location, access point and sensor node's computing power. The <br>nodes have well-know locations and are to be scattered over a <br>well-defined area. We will assume that all information is <br>transmitted and received by means of a unique access point called <br>the sink node. Despite the fact that, for this model, we will <br>consider all nodes as being the same, there is nothing to prevent <br>one node from having more memory, more energy or more <br>computing power available. </span></nobr></DIV>
<DIV style="position:absolute;top:895;left:79"><nobr><span class="ft5"><b>3.</b></span></nobr></DIV>
<DIV style="position:absolute;top:895;left:92"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:895;left:102"><nobr><span class="ft5"><b>ENVIRONMENTAL MONITORING </b></span></nobr></DIV>
<DIV style="position:absolute;top:916;left:79"><nobr><span class="ft5"><b>APPLICATIONS </b></span></nobr></DIV>
<DIV style="position:absolute;top:936;left:79"><nobr><span class="ft13">Environmental Monitoring Applications are used to evaluate <br>qualitatively and quantitatively the natural resources of a <br>determined area. These applications collect data, analyze and <br>follow continuously and systematically environmental variables <br>in order to identify current patterns and predict future trends [7]. <br>Environmental monitoring provides information about the factors <br>influencing conservation, preservation, degradation and <br>environmental recovery. One might consider it a tool of <br>evaluation and control. </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:464"><nobr><span class="ft13">Wireless sensor networks can be used for performing <br>environmental monitoring in indoor locations such as a building <br>or a house or outdoors locations such as forests, lakes, deserts, <br>rivers, etc. Internal monitoring might be described as tracking the <br>variables in an indoor location. For example, one might deploy an <br>infrared camera to track motion in a room that is supposed to be <br>secure; if motion is detected an internal device might trigger an <br>alarm. Sometimes in order to detect and identify an event, <br>information from more than one sensor might be required. These <br>results are processed and compared with the signature of the event <br>of interest. In outdoor monitoring, there may be thousands of <br>sensors scattered over an area and when an event of interest <br>occurs such as temperature change, moisture change or CO2 <br>increase the sensor might trigger the management events module <br>which in turn sends the observer a signal to notify him or her of <br>the event. Wireless sensors might be useful in a way that can save <br>money in deploying a sensor infrastructure such as described in <br>[8] where the authors were able to decrease the number of sensors <br>needed to monitor forest fires in comparison with a wired model.  </span></nobr></DIV>
<DIV style="position:absolute;top:461;left:464"><nobr><span class="ft13">In summary, the value of a wireless sensor network relies in its <br>ability to provide information over a large area in reply to the <br>questions put to users. The query mode is the most common <br>approach used. Another approach is the mode in which sensors <br>may remain waiting for some event to happen. By observing these <br>aspects we draw the first requirement (R1) of our middleware <br>model: The system must be able to function in two modes: query-<br>driven and event-oriented. </span></nobr></DIV>
<DIV style="position:absolute;top:593;left:464"><nobr><span class="ft13">Depending on the application would be more convenient to access <br>a specific node or a specific property. For example, in internal <br>environmental monitoring, if one wants to know the temperature <br>of a determined room you will have to access the information <br>collected by a specific sensor, thus requiring unique node <br>addressing and identification. On the other hand, in external <br>environmental monitoring, sensor nodes do not need to be <br>uniquely identified, as in this kind of application the purpose is to <br>collect the value of a certain variable in a given area. From that <br>observation we extract the second requirement (R2): The system <br>must be able to address uniquely the sensor nodes and also by <br>attribute (property to be observed).  </span></nobr></DIV>
<DIV style="position:absolute;top:786;left:464"><nobr><span class="ft13">In some applications the mobility of sensor nodes must be taken <br>into account. For example, sensors scattered over a forest for <br>collecting dampness and temperature data are to be static, i.e. they <br>must not change its geographical location, while that placing <br>sensors in a river's surface for collecting data about its <br>contamination levels characterizes a mobile environment. Thus, <br>the third requirement (R3) of our middleware model is taking into <br>consideration mobility issues.  </span></nobr></DIV>
<DIV style="position:absolute;top:918;left:464"><nobr><span class="ft13">The sensing coverage area of a given wireless node is smaller <br>than its radio coverage. Besides, sensors operate in noisy <br>environments. To achieve a trustworthy sensory resolution a high <br>density of sensors is required. In some applications the size of the <br>coverage area leads to a great number of sensor nodes. A simple <br>application in the field of environmental monitoring such as <br>surveillance of oceans and forests requires from hundreds to <br>thousands of nodes. In other applications, like internal <br>environmental monitoring, the amount of nodes is limited by the <br>size of the area. Therefore, the fourth requirement (R4) is to take <br>into account the size of the network.  </span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft15{font-size:11px;font-family:Times;color:#000000;}
	.ft16{font-size:11px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="176004.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">4 </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:79"><nobr><span class="ft13">In external environmental monitoring, the nodes are spread in a <br>hostile region, where it is not possible to access them for <br>maintenance. The lifetime of each sensor node depends <br>exclusively on the little available energy for the node. To <br>conserve energy, the speed of the CPU and the bandwidth of the <br>RF channel (Radio Frequency) must be limited. This requirement <br>adds some restrictions in CPU performance, memory size, RF <br>bandwidth and in battery size. In applications where the sensors <br>are not spread in a hostile region it is possible to access them for <br>maintenance and the battery lifetime of each sensor does not <br>become a critical aspect. Finally, the fifth requirement (R5) is to <br>take into consideration the limited energy resources of each <br>sensor node. </span></nobr></DIV>
<DIV style="position:absolute;top:378;left:79"><nobr><span class="ft5"><b>4.</b></span></nobr></DIV>
<DIV style="position:absolute;top:377;left:92"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:378;left:102"><nobr><span class="ft5"><b>MECHANISMS AND ABSTRACTIONS </b></span></nobr></DIV>
<DIV style="position:absolute;top:397;left:79"><nobr><span class="ft13">This middleware model is comprised of three mechanisms and <br>one abstraction. The publish-subscribe paradigm is employed as <br>well as constraints and query languages and application filters to <br>meet R1, R2 and R5 requirements. The design patterns abstraction <br>is used to meet R2, R3 and R4 requirements.  </span></nobr></DIV>
<DIV style="position:absolute;top:493;left:79"><nobr><span class="ft5"><b>4.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:492;left:101"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:493;left:111"><nobr><span class="ft5"><b>Publish-Subscribe Paradigm </b></span></nobr></DIV>
<DIV style="position:absolute;top:512;left:79"><nobr><span class="ft13">The SensorBus is a Message Oriented Middleware (MOM) that <br>employs the publish-subscribe paradigm. In this approach, a <br>component that generates events (producer) publishes the types of <br>events that will be available to other components (consumers) [9]. <br>The consumer interested in a determined event "subscribes" to <br>this event, receiving from this moment on notifications about the <br>event "subscribed" to. These notifications are sent <br>asynchronously from producers to all interested consumers.  The <br>MOM performs the functions of collecting producer's messages, <br>filtering and transforming such messages (when necessary) and <br>routing them to the appropriate consumers. </span></nobr></DIV>
<DIV style="position:absolute;top:691;left:79"><nobr><span class="ft13">The publish-subscribe communication is anonymous, <br>asynchronous and multicast<i>.  </i>Data are sent and received by <br>asynchronous broadcast messages, based in subject, independent <br>from identity and location of producers and consumers. This kind <br>of communication enlists desirable properties for sensor <br>networks; for example, this model saves energy while a given <br>node does not need to be waiting for a synchronous response to <br>proceed as it is in networks that implements end-to-end <br>connections, increasing the lifetime of the network. Furthermore, <br>as it also implements multicast, a group of sensor might be <br>formed regarding a specific application.  </span></nobr></DIV>
<DIV style="position:absolute;top:869;left:79"><nobr><span class="ft13">As a consequence, the adoption of the publish-subscribe<i> </i>paradigm <br>meets the R1 requirement, concerning the need for events and the <br>R2 requirement pertaining to attribute addressing. In addition it <br>also meets the R5 requirement related to energy saving. </span></nobr></DIV>
<DIV style="position:absolute;top:949;left:79"><nobr><span class="ft5"><b>4.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:948;left:101"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:949;left:111"><nobr><span class="ft5"><b>Constraint and Query Languages </b></span></nobr></DIV>
<DIV style="position:absolute;top:968;left:79"><nobr><span class="ft13">Constraint and Query languages are used to filter collecting data <br>by specifying restrictions in the values and preferences of the <br>attributes. A statement in these languages is a string<i>  </i>that <br>represents an expression. </span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:79"><nobr><span class="ft13">The constraint language only includes constants (values) and <br>operations over values. Values and operations with integer, float, <br>boolean and <i>strings</i> are allowed. The language admits several <br>types of expressions. </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:464"><nobr><span class="ft15">·</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:470"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:160;left:490"><nobr><span class="ft13">The expressions can be comparative:  == (equality), != <br>(inequality), &gt;, &gt;=, &lt;, &lt;=. For instance, Temperature &lt; 36.6 <br>means to consider data where the attribute Temperature is <br>less than 36.6 degrees Celsius. </span></nobr></DIV>
<DIV style="position:absolute;top:230;left:464"><nobr><span class="ft15">·</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:470"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:231;left:490"><nobr><span class="ft13">The expressions can be boolean: AND, OR, NOT. For <br>example, Temperature &gt;= 26.6 AND Temperature &lt; = 36.6 <br>implies to consider data where the value of the attribute <br>Temperature is between 26.6 and 36.6 degrees Celsius. </span></nobr></DIV>
<DIV style="position:absolute;top:301;left:464"><nobr><span class="ft15">·</span></nobr></DIV>
<DIV style="position:absolute;top:303;left:470"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:303;left:490"><nobr><span class="ft13">The expressions can be numerical with the mathematical <br>operators + (addition), - (subtraction), * (multiplication) and <br>/ (division). </span></nobr></DIV>
<DIV style="position:absolute;top:358;left:464"><nobr><span class="ft13">The query language has its syntax based on a subgroup of the <br>conditional expression syntax SQL92 [10].  It is an extension of <br>the constraints language with new functions.  This new language <br>embodies identifiers that can hold a constant value. A mapping <br>between identifiers and values is required. In the evaluation of an <br>expression, the occurrence of an identifier is replaced by its <br>associated value. The addition of new operators (between, like, in, <br>is, escape) allows submitting queries similar to those used in <br>databases compliant with SQL92. For example, queries of the <br>type -- Temperature between 26.6 and 36.6 -- are possible. </span></nobr></DIV>
<DIV style="position:absolute;top:521;left:464"><nobr><span class="ft13">The constraint and query languages are intended to ease the work <br>programming of online applications. This type of application <br>access the information sent in real-time by the sensor nodes. <br>Thus, it completes the attendance of the R1 requirement on the <br>way of operation for query. </span></nobr></DIV>
<DIV style="position:absolute;top:616;left:464"><nobr><span class="ft5"><b>4.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:616;left:486"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:616;left:496"><nobr><span class="ft5"><b>Application Filters </b></span></nobr></DIV>
<DIV style="position:absolute;top:636;left:464"><nobr><span class="ft13">Filters are application specific software<i>  </i>modules that deal with <br>diffusion and data processing [11].  Filters are provided before <br>deploying a sensor network. Each filter is specified using a list of <br>attributes to make possible the matching<i> </i>with the incoming data.  </span></nobr></DIV>
<DIV style="position:absolute;top:706;left:464"><nobr><span class="ft13">Filters are used to make internal aggregation of data, collaborative <br>signals processing, caching and tasks that control the data flow in <br>the sensor network [11]. In SensorBus, filters will be used to limit <br>the data flow in the network.  A filter can be designed to restrict <br>the range of values of a determined attribute, for example the <br>application requires that the attribute Temperature has values <br>ranging between 20 and 30 degrees Celsius, the values outside <br>this particular range are of no interest. The filtering process <br>discards the unnecessary data reducing the flow between the <br>nodes.  This decrease reduces the consumption of energy in <br>sensor nodes. Thus, it completes the attendance of the R5 <br>requirement about the energy saving of the sensor nodes. </span></nobr></DIV>
<DIV style="position:absolute;top:909;left:464"><nobr><span class="ft5"><b>4.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:909;left:486"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:909;left:496"><nobr><span class="ft5"><b>Design Patterns </b></span></nobr></DIV>
<DIV style="position:absolute;top:929;left:464"><nobr><span class="ft13">Design patterns are descriptions of objects and communicating <br>classes that are customized to solve a general design problem <br>within a particular context [12]. It describes commonly recurring <br>design architectures extracted from the experience of one or more <br>domain specialists. A design pattern names, abstracts, and <br>identifies the key aspects of a common design structure that make <br>it useful for creating a reusable object-oriented design [12]. We <br>make use of design patterns in SensorBus project and the types <br>we have utilized are as follows: </span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft17{font-size:3px;font-family:Times;color:#000000;}
	.ft18{font-size:11px;font-family:Times;color:#000000;}
	.ft19{font-size:7px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="176005.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">5 </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:79"><nobr><span class="ft13">The  <i>Observer pattern: </i>Defines a one-to-many dependency <br>between objects so that when one object changes state, all of its <br>dependents are notified and updated automatically. We utilize this <br>pattern to implement the publish-subscribe mechanism. </span></nobr></DIV>
<DIV style="position:absolute;top:230;left:79"><nobr><span class="ft13">The <i>Interpreter pattern:</i> Defines a representation for its grammar <br>along with an interpreter that uses the representation to interpret <br>sentences in the language. We make use of this pattern to <br>implement the constraint and query language.  </span></nobr></DIV>
<DIV style="position:absolute;top:300;left:79"><nobr><span class="ft13">The <i>Facade pattern:</i> Defines a unified (higher-level) interface to <br>a set of interfaces in a subsystem that makes the subsystem easier <br>to use. We use this pattern to implement the middleware high-<br>level primitives which will be available to developers. </span></nobr></DIV>
<DIV style="position:absolute;top:370;left:79"><nobr><span class="ft13">The <i>Mediator</i> pattern: Defines an object that encapsulates how a <br>set of objects interact. Mediator promotes loose coupling by <br>keeping objects from referring to each other explicitly, and it lets <br>you vary their interaction independently.  </span></nobr></DIV>
<DIV style="position:absolute;top:441;left:79"><nobr><span class="ft13">The  <i>Adapter pattern:</i> Converts the interface of a class into <br>another interface clients expect. Adapter lets classes work <br>together that couldn't otherwise because of incompatible <br>interfaces. </span></nobr></DIV>
<DIV style="position:absolute;top:511;left:79"><nobr><span class="ft13">The  <i>Router pattern:</i> Decouples multiple sources of input from <br>multiple sources of output to route data correctly without <br>blocking. </span></nobr></DIV>
<DIV style="position:absolute;top:566;left:79"><nobr><span class="ft13">The design patterns <i>Mediator</i>,  <i>Adapter</i> e <i>Router</i> are utilized to <br>implement the middleware message bus. The exchangeable <br>communication mechanism was written using these patterns. This <br>mechanism allows the utilization of any routing protocol designed <br>for sensor networks meeting as a result the requirements R2, R3 <br>and R4. </span></nobr></DIV>
<DIV style="position:absolute;top:677;left:79"><nobr><span class="ft5"><b>5.</b></span></nobr></DIV>
<DIV style="position:absolute;top:676;left:92"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:677;left:102"><nobr><span class="ft5"><b>SENSORBUS ARCHITECTURE </b></span></nobr></DIV>
<DIV style="position:absolute;top:696;left:79"><nobr><span class="ft13">SensorBus is comprised of the following elements: an application <br>service, a message service and a context service as shown in <br>Figure 1. </span></nobr></DIV>
<DIV style="position:absolute;top:751;left:79"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:776;left:79"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:800;left:79"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:824;left:79"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:848;left:79"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:872;left:79"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:887;left:79"><nobr><span class="ft17"> </span></nobr></DIV>
<DIV style="position:absolute;top:903;left:79"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:936;left:155"><nobr><span class="ft18"><b>Figure 1. Middleware architecture. </b></span></nobr></DIV>
<DIV style="position:absolute;top:960;left:79"><nobr><span class="ft13">The following sections present each one of the services mentioned <br>by the means of UML (<i>Unified Modeling Language</i>) component <br>diagrams [13].  </span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:79"><nobr><span class="ft5"><b>5.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:101"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:111"><nobr><span class="ft5"><b>Application Service </b></span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:79"><nobr><span class="ft13">The application service provides Application Programming <br>Interface (API) which simplifies application development. This <br>service is comprised of three components as shown in Figure 2: </span></nobr></DIV>
<DIV style="position:absolute;top:321;left:775"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:349;left:518"><nobr><span class="ft18"><b>Figure 2. Application Service Architecture. </b></span></nobr></DIV>
<DIV style="position:absolute;top:373;left:464"><nobr><span class="ft13">DataBus: component providing a set of operations relating to bus <br>communication for consumers and producers. These operations <br>include: Announcement of data item (producer); to find a data <br>item (consumer); Announcement of data change (consumer); <br>Exclude data item (producer). </span></nobr></DIV>
<DIV style="position:absolute;top:458;left:464"><nobr><span class="ft13">Filter: component providing a set of operations relating to data <br>filtering. </span></nobr></DIV>
<DIV style="position:absolute;top:498;left:464"><nobr><span class="ft13">Language: component that implements the commands and the <br>constraint and query language interpreter. </span></nobr></DIV>
<DIV style="position:absolute;top:547;left:464"><nobr><span class="ft5"><b>5.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:546;left:486"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:547;left:496"><nobr><span class="ft5"><b>Message Service </b></span></nobr></DIV>
<DIV style="position:absolute;top:567;left:464"><nobr><span class="ft13">Message service is responsible for providing communication and <br>coordination for the distributed components, abstracting the <br>developer from these issues. This service also comprises three <br>components as is shown in figure 3: </span></nobr></DIV>
<DIV style="position:absolute;top:774;left:766"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:801;left:527"><nobr><span class="ft18"><b>Figure 3. Message Service Architecture. </b></span></nobr></DIV>
<DIV style="position:absolute;top:825;left:464"><nobr><span class="ft13">Channel: Component designed to deal with the specific transport <br>implementations. Each instance of Channel represents a simple <br>system channel. The component Channel maintains the global <br>state information about the availability of channels and is also <br>responsible for exchanging channel's messages to the transport <br>implementation and vice versa. </span></nobr></DIV>
<DIV style="position:absolute;top:926;left:464"><nobr><span class="ft13">Transport: The communication among the nodes is made through <br>a specific transport implementation such as <i>sockets</i>. Each <br>transport implementation communicates through a channel with a <br>message exchange server called <i>Sinker</i>. All transport <br>implementations have a common interface which is called <br><i>ITransport</i>. </span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:464"><nobr><span class="ft13">Sinker: Component responsible for routing messages among <br>instances of transport implementation, each instance <br>corresponding to an instance of Channel. </span></nobr></DIV>
<DIV style="position:absolute;top:684;left:579"><nobr><span class="ft9">Channel</span></nobr></DIV>
<DIV style="position:absolute;top:641;left:607"><nobr><span class="ft9">IChannel </span></nobr></DIV>
<DIV style="position:absolute;top:761;left:509"><nobr><span class="ft9">Sinker</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:650"><nobr><span class="ft9">Transport </span></nobr></DIV>
<DIV style="position:absolute;top:726;left:685"><nobr><span class="ft9">ITransport </span></nobr></DIV>
<DIV style="position:absolute;top:310;left:685"><nobr><span class="ft9">Filter </span></nobr></DIV>
<DIV style="position:absolute;top:257;left:533"><nobr><span class="ft9">DataBus</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:566"><nobr><span class="ft9">IDataBus</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:685"><nobr><span class="ft9">Language </span></nobr></DIV>
<DIV style="position:absolute;top:165;left:720"><nobr><span class="ft9">ILanguage </span></nobr></DIV>
<DIV style="position:absolute;top:905;left:202"><nobr><span class="ft19">NOS - JVM/KVM</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:207"><nobr><span class="ft19">Application/User </span></nobr></DIV>
<DIV style="position:absolute;top:803;left:199"><nobr><span class="ft19">Application Service </span></nobr></DIV>
<DIV style="position:absolute;top:836;left:226"><nobr><span class="ft19">Message </span></nobr></DIV>
<DIV style="position:absolute;top:877;left:129"><nobr><span class="ft19">Context Service </span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft20{font-size:24px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="176006.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">6 </span></nobr></DIV>
<DIV style="position:absolute;top:160;left:79"><nobr><span class="ft5"><b>5.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:160;left:101"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:160;left:111"><nobr><span class="ft5"><b>Context Service </b></span></nobr></DIV>
<DIV style="position:absolute;top:180;left:79"><nobr><span class="ft13">Inherently, an application running on a wireless sensor network <br>needs to capture information from the execution context, for <br>example, battery level, memory availability, bandwidth, location, <br>application specific information such as temperature and pressure, <br>etc. The middleware gets this information by interacting with <br>several heterogeneous sensors; for example, the level of energy <br>remaining on batteries can be obtained by executing an operating <br>system primitive, location can be acquired from various <br>communications technology such as GPS, infrared and RF. This <br>work does not take into consideration how the context sensing is <br>executed; it is assumed that each sensor provides an interface so <br>the middleware can use it to get the value of the resource of <br>interest.  </span></nobr></DIV>
<DIV style="position:absolute;top:389;left:79"><nobr><span class="ft13">The context service manages the heterogeneous sensors that <br>collect information from the environment. For each resource the <br>middleware manages, there is an adapter that interacts with the <br>physical sensor, processes its information thus obtaining the <br>information demanded by the application. Only resource adapters <br>that are necessary to the running application will be loaded to <br>avoid unnecessary spending of the node's scarce computing <br>power. Figure 4 shows an energy adapter interacting with an <br>energy sensor (an operating system primitive, in this example). </span></nobr></DIV>
<DIV style="position:absolute;top:686;left:380"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:713;left:143"><nobr><span class="ft18"><b>Figure 4. Context Service Architecture. </b></span></nobr></DIV>
<DIV style="position:absolute;top:746;left:79"><nobr><span class="ft5"><b>6.</b></span></nobr></DIV>
<DIV style="position:absolute;top:746;left:92"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:746;left:102"><nobr><span class="ft5"><b>MIDDLEWARE ARCHITECTURE </b></span></nobr></DIV>
<DIV style="position:absolute;top:767;left:79"><nobr><span class="ft5"><b>EXAMPLE </b></span></nobr></DIV>
<DIV style="position:absolute;top:787;left:79"><nobr><span class="ft13">Figure 5 shows the sensor network communication architecture. <br>Each node in the field has the ability to collect data and send it to <br>the next sink node. The sink node can be a mobile node acting as <br>a data source or a fixed host computer (a PC). The user node <br>connects with the sink node through a conventional wireless LAN <br>(e.g. IEEE 802.11x). </span></nobr></DIV>
<DIV style="position:absolute;top:888;left:79"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:1050;left:381"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:1068;left:143"><nobr><span class="ft18"><b>Figure 5. Communication Architecture. </b></span></nobr></DIV>
<DIV style="position:absolute;top:159;left:464"><nobr><span class="ft13">The services and components of SensorBus are distributed in <br>three distinct types of sensor nodes. The components DataBus, <br>Language, Channel and Transport are in the user node. The <br>Sinker component is in the sink node. The sensor nodes contains <br>the Channel and Transport components while filter component <br>and context service will only be loaded if the application requires <br>energy management and other resources such as memory and <br>bandwidth.   </span></nobr></DIV>
<DIV style="position:absolute;top:291;left:464"><nobr><span class="ft13">The development of an application using SensorBus consists in <br>coding the parts for the producer and consumer. The consumer <br>code runs in the user machine while the producer code runs in <br>sensor nodes. The minimum steps required for the use of <br>SensorBus are as follows: </span></nobr></DIV>
<DIV style="position:absolute;top:377;left:464"><nobr><span class="ft0">1.</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:474"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:377;left:490"><nobr><span class="ft13">Create a new DataBus instance. A new transport <br>implementation is created by identifying a specific Sinker; </span></nobr></DIV>
<DIV style="position:absolute;top:417;left:464"><nobr><span class="ft0">2.</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:474"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:417;left:490"><nobr><span class="ft0">Instantiate a producer or a consumer; </span></nobr></DIV>
<DIV style="position:absolute;top:441;left:464"><nobr><span class="ft0">3.</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:474"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:441;left:490"><nobr><span class="ft0">Instantiate a "Channel" entity; </span></nobr></DIV>
<DIV style="position:absolute;top:465;left:464"><nobr><span class="ft0">4.</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:474"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:465;left:490"><nobr><span class="ft13">Register the just created producer or consumer for the <br>channel; and </span></nobr></DIV>
<DIV style="position:absolute;top:504;left:464"><nobr><span class="ft0">5.</span></nobr></DIV>
<DIV style="position:absolute;top:504;left:474"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:504;left:490"><nobr><span class="ft13">The producer generates data items and places them into <br>Channel while the consumer finds and "crunches" those data. </span></nobr></DIV>
<DIV style="position:absolute;top:544;left:464"><nobr><span class="ft13">SensorBus offers other functions that might be implemented, such <br>as listing the available channels, adding new channels and stop <br>receiving new channels.  </span></nobr></DIV>
<DIV style="position:absolute;top:599;left:464"><nobr><span class="ft13">The producer sensor code has to be implemented before setup of <br>the network. If it is not possible to retrieve the sensor for <br>maintenance, the attributes of the data sent will always be the <br>same. To overcome this obstacle the constraint and query <br>languages are used to add new queries that had not been initially <br>foreseen. These queries are sent by the interested consumer <br>(client) in the form of messages. </span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:860"><nobr><span class="ft0"> </span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:515"><nobr><span class="ft18"><b>Figure 6. Middleware architecture example. </b></span></nobr></DIV>
<DIV style="position:absolute;top:937;left:103"><nobr><span class="ft19">WLAN </span></nobr></DIV>
<DIV style="position:absolute;top:976;left:180"><nobr><span class="ft19">Sink node </span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:104"><nobr><span class="ft19">User node </span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:231"><nobr><span class="ft19">Sensor field </span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:301"><nobr><span class="ft19">Sensor nodes </span></nobr></DIV>
<DIV style="position:absolute;top:959;left:309"><nobr><span class="ft20"> </span></nobr></DIV>
<DIV style="position:absolute;top:674;left:143"><nobr><span class="ft9">EnergySensor </span></nobr></DIV>
<DIV style="position:absolute;top:594;left:136"><nobr><span class="ft9">EnergyAdapter </span></nobr></DIV>
<DIV style="position:absolute;top:634;left:306"><nobr><span class="ft9">EnergyEvent </span></nobr></DIV>
<DIV style="position:absolute;top:601;left:343"><nobr><span class="ft9">IEvent</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:183"><nobr><span class="ft9">IAdapter </span></nobr></DIV>
<DIV style="position:absolute;top:807;left:630"><nobr><span class="ft10">Data</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:752"><nobr><span class="ft10">&lt;&lt;user&gt;&gt;</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:608"><nobr><span class="ft10">&lt;&lt;application&gt;&gt; </span></nobr></DIV>
<DIV style="position:absolute;top:798;left:743"><nobr><span class="ft10">Language </span></nobr></DIV>
<DIV style="position:absolute;top:806;left:520"><nobr><span class="ft10">Filter</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:635"><nobr><span class="ft10">Channel </span></nobr></DIV>
<DIV style="position:absolute;top:890;left:505"><nobr><span class="ft10">Transport </span></nobr></DIV>
<DIV style="position:absolute;top:888;left:759"><nobr><span class="ft10">Sinker </span></nobr></DIV>
<DIV style="position:absolute;top:969;left:508"><nobr><span class="ft10">Battery </span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:511"><nobr><span class="ft10">Battery </span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:616"><nobr><span class="ft10">Temperature </span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:630"><nobr><span class="ft10">Sensor </span></nobr></DIV>
<DIV style="position:absolute;top:923;left:610"><nobr><span class="ft10">IAdapter </span></nobr></DIV>
<DIV style="position:absolute;top:759;left:476"><nobr><span class="ft10">Application </span></nobr></DIV>
<DIV style="position:absolute;top:772;left:486"><nobr><span class="ft10">Service </span></nobr></DIV>
<DIV style="position:absolute;top:850;left:771"><nobr><span class="ft10">Message </span></nobr></DIV>
<DIV style="position:absolute;top:864;left:774"><nobr><span class="ft10">Service </span></nobr></DIV>
<DIV style="position:absolute;top:923;left:728"><nobr><span class="ft10">Context Service</span></nobr></DIV>
<DIV style="position:absolute;top:956;left:616"><nobr><span class="ft10">Temperature </span></nobr></DIV>
<DIV style="position:absolute;top:969;left:627"><nobr><span class="ft10">Adapter </span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft21{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="176007.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">7 </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:79"><nobr><span class="ft13">Filters are as well implemented in nodes. Soon after a producer is <br>instantiated, a filter is also instantiated and registered for a new <br>channel. </span></nobr></DIV>
<DIV style="position:absolute;top:214;left:79"><nobr><span class="ft13">Figure 6 shows the components that may be active in a given <br>moment. Although most of the components are the same for a <br>given application, different settings may occur on the context <br>service. The figure shows only two adapters running at the same <br>time and interacting with its associated sensors (temperature and <br>battery). Distinct sensors can be used depending on the physical <br>measurement to be taken and the type of computing resource to be <br>managed. </span></nobr></DIV>
<DIV style="position:absolute;top:355;left:79"><nobr><span class="ft5"><b>7.</b></span></nobr></DIV>
<DIV style="position:absolute;top:355;left:92"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:355;left:102"><nobr><span class="ft5"><b>IMPLEMENTATION ISSUES </b></span></nobr></DIV>
<DIV style="position:absolute;top:375;left:79"><nobr><span class="ft13">The<i> testbed</i> setup for SensorBus evaluation consists of Intel-based <br>equipment equipped with 802.11b cards. The sink node is a <br>centrino-based Dell Lattitude notebook, the sensor nodes are <br>deployed in handheld computers HP iPAQ running Linux <br>operating system on Intel XScale processor. The sensor nodes are <br>placed at various locations in the Electrical Engineering <br>Department Building (about 40m<i>×</i>60m) at Federal University of <br>Pará. Linksys Wireless LAN cards are used working in the DCF <br>mode with a channel bandwidth of 11Mbps. In the building, there <br>is interference from IEEE 802.11 access points (AP) and other <br>electronic devices. </span></nobr></DIV>
<DIV style="position:absolute;top:563;left:79"><nobr><span class="ft5"><b>7.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:563;left:101"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:563;left:111"><nobr><span class="ft5"><b>Working Prototype </b></span></nobr></DIV>
<DIV style="position:absolute;top:583;left:79"><nobr><span class="ft13">For our working prototype, we have chosen the Java platform as <br>our implementation technology because of its broad installed base <br>and to ensure compatibility with most hardware platforms. The <br>KVM (<i>Kilobyte Virtual Machine</i>) [14] is being used due to its <br>freely available source-code and its designed targeting towards <br>small limited-resources devices similar to the sensor nodes of this <br>work. The SensorBus API and its constraint and query language <br>are being coded as Java classes. Due to issues regarding <br>efficiency, the code that will run in sensor nodes is being <br>implemented as native code. </span></nobr></DIV>
<DIV style="position:absolute;top:746;left:79"><nobr><span class="ft13">An object <i>serialization</i> mechanism was implemented because <br>KVM does not support this facility. <i>Serialization</i> mechanism <br>converts an object and its state into a byte stream allowing this <br>object to be moved over a network or persisted in a local file <br>system. Object recovery is performed through another mechanism <br>called <i>deserialization</i>. Other Java technologies as J2SE ­ <i>Java 2 <br>Standard Edition</i> utilize this kind of facility to support the <br>encoding of objects into a stream of bytes while protecting private <br>and transient data. Serialization is used in distributed <br>programming through sockets or <i>Remote Method Invocation <br></i>(RMI). We have coded a semiautomatic <i>serialization</i> in order to <br>store the state of the objects. To achieve this, we had to define a <br>series of new interfaces and classes.  </span></nobr></DIV>
<DIV style="position:absolute;top:955;left:79"><nobr><span class="ft13">One of the most critical problems with <i>serialization  </i>is security <br>because when an object is converted in a byte stream any attacker <br>equipped with properly sniffer software can intercept and access <br>it; in this case even private attributes can be accessed without any <br>special technique. To tackle this issue, secure protocols as HTTPS <br>(<i>Secure HyperText Transport Protocol</i>) or serialization encryption <br>can be used. </span></nobr></DIV>
<DIV style="position:absolute;top:160;left:464"><nobr><span class="ft5"><b>7.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:160;left:486"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:160;left:496"><nobr><span class="ft5"><b>Simulation </b></span></nobr></DIV>
<DIV style="position:absolute;top:180;left:464"><nobr><span class="ft13">Having implemented this working prototype, this research now <br>intends to do performance evaluation by using the very well <br>known tool NS ­ <i>Network Simulator</i> [15]. We plan to integrate <br>the SensorBus<i> </i>middleware with NS in a way that the sensor nodes <br>will plug into NS in order to provide real data for feeding the <br>simulator model. To do so, an execution environment will be <br>added to the simulator. This environment will run as a sole UNIX <br>process and will be plugged to the NS protocol stack through a <br>sensor agent.  </span></nobr></DIV>
<DIV style="position:absolute;top:327;left:464"><nobr><span class="ft13">The sensor agent is actually a NS agent responsible for <br>connecting an execution environment instance to the NS protocol <br>stack. The communication takes place through a pair of UDP <br>(<i>User Datagram Protocol</i>) sockets. Incoming packets are <br>encapsulated in NS packets and transmitted through the simulated <br>sensor network. Parameters that need to be known to the protocol <br>stack are placed in the header of the NS packet while the rest of <br>the information is added to the payload of the NS packet. <br>Similarly, outgoing packets are retrieved from the NS packets and <br>sent to the execution environment to be processed. </span></nobr></DIV>
<DIV style="position:absolute;top:490;left:464"><nobr><span class="ft13">It will be necessary to provide a mechanism to synchronize the <br>execution and simulation environment since they run in distinct <br>times. Simulations will be performed using a NS <i>Directed <br>Diffusion  </i>transport implementation [5] for wireless sensor <br>networks.  </span></nobr></DIV>
<DIV style="position:absolute;top:585;left:464"><nobr><span class="ft5"><b>8.</b></span></nobr></DIV>
<DIV style="position:absolute;top:585;left:477"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:585;left:487"><nobr><span class="ft5"><b>RELATED WORKS </b></span></nobr></DIV>
<DIV style="position:absolute;top:605;left:464"><nobr><span class="ft13">In [16] an overall description of the challenges involving <br>middleware for wireless sensor networks is presented focusing on <br>the restraint aspects of these systems. </span></nobr></DIV>
<DIV style="position:absolute;top:660;left:464"><nobr><span class="ft13">Cougar [17] and SINA [18], <i>Sensor Information Networking <br>Architecture</i>, provide a distributed database interface for wireless <br>sensor networks that use a query language to allow applications to <br>run monitoring functions. Cougar manages the power by <br>distributing the query among the sensor nodes to minimize energy <br>required in data gathering. SINA adds low-level mechanisms to <br>build hierarchical clustering of sensors aiming at efficient data <br>aggregation and also provides protocols which limit the <br>rebroadcast of similar information to neighbor's nodes.  </span></nobr></DIV>
<DIV style="position:absolute;top:807;left:464"><nobr><span class="ft13">AutoSec [19], <i>Automatic Service Composition</i>, manages resources <br>of the sensor networks by providing access control for <br>applications to ensure quality of service. This approach is very <br>similar to conventional middleware technology but the techniques <br>to collect resource information are suitable for wireless sensor <br>networks. </span></nobr></DIV>
<DIV style="position:absolute;top:908;left:464"><nobr><span class="ft13">DSWare [20] provides service abstraction similar to AutoSec, but <br>instead of having a service provided by only one sensor node, the <br>service is supplied by a group of neighbor's nodes.  </span></nobr></DIV>
<DIV style="position:absolute;top:963;left:464"><nobr><span class="ft13">S<i>mart Messages</i> Project [21] proposes a distributed computing <br>model based on migration of executing units. <i>Smart messages </i>are <br>migratory units containing data and code. The goal of <i>Smart <br>Messages Project </i>is to develop a computing model and systems <br>architecture to Networks Embedded Systems (NES). </span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:464"><nobr><span class="ft13">EnviroTrack [22] is a middleware for object-based distributed <br>systems that lifts the abstraction level for programming </span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft22{font-size:6px;font-family:Times;color:#000000;}
	.ft23{font-size:12px;font-family:Times;color:#000000;}
	.ft24{font-size:12px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="176008.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">8 </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:79"><nobr><span class="ft13">environmental monitoring applications. It contains mechanisms <br>that abstract groups of sensors into logical objects.  </span></nobr></DIV>
<DIV style="position:absolute;top:199;left:79"><nobr><span class="ft13">Impala [23] exploits mobile code techniques to alter the <br>middleware's functionality running on a sensor node. The key to <br>energy-efficient management in Impala is that applications are as <br>modular and concise as possible so little changes demands fewer <br>energy resources. </span></nobr></DIV>
<DIV style="position:absolute;top:285;left:79"><nobr><span class="ft13">MiLAN [24] was developed to allow dynamic network setup to <br>meet the applications performance requirements. The applications <br>represent its requests by the means of specialized graphics which <br>incorporates changes due to applications needs. </span></nobr></DIV>
<DIV style="position:absolute;top:355;left:79"><nobr><span class="ft13">In [25], an adaptative middleware is proposed to explore the <br>commitment between resource spending and quality during <br>information collecting. The main goal is to decrease the <br>transmissions among sensor nodes without compromising the <br>overall result. </span></nobr></DIV>
<DIV style="position:absolute;top:441;left:79"><nobr><span class="ft13">Every one of those middleware proposals is designed to make <br>efficient use of wireless sensor networks; they do not support free <br>exchange of the transport mechanism. More specifically, most of <br>those approaches are not capable of altering the routing protocol <br>to meet different application requirements. </span></nobr></DIV>
<DIV style="position:absolute;top:536;left:79"><nobr><span class="ft5"><b>9.</b></span></nobr></DIV>
<DIV style="position:absolute;top:536;left:92"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:536;left:102"><nobr><span class="ft5"><b>CONCLUDING REMARKS </b></span></nobr></DIV>
<DIV style="position:absolute;top:557;left:79"><nobr><span class="ft13">As was demonstrated, application development is closely related <br>to wireless sensor network design. Each communication <br>mechanism provided by a determined routing protocol is <br>application specific, e.g. it is designed to meet some application <br>specific requirement. We suggest that the utility of the <br>middleware for wireless sensor networks is supported by <br>decoupling the communication mechanism from the programming <br>interfaces and also by capability of using more than one <br>communication mechanism to address the requirements of larger <br>number of applications. We have shown that SensorBus, a sensor <br>network middleware that we are developing to meet these goals, <br>can aid the development of different types of sensor network <br>applications. </span></nobr></DIV>
<DIV style="position:absolute;top:776;left:79"><nobr><span class="ft5"><b>10.</b></span></nobr></DIV>
<DIV style="position:absolute;top:775;left:101"><nobr><span class="ft8"><b> </b></span></nobr></DIV>
<DIV style="position:absolute;top:776;left:111"><nobr><span class="ft5"><b>REFERENCES </b></span></nobr></DIV>
<DIV style="position:absolute;top:795;left:79"><nobr><span class="ft0">[1]</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:94"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:795;left:105"><nobr><span class="ft13">P. Rentala, R. Musunuri, S. Gandham and U. Saxena, <i>Survey <br>on Sensor Networks</i>, Technical Report, University of Texas, <br>Dept. of Computer Science, 2002. </span></nobr></DIV>
<DIV style="position:absolute;top:850;left:79"><nobr><span class="ft0">[2]</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:94"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:850;left:105"><nobr><span class="ft13">G. -C. Roman, A. L. Murphy, and G. P. Picco, Software <br>Engineering for Mobility: A Roadmap. In The Future of <br>Software Engineering ­ <i>22</i></span></nobr></DIV>
<DIV style="position:absolute;top:879;left:268"><nobr><span class="ft22"><i>nd</i></span></nobr></DIV>
<DIV style="position:absolute;top:881;left:277"><nobr><span class="ft6"><i> Int. Conf. On Software </i></span></nobr></DIV>
<DIV style="position:absolute;top:897;left:105"><nobr><span class="ft13"><i>Engineering (ICSE2000)</i>, pages 243-258. ACM Press, May <br>2000. </span></nobr></DIV>
<DIV style="position:absolute;top:936;left:79"><nobr><span class="ft0">[3]</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:94"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:936;left:105"><nobr><span class="ft13">J. Pottie and W. J. Kaiser, Embedding the internet wireless <br>integrated network sensors, <i>Communications of the ACM</i>, <br>vol. 43, no. 5, pp. 51-58, May 2000. </span></nobr></DIV>
<DIV style="position:absolute;top:991;left:79"><nobr><span class="ft0">[4]</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:94"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:991;left:105"><nobr><span class="ft13">W. Heinzelman, A. Chandrakasan and H. Balakrishnan, <br>Energy-efficient communication protocol for wireless micro <br>sensor networks. <i>Proceedings of the 33</i></span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:330"><nobr><span class="ft22"><i>rd</i></span></nobr></DIV>
<DIV style="position:absolute;top:1022;left:338"><nobr><span class="ft6"><i> Annual Hawaii </i></span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:105"><nobr><span class="ft13"><i>International Conference on System Sciences</i>, Pages 3005-<br>3014, 2000. </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:464"><nobr><span class="ft0">[5]</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:479"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:490"><nobr><span class="ft21">C. Intanagonwiwat, R. Govindan, and D. Estrin, Directed <br>diffusion: A scalable and robust communication paradigm <br>for sensor networks. In <i>Proceedings of the ACM/IEEE <br>International Conference on Mobile Computing and <br>Networking</i>, pages 56-67, Boston, MA, USA, Aug. 2000. </span></nobr></DIV>
<DIV style="position:absolute;top:245;left:464"><nobr><span class="ft0">[6]</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:479"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:245;left:490"><nobr><span class="ft13">T. Sameer, N. B. Abu-Ghazaleh and Heinzelman W. A <br>Taxonomy of Wireless Micro-Sensor Network Models. <br><i>Mobile Computing and Communications Review</i>, Volume 1, <br>Number 2, 2003. </span></nobr></DIV>
<DIV style="position:absolute;top:315;left:464"><nobr><span class="ft0">[7]</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:479"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:315;left:490"><nobr><span class="ft21">Guia de Chefe ­ Brazilian Institute of Environment <br>(IBAMA) <br><i>http://www2.ibama.gov.br/unidades/guiadechefe/guia/t-<br>1corpo.htm.</i> December, 2004. </span></nobr></DIV>
<DIV style="position:absolute;top:386;left:464"><nobr><span class="ft0">[8]</span></nobr></DIV>
<DIV style="position:absolute;top:386;left:479"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:386;left:490"><nobr><span class="ft13">B. C. Arrue, A. Ollero e J. R. M. de DIOS, An intelligent <br>system for false alarm reduction in infrared forest-fire <br>detection, <i>IEEE Intelligent Systems</i>, vol. 15, pp. 64-73, 2000. </span></nobr></DIV>
<DIV style="position:absolute;top:441;left:464"><nobr><span class="ft0">[9]</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:479"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:441;left:490"><nobr><span class="ft13">G. Couloris, J. Dollimore, e T. Kindberg <i>Distributed <br>Systems: Concepts and Design</i>. Third edition. Addison-<br>Wesley, 2001. </span></nobr></DIV>
<DIV style="position:absolute;top:496;left:464"><nobr><span class="ft0">[10]</span></nobr></DIV>
<DIV style="position:absolute;top:495;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:496;left:490"><nobr><span class="ft21">SQL92 ­ Database Language SQL ­ July 30, 1992.<i> <br>http://www.cs.cmu.edu/afs/andrew.cmu.edu/usr/shadow/www<br>/sql/sql1992.txt</i> </span></nobr></DIV>
<DIV style="position:absolute;top:551;left:464"><nobr><span class="ft0">[11]</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:551;left:490"><nobr><span class="ft13">J. Heidemann, F. Silva, C. Intanagonwiwat, R. Govindan, D. <br>Estrin and D. Ganesan. Building efficient wireless sensor <br>networks with low-level naming. In <i>Proceedings of the <br>Symposium on Operating Systems Principles</i>, pages 146-159, <br>Chateau Lake Louise, Banff, Alberta, Canada, October 2001. </span></nobr></DIV>
<DIV style="position:absolute;top:636;left:464"><nobr><span class="ft0">[12]</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:636;left:490"><nobr><span class="ft21">E. Gamma, R. Helm, R. Johnson e J. Vlissides, <i>Design <br>Patterns</i>. Addison-Wesley, 1995. </span></nobr></DIV>
<DIV style="position:absolute;top:676;left:464"><nobr><span class="ft0">[13]</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:676;left:490"><nobr><span class="ft13">J. Rumbaugh, I. Jacobson and G. Booch. <i>The Unified <br>Modeling Language Reference Manual</i>. Addison Wesley, <br>1998. </span></nobr></DIV>
<DIV style="position:absolute;top:731;left:464"><nobr><span class="ft0">[14]</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:731;left:490"><nobr><span class="ft0">KVM ­ The K Virtual Machine Specification. </span></nobr></DIV>
<DIV style="position:absolute;top:746;left:490"><nobr><span class="ft23"><i>http://java.sun.com/products/kvm</i>/</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:690"><nobr><span class="ft0">, August 2004. </span></nobr></DIV>
<DIV style="position:absolute;top:772;left:464"><nobr><span class="ft0">[15]</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:772;left:490"><nobr><span class="ft13">UCB/LBNL/VINT Network Simulator ­ NS (Version 2). <br><i>http//www.isi.edu./nsnam/ns/</i>, August 2004. </span></nobr></DIV>
<DIV style="position:absolute;top:812;left:464"><nobr><span class="ft0">[16]</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:812;left:490"><nobr><span class="ft13">K. Römer, O. Kasten and F. Mattern. Middleware <br>Challenges for Wireless Sensor Networks. <i>Mobile <br>Computing and Communications Review</i>, volume 6, number <br>2, 2002. </span></nobr></DIV>
<DIV style="position:absolute;top:882;left:464"><nobr><span class="ft0">[17]</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:882;left:490"><nobr><span class="ft13">P. Bonnet, J. Gehrke and P. Seshadri. Querying the Physycal <br>World.  <i>IEEE Personal Communication</i>, 7:10-15, October <br>2000. </span></nobr></DIV>
<DIV style="position:absolute;top:937;left:464"><nobr><span class="ft0">[18]</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:937;left:490"><nobr><span class="ft13">C. Srisathapornphat, C. Jaikaeo and C. Shen. Sensor <br>Information Networking Architecture, <i>International <br>Workshop on Pervasive Computing (IWPC00)</i>, Toronto <br>Canada, August 2000. </span></nobr></DIV>
<DIV style="position:absolute;top:1007;left:464"><nobr><span class="ft0">[19]</span></nobr></DIV>
<DIV style="position:absolute;top:1007;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:1007;left:490"><nobr><span class="ft21">Q. Han and N. Venkatasubramanian. AutoSec: An integrated <br>middleware framework for dynamic service brokering. <i>IEEE <br>Distributed Systems Online</i>, 2(7), 2001. </span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft25{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="176009.png" alt="background image">
<DIV style="position:absolute;top:1136;left:443"><nobr><span class="ft0">9 </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:79"><nobr><span class="ft0">[20]</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:101"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:105"><nobr><span class="ft13">S. Li, S. Son, and J. Stankovic. Event detection services <br>using data service middleware in distributed sensor <br>networks. In <i>Proceedings of the 2</i></span></nobr></DIV>
<DIV style="position:absolute;top:188;left:289"><nobr><span class="ft22"><i>nd</i></span></nobr></DIV>
<DIV style="position:absolute;top:190;left:297"><nobr><span class="ft6"><i> International Workshop </i></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:105"><nobr><span class="ft6"><i>on Information Processing in Sensor Networks</i>, April 2003. </span></nobr></DIV>
<DIV style="position:absolute;top:230;left:79"><nobr><span class="ft0">[21]</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:101"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:230;left:105"><nobr><span class="ft13">Smart Messages project. March, 2003. <br><i>http://discolab.rutgers.edu/sm. </i></span></nobr></DIV>
<DIV style="position:absolute;top:269;left:79"><nobr><span class="ft0">[22]</span></nobr></DIV>
<DIV style="position:absolute;top:269;left:101"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:269;left:105"><nobr><span class="ft13">T. Abdelzaher, B. Blum, Q. Cao, D. Evans, J. George, S. <br>George, T. He, L. Luo, S. Son, R. Stoleru, J. Stankovic and <br>A. Wood. <i>EnviroTrack: Towards an Environmental <br>Computing Paradigm for Distributed Sensor Networks.</i><b> <br></b>Technical report, Department of Computer Science, <br>University of Virginia, 2003. </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:464"><nobr><span class="ft0">[23]</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:490"><nobr><span class="ft21">T. Liu and M. Martonosi. Impala: A middleware system for <br>managing autonomic, parallel sensor systems. In <i>ACM <br>SIGPLAN Symposium on Principles and Practice of Parallel <br>Programming (PPoPP´03)</i>, June 2003 </span></nobr></DIV>
<DIV style="position:absolute;top:230;left:464"><nobr><span class="ft0">[24]</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:230;left:490"><nobr><span class="ft13">A. Murphy and W. Heinzelman, <i>MiLan:</i> <i>Middleware linking <br>applications and networks</i>, Technical Report TR-795, <br>University of Rochester, 2002. </span></nobr></DIV>
<DIV style="position:absolute;top:285;left:464"><nobr><span class="ft0">[25]</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:485"><nobr><span class="ft16"> </span></nobr></DIV>
<DIV style="position:absolute;top:285;left:490"><nobr><span class="ft21">X. Yu, K. Niyogi, S. Mehrotra and N. Venkatasubramanian, <br>Adaptive middleware for distributed sensor networks, <i>IEEE <br>Distributed Systems Online</i>, May 2003. </span></nobr></DIV>
<DIV style="position:absolute;top:371;left:446"><nobr><span class="ft1"><b> </b></span></nobr></DIV>
</DIV>
</BODY>
</HTML>
