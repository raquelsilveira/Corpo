<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>D:\Paper\HTML\171</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2006-11-01T14:07:38+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Times;color:#000000;}
	.ft1{font-size:6px;font-family:Times;color:#000000;}
	.ft2{font-size:15px;font-family:Times;color:#000000;}
	.ft3{font-size:12px;font-family:Times;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:9px;font-family:Times;color:#000000;}
	.ft6{font-size:16px;font-family:Courier;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft9{font-size:11px;line-height:13px;font-family:Times;color:#000000;}
	.ft10{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="171001.png" alt="background image">
<DIV style="position:absolute;top:108;left:110"><nobr><span class="ft0"><b>S </b></span></nobr></DIV>
<DIV style="position:absolute;top:104;left:128"><nobr><span class="ft1">2 </span></nobr></DIV>
<DIV style="position:absolute;top:108;left:134"><nobr><span class="ft0"><b>DB : A Novel Simulation-Based Debugg er for S ensor</b></span></nobr></DIV>
<DIV style="position:absolute;top:138;left:316"><nobr><span class="ft0"><b>Network Applications</b></span></nobr></DIV>
<DIV style="position:absolute;top:143;left:598"><nobr><span class="ft1"></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:208"><nobr><span class="ft2">Ye Wen</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:140"><nobr><span class="ft3">University of California, Santa</span></nobr></DIV>
<DIV style="position:absolute;top:239;left:211"><nobr><span class="ft3">Barbara</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:156"><nobr><span class="ft2">wenye@cs.ucsb.edu</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:411"><nobr><span class="ft2">Rich Wolski</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:359"><nobr><span class="ft3">University of California, Santa</span></nobr></DIV>
<DIV style="position:absolute;top:239;left:431"><nobr><span class="ft3">Barbara</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:386"><nobr><span class="ft2">rich@cs.ucsb.edu</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:627"><nobr><span class="ft2">Selim Gurun</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:579"><nobr><span class="ft3">University of California, Santa</span></nobr></DIV>
<DIV style="position:absolute;top:239;left:650"><nobr><span class="ft3">Barbara</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:597"><nobr><span class="ft2">gurun@cs.ucsb.edu</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:81"><nobr><span class="ft2">ABSTRACT</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:81"><nobr><span class="ft8">S e nsor net wor k c omput i ng can be char act eri zed as resource-const r ai ned<br>distributed computing using unreliable, low bandwidth communi-<br>cation. This combination of characteristics poses significant soft-<br>ware development and maintenance challenges. Effective and effi-<br>cient debugging tools for sensor network are thus critical. Existent<br>development tools, such as TOSSIM, EmStar, ATEMU and Avrora,<br>provide useful debugging support, but not with the fidelity, scale<br>and functionality that we believe are sufficient to meet the needs of<br>the next generation of applications.</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:94"><nobr><span class="ft4">In this paper, we propose a debugger, called S</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:348"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:355"><nobr><span class="ft4">DB, based on a</span></nobr></DIV>
<DIV style="position:absolute;top:494;left:81"><nobr><span class="ft8">distributed full system sensor network simulator with high fidelity<br>and scalable performance, DiSenS. By exploiting the potential of<br>DiSenS as a scalable full system simulator, S</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:324"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:330"><nobr><span class="ft4">DB extends conven-</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:81"><nobr><span class="ft8">tional debugging methods by adding novel device level, program<br>source level, group level, and network level debugging abstractions.<br>The performance evaluation shows that all these debugging features<br>introduce overhead that is generally less than</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:326"><nobr><span class="ft4">10% into the simula-</span></nobr></DIV>
<DIV style="position:absolute;top:603;left:81"><nobr><span class="ft4">tor and thus making S</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:197"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:603;left:203"><nobr><span class="ft4">DB an efficient and effective debugging tool</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:81"><nobr><span class="ft4">for sensor networks.</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:81"><nobr><span class="ft2">Categories and Subject Descriptors</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:81"><nobr><span class="ft8">D.2. 5 [S oftware E n gi n eeri n g] : Te st i ng a nd D e buggi ng; I . 6 [ Simu lation<br>and Modeling]</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:81"><nobr><span class="ft2">General Terms</span></nobr></DIV>
<DIV style="position:absolute;top:738;left:81"><nobr><span class="ft4">Experimentation, Performance</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:81"><nobr><span class="ft2">Keywords</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:81"><nobr><span class="ft4">Sensor Network, Debugging, Simulation</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:81"><nobr><span class="ft2">1.</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:112"><nobr><span class="ft2">INTRODUCTION</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:94"><nobr><span class="ft4">Sensor networks, comprised of tiny resource-constrained devices</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:81"><nobr><span class="ft4">connected by short range radios and powered by batteries, provide</span></nobr></DIV>
<DIV style="position:absolute;top:880;left:81"><nobr><span class="ft1"></span></nobr></DIV>
<DIV style="position:absolute;top:885;left:87"><nobr><span class="ft4">This work was supported by grants from Intel/UCMicro, Mi-</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:81"><nobr><span class="ft9">crosoft, and the National Science Foundation (No. EHS-0209195<br>No. CNF-0423336, and No. NGS-0204019).</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:81"><nobr><span class="ft10">Permission to make digital or hard copies of all or part of this work for<br>personal or classroom use is granted without fee provided that copies are<br>not made or distributed for profit or commercial advantage and that copies<br>bear this notice and the full citation on the first page. To copy otherwise, to<br>republish, to post on servers or to redistribute to lists, requires prior specific<br>permission and/or a fee.<br>EMSOFT'06, October 22­25, 2006, Seoul, Korea.<br>Copyright 2006 ACM 1-59593-542-8/06/0010 ...</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:315"><nobr><span class="ft4">$</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:322"><nobr><span class="ft5">5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:475"><nobr><span class="ft8">an innovative way to implement pervasive and non-intrusive envi-<br>ronmental instrumentation and (potentially) actuation. The resource-<br>constrained nature of sensor network devices poses significant soft-<br>ware development and maintenance challenges. To prolong battery<br>life and promote miniaturization, most devices have little memory,<br>use low-power and unreliable radios, and run long duty cycles. In<br>addition to these per-device constraints, by definition sensor net-<br>works are also distributed systems, with all of the concomitant syn-<br>chronization and consistency concerns that distributed coordination<br>implies.</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:489"><nobr><span class="ft4">For these reasons, effective debugging support is critical. A num-</span></nobr></DIV>
<DIV style="position:absolute;top:487;left:475"><nobr><span class="ft8">ber of sensor network development systems [2, 18, 3, 17, 13, 6]<br>provide debugging support for individual devices and/or the com-<br>plete network. However, they all have their limitations. Some rely<br>on hardware support, subject to the same resource constraints that<br>as the programs on which they operate. Some only monitor the net-<br>work radio traffic. And most importantly, as networks scale, these<br>tools become difficult to apply to the details of collections of inter-<br>acting sensor nodes.</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:489"><nobr><span class="ft4">In this paper, we present a new approach that is based on scalable</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:475"><nobr><span class="ft8">full system sensor network simulation with enhanced debugging<br>features. Our debugging tool is called S</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:693"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:699"><nobr><span class="ft4">DB (where S</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:771"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:781"><nobr><span class="ft4">stands for</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:475"><nobr><span class="ft4">Simulation and Sensor network). The goal of S</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:745"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:751"><nobr><span class="ft4">DB is to adapt</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:475"><nobr><span class="ft8">conventional debugging methods to sensor network applications so<br>that we can have better control of hardware details and debug the<br>complete sensor network in a coordinated way. Our approach relies<br>upon four principle innovations in the area of debugging resource<br>constrained devices.</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:495"><nobr><span class="ft4">· At the single device level, we introduce the concept of debug-</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:509"><nobr><span class="ft8">ging point ­ a generalized notion of break point, watch point,<br>and state interrogation ­ that permits state display from all<br>sensor device subsystems (flash pages, buffers, etc.);</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:495"><nobr><span class="ft4">· Also at the device level, we introduce virtual registers within</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:509"><nobr><span class="ft8">the simulator to support source level instrumentation and trac-<br>ing. The access to these registers does not affect the correct<br>functioning of other components;</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:495"><nobr><span class="ft4">· At the multi-device level, we introduce a coordinated break</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:509"><nobr><span class="ft8">condition, which enables the coordinated execution control<br>of multiple devices;</span></nobr></DIV>
<DIV style="position:absolute;top:961;left:495"><nobr><span class="ft4">· Finally, at the network level, we provide a "time traveling"</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:509"><nobr><span class="ft8">facility to use with network level trace analysis, so that error<br>site can be rapidly restored for detailed inspection.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:489"><nobr><span class="ft4">S</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:496"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:502"><nobr><span class="ft4">DB is built upon DiSenS [25], a scalable distributed full sys-</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:475"><nobr><span class="ft8">tem sensor network simulator DiSenS has a distributed simulation<br>framework. Individual sensor devices are emulated in separated op-<br>erating system threads. DiSenS then partitions and schedules these</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">102</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="171002.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">device emulations to the computer nodes of a cluster, and simulates<br>inter-device communication at the radio level (i.e. below the com-<br>munication protocol stack and radio hardware device interfaces).<br>Sensor device emulations in DiSenS are cycle-accurate. Moreover,<br>a plugin mechanism allows the insertion of power models and radio<br>models with different fidelity levels. Thus DiSenS is capable of ac-<br>curate, large-scale sensor network simulation where the application<br>and operating system code can be executed, unmodified on native<br>hardware.</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:94"><nobr><span class="ft4">DiSenS benefits our design and implementation in many aspects.</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:81"><nobr><span class="ft8">Its simulator infrastructure gives us the full control of device states,<br>which enables the design of debugging points. Its high performance<br>makes our debugger execute efficiently. Its scalability enables us<br>to debug large-scale sensor networks. While the availability of a<br>high-fidelity radio model for sensor network radio remains elusive<br>(making many senor network implementors reluctant to embrace<br>simulation and/or emulation), we believe the ability to debug sensor<br>network programs at scale as a precursor to actual deployment will<br>cut development time and reduce the amount of in situ debugging<br>that will be required in an actual deployment.</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:94"><nobr><span class="ft4">We also wish to emphasize that in this paper we do not claim</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:81"><nobr><span class="ft4">S</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:88"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:94"><nobr><span class="ft4">DB adequately addresses many of the thorny difficulties associ-</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:81"><nobr><span class="ft8">ated with all debugging tools (e.g. the ability to debug optimized<br>code). Rather our focus is on innovations that we believe are im-<br>portant to the development of large-scale senor network deploy-<br>ments and that also improve the current state-of-the-practice in sen-<br>sor network debugging. In Section 2, we first give the background<br>of sensor network debugging. In Section 3, we briefly introduce<br>the features and details of DiSenS that are relevant to our debug-<br>ging purpose. In Section 4, we introduce the debugging point and<br>its use with break conditions. We also present the design of vir-<br>tual hardware based source level instrumentation. In Section 5, we<br>discuss how to control the execution of multiple devices in a co-<br>ordinated way. We focus on the implementation detail in DiSenS<br>infrastructure. In Section 6, we talk about the checkpoint imple-<br>mentations for fast time traveling. We evaluate the performance of<br>our enhancing techniques in Section 7. And we conclude our work<br>in Section 8.</span></nobr></DIV>
<DIV style="position:absolute;top:699;left:81"><nobr><span class="ft2">2.</span></nobr></DIV>
<DIV style="position:absolute;top:699;left:112"><nobr><span class="ft2">RELATED WORK</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:94"><nobr><span class="ft4">Like most embedded devices, sensor network devices can be de-</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:81"><nobr><span class="ft8">bugged with special hardware support. For motes (e.g. Mica2 and<br>MicaZ), Atmel's AVR JTAG ICE (In-Circuit Emulator) [2] is one<br>of the popular hardware-based debuggers. Atmel's AVR family<br>of microcontrollers (that are currently used as the processing ele-<br>ments in many mote implementations) has built-in debugging sup-<br>port, called On-Chip Debugging (OCD). Developers can access the<br>OCD functions via JTAG [10] hardware interface. With JTAG ICE,<br>developers can set break points, step-execute program and query<br>hardware resources. JTAG ICE can also be used with GUI inter-<br>faces or a GDB debugging console. Hardware-based approaches<br>such as JTAG ICE typically have their limitations. For example, it<br>is not possible to synchronize the states of program execution with<br>I/O systems in debugging. This is because when the program exe-<br>cution is stopped in JTAG ICE, the I/O system continues to run at<br>full speed [1]. Also since the debugging support is only provided<br>with the processing unit (i.e. the microcontroller), it is not easy to<br>interrogate the state of other on-board systems, like flash memory.<br>In contrast, by working with the full system DiSenS simulations,<br>S</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:88"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:94"><nobr><span class="ft8">DB does not suffer from these limitations.<br>At network level, many monitoring and visualization tools like</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft8">Sympathy [18, 19], SpyGlass [3], Surge Network Viewer [22] and<br>Mote-VIEW [16] provide a way to trace, display and analyze net-</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">work activities for a physical sensor network. These tools usually<br>use a software data collecting module running on sensor nodes in<br>the network. The collected data is transferred using flooding or<br>multihop routing to the gateway node. The gateway node then for-<br>wards the data to a PC class machine for analysis or visualization.<br>These tools are useful for displaying the network topology and and<br>analyzing the dynamics of data flow, particularly with respect to<br>specific inter-node communication events. Tools like Sympathy<br>even specialize in detecting and localizing sensor network failures<br>in data collection applications. However, these monitoring may be<br>intrusive in that they share many of the scarce device resources they<br>use with the applications they are intended to instrument. These<br>tools may complement what we have with S</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:711"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:717"><nobr><span class="ft4">DB . When a commu-</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:475"><nobr><span class="ft8">nication anomaly is detected, for example, often a program-level<br>debugger may still be necessary to pinpoint the exact location of<br>error in code.</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:489"><nobr><span class="ft4">More generally, while debugging on real hardware is the ul-</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:475"><nobr><span class="ft8">timate way to verify the correctness of sensor network applica-<br>tions, simulation based debuggers provide complementary advan-<br>tages that have been successfully demonstrated by other projects.<br>Many sensor network simulators, like TOSSIM [13], ATEMU [17],<br>Avrora [23] and EmStar [6], provide significant debugging capa-<br>bilities. TOSSIM is a discrete event simulator for TinyOS applica-<br>tions. It translates the TinyOS code into emulation code and links<br>with the emulator itself. So debugging with TOSSIM is actually<br>debugging the emulator. Developers have to keep in their mind<br>the internal representation of device states. While discrete event<br>simulators are useful for verifying functional correctness, they typ-<br>ically do not capture the precise timing characteristics of device<br>hardware, and thus have limited capability in exposing errors in<br>program logic. In contrast, full system simulators, such as ATEMU<br>and Avrora, have much higher fidelity. ATEMU features a source<br>level debugger XATDB, which has a graphic frontend for easy use.<br>XATDB can debug multiple sensor devices, but can only focus on<br>one at a time. Avrora provides rich built-in support for profiling<br>and instrumentation. User code can be inserted at any program ad-<br>dress, watches can be attached to memory locations, and specific<br>events can be monitored. These facilities can be quite useful for<br>debugging purposes. Indeed, we extend Avrora's probe and watch<br>concepts in the development of S</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:654"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:660"><nobr><span class="ft4">DB's debugging points (cf. Sec-</span></nobr></DIV>
<DIV style="position:absolute;top:714;left:475"><nobr><span class="ft8">tion 4). In addition to this support for simulator instrumentation,<br>S</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:483"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:489"><nobr><span class="ft4">DB also provides a source code level instrumentation facility,</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:475"><nobr><span class="ft8">via virtual debugging registers, since it is easier to use for some<br>debugging problems.</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:489"><nobr><span class="ft4">Time traveling for debugging is currently the subject of much</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:475"><nobr><span class="ft8">research [11, 20] in the field of software system development and<br>virtualization. Flashback [20] is a lightweight extension for roll-<br>back and replay for software debugging. Flashback uses shadow<br>processes to take snapshots of the in-memory states of a running<br>process and logs the process' I/O events with the underlying system<br>to support deterministic rollback or replay. VMM (virtual machine<br>monitor) level logging is used in [11] for replaying the system exe-<br>cuting in a virtual machine. Checkpointing the state of a full system<br>simulator is easier than that in a real OS or virtual machine monitor<br>since all the hardware are simulated in software. Our results show<br>that time traveling support in DiSenS has very low overhead due to<br>the simpleness of sensor hardware it emulates.</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:475"><nobr><span class="ft2">3.</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:507"><nobr><span class="ft2">THE DiSenS SIMULATOR</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:489"><nobr><span class="ft4">S</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:496"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:502"><nobr><span class="ft4">DB is built upon DiSenS [25], a distributed sensor network</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:475"><nobr><span class="ft8">simulator designed for high fidelity and scalable performance. DiS-<br>enS provides sensor network applications an execution environ-<br>ment as "close" to real deployment as possible. DiSenS is also able</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">103</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="171003.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">to simulate a sensor network with hundreds of nodes in real time<br>speed using computer clusters. In this section, we briefly introduce<br>the design aspects of DiSenS that are relevant to the implementa-<br>tion of S</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:128"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:134"><nobr><span class="ft4">DB . The complete discussion and evaluation of DiSenS</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:81"><nobr><span class="ft4">are in papers [25, 24].</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:81"><nobr><span class="ft2">3.1</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:121"><nobr><span class="ft2">Full System Device Simulation</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:94"><nobr><span class="ft4">The building blocks of DiSenS are full system device simulators,</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:81"><nobr><span class="ft8">supporting popular sensor network devices, including iPAQ [9],<br>Stargate [21] and Mica2/MicaZ motes [15]. In this paper, we con-<br>fine our description to the functionality necessary for debugging<br>mote applications. However, the same functionality is implemented<br>for more complex devices such as the iPAQ and Stargate. A more<br>full examination of debugging for heterogeneous sensor devices is<br>the subject of our future work.</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:94"><nobr><span class="ft4">The mote device simulator in DiSenS supports most of the Mica2</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:81"><nobr><span class="ft8">and MicaZ hardware features, including the AVR instruction set,<br>the ATmega128L microcontroller (memories, UARTs, timers, SPI<br>and ADC, etc.), the on-board Flash memory, CC1000 (Mica2) and<br>CC2420 (MicaZ) radio chips and other miscellaneous components<br>(like sensor board, LEDs, etc.).</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:94"><nobr><span class="ft4">The core of the device simulator is a cycle-accurate AVR instruc-</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:81"><nobr><span class="ft8">tion emulator. The instruction emulator interacts with other hard-<br>ware simulation components via memory mapped I/O. When an<br>application binary is executed in the simulator, each machine in-<br>struction is fed into the instruction emulator, shifting the internal<br>representation of hardware states accordingly and faithfully. Asyn-<br>chronous state change is modelled as events. Events are scheduled<br>by hardware components and kept in an event queue. The instruc-<br>tion emulator checks the event queue for each instruction execu-<br>tion, triggering timed events. The collection of simulated hardware<br>features is rich enough to boot and execute unmodified binaries of<br>TinyOS [8] and most sensor network applications, including Surge,<br>TinyDB [14] and Deluge [4]. By correctly simulating hardware<br>components, the device simulator ensures the cycle accuracy, pro-<br>viding the basis of faithful simulation of a complete sensor net-<br>work.</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:94"><nobr><span class="ft4">The full system device simulator in DiSenS also presents ex-</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:81"><nobr><span class="ft8">tension points or "hooks" for integrating power and radio models.<br>This extensible architecture provides a way to support the devel-<br>opment of new models and to trade simulation speed for level of<br>accuracy. For debugging, this extensibility enables developers to<br>test applications with different settings. For example, radio models<br>representing different environments (like outdoor, indoor, etc.) can<br>be plugged in to test applications under different circumstances.</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:94"><nobr><span class="ft4">In i t s defaul t confi gurat i on, Di S enS i ncorporat es an accurat e power</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:81"><nobr><span class="ft8">model from [12], a simple linear battery model, a basic lossless ra-<br>dio model, and a simple parameterized statistical model. The struc-<br>ture of the system, however, incorporates these models as modules<br>that can be replaced with more sophisticated counterparts.</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:81"><nobr><span class="ft2">3.2</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:121"><nobr><span class="ft2">Scalable Distributed Simulation</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:94"><nobr><span class="ft4">DiSenS's ability to simulate hundreds of mote devices using dis-</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:81"><nobr><span class="ft8">tributed cluster computing resources is its most distinctive feature.<br>This level of scalability makes it possible to experiment with large<br>sensor network applications before they are actually deployed and<br>to explore reconfiguration options "virtually" so that only the most<br>promising need to be investigated in situ. As a debugging tool,<br>DiSenS's scalability allows developers to identify and correct prob-<br>lems associated with scale. For example, a data sink application<br>may work well in a network of dozens of nodes, but fails when the<br>network size increases to hundreds, due to the problems such as<br>insufficient queue or buffer size. Even for small scale network, the</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">scalability is useful because it translates into simulation speed, and<br>thus debugging efficiency.</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:489"><nobr><span class="ft4">DiSenS achieves its scalability by using a simple yet effective</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:475"><nobr><span class="ft8">synchronization protocol for radio simulation and applying auto-<br>matic node partition algorithms to spread the simulation/emulation<br>workload across machines in a computer cluster. In DiSenS, sensor<br>nodes are simulated in parallel, each running in its own operating<br>system thread and keeping its own virtual clock. Sensor nodes in-<br>teract with each other only in the radio transmission, during which<br>radio packets are exchanged. The radio interaction of sensor nodes<br>can be abstracted into two operations: read radio channel and write<br>radio channel. The analysis [25] shows that only when a node reads<br>radio channel, it needs to synchronize its clock with its neighbors<br>(i.e., potential radio transmitters in its radio range). This ensures<br>that each receiving node receives all the packets it is supposed to<br>receive. A primitive called wait on sync is introduced to perform<br>this synchronization, which forces the caller to wait for neighbor<br>nodes to catch up with its current clock time. To implement this<br>protocol, each node also has to keep its neighbors updated about its<br>clock advance by periodically sending out its current clock time. A<br>more detailed description and analysis of this protocol is in [25].</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:489"><nobr><span class="ft4">To utilize distributed computing r esources, D iS enS partitions nodes</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:475"><nobr><span class="ft8">into groups, each simulated on one machine within a cluster. Com-<br>munication between sensor nodes assigned to the same machine<br>is via a shared-memory communication channel. However, when<br>motes assigned to distinct machines communicate, that communi-<br>cation and synchronization must be implemented via a message<br>pass between machines. Due to the relatively large overhead of<br>remote synchronization via message passing (caused by network<br>latency), partitioning of simulated nodes to cluster machines plays<br>an important role in making the ensemble simulation efficient.</span></nobr></DIV>
<DIV style="position:absolute;top:573;left:489"><nobr><span class="ft4">To address this problem, graph-partitioning algorithms, origi-</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:475"><nobr><span class="ft8">nally developed for tightly-coupled data-parallel high-performance<br>computing applications, are employed. DiSenS uses a popular par-<br>titioning package [7] to partition nodes nearly optimally.</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:489"><nobr><span class="ft4">Our S</span></nobr></DIV>
<DIV style="position:absolute;top:631;left:521"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:527"><nobr><span class="ft4">DB debugging tool is built upon DiSenS , whose design</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:475"><nobr><span class="ft8">has huge impact on how the debugging facilities that we have im-<br>plemented, including both advantages and limitations. In the next 3<br>sections, we'll discuss how DiSenS interacts with S</span></nobr></DIV>
<DIV style="position:absolute;top:678;left:752"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:683;left:758"><nobr><span class="ft4">DB to support</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:475"><nobr><span class="ft4">both conventional and novel debugging techniques.</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:475"><nobr><span class="ft2">4.</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:507"><nobr><span class="ft2">DEBUGGING INDIVIDUAL DEVICES</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:489"><nobr><span class="ft4">S</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:496"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:502"><nobr><span class="ft4">DB was first built as a conventional distributed debugger on</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:475"><nobr><span class="ft8">the DiSenS simulator. Each group of sensor nodes has a standalone<br>debugging proxy waiting for incoming debugging commands. A<br>debugger console thus can attach to each individual sensor node<br>via this group proxy and perform debugging operations. The ba-<br>sic S</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:501"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:507"><nobr><span class="ft4">DB includes most functions in a conventional debugger, like</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:475"><nobr><span class="ft8">state (register and memory) checking, break points and step execu-<br>tion, etc.</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:489"><nobr><span class="ft4">In this section, we discuss how we exploit the potential of a simu-</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:475"><nobr><span class="ft8">lation environment to devise novel techniques for debugging single<br>sensor devices.</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:475"><nobr><span class="ft2">4.1</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:516"><nobr><span class="ft2">Debugging Point</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:489"><nobr><span class="ft4">Debugging is essentially a process of exposing program's in-</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:475"><nobr><span class="ft8">ternal states relevant to its abnormal behavior and pinpointing the<br>cause. Visibility of execution states is a determining factor of how<br>difficult the debugging task is. Building upon a full system simu-<br>lator for each device gives S</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:632"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:638"><nobr><span class="ft4">DB a great potential to expose time</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:475"><nobr><span class="ft4">synchronized state.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:489"><nobr><span class="ft4">Conventional debuggers essentially manipulate three states of a</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:475"><nobr><span class="ft4">program: register, memory and program counter (PC). Simulators</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">104</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="171004.png" alt="background image">
<DIV style="position:absolute;top:82;left:313"><nobr><span class="ft5">Component</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:445"><nobr><span class="ft5">Parameters</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:538"><nobr><span class="ft5">Value</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:588"><nobr><span class="ft5">Interrupt</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:646"><nobr><span class="ft5">Watchable</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:729"><nobr><span class="ft5">Overhead</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:117"><nobr><span class="ft5">PC (pc)</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:304"><nobr><span class="ft5">microcontroller</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:460"><nobr><span class="ft5">none</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:545"><nobr><span class="ft5">Int</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:738"><nobr><span class="ft5">Large</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:117"><nobr><span class="ft5">Register (reg)</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:304"><nobr><span class="ft5">microcontroller</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:454"><nobr><span class="ft5">address</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:545"><nobr><span class="ft5">Int</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:738"><nobr><span class="ft5">Large</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:117"><nobr><span class="ft5">Memory Read (mem rd)</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:324"><nobr><span class="ft5">SRAM</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:453"><nobr><span class="ft5">address</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:532"><nobr><span class="ft5">Boolean</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:117"><nobr><span class="ft5">Memory Write (mem wr)</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:324"><nobr><span class="ft5">SRAM</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:453"><nobr><span class="ft5">address</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:532"><nobr><span class="ft5">Boolean</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:117"><nobr><span class="ft5">Memory (mem)</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:324"><nobr><span class="ft5">SRAM</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:453"><nobr><span class="ft5">address</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:545"><nobr><span class="ft5">Int</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:117"><nobr><span class="ft5">Flash Access (flash access)</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:328"><nobr><span class="ft5">Flash</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:427"><nobr><span class="ft5">command, address</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:532"><nobr><span class="ft5">Boolean</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:117"><nobr><span class="ft5">Flash (flash)</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:328"><nobr><span class="ft5">Flash</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:453"><nobr><span class="ft5">address</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:545"><nobr><span class="ft5">Int</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:117"><nobr><span class="ft5">Power Change (power)</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:309"><nobr><span class="ft5">Power Model</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:460"><nobr><span class="ft5">none</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:540"><nobr><span class="ft5">Float</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:117"><nobr><span class="ft5">Timer Match (timer)</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:324"><nobr><span class="ft5">Timers</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:460"><nobr><span class="ft5">none</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:532"><nobr><span class="ft5">Boolean</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:600"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:664"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:117"><nobr><span class="ft5">Radio Data Ready (spi)</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:315"><nobr><span class="ft5">SPI (radio)</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:460"><nobr><span class="ft5">none</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:532"><nobr><span class="ft5">Boolean</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:600"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:664"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:117"><nobr><span class="ft5">ADC Data Ready (adc)</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:294"><nobr><span class="ft5">ADC (radio/sensor)</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:460"><nobr><span class="ft5">none</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:532"><nobr><span class="ft5">Boolean</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:600"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:664"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:117"><nobr><span class="ft5">Serial Data Received (uart)</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:325"><nobr><span class="ft5">UART</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:460"><nobr><span class="ft5">none</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:532"><nobr><span class="ft5">Boolean</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:600"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:664"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:117"><nobr><span class="ft5">Clock (clock)</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:325"><nobr><span class="ft5">Virtual</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:460"><nobr><span class="ft5">none</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:545"><nobr><span class="ft5">Int</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:601"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:731"><nobr><span class="ft5">Minimal</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:117"><nobr><span class="ft5">Radio Packet Ready (packet)</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:314"><nobr><span class="ft5">Radio Chip</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:460"><nobr><span class="ft5">none</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:536"><nobr><span class="ft5">Packet</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:738"><nobr><span class="ft5">Small</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:117"><nobr><span class="ft5">Program Defined (custom)</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:272"><nobr><span class="ft5">Virtual Debugging Hardware</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:465"><nobr><span class="ft5">ID</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:545"><nobr><span class="ft5">Int</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:602"><nobr><span class="ft5">No</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:662"><nobr><span class="ft5">Yes</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:712"><nobr><span class="ft5">Program defined</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:300"><nobr><span class="ft4">Table 1: The current set of debugging points in S</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:580"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:586"><nobr><span class="ft4">DB .</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:81"><nobr><span class="ft8">can provide much more abundant state information, which may<br>enable or ease certain debugging tasks. For example, to debug a<br>TinyOS module that manages on-board flash memory, it is impor-<br>tant for the internal buffers and flash pages to be displayed directly.<br>It is straightforward for DiSenS but rather difficult in a conventional<br>debugger, which has to invoke complex code sequence to access the<br>flash indirectly.</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:94"><nobr><span class="ft4">We carefully studied the device states in DiSenS and defined a</span></nobr></DIV>
<DIV style="position:absolute;top:504;left:81"><nobr><span class="ft8">series of debugging points. A debugging point is the access point<br>to one of the internal states of the simulated device. The device<br>state that is exposed by a debugging point can then be used by the<br>debugger for displaying program status and controlling program<br>execution, e.g., break and watch, as that in a conventional debug-<br>ger. In this sense, debugging points have extended our debugger's<br>capability of program manipulation.</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:94"><nobr><span class="ft4">Table 1 lists the current set of debugging points defined in S</span></nobr></DIV>
<DIV style="position:absolute;top:609;left:411"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:417"><nobr><span class="ft4">DB.</span></nobr></DIV>
<DIV style="position:absolute;top:630;left:81"><nobr><span class="ft8">It is not a complete list since we are still improving our implemen-<br>tation and discovering more meaningful debugging points. In the<br>table, the first column shows the debugging point name and the<br>abbreviated notation (in parentheses) used by the debugger con-<br>sole. The corresponding hardware component that a debugging<br>point belongs to is listed in the second column. The third and fourth<br>columns specify the parameters and return value of a debugging<br>point. For example, the "memory" point returns the byte content<br>by the given memory address. The fifth column tells whether a de-<br>bugging point has an interrupt associated. And the sixth column<br>specifies whether a watch can be added to the point. The last col-<br>umn estimates the theoretical performance overhead of monitoring<br>a particular debugging point.</span></nobr></DIV>
<DIV style="position:absolute;top:834;left:94"><nobr><span class="ft4">As we see in the table, the common program states interrogated</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:81"><nobr><span class="ft8">by convent i onal debugger s , i . e . r egi s t e r, memor y and pr ogr am count er,<br>are also generalized as debugging points in S</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:332"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:338"><nobr><span class="ft4">DB , listed as reg,</span></nobr></DIV>
<DIV style="position:absolute;top:881;left:81"><nobr><span class="ft8">mem and pc. For memory, we also introduced two extra debug-<br>ging points, mem rd and mem wr, to monitor the access to memory<br>in terms of direction. Notice that debugging points have different<br>time properties: some are persistent while others are transient. In<br>the memory case, the memory content, mem, is persistent, while<br>memory accesses, mem rd and mem wr, are transient. They are<br>valid only when memory is read or written.</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:94"><nobr><span class="ft4">Similarly, the on-board flash has two defined debugging points:</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:81"><nobr><span class="ft8">one for the page content (flash) and the other (flash access) for the<br>flash access, including read, program and erase. The power debug-<br>ging point is used to access the simulated power state of the device,<br>which may be useful for debugging power-aware algorithms.</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:489"><nobr><span class="ft4">Four important hardware events are defined as debugging points:</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:475"><nobr><span class="ft8">timer match event (timer), radio (SPI) data ready (spi), ADC data<br>ready (adc) and serial data ready (uart). They are all transient and<br>all related to an interrupt. These debugging points provide a nat-<br>ural and convenient way to debug sensor network programs since<br>many of these programs are event-driven, such as TinyOS and its<br>application suite. As an example, if we want to break the program<br>execution at the occurrence of a timer match event, we can simply<br>invoke the command:</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:475"><nobr><span class="ft4">&gt; break when timer() == true</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:475"><nobr><span class="ft8">In a more conventional debugger, a breakpoint is typically set in<br>the interrupt handling code, the name of which must be known to<br>the programmer. Furthermore, breaking on these event-based de-<br>bugging points is much more efficient than breaking on a source<br>code line (i.e., a specific program address). This is because match-<br>ing program addresses requires a comparison after the execution<br>of each instruction while matching event-based debugging points<br>only happens when the corresponding hardware events are trig-<br>gered, which occur much less frequently. We will discuss how to<br>use debugging points to set break conditions and their overhead in<br>later this subsection.</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:489"><nobr><span class="ft4">The clock debugging point provides a way for accurate timing</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:475"><nobr><span class="ft8">control over program execution. It can be used to fast forward the<br>execution to a certain point if we know that the bug of our interest<br>will not occur until after a period of time. It would be rather diffi-<br>cult to implement this in a conventional debugger since there is no<br>easy way to obtain accurate clock timing across device subsystems.</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:489"><nobr><span class="ft4">It is also possible to analyze the states and data in the simulator to</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:475"><nobr><span class="ft8">extract useful high-level semantics and use them to build advanced<br>debugging points. An example is the recognition of radio packet.<br>The Mica2 sensor device uses the CC1000 radio chip, which oper-<br>ates at the byte level. Thus an emulator can only see the byte stream<br>transmitted from/to neighbor nodes and not packet boundaries. For<br>application debugging, however, it is often necessary to break pro-<br>gram execution when a complete packet has been transmitted or<br>received. A typical debugging strategy is to set a breakpoint in the<br>radio software stack at the the line of code line that finishes a packet<br>reception. However, this process can be both tedious and unreliable<br>(e.g. software stack may change when a new image is installed),<br>especially during development or maintenance of the radio stack<br>itself. Fortunately, in the current TinyOS radio stack implementa-<br>tion, the radio packet has a fixed format. We implemented a tiny<br>radio packet recognizer in the radio chip simulation code. A "radio<br>packet ready" (packet) debugging point is defined to signal the state</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">105</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft11{font-size:14px;font-family:Times;color:#000000;}
	.ft12{font-size:5px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="171005.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">when a complete packet is received. These extracted high-level se-<br>mantics are useful because we can debug applications without re-<br>lying on the source code, especially when the application binary is<br>optimized code and it is hard to associate exact program addresses<br>with specific source code line. However, discovering these seman-<br>tics using low-level data/states is challenging and non-obvious (at<br>least, to us) and as such continues to be a focus of our on-going<br>research in this area.</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:85"><nobr><span class="ft11"><i>4.1.1</i></span></nobr></DIV>
<DIV style="position:absolute;top:222;left:134"><nobr><span class="ft11"><i>Break Conditions Using Debugging Points</i></span></nobr></DIV>
<DIV style="position:absolute;top:243;left:94"><nobr><span class="ft4">Debugging points are used in a functional form. For example, if</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:81"><nobr><span class="ft4">we want to print a variable X, we can use:</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:81"><nobr><span class="ft4">&gt; print mem(X)</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:81"><nobr><span class="ft8">To implement conditional break or watch points, they can be in-<br>cluded in imperatives such as:</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:81"><nobr><span class="ft4">&gt; break when flash_access(erase, 0x1)</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:81"><nobr><span class="ft8">which breaks the execution when the first page of the flash is erased.<br>It is also possible to compose them:</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:81"><nobr><span class="ft4">&gt; break when timer() &amp;&amp; mem(Y) &gt; 1</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:81"><nobr><span class="ft8">which breaks when a timer match event occurs and a state variable<br>Y , like a counter, is larger than 1.</span></nobr></DIV>
<DIV style="position:absolute;top:479;left:94"><nobr><span class="ft4">The basic algorithm for monitoring and evaluating break con-</span></nobr></DIV>
<DIV style="position:absolute;top:494;left:81"><nobr><span class="ft8">ditions is as follows. Each debugging point maintains a monitor<br>queue. Whenever a break point is set, its condition is added to the<br>queue of every debugging point that is used by the condition. Ev-<br>ery time the state changes at a debugging point, the conditions in<br>its queue is re-evaluated to check whether any of them is satisfied.<br>If so, one of the break points is reached and the execution is sus-<br>pended. Otherwise, the execution continues.</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:94"><nobr><span class="ft4">Note that the monitoring overhead varies for different debugging</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:81"><nobr><span class="ft8">points revealing the possibility for optimization of the basic condi-<br>tion evaluating algorithm. The monitoring overhead is determined<br>by the frequency of state change at a debugging point. Obviously,<br>pc has the largest overhead because it changes at each instruction<br>execution. Event related debugging points have very low overhead<br>since hardware events occur less frequently. For example, the timer<br>event may be triggered for every hundreds of cycles. Clock logi-<br>cally has a large overhead since it changes every clock cycle. How-<br>ever, in simulation, clock time is checked anyway for event trigger-<br>ing. By implementing the clock monitoring itself as an event, we<br>introduce no extra overhead for monitoring clock debugging point.</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:94"><nobr><span class="ft4">Thus we are able to optimize the implementation of condition</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:81"><nobr><span class="ft8">evaluation. For example, considering the following break condi-<br>tion:</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:81"><nobr><span class="ft4">&gt; break when pc() == foo &amp;&amp; mem(Y) &gt; 1</span></nobr></DIV>
<DIV style="position:absolute;top:876;left:81"><nobr><span class="ft8">Using the basic algorithm, the overhead of monitoring the condition<br>is the sum of pc's overhead and mem's overhead. However, since<br>the condition is satisfied when both debugging points match their<br>expression, we could only track mem since it has smaller overhead<br>than pc. When mem is satisfied, we then continue to check pc. In<br>this way, the overall overhead reduces.</span></nobr></DIV>
<DIV style="position:absolute;top:970;left:94"><nobr><span class="ft4">Now we present the general condition evaluation algorithm. Given</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:81"><nobr><span class="ft8">a condition as a logic expression, C, it is first converted into canon-<br>ical form using product of maxterms:</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:199"><nobr><span class="ft4">C = t</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:233"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:243"><nobr><span class="ft4"> t</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:260"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:269"><nobr><span class="ft4"> ...  t</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:313"><nobr><span class="ft1">n</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:424"><nobr><span class="ft4">(1)</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft4">where t</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:122"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:130"><nobr><span class="ft4">is a maxterm. The overhead function f</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:338"><nobr><span class="ft1">ov</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:353"><nobr><span class="ft4">is defined as the</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:81"><nobr><span class="ft4">total overhead to monitor all the debugging points in a maxterm.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft4">Then we sort the maxterms by the value of f</span></nobr></DIV>
<DIV style="position:absolute;top:89;left:719"><nobr><span class="ft1">ov</span></nobr></DIV>
<DIV style="position:absolute;top:83;left:732"><nobr><span class="ft4">(t</span></nobr></DIV>
<DIV style="position:absolute;top:89;left:742"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:83;left:747"><nobr><span class="ft4">) in incremental</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:475"><nobr><span class="ft4">order, say, t</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:542"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:548"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:554"><nobr><span class="ft4">, ..., t</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:586"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:592"><nobr><span class="ft12">n</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:600"><nobr><span class="ft4">. We start the monitoring of C first using</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:475"><nobr><span class="ft4">maxterm t</span></nobr></DIV>
<DIV style="position:absolute;top:120;left:532"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:538"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:549"><nobr><span class="ft4">by adding C to all the debugging points that belong</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:475"><nobr><span class="ft4">to t</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:496"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:139;left:502"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:508"><nobr><span class="ft4">. When t</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:563"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:139;left:569"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:580"><nobr><span class="ft4">is satisfied, we re-evaluate C and stop if it is</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:475"><nobr><span class="ft4">true. Otherwise, we remove C from t</span></nobr></DIV>
<DIV style="position:absolute;top:152;left:689"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:695"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:702"><nobr><span class="ft4">'s debugging points and</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:475"><nobr><span class="ft4">start monitoring t</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:570"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:575"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:582"><nobr><span class="ft4">. If t</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:607"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:613"><nobr><span class="ft12">n</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:624"><nobr><span class="ft4">is monitored and C is still not satisfied,</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:475"><nobr><span class="ft4">we loop back to t</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:571"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:577"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:583"><nobr><span class="ft4">. We repeat this process until C is satisfied. If</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:475"><nobr><span class="ft4">C is unsatisfiable, this process never ends.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:489"><nobr><span class="ft4">Debugging points give us powerful capability to debug sensor</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:475"><nobr><span class="ft8">network programs at a level between the hardware level and the<br>source-code level. However, a direct instrumentation of the source<br>code i s somet i m es easi est and m ost s t r ai ght - f or war d debuggi ng met hod.<br>The typical methodology for implementing source-level instrumen-<br>tation is to use print statements to dump states. Printing, however,<br>can introduce considerable overhead that can mask the problem be-<br>ing tracked.</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:489"><nobr><span class="ft4">In S</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:511"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:517"><nobr><span class="ft4">DB we include an instrumentation facility based on virtual</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:475"><nobr><span class="ft8">registers that serves the same purpose with reduced overhead. We<br>introduce our instrumentation facility in the next subsection.</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:475"><nobr><span class="ft2">4.2</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:515"><nobr><span class="ft2">Virtual Hardware Based Source Code</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:516"><nobr><span class="ft2">Instrumentation</span></nobr></DIV>
<DIV style="position:absolute;top:433;left:489"><nobr><span class="ft4">Sensor devices are usually resource-constrained, lacking the nec-</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:475"><nobr><span class="ft8">essary facility for debugging in both hardware and software. On<br>a Mica2 sensor device, the only I/O method that can be used for<br>display internal status by the program is to flash the three LEDs,<br>which is tedious and error-prone to decode. DiSenS faithfully sim-<br>ulates the sensor hardware, thus inheriting this limitation. Because<br>we insist that DiSenS maintain binary transparency with the native<br>hardware it emulates, the simulated sensor network program is not<br>able to perform a simple "printf".</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:489"><nobr><span class="ft4">To solve this problem, we introduce three virtual registers as an</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:475"><nobr><span class="ft8">I/O channel for the communication between application and sim-<br>ulator. Their I/O addresses are allocated in the reserved memory<br>space of ATmega128L. Thus the access of these virtual registers<br>will not affect the correct functioning of other components. Table 2<br>lists the three registers and their functions.</span></nobr></DIV>
<DIV style="position:absolute;top:684;left:533"><nobr><span class="ft4">Address</span></nobr></DIV>
<DIV style="position:absolute;top:684;left:607"><nobr><span class="ft4">Name</span></nobr></DIV>
<DIV style="position:absolute;top:684;left:685"><nobr><span class="ft4">Functionality</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:542"><nobr><span class="ft4">0x75</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:594"><nobr><span class="ft4">VDBCMD</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:669"><nobr><span class="ft4">Command Register</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:542"><nobr><span class="ft4">0x76</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:602"><nobr><span class="ft4">VDBIN</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:682"><nobr><span class="ft4">Input Register</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:542"><nobr><span class="ft4">0x77</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:595"><nobr><span class="ft4">VDBOUT</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:678"><nobr><span class="ft4">Output Register</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:475"><nobr><span class="ft8">Table 2: Virtual registers for communication between applica-<br>tion and simulator.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:489"><nobr><span class="ft4">The operation of virtual registers is as follows: an application</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:475"><nobr><span class="ft8">first issues a command in the command register, VDBCMD; then<br>the output data is transferred via VDBOUT register and the input<br>data is read from em VDBIN register. The simplest application<br>of virtual registers is to print debugging messages by first send-<br>ing a "PRINT" command and then continuously writing the ASCII<br>characters in a string to the VDBOUT register until a new line is<br>reached. On the simulator side, whenever a command is issued, it<br>either reads from the VDBOUT register or sending data to VDBIN.<br>In the print case, when the simulator gets all the characters (ended<br>by a new line), it will print out on the host console of the simulating<br>machine.</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:489"><nobr><span class="ft4">A more advanced use of virtual registers is to control a debug-</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:475"><nobr><span class="ft8">ging point. We term this combination of virtual registers and de-<br>bugging points a program defined debugging point (custom, as listed<br>in the last line of Table 1). The state of a custom debugging point is<br>generated by the instrumentation code in the program. To do so, the<br>instrumentation code first sends a "DEBUG" command to the VD-</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">106</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft13{font-size:10px;font-family:Times;color:#000000;}
	.ft14{font-size:16px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="171006.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">BCMD register, then outputs the debugging data on the VDBOUT<br>register, in the form of a tuple, &lt; id, value &gt;. The id is used to<br>identify the instrumentation point in the source code and the value<br>is any value generated by the instrumented code. If there is a break<br>condition registered at this point, it will be checked against the tu-<br>ple and execution will stop when it is matched. As an example, if<br>we want to break at the</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:217"><nobr><span class="ft4">10th entry of a function, we can instru-</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:81"><nobr><span class="ft8">ment the function and keep a counter of entries. Every time the<br>counter changes, we output the counter value via virtual registers.<br>The break condition will be satisfied when the value equals to</span></nobr></DIV>
<DIV style="position:absolute;top:224;left:416"><nobr><span class="ft4">10.</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:94"><nobr><span class="ft4">To make it easy to use, we developed a small C library for ac-</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:81"><nobr><span class="ft8">cessing the virtual registers transparently. Developers can invoke<br>accessing functions on these registers by simply calling the C APIs,<br>for example, in a TinyOS program.</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:94"><nobr><span class="ft4">Instrumentation via the virtual registers has the minimal intru-</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:81"><nobr><span class="ft8">siveness on application execution. When generating a debugging<br>point event by sending a &lt; id, value &gt; tuple, only three register<br>accesses are needed if both values in the tuple are</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:353"><nobr><span class="ft4">8-bits each (one</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:81"><nobr><span class="ft4">for the command and two for the data).</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:81"><nobr><span class="ft2">5.</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:81"><nobr><span class="ft2">COORDINATED PARALLEL DEBUGGING</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:112"><nobr><span class="ft2">OF MULTIPLE DEVICES</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:94"><nobr><span class="ft4">DiSenS's scalability and performance enables S</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:361"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:367"><nobr><span class="ft4">DB to debug</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:81"><nobr><span class="ft8">large cooperating ensembles of sensors as a simulated sensor net-<br>work deployment. Like other debuggers, S</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:314"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:320"><nobr><span class="ft4">DB permits its user to</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:81"><nobr><span class="ft8">attach to and "focus" on a specific sensor while the other sensors<br>in the ensemble execute independently. However, often, more sys-<br>tematic errors emerge from the interactions among sensor nodes<br>even when individual devices and/or applications are functioning<br>correctly. To reveal these kinds of errors, developers must be able<br>to interrogate and control multiple sensor devices in a coordinated<br>way.</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:94"><nobr><span class="ft4">Debugging a program normally involves displaying program sta-</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:81"><nobr><span class="ft8">tus, breaking program execution at arbitrary points, step-executing,<br>etc. By extending this concept to parallel debugging, we want to be<br>able to:</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:98"><nobr><span class="ft4">1. Display the status of multiple devices in parallel;</span></nobr></DIV>
<DIV style="position:absolute;top:701;left:98"><nobr><span class="ft4">2. Break the execution of multiple devices at certain common</span></nobr></DIV>
<DIV style="position:absolute;top:717;left:114"><nobr><span class="ft4">point;</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:98"><nobr><span class="ft4">3. Step-execute multiple devices at the same pace.</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:81"><nobr><span class="ft8">The first and third items in the above "wish list" are easy to imple-<br>ment in a simulation context. S</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:250"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:785;left:256"><nobr><span class="ft4">DB can simply "multicast" its de-</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:81"><nobr><span class="ft8">bugging commands to a batch of sensor nodes once their execution<br>stop at a certain common point. As for the second item, since DiS-<br>enS is, in effect, executing multiple parallel simulations without<br>a centralized clock, implementing a time-correlated and common<br>breakpoint shares the same coordination challenges with in parallel<br>debugging counterpart.</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:94"><nobr><span class="ft4">The simplest form of coordinated break is to pause the execution</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:81"><nobr><span class="ft4">of a set of involved nodes at a specific virtual time, T :</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:81"><nobr><span class="ft4">&gt; :break when clock() == T</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:81"><nobr><span class="ft8">where the colon before "break" indicates that it is a batch command<br>and will be sent to all the nodes in a global batch list (maintained<br>by other commands).</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:94"><nobr><span class="ft4">It is necessary to review DiSenS's synchronization mechanism</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:81"><nobr><span class="ft4">first. We summarize the major rules as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:98"><nobr><span class="ft4">1. A node that receives or samples radio channel must wait for</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:114"><nobr><span class="ft4">all its neighbors to catch up with its current clock time;</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:589"><nobr><span class="ft11"><i>A</i></span></nobr></DIV>
<DIV style="position:absolute;top:193;left:617"><nobr><span class="ft11"><i>C</i></span></nobr></DIV>
<DIV style="position:absolute;top:97;left:607"><nobr><span class="ft11"><i>B</i></span></nobr></DIV>
<DIV style="position:absolute;top:97;left:636"><nobr><span class="ft11"><i>D</i></span></nobr></DIV>
<DIV style="position:absolute;top:107;left:483"><nobr><span class="ft11"><i>Y</i></span></nobr></DIV>
<DIV style="position:absolute;top:206;left:563"><nobr><span class="ft3">Receive Receive</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:593"><nobr><span class="ft3">Update Transmit</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:482"><nobr><span class="ft11"><i>X</i></span></nobr></DIV>
<DIV style="position:absolute;top:149;left:640"><nobr><span class="ft13"><i>clock update &amp; byte transmission</i></span></nobr></DIV>
<DIV style="position:absolute;top:128;left:534"><nobr><span class="ft13"><i>clock update</i></span></nobr></DIV>
<DIV style="position:absolute;top:238;left:475"><nobr><span class="ft8">Figure 1: Illustration of synchronization between sensor nodes<br>in DiSenS . Dashed arrows indicate the update and transmis-<br>sion messages. A &lt; B &lt; C &lt; D.</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:492"><nobr><span class="ft4">2. All nodes must periodically broadcast their clock updates to</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:509"><nobr><span class="ft4">neighbors;</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:492"><nobr><span class="ft4">3. Before any wait, a node must first send its clock update (to</span></nobr></DIV>
<DIV style="position:absolute;top:364;left:509"><nobr><span class="ft4">avoid loop waiting);</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:492"><nobr><span class="ft4">4. Radio byte is always sent with a clock update at the end of</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:509"><nobr><span class="ft4">its last bit transmission.</span></nobr></DIV>
<DIV style="position:absolute;top:433;left:475"><nobr><span class="ft8">Figure 1 illustrates the process. At time point A, node X receives.<br>It first sends an update of its clock and wait for its neighbor Y<br>(rule 3 &amp; 1). Y runs to B and sends its clock update (rule 2), which<br>wakes up X. X proceeds to C and receives again. Y starts a byte<br>transmission at B. At D, the last bit transmitted and so the byte<br>along with a clock update is sent to X (rule 4). X receives the<br>byte, knowing Y passes its current time, and proceeds.</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:647"><nobr><span class="ft14"><i><b>B</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:586;left:505"><nobr><span class="ft14"><i><b>Y</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:670;left:504"><nobr><span class="ft14"><i><b>X</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:683;left:660"><nobr><span class="ft14"><i><b>A</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:698;left:639"><nobr><span class="ft11"><i>Receive</i></span></nobr></DIV>
<DIV style="position:absolute;top:575;left:701"><nobr><span class="ft14"><i><b>C</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:634;left:701"><nobr><span class="ft11"><i>Break point</i></span></nobr></DIV>
<DIV style="position:absolute;top:558;left:602"><nobr><span class="ft11"><i>Last update Next update</i></span></nobr></DIV>
<DIV style="position:absolute;top:613;left:576"><nobr><span class="ft3">update for break</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:475"><nobr><span class="ft8">Figure 2: Break at a certain point of time. Dashed arrows in-<br>dicate the update and transmission messages. B &lt; A &lt; C.</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:489"><nobr><span class="ft4">Now, let's see what happens when we ask multiple nodes to stop</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:475"><nobr><span class="ft8">at the same time. Figure 2 shows one case of the situation. X<br>receives at time A and sends an update and waits for Y . Y sends<br>an update at B. Its next update time is C. But we want to break at<br>a point before C but after A. Since Y breaks (thus waits), it sends<br>an update (rule 3). X receives the update, wakes up, proceeds to<br>the break point and stops. Now both X and Y are stopped at the<br>same time point.</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:489"><nobr><span class="ft4">In Figure 3, the situation is similar to the case in Figure 2. The</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:475"><nobr><span class="ft8">difference is that now the break point is in the middle of a byte<br>transmission for Y . Y can not just send an update to X and let<br>X proceeds to break point as in Figure 2. because if X gets the<br>update from Y , it believes Y has no byte to send up to the break<br>point and will continue its radio receiving logic. Thus the partial<br>byte from Y is lost. This problem is caused by rule 4. We solve<br>it by relaxing the rule: Whenever a node is stopped (thus it waits)<br>in the middle of a byte transmission, the byte is pre-transmitted<br>with the clock update. We can do this because mote radio always<br>transmits in byte unit. Once a byte transmission starts, we already</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">107</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft15{font-size:10px;font-family:Times;color:#ffffff;}
	.ft16{font-size:13px;font-family:Times;color:#000000;}
	.ft17{font-size:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="171007.png" alt="background image">
<DIV style="position:absolute;top:97;left:253"><nobr><span class="ft14"><i><b>B</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:108;left:111"><nobr><span class="ft14"><i><b>Y</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:193;left:110"><nobr><span class="ft14"><i><b>X</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:206;left:265"><nobr><span class="ft14"><i><b>A</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:220;left:245"><nobr><span class="ft11"><i>Receive</i></span></nobr></DIV>
<DIV style="position:absolute;top:97;left:306"><nobr><span class="ft14"><i><b>C</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:157;left:306"><nobr><span class="ft11"><i>Break point</i></span></nobr></DIV>
<DIV style="position:absolute;top:82;left:191"><nobr><span class="ft11"><i>Transmit start Transmit</i></span></nobr></DIV>
<DIV style="position:absolute;top:136;left:142"><nobr><span class="ft3">update &amp; pre-transmit</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:81"><nobr><span class="ft8">Figure 3: Extension to the synchronization protocol: pre-<br>transmission. Dashed arrows indicate the update and transmis-<br>sion messages. B &lt; A &lt; C.</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:81"><nobr><span class="ft8">know its content. Also, in DiSenS , each byte received by a node is<br>buffered with timestamp. It will be processed only when the time<br>matches the local clock. With this relaxed rule, we are now able to<br>stop multiple sensor nodes at the same virtual time.</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:94"><nobr><span class="ft4">The next question is how to perform a conditional break on mul-</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:81"><nobr><span class="ft4">tiple nodes. Notice that we cannot simply implement:</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:81"><nobr><span class="ft4">&gt; :break when mem(X) &gt; 3</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:81"><nobr><span class="ft8">because it asks the nodes to break independently. Whenever a node<br>breaks at some point, other nodes with direct or indirect neighbor-<br>hood relationship with it will wait at indeterminate points due to<br>the synchronization requirement. Whether they all satisfy the con-<br>dition is not clear. A reasonable version of this command is:</span></nobr></DIV>
<DIV style="position:absolute;top:544;left:81"><nobr><span class="ft4">&gt; :break when *.mem(X) &gt; 3</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:81"><nobr><span class="ft4">or</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:81"><nobr><span class="ft4">&gt; :break when node1.mem(X) &gt; 3</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:153"><nobr><span class="ft4">&amp;&amp; ... &amp;&amp; nodek.mem(X) &gt; 3</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:81"><nobr><span class="ft8">which means "break when X &gt; 3 for all the nodes". In the gen-<br>eral form, we define a coordinated break as a break with condition<br>cond</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:109"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:119"><nobr><span class="ft4"> cond</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:160"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:170"><nobr><span class="ft4"> ...  cond</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:239"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:669;left:246"><nobr><span class="ft4">, where cond</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:319"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:669;left:328"><nobr><span class="ft4">is a logic expression</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:81"><nobr><span class="ft4">for node i.</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:153"><nobr><span class="ft15">000000000000000</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:153"><nobr><span class="ft15">000000000000000</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:153"><nobr><span class="ft13"><i>111111111111111</i></span></nobr></DIV>
<DIV style="position:absolute;top:741;left:153"><nobr><span class="ft13"><i>111111111111111</i></span></nobr></DIV>
<DIV style="position:absolute;top:784;left:200"><nobr><span class="ft15">000000000</span></nobr></DIV>
<DIV style="position:absolute;top:771;left:200"><nobr><span class="ft15">000000000</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:200"><nobr><span class="ft13"><i>111111111</i></span></nobr></DIV>
<DIV style="position:absolute;top:771;left:200"><nobr><span class="ft13"><i>111111111</i></span></nobr></DIV>
<DIV style="position:absolute;top:815;left:231"><nobr><span class="ft15">00000000000000</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:231"><nobr><span class="ft15">00000000000000</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:231"><nobr><span class="ft13"><i>11111111111111</i></span></nobr></DIV>
<DIV style="position:absolute;top:802;left:231"><nobr><span class="ft13"><i>11111111111111</i></span></nobr></DIV>
<DIV style="position:absolute;top:742;left:88"><nobr><span class="ft4">X</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:87"><nobr><span class="ft4">Y</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:87"><nobr><span class="ft4">Z</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:148"><nobr><span class="ft13"><i>A</i></span></nobr></DIV>
<DIV style="position:absolute;top:836;left:195"><nobr><span class="ft13"><i>B</i></span></nobr></DIV>
<DIV style="position:absolute;top:836;left:226"><nobr><span class="ft13"><i>C</i></span></nobr></DIV>
<DIV style="position:absolute;top:835;left:303"><nobr><span class="ft13"><i>D</i></span></nobr></DIV>
<DIV style="position:absolute;top:713;left:220"><nobr><span class="ft13"><i>Condition satisfied</i></span></nobr></DIV>
<DIV style="position:absolute;top:867;left:81"><nobr><span class="ft8">Figure 4: Coordinated break. The shaded boxes represent the<br>time range during which a local condition is satisfied. Between<br>C and D, the global condition is satisfied. A &lt; B &lt; C &lt; D.</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:94"><nobr><span class="ft4">Figure 4 illustrates the meaning of this form of breakpoint. The</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:81"><nobr><span class="ft8">shaded boxes are the time period during which the local condi-<br>tion for a node is satisfied. In Figure 4, the global condition, i.e.<br>cond</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:109"><nobr><span class="ft1">x</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:118"><nobr><span class="ft4"> cond</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:158"><nobr><span class="ft1">y</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:168"><nobr><span class="ft4"> cond</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:208"><nobr><span class="ft1">z</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:214"><nobr><span class="ft4">, is satisfied between time C and D. Time</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:81"><nobr><span class="ft4">C is the exact point where we want to break.</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:94"><nobr><span class="ft4">Before we present the algorithm that implements coordinated</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft8">break, we need to first introduce a new synchronization scheme.<br>We call it partially ordered synchronization. By default DiSenS<br>implements peer synchronization: all the nodes are running in arbi-<br>trary order except synchronized during receiving or sampling. The</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">new scheme imposes a partial order. In this scheme, a node master<br>is first specified. Then all the other nodes proceed by following the<br>master node. That is, at any wall clock time t</span></nobr></DIV>
<DIV style="position:absolute;top:120;left:736"><nobr><span class="ft1">wall</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:763"><nobr><span class="ft4">(i.e., the real</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:475"><nobr><span class="ft4">world time), for any node</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:615"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:620"><nobr><span class="ft4">, clock</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:657"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:665"><nobr><span class="ft4">&lt;= clock</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:721"><nobr><span class="ft1">master</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:758"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:598"><nobr><span class="ft16"><b>A</b></span></nobr></DIV>
<DIV style="position:absolute;top:300;left:666"><nobr><span class="ft16"><b>C</b></span></nobr></DIV>
<DIV style="position:absolute;top:170;left:615"><nobr><span class="ft16"><b>B</b></span></nobr></DIV>
<DIV style="position:absolute;top:170;left:649"><nobr><span class="ft16"><b>D</b></span></nobr></DIV>
<DIV style="position:absolute;top:473;left:564"><nobr><span class="ft16"><b>A</b></span></nobr></DIV>
<DIV style="position:absolute;top:473;left:616"><nobr><span class="ft16"><b>C</b></span></nobr></DIV>
<DIV style="position:absolute;top:474;left:666"><nobr><span class="ft16"><b>E</b></span></nobr></DIV>
<DIV style="position:absolute;top:341;left:616"><nobr><span class="ft16"><b>B</b></span></nobr></DIV>
<DIV style="position:absolute;top:341;left:666"><nobr><span class="ft16"><b>D</b></span></nobr></DIV>
<DIV style="position:absolute;top:275;left:501"><nobr><span class="ft17"><b>X</b></span></nobr></DIV>
<DIV style="position:absolute;top:362;left:500"><nobr><span class="ft17"><b>Y</b></span></nobr></DIV>
<DIV style="position:absolute;top:447;left:501"><nobr><span class="ft17"><b>X</b></span></nobr></DIV>
<DIV style="position:absolute;top:190;left:501"><nobr><span class="ft17"><b>Y</b></span></nobr></DIV>
<DIV style="position:absolute;top:511;left:475"><nobr><span class="ft8">Figure 5: TOP: peer synchronization in DiSenS . A &lt; B &lt;<br>D &lt; C. BOTTOM: partially ordered synchronization for S</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:806"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:812"><nobr><span class="ft4">DB.</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:475"><nobr><span class="ft8">A &lt; C &lt; E, B = C, D = E. Dashed arrows indicate the<br>update and transmission messages. (Some update messages are<br>omitted)</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:489"><nobr><span class="ft4">Figure 5 illustrates the two synchronization schemes. The top</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:475"><nobr><span class="ft8">part shows DiSenS's peer synchronization scheme. Node X waits<br>at A. Y sends update at B and wakes X. Then Y waits at D,<br>waken by X's update at C. X and Y proceed in parallel afterwards.<br>The bottom part shows S</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:614"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:620"><nobr><span class="ft4">DB's partially ordered synchronization</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:475"><nobr><span class="ft8">scheme. Here Y is the master. X first waits at A. Y sends its<br>update at B. X receives the update and runs to the updated point,<br>which is C (=B). Then X waits again. When Y runs to D and<br>sends update. X can proceed to E (=D). If Y needs to wait to<br>receive, X will wake it up when X reaches E according to rule 3.<br>Obviously, in this scheme, X always follows Y .</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:489"><nobr><span class="ft4">Now we can give our algorithm for coordinated break. Using</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:475"><nobr><span class="ft8">Figure 4 as the example, we first designate X as the master. At<br>point A, X's condition is satisfied. X stops at A. Since Y and<br>Z follow X, they all stop at A. Then we choose the next node as<br>the new master, whose condition is not satisfied yet. It is Y . X<br>and Z follow Y until Y reaches B. Next, similarly, we choose Z<br>as new master. At time C, we find cond</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:705"><nobr><span class="ft1">x</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:716"><nobr><span class="ft4"> cond</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:758"><nobr><span class="ft1">y</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:769"><nobr><span class="ft4"> cond</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:810"><nobr><span class="ft1">z</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:823"><nobr><span class="ft4">=</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:475"><nobr><span class="ft8">true. We break the execution and C is exactly our break point. In<br>this algorithm, the aforementioned pre-transmission also plays an<br>important role in that it enables us to stop all nodes at the same time<br>point precisely.</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:489"><nobr><span class="ft4">Coordinated break, however, does not work with arbitrary con-</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:475"><nobr><span class="ft8">ditions. Consider the case where the local conditions in Figure 4<br>are connected by injunction instead of conjunction. The break<br>point now should be at time A. Since we are not able to predict<br>which node will first satisfy its condition, it is not possible for us<br>to stop all the nodes together at time A unless we synchronize all<br>the nodes cycle by cycle, which would limit the scalability and the<br>performance significantly. For the same reason, we can not set up<br>multiple coordinated break points. We reiterate that these limita-</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">108</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft18{font-size:15px;line-height:20px;font-family:Times;color:#000000;}
	.ft19{font-size:11px;line-height:19px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="171008.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">tions are a direct result of our desire to scale DiSenS and to use<br>S</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:88"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:94"><nobr><span class="ft4">DB on large-scale simulated networks. That is, we have sacri-</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:81"><nobr><span class="ft8">ficed generality in favor of the performance gained through parallel<br>and distributed-memory implementation.</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:94"><nobr><span class="ft4">Although the generality of coordinated break is limited, it is still</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:81"><nobr><span class="ft8">useful in many situations. For example, for a data sink application,<br>we may want to determine why data is lost when a surge of data<br>flows to the sink node. In this case, we would break the execution<br>of the sink node based on the condition that its neighbor nodes have<br>sent data to it. Then we step-execute the program running on the<br>sink node to determine why the data is being lost. To implement<br>the condition of data sent on neighbor nodes we can simply use<br>source code instrumentation exporting a custom debugging point.<br>Thus this example also illustrates how the single-device debugging<br>features discussed in the previous section can be integrated with the<br>group debugging features.</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:81"><nobr><span class="ft2">6.</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:112"><nobr><span class="ft2">FAST TIME TRAVELING FOR<br>REPLAYABLE DEBUGGING</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:94"><nobr><span class="ft4">Even with the ability to perform coordinated breakpoints, the</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:81"><nobr><span class="ft8">normal debugging cycle of break/step/print i s still cumbersome when<br>the complete sensor network is debugged, especially if the size of<br>network is large. The high level nature of some systematic errors<br>requires a global view of the interactions among sensor nodes. An<br>alternative model for debugging sensor networks is:</span></nobr></DIV>
<DIV style="position:absolute;top:504;left:101"><nobr><span class="ft4">· A simulation is conducted with tracing. Trace log is analyzed</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:114"><nobr><span class="ft4">to pinpoint the anomaly.</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:101"><nobr><span class="ft4">· Quickly return to the point when the anomaly occurs to per-</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:114"><nobr><span class="ft4">form detailed source code level debugging.</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:81"><nobr><span class="ft8">To achieve this, we need to trace the simulation and restore the<br>state of network at any point in the trace. The debugging points<br>and virtual hardware based instrumentation discussed in section 4<br>can be used to trace the simulation in a way similar to [23]. In this<br>section, we present the S</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:213"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:220"><nobr><span class="ft4">DB's design of fast time traveling, which</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:81"><nobr><span class="ft4">enables the restoration of network states.</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:94"><nobr><span class="ft4">The basic mechanism required to implement time traveling is</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:81"><nobr><span class="ft8">a periodic checkpoint. A checkpoint of a simulation is a com-<br>plete copy of the state of the simulated sensor network. DiSenS is<br>an object oriented framework in representing device components.<br>When a checkpoint is initiated, the state saving function is invoked<br>first at the highest level "machine" object. Recursively, the sub-<br>components in the "machine" invoke their own state saving func-<br>tions. The saved state is comprised of registers, memories (SRAM,<br>EEPROM, etc.) and auxiliary state variables in each component.<br>It also includes some simulation related states. For example, we<br>need to save the event queue content, the received radio byte queue<br>in the radio model and the status of the power model, etc. The<br>complete binary of the state is saved into a timestamped file. The<br>result checkpoint file for DiSenS has a size of</span></nobr></DIV>
<DIV style="position:absolute;top:891;left:335"><nobr><span class="ft4">4948 bytes, mostly</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:81"><nobr><span class="ft4">comprised of SRAM (</span></nobr></DIV>
<DIV style="position:absolute;top:906;left:201"><nobr><span class="ft4">4KB) content.</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:94"><nobr><span class="ft4">Checkpoint for the on-board flash has to be handled differently.</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:81"><nobr><span class="ft4">Motes have a</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:158"><nobr><span class="ft4">512KB flash chip used for sensor data logging and</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:81"><nobr><span class="ft8">in-network programming. If flash content is saved as other com-<br>ponents, the checkpoint file will be as large as over half megabyte,<br>which is</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:130"><nobr><span class="ft4">128 times larger than the one without flash. So if flash is</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:81"><nobr><span class="ft8">also saved in a snapshot way, it is both extremely space and time<br>inefficient for a large scale sensor network. We solve this problem<br>by saving flash operations in a log file. Since most sensor network<br>applications use flash infrequently and flash content is updated in<br>page unit, the overhead of saving log is much smaller than saving</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">flash snapshots. Notice that the flash buffers have to be saved in the<br>snapshot checkpoint file.</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:489"><nobr><span class="ft4">Once a simulation is finished, we have a set of snapshot check-</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:475"><nobr><span class="ft8">points and a continuous flash log. Given an arbitrary time point T ,<br>to restore the state of system includes the following steps:</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:492"><nobr><span class="ft4">1. Restore: find the latest checkpoint CP that is prior to T and</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:509"><nobr><span class="ft4">load the snapshot checkpoint file;</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:492"><nobr><span class="ft4">2. Replay: if flash is used, replay the flash operation log up to</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:509"><nobr><span class="ft4">CP 's time;</span></nobr></DIV>
<DIV style="position:absolute;top:260;left:492"><nobr><span class="ft4">3. Re-run: start from CP , re-run the simulation until time T .</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:489"><nobr><span class="ft4">Checkpoints can also be initiated by methods other than the need</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:475"><nobr><span class="ft4">to take a periodic snapshot. For example, under S</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:762"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:769"><nobr><span class="ft4">DB a break</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:475"><nobr><span class="ft8">point can be associated with a checkpoint so that once the execu-<br>tion breaks, a checkpoint is generated. Thus, a developer can move<br>between the checkpoints to find the exact point when error occurs<br>during a replayed simulation. Checkpoint can also be initiated by a<br>debugging point, especially custom debugging points. By allowing<br>checkpoint to be triggered in conjunction with debugging points<br>S</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:483"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:489"><nobr><span class="ft4">DB integrates the replay and state-saving capabilities needed to</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:475"><nobr><span class="ft8">efficiently re-examine an error condition with the execution control<br>over state changes.</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:475"><nobr><span class="ft2">7.</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:507"><nobr><span class="ft2">EVALUATION</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:489"><nobr><span class="ft4">Since S</span></nobr></DIV>
<DIV style="position:absolute;top:494;left:530"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:536"><nobr><span class="ft4">DB is built upon DiSenS , its performance is highly de-</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:475"><nobr><span class="ft8">pendent on DiSenS itself. We begin this section by focusing on the<br>the performance of DiSenS simulation/emulation and then show the<br>overhead introduced by various S</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:655"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:661"><nobr><span class="ft4">DB debugging facilities. All ex-</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:475"><nobr><span class="ft8">periments described in this section are conducted using a 16-node<br>cluster in which each host has dual 3.2GHz Intel Xeon processors<br>with 1GB memory. The hosts are connected via switched gigabit<br>Ethernet. To make fair comparison, we use the same sensor net-<br>work application CntToRfm for evaluation.</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:475"><nobr><span class="ft2">7.1</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:515"><nobr><span class="ft2">Performance of DiSenS</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:489"><nobr><span class="ft4">For brevity, we present only the typical simulation speed of DiS-</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:475"><nobr><span class="ft8">enS on the cluster. A more thorough examination of scalability<br>and performance under different configurations can be found in pa-<br>per [25].</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:489"><nobr><span class="ft4">Figure 6 shows the performance achieved by DiSenS when sim-</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:475"><nobr><span class="ft4">ulating various numbers of nodes on the cluster in both</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:789"><nobr><span class="ft4">1-D and</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:475"><nobr><span class="ft8">2-D topologies. In the figure, the X axis shows the total number<br>of nodes simulated. The Y -axis is the normalized simulation speed<br>(compared to real time speed on hardware). For the</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:759"><nobr><span class="ft4">1-D topology,</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:475"><nobr><span class="ft4">all nodes are oriented on a straight line,</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:701"><nobr><span class="ft4">50 meters apart (assum-</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:475"><nobr><span class="ft4">ing the maximal radio range is</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:647"><nobr><span class="ft4">60 meters). For the 2-D topology,</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:475"><nobr><span class="ft8">nodes are arranged in a square grid. Again the distance between<br>two nodes is</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:549"><nobr><span class="ft4">50 meters. Both performance curves are very close</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:475"><nobr><span class="ft4">except in the middle part, where</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:658"><nobr><span class="ft4">2-D topology has slightly worse</span></nobr></DIV>
<DIV style="position:absolute;top:891;left:475"><nobr><span class="ft4">performance.</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:489"><nobr><span class="ft4">The simulation speed drops noticeably from</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:740"><nobr><span class="ft4">1 to 4 nodes but</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:475"><nobr><span class="ft4">then the speed curve keeps flat until</span></nobr></DIV>
<DIV style="position:absolute;top:919;left:668"><nobr><span class="ft4">128 nodes are simulated. After</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:475"><nobr><span class="ft8">that, the speed decreases linearly. The transition from flat to lin-<br>ear decrement is because there is not enough computing resources<br>within the cluster (</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:577"><nobr><span class="ft4">16 hosts).</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:489"><nobr><span class="ft4">To summarize the results from [25], DiSenS is able to simulate</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:475"><nobr><span class="ft8">one mote 9 times faster than real time speed, or 160 nodes at near<br>real time speed, or 2048 nodes at nearly a tenth of real time speed.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">109</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft20{font-size:7px;font-family:Times;color:#000000;}
	.ft21{font-size:6px;line-height:9px;font-family:Times;color:#000000;}
	.ft22{font-size:15px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="171009.png" alt="background image">
<DIV style="position:absolute;top:315;left:219"><nobr><span class="ft1">Total number of nodes</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:100"><nobr><span class="ft1">Normalized simulated clock speed</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:130"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:153"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:176"><nobr><span class="ft1">4</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:200"><nobr><span class="ft1">8</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:221"><nobr><span class="ft1">16</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:244"><nobr><span class="ft1">32</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:267"><nobr><span class="ft1">64</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:288"><nobr><span class="ft1">128</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:311"><nobr><span class="ft1">256</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:335"><nobr><span class="ft1">512 1024</span></nobr></DIV>
<DIV style="position:absolute;top:288;left:110"><nobr><span class="ft1">0.01</span></nobr></DIV>
<DIV style="position:absolute;top:227;left:110"><nobr><span class="ft1">0.10</span></nobr></DIV>
<DIV style="position:absolute;top:166;left:110"><nobr><span class="ft1">1.00</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:110"><nobr><span class="ft1">10.00</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:327"><nobr><span class="ft21">one dimension<br>two dimensions</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:81"><nobr><span class="ft4">Figure 6: DiSenS simulation performance in</span></nobr></DIV>
<DIV style="position:absolute;top:346;left:362"><nobr><span class="ft4">1-D and 2-D</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:81"><nobr><span class="ft8">topologies. X-axis is total number of nodes simulated. Y -axis<br>is normalized simulation speed (compared to execution speed<br>on real device).</span></nobr></DIV>
<DIV style="position:absolute;top:462;left:81"><nobr><span class="ft2">7.2</span></nobr></DIV>
<DIV style="position:absolute;top:462;left:121"><nobr><span class="ft2">Performance of a Break Condition on a</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:121"><nobr><span class="ft2">Single Device</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:94"><nobr><span class="ft4">We first evaluate the cost of monitoring debugging points in single-</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:81"><nobr><span class="ft8">device debugging. Not all the listed (in Table 1) debugging points<br>are evaluated since the overhead for some of them is application<br>dependent.</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:151"><nobr><span class="ft20">pc</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:187"><nobr><span class="ft20">memrd</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:233"><nobr><span class="ft20">memwr</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:282"><nobr><span class="ft20">power</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:330"><nobr><span class="ft20">timer</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:381"><nobr><span class="ft20">spi</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:236"><nobr><span class="ft20">Debugging Point</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:98"><nobr><span class="ft20">Relative Simulation Speed</span></nobr></DIV>
<DIV style="position:absolute;top:788;left:121"><nobr><span class="ft20">0.0</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:121"><nobr><span class="ft20">0.2</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:121"><nobr><span class="ft20">0.4</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:121"><nobr><span class="ft20">0.6</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:121"><nobr><span class="ft20">0.8</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:121"><nobr><span class="ft20">1.0</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:81"><nobr><span class="ft8">Figure 7: Relative simulation speed for various debugging<br>points. X-axis shows the name of debugging points. Y -axis<br>is the ratio to original simulation speed (without monitoring<br>debugging points).</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:94"><nobr><span class="ft4">Figure 7 gives the relative simulation speed of evaluating various</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:81"><nobr><span class="ft8">debugging points. For each one, we set a break condition using<br>the debugging point and run the simulation. The result shows that<br>pc has the largest overhead since the PC change occurs for every<br>instruction execution. Memory related debugging points has less<br>overhead. Power and event-based debugging points have the least<br>overhead since their states change infrequently.</span></nobr></DIV>
<DIV style="position:absolute;top:83;left:475"><nobr><span class="ft2">7.3</span></nobr></DIV>
<DIV style="position:absolute;top:83;left:515"><nobr><span class="ft2">Performance of a Coordinated Break</span></nobr></DIV>
<DIV style="position:absolute;top:99;left:516"><nobr><span class="ft2">Condition with Multiple Devices</span></nobr></DIV>
<DIV style="position:absolute;top:121;left:489"><nobr><span class="ft4">We evaluate the overhead of monitoring the coordinated break</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:475"><nobr><span class="ft4">condition in this subsection. We run our experiments with a</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:813"><nobr><span class="ft4">2-D</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:475"><nobr><span class="ft4">4 × 4 grid of sensor nodes, distributed in 4 groups (hosts).</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:515"><nobr><span class="ft20">0.85</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:515"><nobr><span class="ft20">0.90</span></nobr></DIV>
<DIV style="position:absolute;top:287;left:515"><nobr><span class="ft20">0.95</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:515"><nobr><span class="ft20">1.00</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:631"><nobr><span class="ft20">Involved Groups</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:492"><nobr><span class="ft20">Relative Simulation Speed</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:536"><nobr><span class="ft20">1</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:621"><nobr><span class="ft20">2</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:706"><nobr><span class="ft20">3</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:790"><nobr><span class="ft20">4</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:475"><nobr><span class="ft8">Figure 8: Relative simulation speed of monitoring a coordi-<br>nated break condition for multiple devices. X-axis is the num-<br>ber of groups (hosts) involved. Y -axis is the ratio to original<br>simulation speed (without condition monitoring).</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:489"><nobr><span class="ft4">Figure 8 shows the speed ratio between the simulation with mon-</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:475"><nobr><span class="ft4">itoring and without. When the group number is</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:744"><nobr><span class="ft4">1, only nodes in</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:475"><nobr><span class="ft4">one group are involved in the break condition. For group number</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:475"><nobr><span class="ft19">2, nodes in both groups are used in the break condition, and so on.<br>The speed ratio curve drops when the number of groups increases.</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:489"><nobr><span class="ft4">The overhead of monitoring coordinated break condition is mostly</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:475"><nobr><span class="ft8">due to the extra synchronization cost introduced by the new par-<br>tially ordered synchronization scheme. Obviously, when more nodes<br>(especially remote nodes) involved, the simulation overhead is higher.</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:475"><nobr><span class="ft2">7.4</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:516"><nobr><span class="ft22">Performance of Checkpointing for Time<br>Traveling</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:489"><nobr><span class="ft4">We evaluate the overhead of checkpointing in four configura-</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:475"><nobr><span class="ft4">tions:</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:509"><nobr><span class="ft4">1 × 1, 4 × 1, 16 × 1 and 4 × 4, where x × y means x nodes</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:475"><nobr><span class="ft8">per group and y groups. For each one, we vary the checkpoint in-<br>terval from</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:538"><nobr><span class="ft4">1/8 up to 4 virtual seconds.</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:489"><nobr><span class="ft4">Figure 9 shows the relative simulation speed when checkpoint-</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:475"><nobr><span class="ft8">ing the system periodically. Naturally, the overhead increases when<br>checkpointing more frequently. It is hard to distinguish the single-<br>group curves since their differences are so small. In general, check-<br>pointing in multi-group simulation seems to have larger overhead<br>than single-group. However, the checkpoint overhead is relatively<br>small. All four curves lie above</span></nobr></DIV>
<DIV style="position:absolute;top:906;left:650"><nobr><span class="ft4">96% of original simulation speed,</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:475"><nobr><span class="ft4">which translates to less than</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:634"><nobr><span class="ft4">4% of overhead. This result encour-</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:475"><nobr><span class="ft8">ages us to use time-traveling extensively in debugging. Developers<br>thus can always return to the last break point or a previous trace<br>point with little cost.</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:489"><nobr><span class="ft4">To summarize, we find that most of the new debugging facili-</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:475"><nobr><span class="ft4">ties we have introduced with S</span></nobr></DIV>
<DIV style="position:absolute;top:999;left:641"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:647"><nobr><span class="ft4">DB have small overhead (less than</span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:475"><nobr><span class="ft8">10%). As a result, we are able to debug sensor network applica-<br>tions using tools that operate at different levels of abstraction while<br>preserving the high performance and scalability provided by DiS-<br>enS.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">110</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft23{font-size:7px;line-height:11px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="171010.png" alt="background image">
<DIV style="position:absolute;top:263;left:121"><nobr><span class="ft20">0.96</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:121"><nobr><span class="ft20">0.98</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:121"><nobr><span class="ft20">1.00</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:121"><nobr><span class="ft20">1.02</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:121"><nobr><span class="ft20">1.04</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:179"><nobr><span class="ft20">Checkpoint Interval in Virtual Time (second)</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:98"><nobr><span class="ft20">Relative Simulation Speed</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:138"><nobr><span class="ft20">1/8</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:189"><nobr><span class="ft20">1/4</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:240"><nobr><span class="ft20">1/2</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:294"><nobr><span class="ft20">1</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:345"><nobr><span class="ft20">2</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:396"><nobr><span class="ft20">4</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:173"><nobr><span class="ft23">1x1<br>4x1<br>16x1<br>4x4</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:81"><nobr><span class="ft8">Figure 9: Relative simulation speed for checkpointing. X-axis<br>is the interval between two checkpoints (in terms of virtual<br>clock time of mote device). Y -axis is the ratio to original simu-<br>lation speed (without checkpointing).</span></nobr></DIV>
<DIV style="position:absolute;top:463;left:81"><nobr><span class="ft2">8.</span></nobr></DIV>
<DIV style="position:absolute;top:463;left:112"><nobr><span class="ft2">CONCLUSION</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:94"><nobr><span class="ft4">S</span></nobr></DIV>
<DIV style="position:absolute;top:481;left:102"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:108"><nobr><span class="ft4">DB is an efficient and effective sensor network debugger based</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:81"><nobr><span class="ft4">on DiSenS, a scalable distributed sensor network simulator. S</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:415"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:421"><nobr><span class="ft4">DB</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:81"><nobr><span class="ft8">makes four innovations to the conventional debugging scheme at<br>different levels of abstraction. For effective debugging of single<br>sensor devices, debugging points are introduced for the interroga-<br>tion of all interested subsystem states in a sensor device. To facil-<br>itate source level tracing and instrumentation, we extend the simu-<br>lated sensor device hardware with a set of virtual registers provid-<br>ing a way for the communication between simulator and simulated<br>program. At the multi-device level, we discuss the implementa-<br>tion of coordinated break condition in the distributed framework.<br>This new type of break condition enables coordinated parallel exe-<br>cution control of multiple sensor devices. A time traveling facility<br>is introduced for the network level debugging, used for rapid er-<br>ror site restoration when working with sensor network trace analy-<br>sis. Overall, these debugging features impose overhead of less than</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:81"><nobr><span class="ft19">10% (generally) to DiSenS, and thus enable efficient debugging of<br>large scale sensor networks.</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:94"><nobr><span class="ft4">S</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:102"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:108"><nobr><span class="ft4">DB is still an ongoing project that we think to make it a com-</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:81"><nobr><span class="ft8">prehensive debugging tool for sensor networks, there is still a lot of<br>work to do. The most imperative task is to design and implement a<br>graphic user interface for intuitive and productive debugging. We<br>are planning to build a plugin in the famous Eclipse [5] develop-<br>ment environment, which controls the debugging and simulation<br>functions in S</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:159"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:165"><nobr><span class="ft4">DB and DiSenS. We are also interested in incor-</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:81"><nobr><span class="ft8">porating the debugging needs according to people's experiences in<br>sensor network development and discovering new debugging tech-<br>niques, especially at the network level.</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:81"><nobr><span class="ft2">9.</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:112"><nobr><span class="ft2">REFERENCES</span></nobr></DIV>
<DIV style="position:absolute;top:956;left:87"><nobr><span class="ft5">[1] Atmel. AVR JTAG ICE User Guide. 2001. http://www.atmel.</span></nobr></DIV>
<DIV style="position:absolute;top:970;left:107"><nobr><span class="ft5">com/dyn/resources/prod documents/DOC2475.PDF</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:421"><nobr><span class="ft5">.</span></nobr></DIV>
<DIV style="position:absolute;top:984;left:87"><nobr><span class="ft5">[2] Atmel's AVR JTAG ICE. http://www.atmel.com/dyn/</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:107"><nobr><span class="ft5">products/tools card.asp?tool id=2737</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:360"><nobr><span class="ft5">.</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:87"><nobr><span class="ft5">[3] C. Buschmann, D. Pfisterer, S. Fischer, S. P. Fekete, and A. Kr¨oller.</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:107"><nobr><span class="ft10">SpyGlass: taking a closer look at sensor networks. In the Proceedings<br>of the 2nd international conference on Embedded networked sensor<br>systems, pages 301­302, 2004. New York, NY, USA.</span></nobr></DIV>
<DIV style="position:absolute;top:1068;left:87"><nobr><span class="ft5">[4] A. Chlipala, J. W. Hui, and G. Tolle. Deluge: Dissemination</span></nobr></DIV>
<DIV style="position:absolute;top:87;left:502"><nobr><span class="ft10">Protocols for Network Reprogramming at Scale. Fall 2003 UC<br>Berkeley class project paper, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:116;left:481"><nobr><span class="ft5">[5] Eclipse: an extensible development platform and application</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:502"><nobr><span class="ft5">frameworks for building software. http://www.eclipse.org.</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:481"><nobr><span class="ft5">[6] L. Girod, J. Elson, A. Cerpa, T. Stathopoulos, N. Ramanathan, and</span></nobr></DIV>
<DIV style="position:absolute;top:158;left:502"><nobr><span class="ft10">D. Estrin. EmStar: a Software Environment for Developing and<br>Deploying Wireless Sensor Networks. USENIX Technical<br>Conference, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:481"><nobr><span class="ft5">[7] B. Hendrickson and R. Leland. The Chaco User's Guide: Version</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:502"><nobr><span class="ft5">2.0. Technical Report SAND94­2692, Sandia National Lab, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:481"><nobr><span class="ft5">[8] J. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and K. Pister.</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:502"><nobr><span class="ft10">System architecture directions for network sensors. International<br>Conference on Architectural Support for Programming Languages<br>and Operating Systems, Oct. 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:481"><nobr><span class="ft5">[9] iPAQ devices. http://welcome.hp.com/country/us/en/</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:502"><nobr><span class="ft5">prodserv/handheld.html</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:660"><nobr><span class="ft5">.</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:475"><nobr><span class="ft5">[10] Boundary-Scan (JTAG) test and in-system programming solutions</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:502"><nobr><span class="ft5">(IEEE 1149.1). http://www.jtag.com/main.php.</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:475"><nobr><span class="ft5">[11] S. T. King, G. W. Dunlap, and P. M. Chen. Debugging Operating</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:502"><nobr><span class="ft10">Systems with Time-Traveling Virtual Machines. In the Proceedings<br>of USENIX Annual Technical Conference 2005, Apr. 2005. Anaheim,<br>CA.</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:475"><nobr><span class="ft5">[12] O. Landsiedel, K. Wehrle, and S. Gtz. Accurate Prediction of Power</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:502"><nobr><span class="ft10">Consumption in Sensor Networks. In Proceedings of The Second<br>IEEE Workshop on Embedded Networked Sensors (EmNetS-II), May<br>2005. Sydney, Australia.</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:475"><nobr><span class="ft5">[13] P. Levis, N. Lee, M. Welsh, and D. Culler. TOSSIM: Accurate and</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:502"><nobr><span class="ft10">Scalable Simulation of Entire TinyOS Applications. ACM<br>Conference on Embedded Networked Sensor Systems, Nov. 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:475"><nobr><span class="ft5">[14] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. The</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:502"><nobr><span class="ft10">Design of an Acquisitional Query Processor for Sensor Networks. In<br>Proceedings of SIGMOD 2003, June 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:475"><nobr><span class="ft5">[15] Mote hardware platform.</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:502"><nobr><span class="ft5">http://www.tinyos.net/scoop/special/hardware</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:819"><nobr><span class="ft5">.</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:475"><nobr><span class="ft5">[16] MOTE-VIEW Monitoring Software. http://www.xbow.com/</span></nobr></DIV>
<DIV style="position:absolute;top:577;left:502"><nobr><span class="ft5">Products/productsdetails.aspx?sid=88</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:761"><nobr><span class="ft5">.</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:475"><nobr><span class="ft5">[17] J. Polley, D. Blazakis, J. McGee, D. Rusk, and J. S. Baras. ATEMU:</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:502"><nobr><span class="ft10">A Fine-grained Sensor Network Simulator. IEEE Communications<br>Society Conference on Sensor and Ad Hoc Communications and<br>Networks, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:475"><nobr><span class="ft5">[18] N. Ramanathan, K. Chang, R. Kapur, L. Girod, E. Kohler, and</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:502"><nobr><span class="ft10">D. Estrin. Sympathy for the Sensor Network Debugger. In the<br>Proceedings of 3rd ACM Conference on Embedded Networked<br>Sensor Systems (SenSys '05), Nov. 2005. San Diego, California.</span></nobr></DIV>
<DIV style="position:absolute;top:702;left:475"><nobr><span class="ft5">[19] N. Ramanathan, E. Kohler, and D. Estrin. Towards a debugging</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:502"><nobr><span class="ft10">system for sensor networks. International Journal of Network<br>Management, 15(4):223­234, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:475"><nobr><span class="ft5">[20] S. M. Srinivasan, S. Kandula, C. R. Andrews, and Y. Zhou.</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:502"><nobr><span class="ft10">Flashback: A Lightweight Extension for Rollback and Deterministic<br>Replay for Software Debugging. In the Proceedings of USENIX<br>Annual Technical Conference 2004, June 2004. Boston, MA.</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:475"><nobr><span class="ft5">[21] Stargate: a platform X project.</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:502"><nobr><span class="ft5">http://platformx.sourceforge.net/</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:739"><nobr><span class="ft5">.</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:475"><nobr><span class="ft5">[22] Surge Network Viewer. http://xbow.com/Products/</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:502"><nobr><span class="ft5">productsdetails.aspx?sid=86</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:696"><nobr><span class="ft5">.</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:475"><nobr><span class="ft5">[23] B. Titzer and J. Palsberg. Nonintrusive Precision Instrumentation of</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:502"><nobr><span class="ft10">Microcontroller Software. In the Proceedings of ACM<br>SIGPLAN/SIGBED 2005 Conference on Languages, Compilers, and<br>Tools for Embedded Systems (LCTES'05), June 2005. Chicago,<br>Illinois.</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:475"><nobr><span class="ft5">[24] Y. Wen, S. Gurun, N. Chohan, R. Wolski, and C. Krintz. SimGate:</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:502"><nobr><span class="ft10">Full-System, Cycle-Close Simulation of the Stargate Sensor Network<br>Intermediate Node. In Proceedings of International Conference on<br>Embedded Computer Systems: Architectures, MOdeling, and<br>Simulation (IC-SAMOS), 2006. Samos, Greece.</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:475"><nobr><span class="ft5">[25] Y. Wen, R. Wolski, and G. Moore. DiSenS: Scalable Distributed</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:502"><nobr><span class="ft10">Sensor Network Simulation. Technical Report CS2005-30,<br>University of California, Santa Barbara, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">111</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
