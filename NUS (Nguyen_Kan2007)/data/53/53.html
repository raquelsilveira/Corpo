<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>p202-scholer.dvi</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2002-06-20T11:57:54+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Times;color:#000000;}
	.ft1{font-size:15px;font-family:Times;color:#000000;}
	.ft2{font-size:12px;font-family:Times;color:#000000;}
	.ft3{font-size:11px;font-family:Times;color:#000000;}
	.ft4{font-size:15px;font-family:Times;color:#000000;}
	.ft5{font-size:9px;font-family:Times;color:#000000;}
	.ft6{font-size:9px;font-family:Times;color:#000000;}
	.ft7{font-size:6px;font-family:Times;color:#000000;}
	.ft8{font-size:16px;font-family:Times;color:#000000;}
	.ft9{font-size:11px;font-family:Times;color:#000000;}
	.ft10{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft11{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="53001.png" alt="background image">
<DIV style="position:absolute;top:109;left:146"><nobr><span class="ft0"><b>Compression of Inverted Indexes For Fast Query</b></span></nobr></DIV>
<DIV style="position:absolute;top:139;left:390"><nobr><span class="ft0"><b>Evaluation</b></span></nobr></DIV>
<DIV style="position:absolute;top:207;left:206"><nobr><span class="ft1">Falk Scholer</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:328"><nobr><span class="ft1">Hugh E. Williams</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:487"><nobr><span class="ft1">John Yiannis</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:612"><nobr><span class="ft1">Justin Zobel</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:269"><nobr><span class="ft2">School of Computer Science and Information Technology</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:346"><nobr><span class="ft2">RMIT University, GPO Box 2476V</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:366"><nobr><span class="ft2">Melbourne, Australia, 3001.</span></nobr></DIV>
<DIV style="position:absolute;top:276;left:330"><nobr><span class="ft3">{fscholer,hugh,jyiannis,jz}@cs.rmit.edu.au</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:81"><nobr><span class="ft4"><b>ABSTRACT</b></span></nobr></DIV>
<DIV style="position:absolute;top:355;left:81"><nobr><span class="ft10">Compression reduces both the size of indexes and the time<br>needed to evaluate queries. In this paper, we revisit the<br>compression of inverted lists of document postings that store<br>the position and frequency of indexed terms, considering two<br>approaches to improving retrieval efficiency:better imple-<br>mentation and better choice of integer compression schemes.<br>First, we propose several simple optimisations to well-known<br>integer compression schemes, and show experimentally that<br>these lead to significant reductions in time. Second, we ex-<br>plore the impact of choice of compression scheme on retrieval<br>efficiency.</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:94"><nobr><span class="ft3">In experiments on large collections of data, we show two</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:81"><nobr><span class="ft10">surprising results:use of simple byte-aligned codes halves<br>the query evaluation time compared to the most compact<br>Golomb-Rice bitwise compression schemes; and, even when<br>an index fits entirely in memory, byte-aligned codes result<br>in faster query evaluation than does an uncompressed index,<br>emphasising that the cost of transferring data from memory<br>to the CPU cache is less for an appropriately compressed in-<br>dex than for an uncompressed index. Moreover, byte-aligned<br>schemes have only a modest space overhead:the most com-<br>pact schemes result in indexes that are around 10% of the<br>size of the collection, while a byte-aligned scheme is around<br>13%. We conclude that fast byte-aligned codes should be<br>used to store integers in inverted lists.</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:81"><nobr><span class="ft4"><b>Categories and Subject Descriptors</b></span></nobr></DIV>
<DIV style="position:absolute;top:798;left:81"><nobr><span class="ft10">H.3.4 [Information Storage and Retrieval]:Systems<br>and Software Performance evaluation (efficiency and effec-<br>tiveness); E.4 [Data]:Coding and Information Theory Data<br>compaction and compression</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:81"><nobr><span class="ft4"><b>General Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:911;left:81"><nobr><span class="ft3">Performance, Algorithms, Design</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:81"><nobr><span class="ft11">Permission to make digital or hard copies of all or part of this work for<br>personal or classroom use is granted without fee provided that copies are<br>not made or distributed for profit or commercial advantage and that copies<br>bear this notice and the full citation on the first page. To copy otherwise, to<br>republish, to post on servers or to redistribute to lists, requires prior specific<br>permission and/or a fee.<br><i>SIGIR'02, </i>August 11-15, 2002, Tampere, Finland.<br>Copyright 2002 ACM 1-58113-561-0/02/0008 ...</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:316"><nobr><span class="ft3">$</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:323"><nobr><span class="ft5">5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:475"><nobr><span class="ft4"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:355;left:475"><nobr><span class="ft10">Inverted indexes, retrieval efficiency, index compression, in-<br>teger coding</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:475"><nobr><span class="ft4"><b>1.</b></span></nobr></DIV>
<DIV style="position:absolute;top:406;left:506"><nobr><span class="ft4"><b>INTRODUCTION</b></span></nobr></DIV>
<DIV style="position:absolute;top:429;left:489"><nobr><span class="ft3">Search engines have demanding performance requirements.</span></nobr></DIV>
<DIV style="position:absolute;top:444;left:475"><nobr><span class="ft10">Users expect fast answers to queries, many queries must be<br>processed per second, and the quantity of data that must<br>be searched in response to each query is staggering. The<br>demands continue to grow:the Google search engine, for<br>example, indexed around one billion documents a year ago<br>and now manages more than double that figure</span></nobr></DIV>
<DIV style="position:absolute;top:518;left:758"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:764"><nobr><span class="ft3">. Moreover,</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:475"><nobr><span class="ft10">the increasing availability and affordability of large storage<br>devices suggests that the amount of data stored online will<br>continue to grow.</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:489"><nobr><span class="ft3">Inverted indexes are used to evaluate queries in all prac-</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:475"><nobr><span class="ft10">tical search engines [14]. Compression of these indexes has<br>three major benefits for performance. First, a compressed<br>index requires less storage space. Second, compressed data<br>makes better use of the available communication bandwidth;<br>more information can be transfered per second than when<br>the data is uncompressed. For fast decompression schemes,<br>the total time cost of transfering compressed data and sub-<br>sequently decompressing is potentially much less than the<br>cost of transferring uncompressed data. Third, compression<br>increases the likelihood that the part of the index required<br>to evaluate a query is already cached in memory, thus en-<br>tirely avoiding a disk access. Thus index compression can<br>reduce costs in retrieval systems.</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:489"><nobr><span class="ft3">We have found that an uncompressed inverted index that</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:475"><nobr><span class="ft10">stores the location of the indexed words in web documents<br>typically consumes more than 30% of the space required<br>to store the uncompressed collection of documents. (Web<br>documents often include a great deal of information that is<br>not indexed, such as HTML tags; in the TREC web data,<br>which we use in our experiments, on average around half<br>of each document is indexable text.) When the index is<br>compressed, the index size is reduced to between 10%­15%<br>of that required to store the uncompressed collection; this<br>size includes document numbers, in-document frequencies,<br>and word positions within documents. If the index is too<br>large to fit entirely within main memory, then querying the<br>uncompressed index is slower:as we show later, it is up to<br>twice as slow as the fastest compressed scheme.</span></nobr></DIV>
<DIV style="position:absolute;top:1040;left:489"><nobr><span class="ft3">In this paper, we revisit compression schemes for the in-</span></nobr></DIV>
<DIV style="position:absolute;top:1062;left:476"><nobr><span class="ft7">1</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:482"><nobr><span class="ft3">See http://www.google.com/</span></nobr></DIV>
<DIV style="position:absolute;top:1122;left:449"><nobr><span class="ft9">222</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft12{font-size:5px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="53002.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft10">verted list component of inverted indexes. We also propose<br>a new method for decoding lists. There have been a great<br>many reports of experiments on compression of indexes with<br>bitwise compression schemes [6, 8, 12, 14, 15], which use an<br>integral number of bits to represent each integer, usually<br>with no restriction on the alignment of the integers to byte<br>or machine-word boundaries. We consider several aspects<br>of these schemes:how to decode bitwise representations of<br>integers efficiently; how to minimise the operations required<br>for the most compact scheme, Golomb coding; and the rela-<br>tive performance of Elias gamma coding, Elias delta coding,<br>Golomb coding, and Rice coding for storing indexes.</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:94"><nobr><span class="ft3">We question whether bitwise compression schemes are the</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:81"><nobr><span class="ft10">best choice for storing lists of integers. As an alternative,<br>we consider bytewise integer compression schemes, which<br>require that each integer is stored in an integral number of<br>blocks, where each block is eight bits. The length of each<br>stored integer can therefore be measured in an exact number<br>of bytes. An additional restriction is to require that these<br>eight-bit blocks must align to machine-word or byte bound-<br>aries.</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:124"><nobr><span class="ft3">We propose and experimentally investigate several</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:81"><nobr><span class="ft3">variations of bytewise schemes.</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:94"><nobr><span class="ft3">We investigate the performance of different index com-</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:81"><nobr><span class="ft10">pression schemes through experiments on large query sets<br>and collections of Web documents. We report two surpris-<br>ing results.</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:101"><nobr><span class="ft3">· For a 20 gigabyte collection, where the index is several</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:114"><nobr><span class="ft10">times larger than main memory, optimised bytewise<br>schemes more than halve the average decoding time<br>compared to the fastest bitwise approach.</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:101"><nobr><span class="ft3">· For a much smaller collection, where the index fits in</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:114"><nobr><span class="ft10">main memory, a bytewise compressed index can still<br>be processed faster than an uncompressed index.</span></nobr></DIV>
<DIV style="position:absolute;top:630;left:81"><nobr><span class="ft10">These results show that effective use of communication band-<br>widths is important for not only disk-to-memory transfers<br>but also memory-to-cache transfers. The only disadvantage<br>of bytewise compressed indexes is that they are up to 30%<br>larger than bitwise compressed indexes; the smallest bitwise<br>index is around 10% of the uncompressed collection size,<br>while the bytewise index is around 13%.</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:81"><nobr><span class="ft4"><b>2.</b></span></nobr></DIV>
<DIV style="position:absolute;top:756;left:112"><nobr><span class="ft4"><b>INVERTED INDEXES</b></span></nobr></DIV>
<DIV style="position:absolute;top:779;left:94"><nobr><span class="ft3">An inverted index consists of two major components:the</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:81"><nobr><span class="ft10">vocabulary of terms--for example the words--from the col-<br>lection, and inverted lists, which are vectors that contain<br>information about the occurrence of the terms [14].</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:94"><nobr><span class="ft3">In a basic implementation, for each term t there is an in-</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:81"><nobr><span class="ft3">verted list that contains postings &lt; f</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:312"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:327"><nobr><span class="ft3">, d &gt; where f</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:410"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:430"><nobr><span class="ft3">is</span></nobr></DIV>
<DIV style="position:absolute;top:873;left:81"><nobr><span class="ft10">the frequency f of term t in the ordinal document d. One<br>posting is stored in the list for each document that contains<br>the term t. Inverted lists of this form--along with additional<br>statistics such as the document length l</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:322"><nobr><span class="ft7">d</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:328"><nobr><span class="ft3">, and f</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:370"><nobr><span class="ft7">t</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:376"><nobr><span class="ft3">, the num-</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:81"><nobr><span class="ft10">ber of documents that contain the term t--are sufficient to<br>support ranked and Boolean query modes.</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:94"><nobr><span class="ft3">To support phrase querying or proximity querying, addi-</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:81"><nobr><span class="ft10">tional information must be kept in the inverted lists. Thus<br>inverted list postings should be of the form</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:114"><nobr><span class="ft3">&lt; f</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:136"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:150"><nobr><span class="ft3">, d, [o</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:180"><nobr><span class="ft7">0,d,t</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:205"><nobr><span class="ft3">. . . o</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:230"><nobr><span class="ft7">f</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:236"><nobr><span class="ft12">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:250"><nobr><span class="ft7">,d,t</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:267"><nobr><span class="ft3">] &gt;</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft10">The additional information is the list of offsets o; one off-<br>set is stored for each of the f</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:268"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:289"><nobr><span class="ft3">occurrences of term t in</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft10">document d. Postings in inverted lists are usually ordered<br>by increasing d, and the offsets likewise ordered within the<br>postings by increasing o. This has the benefit that differ-<br>ences between values--rather than the raw values--can be<br>stored, improving the compressibility of the lists.</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:489"><nobr><span class="ft3">Other arrangements of the postings in lists are useful when</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:475"><nobr><span class="ft10">lists are not necessarily completely processed in response to<br>a query. For example, in frequency-sorted indexes [9, 10]<br>postings are ordered by f</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:628"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:642"><nobr><span class="ft3">, and in impact-ordered indexes</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:475"><nobr><span class="ft10">the postings are ordered by quantised weights [1]. These ap-<br>proaches also rely on compression to help achieve efficiency<br>gains, and the improvements to compression performance<br>we describe in this paper are as applicable to these methods<br>as they are to the simple index representations we use as a<br>testbed for our compression methods.</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:489"><nobr><span class="ft3">Consider an example inverted list with offsets for the term</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:475"><nobr><span class="ft3">"Matthew":</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:509"><nobr><span class="ft3">&lt; 3, 7, [6, 51, 117] &gt;&lt; 1, 44, [12] &gt;&lt; 2, 117, [14, 1077] &gt;</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:475"><nobr><span class="ft10">In this index, the terms are words, the offsets are word po-<br>sitions within the documents, and the lists are ordered by d.<br>This inverted list states that the term "Matthew" occurs 3<br>times in document 7, at offsets 6, 51, and 117. It also occurs<br>once in document 44 at offset 12, and twice in document 117,<br>at offsets 14 and 1077.</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:489"><nobr><span class="ft3">Ranked queries can be answered using the inverted index</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:475"><nobr><span class="ft10">as follows. First, the terms in the user's query are located<br>in the inverted index vocabulary. Second, the correspond-<br>ing inverted lists for each term are retrieved from disk, and<br>then processed by decreasing f</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:662"><nobr><span class="ft7">t</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:667"><nobr><span class="ft3">. Third, for each posting in</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:475"><nobr><span class="ft3">each inverted list, an accumulator weight A</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:747"><nobr><span class="ft7">d</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:759"><nobr><span class="ft3">is increased;</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:475"><nobr><span class="ft10">the magnitude of the increase is dependent on the similarity<br>measure used, and can consider the weight w</span></nobr></DIV>
<DIV style="position:absolute;top:603;left:758"><nobr><span class="ft7">q,t</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:777"><nobr><span class="ft3">of term t</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:475"><nobr><span class="ft3">in the query q, the weight w</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:653"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:672"><nobr><span class="ft3">of the term t in the docu-</span></nobr></DIV>
<DIV style="position:absolute;top:630;left:475"><nobr><span class="ft10">ment d, and other factors. Fourth, after processing part [1,<br>6] or all of the lists, the accumulator scores are partially<br>sorted to identify the most similar documents. Last, for a<br>typical search engine, document summaries of the top ten<br>documents are generated or retrieved and shown to the user.<br>The offsets stored in each inverted list posting are not used<br>in ranked query processing.</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:489"><nobr><span class="ft3">Phrase queries require offsets and that a given sequence of</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:475"><nobr><span class="ft10">words be contiguous in a matching document. For example,<br>consider a combined ranked and phrase query:</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:509"><nobr><span class="ft3">"Matthew Richardson" Richmond</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:475"><nobr><span class="ft10">To evaluate such a query, the same first two steps as for<br>ranked querying are applied. Then, instead of accumulating<br>weights, it is necessary to construct a temporary inverted list<br>for the phrase, by fetching the inverted list of each of the<br>individual terms and combining them. If the inverted list for<br>"Matthew" is as above and the inverted list for "Richard-<br>son" is</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:509"><nobr><span class="ft3">&lt; 1, 7, [52] &gt; &lt; 2, 12, [1, 4] &gt; &lt; 1, 44, [83] &gt;</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:475"><nobr><span class="ft10">then both words occur in document 7 and as an ordered<br>pair. Only the word "Richardson" is in document 12, both<br>words occur in document 44 but not as a pair, and only<br>"Matthew" occurs in document 117. The list for "Matthew<br>Richardson" is therefore</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:509"><nobr><span class="ft3">&lt; 1, 7, [51] &gt;</span></nobr></DIV>
<DIV style="position:absolute;top:1122;left:449"><nobr><span class="ft9">223</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="53003.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft10">After this, the ranking process is continued from the third<br>step, where the list for the term "Richmond" and the newly<br>created list are used to adjust accumulator weights. Phrase<br>queries can involve more than two words.</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:81"><nobr><span class="ft4"><b>3.</b></span></nobr></DIV>
<DIV style="position:absolute;top:165;left:112"><nobr><span class="ft4"><b>COMPRESSING INVERTED INDEXES</b></span></nobr></DIV>
<DIV style="position:absolute;top:188;left:94"><nobr><span class="ft3">Special-purpose integer compression schemes offer both</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:81"><nobr><span class="ft10">fast decoding and compact storage of inverted lists [13, 14].<br>In this section, we consider how inverted lists are compressed<br>and stored on disk. We limit our discussions here to the<br>special-purpose integer compression techniques that have<br>previously been shown to be suitable for index compression,<br>and focus on their use in increasing the speed of retrieval<br>systems.</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:94"><nobr><span class="ft3">Without compression, the time cost of retrieving inverted</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:81"><nobr><span class="ft10">lists is the sum of the time taken to seek for and then retrieve<br>the inverted lists from disk into memory, and the time taken<br>to transfer the lists from memory into the CPU cache be-<br>fore they are processed. The speed of access to compressed<br>inverted lists is determined by two factors:first, the com-<br>putational requirements for decoding the compressed data<br>and, second, the time required to seek for and retrieve the<br>compressed data from disk and to transfer it to the CPU<br>cache before it is decoded. For a compression scheme to<br>allow faster access to inverted lists, the total retrieval time<br>and CPU processing costs should be less than the retrieval<br>time of the uncompressed representation. However, a third<br>factor makes compression attractive even if CPU process-<br>ing costs exceed the saving in disk transfer time:compress-<br>ing inverted lists increases the number of lists that can be<br>cached in memory between queries, so that in the context of<br>a stream of queries use of compression reduces the number<br>of disk accesses. It is therefore important that a compres-<br>sion scheme be efficient in both decompression CPU costs<br>and space requirements.</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:94"><nobr><span class="ft3">There are two general classes of compression scheme that</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:81"><nobr><span class="ft3">are appropriate for storing inverted lists.</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:349"><nobr><span class="ft3">Variable-bit or</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:81"><nobr><span class="ft10">bitwise schemes store integers in an integral number of bits.<br>Well-known bitwise schemes include Elias gamma and delta<br>coding [3] and Golomb-Rice coding [4]. Bytewise schemes<br>store an integer in an integral number of blocks, where a<br>block is eight bits in size; we distinguish between blocks and<br>bytes here, since there is no implied restriction that a block<br>must align to a physical byte-boundary. A simple bytewise<br>scheme is variable-byte coding [2, 13]; uncompressed inte-<br>gers are also stored in an integral number of blocks, but we<br>do not define them as bytewise schemes since, on most ar-<br>chitectures, an integer has a fixed-size representation of four<br>bytes. In detail, these schemes are as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:94"><nobr><span class="ft3">Elias coding [3] is a non-parameterised bitwise method of</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:81"><nobr><span class="ft10">coding integers. (Non-parameterised methods use static or<br>fixed codes to store integers.) The Elias gamma code repre-<br>sents a positive integer k by 1 + log</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:306"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:314"><nobr><span class="ft3">k stored as a unary</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:81"><nobr><span class="ft10">code, followed by the binary representation of k without its<br>most significant bit. Using Elias gamma coding, small inte-<br>gers are compactly represented; in particular, the integer 1<br>is represented as a single 1-bit. Gamma coding is relatively<br>inefficient for storing integers larger than 15 [13].</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:94"><nobr><span class="ft3">Elias delta codes are suited to coding larger integers, but</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft10">are inefficient for small values. For an integer k, a delta<br>code stores the gamma code representation of 1 + log</span></nobr></DIV>
<DIV style="position:absolute;top:1040;left:413"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:422"><nobr><span class="ft3">k ,</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft10">and then the binary representation of k without its most<br>significant bit.</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:489"><nobr><span class="ft3">Golomb-Rice bitwise coding [4] has been shown to offer</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:475"><nobr><span class="ft10">more compact storage of integers and faster retrieval than<br>the Elias codes [13]; indeed, it is bitwise optimal under the<br>assumption that the set of documents with a given term is<br>random. The codes are adapted to per-term likelihoods via<br>a parameter that is used to determine the code emitted for<br>an integer. In many cases, this parameter must be stored<br>separately using, for example, an Elias code. For coding of<br>inverted lists, a single parameter is used for all document<br>numbers in a postings list, but each posting requires a pa-<br>rameter for its offsets. The parameters can be calculated as<br>the lists are decoded using statistics stored in memory and<br>in the lists, as we discuss later.</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:489"><nobr><span class="ft3">Coding of an integer k using Golomb codes with respect</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:475"><nobr><span class="ft10">to a parameter b is as follows. The code that is emitted is in<br>two parts:first, the unary code of a quotient q is emitted,<br>where q = (k - 1)/b + 1; second, a binary code is emitted<br>for the remainder r, where r = k - q × b - 1. The number<br>of bits required to store the remainder r is either log</span></nobr></DIV>
<DIV style="position:absolute;top:373;left:797"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:805"><nobr><span class="ft3">b or</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:481"><nobr><span class="ft3">log</span></nobr></DIV>
<DIV style="position:absolute;top:389;left:499"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:508"><nobr><span class="ft3">b . To retrieve the remainder, the value of the "toggle</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:475"><nobr><span class="ft3">point" t = 1 ((log</span></nobr></DIV>
<DIV style="position:absolute;top:404;left:586"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:594"><nobr><span class="ft3">k)+1))-b is required, where</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:781"><nobr><span class="ft3">indicates</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:475"><nobr><span class="ft3">a left-shift operation. After retrieving</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:725"><nobr><span class="ft3">log</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:742"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:751"><nobr><span class="ft3">b bits of the</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:475"><nobr><span class="ft10">remainder r, the remainder is compared to t. If r &gt; t, then<br>one additional bit of the remainder must be retrieved. It<br>is generally thought that caching calculated values of log</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:819"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:463;left:828"><nobr><span class="ft3">b</span></nobr></DIV>
<DIV style="position:absolute;top:479;left:475"><nobr><span class="ft10">is necessary for fast decoding, with a main-memory penalty<br>of having to store the values. However, as we show later,<br>when the standard log library function is replaced with a<br>fast bit-shifting version, caching is unnecessary.</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:489"><nobr><span class="ft3">Rice coding is a variant of Golomb coding where the value</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:475"><nobr><span class="ft10">of b is restricted to be a power of 2. The advantage of this<br>restriction is that there is no "toggle point" calculation re-<br>quired, that is, the remainder is always stored in exactly</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:481"><nobr><span class="ft3">log</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:499"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:508"><nobr><span class="ft3">b bits. The disadvantage of this scheme is that the</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:475"><nobr><span class="ft10">choice of value for b is restricted and, therefore, the com-<br>pression is slightly less effective than that of Golomb coding.</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:489"><nobr><span class="ft3">For compression of inverted lists, a value of b is required.</span></nobr></DIV>
<DIV style="position:absolute;top:667;left:475"><nobr><span class="ft10">Witten et al. [14] report that for cases where the probability<br>of any particular integer value occurring is small--which is<br>the usual case for document numbers d and offsets o--then<br>b can be calculated as:</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:509"><nobr><span class="ft3">b = 0.69 × mean(k)</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:475"><nobr><span class="ft10">For each inverted list, the mean value of document numbers<br>d can be approximated as k = N/f</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:685"><nobr><span class="ft7">t</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:695"><nobr><span class="ft3">where N is the number</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:475"><nobr><span class="ft3">of documents in the collection and f</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:692"><nobr><span class="ft7">t</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:701"><nobr><span class="ft3">is the number of post-</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:475"><nobr><span class="ft10">ings in the inverted list for term t [14]. This approach can<br>also be extended to offsets:the mean value of offsets o for<br>an inverted list posting can be approximated as k = l</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:800"><nobr><span class="ft7">d</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:806"><nobr><span class="ft3">/f</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:820"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:475"><nobr><span class="ft3">where l</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:519"><nobr><span class="ft7">d</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:530"><nobr><span class="ft3">is the length of document d and f</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:732"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:751"><nobr><span class="ft3">is the number</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:475"><nobr><span class="ft10">of offsets of term t within that document. As the statistics<br>N, f</span></nobr></DIV>
<DIV style="position:absolute;top:899;left:504"><nobr><span class="ft7">t</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:509"><nobr><span class="ft3">, and l are often available in memory, or in a simple</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:475"><nobr><span class="ft10">auxiliary structure on disk, storage of b values is not required<br>for decoding; approximate values of l can be stored in mem-<br>ory for compactness [7], but use of approximate values has<br>little effect on compression effectiveness as it leads to only<br>small relative errors in computation of b.</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:489"><nobr><span class="ft3">In bytewise coding an integer is stored in an integral num-</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:475"><nobr><span class="ft10">ber of eight-bit blocks. For variable-byte codes, seven bits<br>in each block are used to store a binary representation of<br>the integer k. The remaining bit is used to indicate whether<br>the current block is the final block for k, or whether an ad-<br>ditional block follows. Consider an example of an integer k</span></nobr></DIV>
<DIV style="position:absolute;top:1122;left:449"><nobr><span class="ft9">224</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft13{font-size:14px;font-family:Times;color:#000000;}
	.ft14{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="53004.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft3">in the range of 2</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:184"><nobr><span class="ft7">7</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:195"><nobr><span class="ft3">= 128 to 2</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:261"><nobr><span class="ft7">14</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:278"><nobr><span class="ft3">= 16, 384. Two blocks are</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:81"><nobr><span class="ft10">required to represent this integer:the first block contains<br>the seven least-significant bits of the integer and the eighth<br>bit is used to flag that another block follows; the second<br>block contains the remaining most-significant bits and the<br>eighth bit flags that no further blocks follow. We use the<br>convention that the flag bit is set to 1 in the final block and<br>0 otherwise.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:94"><nobr><span class="ft3">Compressing an inverted index, then, involves choosing</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:81"><nobr><span class="ft10">compression schemes for the three kinds of data that are<br>stored in a posting:a document number d, an in-document<br>frequency f</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:149"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:163"><nobr><span class="ft3">, and a sequence of offsets o. A standard choice</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:81"><nobr><span class="ft10">is to use Golomb codes for document numbers, gamma codes<br>for frequencies, and delta codes for offsets [14]. (We explore<br>the properties of this choice later.) In this paper, we describe<br>such a choice as a GolD-GamF-DelO index.</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:81"><nobr><span class="ft4"><b>3.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:348;left:121"><nobr><span class="ft4"><b>Fast Decoding</b></span></nobr></DIV>
<DIV style="position:absolute;top:370;left:94"><nobr><span class="ft3">We experiment with compression of inverted lists of post-</span></nobr></DIV>
<DIV style="position:absolute;top:386;left:81"><nobr><span class="ft3">ings that contain frequencies f</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:259"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:386;left:273"><nobr><span class="ft3">, documents numbers d, and</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:81"><nobr><span class="ft10">offsets o. For fast decompression of these postings, there are<br>two important considerations:first, the choice of compres-<br>sion scheme for each component of the posting; and, second,<br>modifications to each compression scheme so that it is both<br>fast and compatible with the schemes used for the other<br>components. In this section, we outline the optimisations<br>we use for fast decompression. Our code is publically avail-<br>able and distributed under the GNU public licence.</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:392"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:81"><nobr><span class="ft13"><i>Bitwise Compression</i></span></nobr></DIV>
<DIV style="position:absolute;top:563;left:81"><nobr><span class="ft10">We have experimented with a range of variations of bitwise<br>decompression schemes. Williams and Zobel [13] reported<br>results for several efficient schemes, where vectors that con-<br>tain compressed integers are retrieved from disk and subse-<br>quently decoded.</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:183"><nobr><span class="ft7">3</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:198"><nobr><span class="ft3">In their approach, vector decoding uses</span></nobr></DIV>
<DIV style="position:absolute;top:641;left:81"><nobr><span class="ft10">bitwise shift operations, bit masks, multiplication, subtrac-<br>tion, and function calls to retrieve sequences of bits that<br>span byte boundaries. In our experiments on Intel Pentium-<br>based servers running the Linux operating system, we have<br>found that bitwise shift operations are usually faster than<br>bit masks, and that the function calls are slow. By opti-<br>mising our code to use bitwise shifts and to remove nested<br>function calls, we have found that the overall time to decode<br>vectors--regardless of the compression scheme used--is on<br>average around 60% of that using the code of Williams and<br>Zobel.</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:94"><nobr><span class="ft3">Other optimisations that are specific to Golomb-Rice cod-</span></nobr></DIV>
<DIV style="position:absolute;top:829;left:81"><nobr><span class="ft10">ing are also of value. Golomb-Rice decoding requires that<br>log</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:99"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:845;left:107"><nobr><span class="ft3">b is calculated to determine the number of remainder</span></nobr></DIV>
<DIV style="position:absolute;top:861;left:81"><nobr><span class="ft3">bits to be retrieved.</span></nobr></DIV>
<DIV style="position:absolute;top:861;left:219"><nobr><span class="ft3">It is practicable to explicitly cache</span></nobr></DIV>
<DIV style="position:absolute;top:876;left:81"><nobr><span class="ft3">values of log</span></nobr></DIV>
<DIV style="position:absolute;top:881;left:159"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:876;left:167"><nobr><span class="ft3">b in a hash table as they are calculated, or</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:81"><nobr><span class="ft10">to pre-calculate all likely-to-be-used values as the retrieval<br>query engine is initialised. This saves recalculation of loga-<br>rithms when a value of b is reused in later processing, with<br>the penalty of additional memory requirements for storing<br>the lookup table.</span></nobr></DIV>
<DIV style="position:absolute;top:970;left:94"><nobr><span class="ft3">We measured the performance of Golomb coding with and</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:81"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:88"><nobr><span class="ft3">The</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:124"><nobr><span class="ft3">search</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:174"><nobr><span class="ft3">engine</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:225"><nobr><span class="ft3">used</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:264"><nobr><span class="ft3">in</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:289"><nobr><span class="ft3">these</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:332"><nobr><span class="ft3">experiments</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:417"><nobr><span class="ft3">and</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:81"><nobr><span class="ft3">our</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:119"><nobr><span class="ft3">integer</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:178"><nobr><span class="ft3">compression</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:269"><nobr><span class="ft3">code</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:314"><nobr><span class="ft3">is</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:341"><nobr><span class="ft3">available</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:411"><nobr><span class="ft3">from</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:81"><nobr><span class="ft3">http://www.seg.rmit.edu.au/</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft7">3</span></nobr></DIV>
<DIV style="position:absolute;top:1040;left:88"><nobr><span class="ft3">The code used by Williams and Zobel in their ex-</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:81"><nobr><span class="ft14">periments is available from http://www.cs.rmit.edu.au/<br>~hugh/software/</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft10">without caching. Timings are average elapsed query evalua-<br>tion cost to process index information for 25,000 queries on a<br>9.75 gigabyte (Gb) collection of Web data [5] using our pro-<br>totype retrieval engine on a GolD-GamF-GolO index (that<br>is, Golomb document numbers, gamma frequencies, Golomb<br>offsets); we discuss collection statistics and experimental de-<br>sign further in Section 4. The cache lookup table size is<br>unrestricted.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:489"><nobr><span class="ft3">We found that, without caching of log</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:725"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:733"><nobr><span class="ft3">b values, the av-</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:475"><nobr><span class="ft10">erage query evaluation time is 0.961 seconds. Caching of<br>log</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:493"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:502"><nobr><span class="ft3">b values as they are calculated during query processing</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:475"><nobr><span class="ft10">roughly halves the average query evaluation time, to 0.494<br>seconds. Pre-calculating and storing the values offers almost<br>no benefit over caching during query processing, reducing<br>the time to 0.491 seconds; this reflects that only limited<br>b values are required during query evaluation. Caching of<br>toggle points yields 0.492 seconds. As toggle points are cal-<br>culated using bitwise shifts, addition, and subtraction, this<br>is further evidence that bitwise shifts are inexpensive on our<br>hardware.</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:489"><nobr><span class="ft3">An alternative approach to managing log computations</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:475"><nobr><span class="ft10">is to replace the standard library log function with a loop<br>that determines</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:586"><nobr><span class="ft3">log</span></nobr></DIV>
<DIV style="position:absolute;top:436;left:604"><nobr><span class="ft7">2</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:612"><nobr><span class="ft3">b using bitwise shifts and equality</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:475"><nobr><span class="ft10">tests; the logarithm value can be determined by locating<br>the position of the most-significant 1-bit in b. We found<br>that this led to slight additional improvements in the speed<br>of decoding Golomb codes, outperforming explicit caching.<br>All Golomb-Rice coding results reported in this paper are<br>computed in this way.</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:475"><nobr><span class="ft13"><i>Bytewise Compression</i></span></nobr></DIV>
<DIV style="position:absolute;top:580;left:475"><nobr><span class="ft10">We have experimented with improvements to variable-byte<br>coding. Unlike in bitwise coding, we have found that mask-<br>ing and shifting are equally as fast because of the large num-<br>ber of shifts required. We use shifts in our experiments.</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:489"><nobr><span class="ft3">Perhaps the most obvious way to increase the speed of</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:475"><nobr><span class="ft10">variable-byte decoding is to align the eight-bit blocks to byte<br>boundaries. Alignment with byte boundaries limits the de-<br>coding to only one option:the flag bit indicating if this is the<br>last byte in the integer is always the most significant bit, and<br>the remaining seven bits contain the value. Without byte<br>alignment, additional conditional tests and operations are<br>required to extract the flag bit, and the seven-bit value can<br>span byte boundaries. We would expect that byte alignment<br>would improve the speed of decoding variable-byte integers.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:489"><nobr><span class="ft3">Figure 1 shows the effect of byte alignment of variable-</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:475"><nobr><span class="ft10">byte integers. In this experiment, variable-byte coding is<br>used to store the offsets o in each inverted list posting. The<br>optimised Golomb coding scheme described in the previ-<br>ous section is used to code document numbers d and Elias<br>gamma coding is used to store the frequencies f</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:759"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:774"><nobr><span class="ft3">. We refer</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:475"><nobr><span class="ft3">to this as a GolD-GamF-VbyO index.</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:489"><nobr><span class="ft3">The graph at the left of Figure 1 shows total index size</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:475"><nobr><span class="ft10">as a percentage of the uncompressed collection being in-<br>dexed. The first bar shows that, without byte alignment,<br>the GolD-GamF-VbyO index requires almost 13% of the<br>space required by the collection. The second bar shows that<br>padding to byte alignment after storing the Gamma-coded<br>f</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:482"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:499"><nobr><span class="ft3">values increases the space requirement to just over 13.5%</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:475"><nobr><span class="ft10">of the collection size. We discuss the other schemes in this<br>figure later in this section.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:489"><nobr><span class="ft3">The graph at the right of Figure 1 shows elapsed query</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:475"><nobr><span class="ft3">evaluation times using different index designs. Timings are</span></nobr></DIV>
<DIV style="position:absolute;top:1122;left:449"><nobr><span class="ft9">225</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft15{font-size:7px;font-family:Times;color:#000000;}
	.ft16{font-size:8px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="53005.png" alt="background image">
<DIV style="position:absolute;top:376;left:141"><nobr><span class="ft15">Original</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:103"><nobr><span class="ft15">Original with byte boundary</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:153"><nobr><span class="ft15">Signature block</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:115"><nobr><span class="ft15">Signature block with byte boundary</span></nobr></DIV>
<DIV style="position:absolute;top:346;left:134"><nobr><span class="ft15">0</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:134"><nobr><span class="ft15">5</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:129"><nobr><span class="ft15">10</span></nobr></DIV>
<DIV style="position:absolute;top:147;left:129"><nobr><span class="ft15">15</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:129"><nobr><span class="ft15">20</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:121"><nobr><span class="ft16"><b>Size (% of Collection)</b></span></nobr></DIV>
<DIV style="position:absolute;top:376;left:273"><nobr><span class="ft15">Original</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:236"><nobr><span class="ft15">Original with byte boundary</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:288"><nobr><span class="ft15">Signature block</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:251"><nobr><span class="ft15">Signature block with byte boundary</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:340"><nobr><span class="ft15">Scanning</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:303"><nobr><span class="ft15">Scanning with byte boundary</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:318"><nobr><span class="ft15">Scanning with signature block</span></nobr></DIV>
<DIV style="position:absolute;top:487;left:283"><nobr><span class="ft15">Scanning with signature block and byte boundary</span></nobr></DIV>
<DIV style="position:absolute;top:346;left:258"><nobr><span class="ft15">0.0</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:258"><nobr><span class="ft15">0.2</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:258"><nobr><span class="ft15">0.4</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:258"><nobr><span class="ft15">0.6</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:258"><nobr><span class="ft15">0.8</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:258"><nobr><span class="ft15">1.0</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:247"><nobr><span class="ft16"><b>Average Query Time (Seconds)</b></span></nobr></DIV>
<DIV style="position:absolute;top:548;left:81"><nobr><span class="ft10">Figure 1: Variable-byte schemes for compressing off-<br>sets in inverted lists in a GolD-GamF-VbyOindex.<br>Four different compression schemes are shown and,<br>for each, both original and scanning decoding are<br>shown. Scanning decoding can be used when offsets<br>are not needed for query resolution.</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:81"><nobr><span class="ft10">the average elapsed query evaluation cost to process the<br>inverted lists for 25,000 queries on a 20 Gb collection of<br>Web [5] data using our prototype retrieval engine. Queries<br>are processed as conjunctive Boolean queries. The first bar<br>shows that the average time is around 0.7 seconds for the<br>GolD-GamF-VbyO index without byte alignment. The sec-<br>ond bar shows that the effect of byte alignment is a 25% re-<br>duction in average query time. Therefore, despite the small<br>additional space requirement, byte-alignment is beneficial<br>when storing variable-byte integers.</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:94"><nobr><span class="ft3">A second optimisation to variable-byte coding is to con-</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:81"><nobr><span class="ft10">sider the query mode when processing the index. For query-<br>ing that does not use offsets--such as ranked and Boolean<br>querying--decoding of the offsets in each posting is unneces-<br>sary. Rather, all that is required are the document numbers<br>d and document frequencies f</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:262"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:276"><nobr><span class="ft3">. An optimisation is there-</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:81"><nobr><span class="ft10">fore to only examine the flag bit of each block and to ignore<br>the remaining seven bits that contain the value. The value<br>of f</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:104"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:123"><nobr><span class="ft3">indicates the number of offsets o stored in the post-</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:81"><nobr><span class="ft3">ing. By examining flag bits until f</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:296"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:315"><nobr><span class="ft3">1-bits are processed,</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:81"><nobr><span class="ft10">it is possible to bypass the offsets with minimal processing.<br>We call this approach scanning.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:94"><nobr><span class="ft3">Scanning can also be used in query modes that do require</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft10">offset decoding. As we discussed earlier, phrase querying<br>requires that all terms are present in a matching document.<br>After processing the inverted list for the first term that is</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft10">evaluated in a phrase query, a temporary inverted list of<br>postings is created. This temporary list has a set D of doc-<br>uments that contain the first term. When processing the<br>second term in the query, a second set of document num-<br>bers D are processed. Offsets for the posting associated<br>with document d  D can be scanned, that is, passed over<br>without decoding, if d is not a member of D. (At the same<br>time, document numbers in D that are not in D are dis-<br>carded.)</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:489"><nobr><span class="ft3">We show the performance of scanning in Figure 1. The</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:475"><nobr><span class="ft10">fifth and sixth bars show how scanning affects query evalu-<br>ation time for variable-bytes that are either unaligned and<br>aligned to byte boundaries in the GolD-GamF-VbyO index.<br>Scanning removes the processing of seven-bit values. This<br>reduces the cost of retrieving unaligned variable-bytes to less<br>than that of the aligned variable-byte schemes; the small<br>speed advantage is due to the retrieval of smaller lists in the<br>unaligned version. Scanning has little effect on byte-aligned<br>variable bytes, reflecting that the processing of seven-bit val-<br>ues using shift operations has a low cost. Overall, however,<br>byte-alignment is preferred since the decoding cost of offsets<br>is expensive in an unaligned scheme.</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:489"><nobr><span class="ft3">A third optimisation is an approach we call signature</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:475"><nobr><span class="ft10">blocks, which are a variant of skipping. Skipping is the ap-<br>proach of storing additional integers in inverted lists that<br>indicate how much data can be skipped without any pro-<br>cessing [14]. Skipping has the disadvantage of an additional<br>storage space requirement, but has been shown to offer sub-<br>stantial speed improvements [14]. A signature block is an<br>eight-bit block that stores the flag bits of up to eight blocks<br>that follow. For example, a signature block with the bit-<br>string 11100101 represents that five integers are stored in<br>the eight following eight-bit blocks:the string 111 repre-<br>sents that the first three blocks store one integer each; the<br>string 001 represents that the fourth integer is stored over<br>three blocks; and, the string 01 represents that the final in-<br>teger is stored over two blocks. As all flag bits are stored<br>in the signature block, the following blocks use all eight bits<br>to store values, rather the seven-bit scheme in the standard<br>variable-byte integer representation.</span></nobr></DIV>
<DIV style="position:absolute;top:714;left:489"><nobr><span class="ft3">The primary use of signature blocks is skipping. To skip</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:475"><nobr><span class="ft3">offsets, f</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:527"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:544"><nobr><span class="ft3">offset values must be retrieved but not processed.</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:475"><nobr><span class="ft10">By counting the number of 1-bits in a signature block, the<br>number of integers stored in the next eight blocks can be<br>determined. If the value of f</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:650"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:669"><nobr><span class="ft3">exceeds this, then a second</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:475"><nobr><span class="ft3">or subsequent signature block is processed until f</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:777"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:797"><nobr><span class="ft3">offsets</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:475"><nobr><span class="ft10">have been skipped. The last signature block is, on average,<br>half full. We have found that bitwise shifts are faster than<br>a lookup table for processing of signature blocks.</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:489"><nobr><span class="ft3">The speed and space requirements are also shown in Fig-</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:475"><nobr><span class="ft10">ure 1. Not surprisingly, the signature block scheme requires<br>more space than the previous variable-byte schemes. This<br>space requirement is further increased if byte alignment of<br>blocks is enforced. In terms of speed, the third and fourth<br>bars in the right-hand histogram show that signature blocks<br>are slower than the original variable-byte schemes when off-<br>sets are processed in the GolD-GamF-VbyO index. These<br>results are not surprising:signature blocks are slow to pro-<br>cess when they are unaligned, and the byte-aligned version<br>is slow because processing costs are no less than the original<br>variable-byte schemes and longer disk reads are required.</span></nobr></DIV>
<DIV style="position:absolute;top:1044;left:489"><nobr><span class="ft3">As shown by the seventh bar, when offsets are skipped the</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:475"><nobr><span class="ft3">unaligned signature block scheme is slower than the original</span></nobr></DIV>
<DIV style="position:absolute;top:1122;left:449"><nobr><span class="ft9">226</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft17{font-size:6px;font-family:Times;color:#000000;}
	.ft18{font-size:5px;font-family:Times;color:#000000;}
	.ft19{font-size:7px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="53006.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft10">variable-byte scheme. The savings of skipping with signa-<br>ture blocks are negated by more complex processing when<br>blocks are not byte-aligned. In contrast, the right-most bar<br>shows that the byte-aligned signature block scheme with<br>skipping is slightly faster on average than all other schemes.<br>However, we conclude--given the compactness of the in-<br>dex and good overall performance--that the best all-round<br>scheme is the original variable-byte scheme with byte align-<br>ment. Therefore, all variable-byte results reported in the<br>Section 4 use the original byte-aligned variable-byte scheme<br>with scanning.</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:81"><nobr><span class="ft13"><i>Customised Compression</i></span></nobr></DIV>
<DIV style="position:absolute;top:292;left:81"><nobr><span class="ft10">Combinations of bitwise and bytewise compression schemes<br>are also possible. The aim of such approaches is to com-<br>bine the fast decoding of bytewise schemes with the com-<br>pact storage of bitwise schemes. For example, a simple and<br>efficient custom scheme is to store a single bit that indicates<br>which of two compression schemes is used, and then to store<br>the integer using the designated compression scheme. We<br>have experimented with several approaches for storing off-<br>sets. The simplest and most efficient approach we tested<br>is as follows:when f</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:210"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:433;left:230"><nobr><span class="ft3">= 1, we store a single bit indicat-</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:81"><nobr><span class="ft10">ing whether the following offset is stored as a bitwise Elias<br>delta code or as a bytewise eight-bit binary representation.<br>When storing values, we use Elias delta coding if the value<br>is greater than 256 and the binary scheme otherwise. This<br>scheme has the potential to reduce space because in the me-<br>dian posting f</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:168"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:187"><nobr><span class="ft3">is 1 and the average offset is around 200.</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:81"><nobr><span class="ft10">Selective use of a fixed-width representation can save stor-<br>age of the 6-bit prefix used to indicate magnitude in the<br>corresponding delta code.</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:94"><nobr><span class="ft3">We report the results with this scheme, which we call cus-</span></nobr></DIV>
<DIV style="position:absolute;top:605;left:81"><nobr><span class="ft10">tom, in the next section. This was the fastest custom scheme<br>we tested. Other approaches we tried included switching be-<br>tween variable-byte and bitwise schemes, using the custom<br>scheme when f</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:173"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:193"><nobr><span class="ft3">is either 1 or 2, and other simple varia-</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:81"><nobr><span class="ft3">tions. We omit results for these less successful approaches.</span></nobr></DIV>
<DIV style="position:absolute;top:699;left:81"><nobr><span class="ft4"><b>4.</b></span></nobr></DIV>
<DIV style="position:absolute;top:699;left:112"><nobr><span class="ft4"><b>RESULTS</b></span></nobr></DIV>
<DIV style="position:absolute;top:722;left:94"><nobr><span class="ft3">All experiments described in this paper are carried out on</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:81"><nobr><span class="ft10">an Intel Pentium III based machine with 512 Mb of main-<br>memory running the Linux operating system. Other pro-<br>cesses and disk activity was minimised during timing exper-<br>iments, that is, the machine was under light-load.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:94"><nobr><span class="ft3">A theme throughout these experiments and greatly im-</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:81"><nobr><span class="ft10">pacting on the results is the importance of caching. On a<br>modern machine, caching takes place at two levels. One level<br>is the caching of recently-accessed disk blocks in memory, a<br>process that is managed by the operating system. When the<br>size of the index significantly exceeds memory capacity, to<br>make space to fetch a new inverted list, the blocks contain-<br>ing material that has not been accessed for a while must be<br>discarded. One of the main benefits of compression is that a<br>much greater volume of index information can be cached in<br>memory. For this reason, we test our compression schemes<br>with streams of 10,000 or 25,000 queries extracted from a<br>query log [11], where the frequency distribution of query<br>terms leads to beneficial use of caching. Again, queries are<br>processed as conjunctive Boolean queries.</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:94"><nobr><span class="ft3">The other level at which caching takes place is the reten-</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft10">tion in the CPU cache of small blocks of data, typically of<br>128 bytes, recently accessed from memory. CPU caching</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:517"><nobr><span class="ft17">DelD-GamF-GolO</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:533"><nobr><span class="ft17">GolD-GamF-GamO</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:555"><nobr><span class="ft17">GolD-GamF-DelO</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:574"><nobr><span class="ft17">GolD-GamF-GolO</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:595"><nobr><span class="ft17">GolD-GamF-RicO</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:612"><nobr><span class="ft17">GolD-GamF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:633"><nobr><span class="ft17">GolD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:653"><nobr><span class="ft17">RicD-GamF-RicO</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:672"><nobr><span class="ft17">RicD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:689"><nobr><span class="ft17">VbyD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:738"><nobr><span class="ft17">Custom</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:736"><nobr><span class="ft17">No compression</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:532"><nobr><span class="ft18">0</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:528"><nobr><span class="ft18">10</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:528"><nobr><span class="ft18">20</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:528"><nobr><span class="ft18">30</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:528"><nobr><span class="ft18">40</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:520"><nobr><span class="ft19"><b>Index Size (% of Collection)</b></span></nobr></DIV>
<DIV style="position:absolute;top:343;left:517"><nobr><span class="ft17">DelD-GamF-GolO</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:533"><nobr><span class="ft17">GolD-GamF-GamO</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:555"><nobr><span class="ft17">GolD-GamF-DelO</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:574"><nobr><span class="ft17">GolD-GamF-GolO</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:595"><nobr><span class="ft17">GolD-GamF-RicO</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:612"><nobr><span class="ft17">GolD-GamF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:633"><nobr><span class="ft17">GolD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:653"><nobr><span class="ft17">RicD-GamF-RicO</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:672"><nobr><span class="ft17">RicD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:689"><nobr><span class="ft17">VbyD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:319;left:738"><nobr><span class="ft17">Custom</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:736"><nobr><span class="ft17">No compression</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:532"><nobr><span class="ft18">0</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:532"><nobr><span class="ft18">1</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:532"><nobr><span class="ft18">2</span></nobr></DIV>
<DIV style="position:absolute;top:135;left:532"><nobr><span class="ft18">3</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:532"><nobr><span class="ft18">4</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:525"><nobr><span class="ft19"><b>Average Query Time (Seconds x 10^-2)</b></span></nobr></DIV>
<DIV style="position:absolute;top:656;left:475"><nobr><span class="ft3">Figure 2:</span></nobr></DIV>
<DIV style="position:absolute;top:656;left:565"><nobr><span class="ft3">Performance of integer compression</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:475"><nobr><span class="ft10">schemes for offsets in inverted lists, in an index with<br>Golomb document numbers and gamma frequencies.<br>In this experiment, the index fits in main memory.<br>A 500 Mb collection is used, and results are aver-<br>aged over 10,000 queries.</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:475"><nobr><span class="ft10">is managed in hardware. In current desktop computers, as<br>many as 150 instruction cycles are required to fetch a single<br>machine-word into the CPU. At a coarser level, compres-<br>sion of postings lists means that the number of fetches from<br>memory to cache during decompression is halved.</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:475"><nobr><span class="ft13"><i>Small collection</i></span></nobr></DIV>
<DIV style="position:absolute;top:894;left:475"><nobr><span class="ft10">Figure 2 shows the relative performance of the integer com-<br>pression schemes we have described for storing offsets, on<br>a 500 Mb collection of 94,802 Web documents drawn from<br>the TREC Web track data [5]; timing results are averaged<br>over 10,000 queries drawn from an Excite search engine<br>query log [11]. The index contains 703, 518 terms.</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:489"><nobr><span class="ft3">These results show the effect of varying the coding scheme</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:475"><nobr><span class="ft3">used for document numbers d, frequencies f</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:735"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:749"><nobr><span class="ft3">, and offsets o.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:475"><nobr><span class="ft10">In all cases where both bitwise and variable-byte codes are<br>used, the bitwise codes are padded to a byte boundary before<br>a variable-byte code is emitted; thus, for example, in a GolD-<br>GamF-VbyO index, there is padding between the gamma</span></nobr></DIV>
<DIV style="position:absolute;top:1122;left:449"><nobr><span class="ft9">227</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft20{font-size:6px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="53007.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft10">frequency and the sequence of variable-byte offsets. Not all<br>code combinations are shown; for example, given that the<br>speed advantage of using variable-byte document numbers<br>is small, we have not reported results for index types such as<br>VbyD-GamF-RicD, and due to the use of padding a choice<br>such as VbyD-GamF-VbyD. Given the highly skew distribu-<br>tion of f</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:133"><nobr><span class="ft7">d,t</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:152"><nobr><span class="ft3">values, Golomb or Rice are not suitable coding</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:81"><nobr><span class="ft3">methods, so these have not been tried.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:94"><nobr><span class="ft3">In the "no compression" case, fixed-width fields are used</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:81"><nobr><span class="ft10">to store postings. Document numbers are stored in 32 bits,<br>frequencies in 16 bits, and offsets in 24 bits; these were the<br>smallest multiples of bytes that would not overflow for rea-<br>sonable assumptions about data properties.</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:94"><nobr><span class="ft3">The relative performance of Elias delta and gamma, Rice,</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:81"><nobr><span class="ft10">and Golomb coding is as expected. The non-parameterised<br>Elias coding schemes result in larger indexes than the param-<br>terised Golomb-Rice schemes that, in turn, result in slower<br>query evaluation. The average difference between offsets is<br>greater than 15, making Elias delta coding more appropri-<br>ate overall than gamma coding; the latter is both slower and<br>less space-efficient.</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:94"><nobr><span class="ft3">On the lower graph in Figure 2, comparing the fourth and</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:81"><nobr><span class="ft10">fifth columns and comparing the fifth and eighth columns,<br>it can be seen that choice of Golomb or Rice codes for either<br>offsets or document numbers has virtually no impact on in-<br>dex size. Comparing the fifth and eighth columns on the up-<br>per graph, the schemes yield similar decoding times for docu-<br>ment numbers. However, Rice codes are markedly faster for<br>decoding offsets, because no toggle point calculation is re-<br>quired. Among the bitwise schemes, we conclude that Rice<br>coding should be used in preference to other schemes for<br>coding document numbers and offsets.</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:94"><nobr><span class="ft3">The most surprising result is the effect of using the op-</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:81"><nobr><span class="ft10">timised byte-boundary variable-byte scheme for coding off-<br>sets. Despite the variable-byte index being 26% larger than<br>the corresponding Rice-coded index, the overall query evalu-<br>ation time is 62% less. Further speed gains are given by cod-<br>ing all values in variable-byte codes. Indeed, variable-byte<br>decoding is faster even than processing uncompressed lists.<br>This result is remarkable:the cost of transfering variable-<br>byte coded lists from memory to the CPU cache and then<br>decoding the lists is less than the cost of transferring un-<br>compressed lists. To our knowledge, this is the first practi-<br>cal illustration that compression improves the efficiency of<br>an in-memory retrieval system. We conclude from this that<br>variable-byte coding should be used to store offsets to reduce<br>both disk retrieval and memory retrieval costs.</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:94"><nobr><span class="ft3">In experiments with integers, Williams and Zobel found</span></nobr></DIV>
<DIV style="position:absolute;top:840;left:81"><nobr><span class="ft10">that variable-byte coding is faster than the bitwise schemes<br>for storing large integers of the magnitude stored in inverted<br>lists [13]. Our result confirms this observation for retrieval<br>systems, while also showing that the effect extends to fast<br>retrieval from memory and that improvements to variable-<br>byte coding can considerably increase decoding speed.</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:94"><nobr><span class="ft3">The custom scheme uses both Elias delta and a binary</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:81"><nobr><span class="ft10">bytewise scheme, reducing query evaluation to around 58%<br>of the time for the Elias delta scheme. However, the custom<br>scheme is almost twice as slow as the variable-byte scheme<br>and, therefore, has little benefit in practice.</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:81"><nobr><span class="ft13"><i>Large collection</i></span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft10">Figure 3 shows the results of a larger experiment with an<br>index that does not fit within the main-memory of our ma-</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:532"><nobr><span class="ft18">DelD-GamF-GolO</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:557"><nobr><span class="ft18">GolD-GamF-GamO</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:587"><nobr><span class="ft18">GolD-GamF-DelO</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:615"><nobr><span class="ft18">GolD-GamF-GolO</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:641"><nobr><span class="ft18">GolD-GamF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:671"><nobr><span class="ft18">RicD-GamF-RicO</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:698"><nobr><span class="ft18">RicD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:724"><nobr><span class="ft18">VbyD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:759"><nobr><span class="ft18">No compression</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:534"><nobr><span class="ft18">0</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:530"><nobr><span class="ft18">10</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:530"><nobr><span class="ft18">20</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:530"><nobr><span class="ft18">30</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:530"><nobr><span class="ft18">40</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:523"><nobr><span class="ft20"><b>Index Size (% of Collection)</b></span></nobr></DIV>
<DIV style="position:absolute;top:343;left:532"><nobr><span class="ft18">DelD-GamF-GolO</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:557"><nobr><span class="ft18">GolD-GamF-GamO</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:587"><nobr><span class="ft18">GolD-GamF-DelO</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:615"><nobr><span class="ft18">GolD-GamF-GolO</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:641"><nobr><span class="ft18">GolD-GamF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:671"><nobr><span class="ft18">RicD-GamF-RicO</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:698"><nobr><span class="ft18">RicD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:724"><nobr><span class="ft18">VbyD-VbyF-VbyO</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:759"><nobr><span class="ft18">No compression</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:528"><nobr><span class="ft18">0.0</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:528"><nobr><span class="ft18">0.5</span></nobr></DIV>
<DIV style="position:absolute;top:188;left:528"><nobr><span class="ft18">1.0</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:528"><nobr><span class="ft18">1.5</span></nobr></DIV>
<DIV style="position:absolute;top:80;left:528"><nobr><span class="ft18">2.0</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:519"><nobr><span class="ft20"><b>Average Query Time (Seconds) </b></span></nobr></DIV>
<DIV style="position:absolute;top:656;left:475"><nobr><span class="ft10">Figure 3: The performance of integer compression<br>schemes for compressing offsets in inverted lists,<br>with Golomb-coded document numbers and gamma-<br>coded offsets. In this experiment, the index is sev-<br>eral times larger than main memory. A 20 Gb col-<br>lection is used, and results are averaged over 25,000<br>queries.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:475"><nobr><span class="ft10">chine. Exactly the same index types are tried as for the<br>experiment above. A 20 Gb collection of 4,014,894 Web doc-<br>uments drawn from the TREC Web track data [5] is used<br>and timing results are averaged over 25,000 Boolean queries<br>drawn from an Excite search engine query log [11].</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:810"><nobr><span class="ft3">The</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:475"><nobr><span class="ft10">index contains 9,574,703 terms. We include only selected<br>schemes in our results.</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:489"><nobr><span class="ft3">We again note that we have not used heuristics to reduce</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:475"><nobr><span class="ft10">query evaluation costs such as frequency-ordering or early<br>termination. Indeed, we have not even used stopping; with<br>stopwords removed, query times are greatly impoved. Our<br>aim in this research is to measure the impact on index de-<br>coding time of different choices of compression method, not<br>to establish new benchmarks for query evaluation time. Our<br>improvements to compression techniques could, however, be<br>used in conjunction with the other heuristics, in all likeli-<br>hood further reducing query evaluation time compared to<br>the best times reported previously.</span></nobr></DIV>
<DIV style="position:absolute;top:1122;left:449"><nobr><span class="ft9">228</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="53008.png" alt="background image">
<DIV style="position:absolute;top:86;left:94"><nobr><span class="ft3">The relative speeds of the bitwise Golomb, Elias delta, and</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:81"><nobr><span class="ft10">variable-byte coded offset schemes are similar to that of our<br>experiments with the 500 Mb collection. Again, variable-<br>byte coding results in the fastest query evaluation. Perhaps<br>unsurprisingly given the results described above, an uncom-<br>pressed index that does not fit in main-memory is relatively<br>much slower than the variable-byte scheme; the disk trans-<br>fer costs are a larger fraction of the overall query cost when<br>the index does not fit in memory, and less use can be made<br>of the memory cache. Indexes with variable-byte offsets are<br>twice as fast as indexes with Golomb, delta, or gamma off-<br>sets, and one-and-a-half times as fast as indexes with Rice<br>offsets. VbyD-VbyF-VbyO indexes are twice as fast as any<br>index type with non-variable-byte offsets.</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:94"><nobr><span class="ft3">In separate experiments we have observed that the gains</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:81"><nobr><span class="ft10">demonstrated by compression continue to increase with col-<br>lection size, as the proportion of the index that can be held<br>in memory declines. Despite the loss in compression with<br>variable-byte coding, indexes are still less than one-seventh<br>of the size of the indexed data, and the efficiency gains are<br>huge.</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:81"><nobr><span class="ft4"><b>5.</b></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:112"><nobr><span class="ft4"><b>CONCLUSIONS</b></span></nobr></DIV>
<DIV style="position:absolute;top:453;left:94"><nobr><span class="ft3">Compression of inverted lists can significantly improve the</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:81"><nobr><span class="ft10">performance of retrieval systems. We have shown that an ef-<br>ficiently implemented variable-byte bytewise scheme results<br>in query evaluation that is twice as fast as more compact<br>bitwise schemes. Moreover, we have demonstrated that the<br>cost of transferring data from memory to the CPU cache<br>can also be reduced by compression:when an index fits in<br>main memory, the transfer of compressed data from mem-<br>ory to the cache and subsequent decoding is less than that<br>of transferring uncompressed data. Using byte-aligned cod-<br>ing, we have shown that queries can be run more than twice<br>as fast as with bitwise codes, at a small loss of compression<br>efficiency. These are dramatic gains.</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:94"><nobr><span class="ft3">Modern computer architectures create opportunities for</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:81"><nobr><span class="ft3">compression to yield performance advantages.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:378"><nobr><span class="ft3">Once, the</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:81"><nobr><span class="ft10">main benefits of compression were to save scarce disk space<br>and computer-to-computer transmission costs. An equally<br>important benefit now is to make use of the fact that the<br>CPU is largely idle. Fetching a single byte from memory in-<br>volves a delay of 12 to 150 CPU cycles; a fetch from disk in-<br>volves a delay of 10,000,000 cycles. Compression can greatly<br>reduce the number of such accesses, while CPU time that<br>would otherwise be unused can be spent on decoding. With<br>fast decoding, overall costs are much reduced, greatly in-<br>creasing query evaluation speed. In current computers such<br>architecture considerations are increasingly important to de-<br>velopment of new algorithms for query processing.</span></nobr></DIV>
<DIV style="position:absolute;top:861;left:411"><nobr><span class="ft3">Poor</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:81"><nobr><span class="ft10">caching has been a crucial shortcoming of existing algo-<br>rithms investigated in this research.</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:94"><nobr><span class="ft3">There are several possible extensions to this work. We</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:81"><nobr><span class="ft10">plan to investigate nibble-coding, a variant of variable-byte<br>coding where two flag bits are used in each variable-byte<br>block. It is likely that this approach may improve the per-<br>formance of signature blocks. We will also experiment with<br>phrase querying in practice and to explore the average query<br>evaluation speed when partial scanning is possible.</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:81"><nobr><span class="ft4"><b>6.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:112"><nobr><span class="ft4"><b>REFERENCES</b></span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:88"><nobr><span class="ft3">[1] V. Anh, O. de Kretser, and A. Moffat. Vector-Space</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:109"><nobr><span class="ft3">ranking with effective early termination. In W. Croft,</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:503"><nobr><span class="ft10">D. Harper, D. Kraft, and J. Zobel, editors, Proc.<br>ACM-SIGIR International Conference on Research<br>and Development in Information Retrieval, pages<br>35­42, New York, Sept. 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:151;left:482"><nobr><span class="ft3">[2] E. de Moura, G. Navarro, N. Ziviani, and</span></nobr></DIV>
<DIV style="position:absolute;top:166;left:503"><nobr><span class="ft10">R. Baeza-Yates. Fast and flexible word searching on<br>compressed text. ACM Transactions on Information<br>Systems, 18(2):113­139, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:482"><nobr><span class="ft3">[3] P. Elias. Universal codeword sets and representations</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:503"><nobr><span class="ft10">of the integers. IEEE Transactions on Information<br>Theory, IT-21(2):194­203, Mar. 1975.</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:482"><nobr><span class="ft3">[4] S. Golomb. Run-length encodings. IEEE Transactions</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:503"><nobr><span class="ft3">on Information Theory, IT­12(3):399­401, July 1966.</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:482"><nobr><span class="ft3">[5] D. Hawking, N. Creswell, and P. Thistlewaite.</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:503"><nobr><span class="ft10">Overview of TREC-7 very large collection track. In<br>E. Voorhees and D. Harman, editors, Proc. Text<br>Retrieval Conference (TREC), pages 91­104,<br>Washington, 1999. National Institute of Standards<br>and Technology Special Publication 500-242.</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:482"><nobr><span class="ft3">[6] A. Moffat and J. Zobel. Self-indexing inverted files for</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:503"><nobr><span class="ft10">fast text retrieval. ACM Transactions on Information<br>Systems, 14(4):349­379, Oct. 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:482"><nobr><span class="ft3">[7] A. Moffat, J. Zobel, and R. Sacks-Davis.</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:503"><nobr><span class="ft10">Memory-efficient ranking. Information Processing &amp;<br>Management, 30(6):733­744, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:482"><nobr><span class="ft3">[8] G. Navarro, E. de Moura, M. Neubert, N. Ziviani, and</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:503"><nobr><span class="ft10">R. Baeza-Yates. Adding compression to block<br>addressing inverted indexes. Information Retrieval,<br>3(1):49­77, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:482"><nobr><span class="ft3">[9] M. Persin. Document filtering for fast ranking. In</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:503"><nobr><span class="ft10">W. Croft and C. van Rijsbergen, editors, Proc.<br>ACM-SIGIR International Conference on Research<br>and Development in Information Retrieval, pages<br>339­348, Dublin, Ireland, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:475"><nobr><span class="ft3">[10] M. Persin, J. Zobel, and R. Sacks-Davis. Filtered</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:503"><nobr><span class="ft10">document retrieval with frequency-sorted indexes.<br>Journal of the American Society for Information<br>Science, 47(10):749­764, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:475"><nobr><span class="ft3">[11] A. Spink, D. Wolfram, B. J. Jansen, and T. Saracevic.</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:503"><nobr><span class="ft10">Searching the web:The public and their queries.<br>Journal of the American Society for Information<br>Science, 52(3):226­234, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:475"><nobr><span class="ft3">[12] A. Vo and A. Moffat. Compressed inverted files with</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:503"><nobr><span class="ft10">reduced decoding overheads. In R. Wilkinson,<br>B. Croft, K. van Rijsbergen, A. Moffat, and J. Zobel,<br>editors, Proc. ACM-SIGIR International Conference<br>on Research and Development in Information<br>Retrieval, pages 290­297, Melbourne, Australia, July<br>1998.</span></nobr></DIV>
<DIV style="position:absolute;top:873;left:475"><nobr><span class="ft3">[13] H. Williams and J. Zobel. Compressing integers for</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:503"><nobr><span class="ft10">fast file access. Computer Journal, 42(3):193­201,<br>1999.</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:475"><nobr><span class="ft3">[14] I. Witten, A. Moffat, and T. Bell. Managing</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:503"><nobr><span class="ft10">Gigabytes: Compressing and Indexing Documents and<br>Images. Morgan Kaufmann Publishers, Los Altos, CA<br>94022, USA, second edition, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:475"><nobr><span class="ft3">[15] N. Ziviani, E. de Moura, G. Navarro, and</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:503"><nobr><span class="ft10">R. Baeza-Yates. Compression:A key for<br>next-generation text retrieval systems. IEEE<br>Computer, 33(11):37­44, Nov. 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:1122;left:449"><nobr><span class="ft9">229</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
