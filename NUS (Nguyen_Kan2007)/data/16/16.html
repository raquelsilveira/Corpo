<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Microsoft Word - ITiCSE 2005 for publication 2.doc</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="author" content="portatil">
<META name="date" content="2005-06-07T22:42:02+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:25px;font-family:Times;color:#000000;}
	.ft1{font-size:16px;font-family:Times;color:#000000;}
	.ft2{font-size:13px;font-family:Times;color:#000000;}
	.ft3{font-size:11px;font-family:Times;color:#000000;}
	.ft4{font-size:8px;font-family:Times;color:#000000;}
	.ft5{font-size:9px;font-family:Times;color:#000000;}
	.ft6{font-size:16px;font-family:Courier;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:16px;line-height:25px;font-family:Times;color:#000000;}
	.ft9{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft10{font-size:9px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="16001.png" alt="background image">
<DIV style="position:absolute;top:109;left:142"><nobr><span class="ft0"><b>A Programming Languages Course for Freshmen </b></span></nobr></DIV>
<DIV style="position:absolute;top:144;left:351"><nobr><span class="ft1">J. Ángel Velázquez-Iturbide </span></nobr></DIV>
<DIV style="position:absolute;top:165;left:364"><nobr><span class="ft2">Universidad Rey Juan Carlos </span></nobr></DIV>
<DIV style="position:absolute;top:182;left:356"><nobr><span class="ft2">C/ Tulipán s/n, 28933 Móstoles, </span></nobr></DIV>
<DIV style="position:absolute;top:199;left:414"><nobr><span class="ft2">Madrid, Spain </span></nobr></DIV>
<DIV style="position:absolute;top:223;left:360"><nobr><span class="ft1">angel.velazquez@urjc.es </span></nobr></DIV>
<DIV style="position:absolute;top:248;left:459"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:144;left:711"><nobr><span class="ft8"> <br> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:274;left:81"><nobr><span class="ft1">ABSTRACT</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:179"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:294;left:81"><nobr><span class="ft9">Programming languages are a part of the core of computer <br>science. Courses on programming languages are typically offered <br>to junior or senior students, and textbooks are based on this <br>assumption. However, our computer science curriculum offers the <br>programming languages course in the first year. This unusual <br>situation led us to design it from an untypical approach. In this <br>paper, we first analyze and classify proposals for the <br>programming languages course into different pure and hybrid <br>approaches. Then, we describe a course for freshmen based on <br>four pure approaches, and justify the main choices made. Finally, <br>we identify the software used for laboratories and outline our <br>experience after teaching it for seven years. </span></nobr></DIV>
<DIV style="position:absolute;top:503;left:81"><nobr><span class="ft1">Categories and Subject Descriptors</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:353"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:524;left:81"><nobr><span class="ft9">K.3.2 [Computers and education]: Computer and information <br>science education ­ computer science education. </span></nobr></DIV>
<DIV style="position:absolute;top:574;left:81"><nobr><span class="ft1">General Terms</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:198"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:594;left:81"><nobr><span class="ft3">Languages, Theory. </span></nobr></DIV>
<DIV style="position:absolute;top:629;left:81"><nobr><span class="ft1">Keywords</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:81"><nobr><span class="ft9">Programming languages, formal grammars, language description, <br>programming paradigms, functional programming, recursion. </span></nobr></DIV>
<DIV style="position:absolute;top:700;left:81"><nobr><span class="ft1">1.  INTRODUCTION </span></nobr></DIV>
<DIV style="position:absolute;top:720;left:81"><nobr><span class="ft9">The topic of programming languages is a part of the core of <br>computer science. It played a relevant role in all the curricula <br>recommendations delivered by the ACM or the IEEE-CS since <br>the first Curriculum'68 [2]. Recent joint curricular <br>recommendations of the ACM and the IEEE-CS identified several <br>"areas" which structure the body of knowledge of the discipline. <br>The list of areas has grown since the first proposal made by the <br>Denning Report [4] up to 14 in the latest version, Computing <br>Curricula 2001 [12]. Programming languages has always been <br>one of these areas. </span></nobr></DIV>
<DIV style="position:absolute;top:888;left:81"><nobr><span class="ft9">Internationally reputed curricular recommendations are a valuable <br>tool for the design of particular curricula. However, each country </span></nobr></DIV>
<DIV style="position:absolute;top:273;left:477"><nobr><span class="ft9">has specific features that constrain the way of organizing their <br>studies. In Spain, the curriculum of a discipline offered by a <br>university is the result of a trade-off. On the one hand, the <br>university must at least offer a number of credits of the core <br>subject matters established by the Government. On the other <br>hand, the university may offer supplementary credits of the core <br>as well as mandatory and optional courses defined according to <br>the profile of the University and the faculty. Any proposal of a <br>new curriculum follows a well-established process: (1) the <br>curriculum is designed by a Center after consulting the <br>departments involved; (2) it must be approved by the University <br>Council; (3) the Universities Council of the Nation must deliver a <br>(positive) report; and (4) the curriculum is published in the <br>Official Bulletin of the Nation. This scheme has a number of <br>advantages, e.g. a minimum degree of coherence among all the <br>universities is guaranteed. However, it also has a number of <br>disadvantages, e.g. the process to change a curriculum is very <br>rigid. </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:477"><nobr><span class="ft9">The Universidad Rey Juan Carlos is a young university, now <br>seven years old. It offered studies of computer science since the <br>very first year. The curriculum was designed by an external <br>committee, so the teachers of computer science thereafter hired by <br>the university did not have the opportunity to elaborate on it. The <br>curriculum had a few weak points that would recommend a light <br>reform, but the priorities of the new university postponed it. </span></nobr></DIV>
<DIV style="position:absolute;top:687;left:477"><nobr><span class="ft9">The curriculum establishes the features of the "Foundations of <br>programming languages" course. The course is scheduled to last <br>for fifteen weeks, with three lecture hours per week and two <br>supervised laboratory hours per week. However, some flexibility <br>is allowed, so that some weeks may be released from the lab <br>component. </span></nobr></DIV>
<DIV style="position:absolute;top:791;left:477"><nobr><span class="ft9">This course is both a strong and a weak feature of the curriculum. <br>It is a strong feature because programming languages are <br>marginal in the official core. Consequently, our curriculum is <br>closer to international recommendations than most Spanish <br>universities. However, it is a weak feature, because the course is <br>offered in the second semester of the first year! Notice that the <br>programming languages course is more typically offered as an <br>intermediate or advanced course in the third or fourth year. </span></nobr></DIV>
<DIV style="position:absolute;top:927;left:477"><nobr><span class="ft9">Our problem was how to teach the programming languages course <br>to freshmen. The paper presents our design of the course and our <br>experience. In the second section we first analyze and classify <br>proposals for the programming languages course into different <br>pure and hybrid approaches. In section 3, we describe a course for <br>freshmen based on four pure approaches, and justify the choices <br>made with respect to the factors that most influenced its design. <br>Finally, we identify the software used for laboratories and outline <br>our experience after teaching it for seven years. </span></nobr></DIV>
<DIV style="position:absolute;top:932;left:87"><nobr><span class="ft4"> </span></nobr></DIV>
<DIV style="position:absolute;top:954;left:87"><nobr><span class="ft10">Permission to make digital or hard copies of all or part of this work for <br>personal or classroom use is granted without fee provided that copies are <br>not made or distributed for profit or commercial advantage and that <br>copies bear this notice and the full citation on the first page. To copy <br>otherwise, or republish, to post on servers or to redistribute to lists, <br>requires prior specific permission and/or a fee. <br>ITiCSE'05, June 27­29, 2005, Monte de Caparica, Portugal. <br>Copyright 2005 ACM 1-59593-024-8/05/0006...$5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:353"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">271</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft11{font-size:16px;line-height:21px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="16002.png" alt="background image">
<DIV style="position:absolute;top:109;left:81"><nobr><span class="ft11">2.  APPROACHES TO TEACHING <br>PROGRAMMING LANGUAGES </span></nobr></DIV>
<DIV style="position:absolute;top:151;left:81"><nobr><span class="ft9">Since  Curriculum'68, several issues on programming languages <br>have received attention in the different curriculum <br>recommendations: particular programming languages, language <br>implementation, etc. It is formative to study (or to browse, at <br>least) such recommendations, even though the large number of <br>topics can be discouraging for the teacher. </span></nobr></DIV>
<DIV style="position:absolute;top:255;left:81"><nobr><span class="ft9">In this section, we try to organize different contributions. Firstly, <br>we identify "pure" approaches to the programming languages <br>course. Secondly, we describe their implementation, usually as <br>hybrid approaches. Finally, we briefly discuss the issue of which <br>programming languages and paradigms to use for the course. </span></nobr></DIV>
<DIV style="position:absolute;top:344;left:81"><nobr><span class="ft1">2.1  Pure Approaches </span></nobr></DIV>
<DIV style="position:absolute;top:364;left:81"><nobr><span class="ft9">Probably, the best study on approaches to the programming <br>languages course was given by King [7]. He made a study of 15 <br>textbooks and found 10 different goals. Furthermore, he identified <br>3 approaches on which these textbooks were based and discussed <br>a number of issues. We have extended his classification up to 5 <br>approaches. Although most books and courses follow a hybrid <br>approach, it is clarifying to distinguish the following pure ones: </span></nobr></DIV>
<DIV style="position:absolute;top:483;left:81"><nobr><span class="ft3">·  Catalogue approach. It provides a survey of several </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:102"><nobr><span class="ft9">programming languages. This approach has several <br>advantages: the student acquires a good education in several <br>languages, it allows studying the interaction among different <br>constructs of a language, and the languages may be studied in <br>chronological order. However, it also exhibits disadvantages: <br>there is much redundancy in studying similar features in <br>different languages, and there is no guarantee that the student <br>acquires a solid education. </span></nobr></DIV>
<DIV style="position:absolute;top:636;left:81"><nobr><span class="ft3">·  Descriptive (or anatomic [5]) approach. Programming </span></nobr></DIV>
<DIV style="position:absolute;top:653;left:102"><nobr><span class="ft9">languages have many common elements which can be <br>grouped into categories and studied independently. Typical <br>examples are: data types, hiding mechanisms, execution <br>control, etc. The advantages and disadvantages of this <br>approach are roughly the opposite of the previous one. </span></nobr></DIV>
<DIV style="position:absolute;top:741;left:81"><nobr><span class="ft3">·  Paradigm approach. Although each language has different </span></nobr></DIV>
<DIV style="position:absolute;top:758;left:102"><nobr><span class="ft9">characteristics and constructs, it is based on a basic model of <br>computation called programming paradigm. The paradigm <br>approach is an evolution of the descriptive approach described <br>above since it generalizes language constructs and groups <br>them consistently. Typical examples of paradigms are <br>functional, logic and imperative programming. </span></nobr></DIV>
<DIV style="position:absolute;top:862;left:81"><nobr><span class="ft3">·  Formal approach. It studies the foundations of programming </span></nobr></DIV>
<DIV style="position:absolute;top:879;left:102"><nobr><span class="ft9">languages, mainly their syntax and semantics. The main <br>advantage of this approach is that the student acquires a solid <br>conceptual background. However, it has the risk of being too <br>formal and therefore keeping far from the study of the <br>programming languages themselves. </span></nobr></DIV>
<DIV style="position:absolute;top:967;left:81"><nobr><span class="ft3">·  Implementation approach. It comprises language processing </span></nobr></DIV>
<DIV style="position:absolute;top:984;left:102"><nobr><span class="ft9">topics. This approach is usually adopted jointly with the <br>descriptive one, so that the run-time mechanisms that support <br>each language construct are also described. This allows <br>estimating the computational cost of each construct. However, <br>the student may associate each concept with a particular <br>implementation; this approach may also be in contradiction </span></nobr></DIV>
<DIV style="position:absolute;top:109;left:498"><nobr><span class="ft9">with the idea that a high level language should be <br>understandable independently from its implementation. </span></nobr></DIV>
<DIV style="position:absolute;top:150;left:477"><nobr><span class="ft1">2.2  Implementation of Pure Approaches </span></nobr></DIV>
<DIV style="position:absolute;top:170;left:477"><nobr><span class="ft9">The formal and implementation approaches are the basis of two <br>well known and established courses: computation theory and <br>language processors. They are not studied in this paper as <br>standalone courses, but we consider their integration into the <br>programming languages course. </span></nobr></DIV>
<DIV style="position:absolute;top:259;left:477"><nobr><span class="ft9">Despite these "pure" approaches, it is more common to adopt a <br>hybrid one, formed by a combination of several approaches. For <br>instance, we have explained that a descriptive course may address <br>the implementation of language constructs. The descriptive and <br>paradigm approaches also are commonly complemented by a <br>small catalogue of selected languages. It is also common to find a <br>descriptive part based on the imperative paradigm, followed by a <br>second part based on the catalogue or the paradigm approaches. <br>Finally, the formal approach can complement the descriptive or <br>implementation ones. </span></nobr></DIV>
<DIV style="position:absolute;top:426;left:477"><nobr><span class="ft9">From a historical point of view, the catalogue approach was the <br>most common in the first years of computing curricula. However, <br>it has almost universally been abandoned, with some interesting <br>exceptions, such as the experience by Maurer [9] on a subfamily <br>of four C-like languages. </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:477"><nobr><span class="ft9">The trend has been towards giving more importance to the <br>foundations of programming languages, mainly elements and <br>paradigms. After this evolution, it seems that the two most <br>common organizations are: </span></nobr></DIV>
<DIV style="position:absolute;top:586;left:477"><nobr><span class="ft3">·  Descriptive approach, complemented with some languages or </span></nobr></DIV>
<DIV style="position:absolute;top:603;left:498"><nobr><span class="ft9">paradigms. It is the most common organization, according to <br>currently available textbooks. </span></nobr></DIV>
<DIV style="position:absolute;top:643;left:477"><nobr><span class="ft3">·  Descriptive approach, illustrated by means of interpreters of </span></nobr></DIV>
<DIV style="position:absolute;top:661;left:498"><nobr><span class="ft9">some selected languages. Interpreters and paradigms can be <br>combined in two symmetrical ways: either implementing an <br>interpreter in each paradigm [14], or implementing an <br>interpreter for one language of each paradigm; the latter <br>approach can be adopted with an imperative language [6] or, <br>more probably, with a functional language [1]. </span></nobr></DIV>
<DIV style="position:absolute;top:765;left:477"><nobr><span class="ft9">There are few proposals for a holistic approach. One exception is <br>Wick and Stevenson's proposal [17], which combines the <br>descriptive, formal, paradigm and implementation approaches into <br>a "reductionistic" one. </span></nobr></DIV>
<DIV style="position:absolute;top:847;left:477"><nobr><span class="ft1">2.3  Choice of Languages and Paradigms </span></nobr></DIV>
<DIV style="position:absolute;top:867;left:477"><nobr><span class="ft9">Courses on programming languages do not simply consist in the <br>study of one or several languages, but their study usually is a part <br>of the course. The selection of these languages rises some <br>questions, that we cannot discuss here. </span></nobr></DIV>
<DIV style="position:absolute;top:940;left:477"><nobr><span class="ft9">A related issue is the selection of programming paradigms. Not all <br>the paradigms can be equally useful for a course on programming <br>languages for freshmen. Firstly, some paradigms are richer to <br>illustrate language elements than others. Secondly, some <br>paradigms can be more adequate to freshmen than others. There is <br>not a catalogue of paradigms classified by suitable academic year, <br>but it is important to use a more objective criterion than just the <br>personal opinion of faculty. </span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">272</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft12{font-size:11px;line-height:21px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="16003.png" alt="background image">
<DIV style="position:absolute;top:109;left:81"><nobr><span class="ft9">We have used the Computing Curricula 2001 [12] as an objective <br>basis to identify feasible paradigms. They identify the paradigms <br>that have succeeded in CS1: procedural, object-oriented, <br>functional, algorithmic notations, and low-level languages. The <br>last two choices are useful for CS1 but not for a programming <br>languages course, thus the remaining choices are procedural, <br>object-oriented, and functional. An additional choice, not cited by <br>Computing Curricula 2001, consists in the use of tiny languages <br>[8][10]. These languages can be ad hoc designed for a specific <br>domain or embedded into operating systems or applications. </span></nobr></DIV>
<DIV style="position:absolute;top:286;left:81"><nobr><span class="ft1">3.  OUR PROPOSAL </span></nobr></DIV>
<DIV style="position:absolute;top:306;left:81"><nobr><span class="ft9">We discarded the catalogue approach because it would only <br>contribute to a memorization effort by freshmen. Consequently, <br>our course is based on the remaining four approaches: </span></nobr></DIV>
<DIV style="position:absolute;top:362;left:81"><nobr><span class="ft3">·  Formal approach. Formal grammars and syntax notations are </span></nobr></DIV>
<DIV style="position:absolute;top:379;left:102"><nobr><span class="ft3">given in depth. Language semantics is simply introduced. </span></nobr></DIV>
<DIV style="position:absolute;top:404;left:81"><nobr><span class="ft3">·  Implementation approach. Only basic concepts are given. </span></nobr></DIV>
<DIV style="position:absolute;top:429;left:81"><nobr><span class="ft3">·  Descriptive approach. Basic language elements are reviewed. </span></nobr></DIV>
<DIV style="position:absolute;top:455;left:81"><nobr><span class="ft3">·  Paradigm approach. A programming paradigm is given in </span></nobr></DIV>
<DIV style="position:absolute;top:473;left:102"><nobr><span class="ft3">depth (functional programming) but others are just sketched. </span></nobr></DIV>
<DIV style="position:absolute;top:498;left:81"><nobr><span class="ft3">Table 1 contains the contents of the course we offer. </span></nobr></DIV>
<DIV style="position:absolute;top:522;left:81"><nobr><span class="ft9">There are several major factors to consider for the design of a <br>programming languages course. Firstly, the course when it is <br>offered to students determines to a large extent the knowledge and <br>maturity of students. Secondly, the existence of related courses, <br>such as courses on automata theory or programming <br>methodology, may recommend removing some overlapping <br>topics. Thirdly, the specialization profile of faculty can foster the <br>choice of a given topic instead of another one. Fourthly, a course <br>with so many different topics must guarantee coherence among <br>them. Finally, time constraints typically limit the number of <br>topics to consider. </span></nobr></DIV>
<DIV style="position:absolute;top:706;left:81"><nobr><span class="ft9">In the following subsections we justify the adequacy of the <br>choices made with respect to these factors. </span></nobr></DIV>
<DIV style="position:absolute;top:747;left:98"><nobr><span class="ft3">Table 1.  Syllabus of our programming languages course </span></nobr></DIV>
<DIV style="position:absolute;top:769;left:81"><nobr><span class="ft12">PART I.  INTRODUCTION <br>Chapter 1.  General issues </span></nobr></DIV>
<DIV style="position:absolute;top:807;left:102"><nobr><span class="ft9">Computer and programming languages. Elements, properties <br>and history of programming languages. Classifications. </span></nobr></DIV>
<DIV style="position:absolute;top:848;left:81"><nobr><span class="ft12">PART II.  SYNTACTIC FOUNDATIONS OF <br>PROGRAMMING LANGUAGES <br>Chapter 2.  Grammars and formal languages </span></nobr></DIV>
<DIV style="position:absolute;top:901;left:102"><nobr><span class="ft9">Alphabets, symbols and chains. Languages. Grammars. <br>Derivation of sentences. Recursive grammars. Classification <br>of grammars: Chomsky's hierarchy. Abstract machines. </span></nobr></DIV>
<DIV style="position:absolute;top:958;left:81"><nobr><span class="ft3">Chapter 3. Regular grammars </span></nobr></DIV>
<DIV style="position:absolute;top:973;left:102"><nobr><span class="ft9">Definition. Uses and limitations. Regular expressions and <br>regular languages. Finite-state automata. </span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:81"><nobr><span class="ft3">Chapter 4. Context-free grammars </span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:102"><nobr><span class="ft9">Definition. Uses and limitations. Parsing trees. The ambiguity <br>problem and its removal. </span></nobr></DIV>
<DIV style="position:absolute;top:110;left:477"><nobr><span class="ft12">PART III.  DESCRIPTION AND PROCESSING OF <br>PROGRAMMING LANGUAGES <br>Chapter 5. Language processors </span></nobr></DIV>
<DIV style="position:absolute;top:163;left:498"><nobr><span class="ft9">Abstract (or virtual) machines. Classes of processors. Stages <br>in language processing. Concrete vs. abstract syntax. </span></nobr></DIV>
<DIV style="position:absolute;top:204;left:477"><nobr><span class="ft3">Chapter 6. Lexical and syntactic notations </span></nobr></DIV>
<DIV style="position:absolute;top:219;left:498"><nobr><span class="ft9">Lexical and syntactic elements. Regular definitions. Syntax <br>notations: BNF, EBNF, syntax charts. </span></nobr></DIV>
<DIV style="position:absolute;top:260;left:477"><nobr><span class="ft3">Chapter 7. Semantics </span></nobr></DIV>
<DIV style="position:absolute;top:276;left:498"><nobr><span class="ft3">Semantics. Classes of semantics. Static semantics. Binding. </span></nobr></DIV>
<DIV style="position:absolute;top:301;left:477"><nobr><span class="ft12">PART IV.  THE FUNCTIONAL PARADIGM <br>Chapter 8.  Basic elements </span></nobr></DIV>
<DIV style="position:absolute;top:338;left:498"><nobr><span class="ft9">Function definition and application. Programs and <br>expressions. Overview of functional languages. Built-in types, <br>values and operations. The conditional expression. </span></nobr></DIV>
<DIV style="position:absolute;top:395;left:477"><nobr><span class="ft3">Chapter 9. Advanced elements </span></nobr></DIV>
<DIV style="position:absolute;top:411;left:498"><nobr><span class="ft9">Operational semantics: term rewriting. Recursive functions. <br>Local definitions. </span></nobr></DIV>
<DIV style="position:absolute;top:452;left:477"><nobr><span class="ft3">Chapter 10. Functional data types </span></nobr></DIV>
<DIV style="position:absolute;top:467;left:498"><nobr><span class="ft3">Constructors. Equations and patterns. Pattern matching. </span></nobr></DIV>
<DIV style="position:absolute;top:492;left:477"><nobr><span class="ft12">PART V.  ELEMENTS OF PROGRAMMING LANGUAGES <br>Chapter 11. Lexical and syntactical elements </span></nobr></DIV>
<DIV style="position:absolute;top:530;left:498"><nobr><span class="ft9">Identifiers. Numbers. Characters. Comments. Delimeters. <br>Notations for expressions. Program structure and blocks. </span></nobr></DIV>
<DIV style="position:absolute;top:571;left:477"><nobr><span class="ft3">Chapter 12. Data types </span></nobr></DIV>
<DIV style="position:absolute;top:586;left:498"><nobr><span class="ft9">Recursive types. Parametric types: polymorphism. <br>Polymorphic functions. Type systems. Type checking and <br>inference. Type equivalence. Type conversion. Overloading. </span></nobr></DIV>
<DIV style="position:absolute;top:643;left:477"><nobr><span class="ft12">PART VI.  PROGRAMMING PARADIGMS <br>Chapter 13. Other paradigms and languages </span></nobr></DIV>
<DIV style="position:absolute;top:681;left:498"><nobr><span class="ft9">Imperative paradigms. Logic paradigm. Motivation of <br>concurrency. Other computer languages: mark-up languages. </span></nobr></DIV>
<DIV style="position:absolute;top:732;left:477"><nobr><span class="ft1">3.1  Maturity of Students </span></nobr></DIV>
<DIV style="position:absolute;top:752;left:477"><nobr><span class="ft9">One major concern was the fact that the course is offered to <br>freshmen. A single approach could not be used because of the <br>freshmen's lack of knowledge of programming languages. A <br>variety of contents from the different approaches must be selected <br>in order to give them a comprehensible and rich view of <br>programming languages. </span></nobr></DIV>
<DIV style="position:absolute;top:856;left:477"><nobr><span class="ft9">The lack of maturity and capability of students to understand <br>certain topics was a bottleneck for course organization. The <br>different topics can be given with varying degrees of depth, but <br>always making sure that freshmen can master them. We found <br>that some topics are especially difficult to understand, even <br>formulated in the simplest way. This mainly applies to: </span></nobr></DIV>
<DIV style="position:absolute;top:960;left:477"><nobr><span class="ft3">·  Semantics of programming languages. </span></nobr></DIV>
<DIV style="position:absolute;top:985;left:477"><nobr><span class="ft3">·  Implementation of programming languages. </span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:477"><nobr><span class="ft3">·  Some programming paradigms, such as concurrency. </span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:477"><nobr><span class="ft9">Consequently, these topics were included in a summarized way, <br>so that students could achieve a global view of them and </span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">273</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="16004.png" alt="background image">
<DIV style="position:absolute;top:109;left:81"><nobr><span class="ft9">understand the main issues involved. The rest of the topics could <br>potentially be taught more deeply, but without forgetting that they <br>were offered to freshmen. </span></nobr></DIV>
<DIV style="position:absolute;top:165;left:81"><nobr><span class="ft9">In terms of Bloom's taxonomy [2], the three topics above can be <br>mastered at the knowledge level, or even comprehension level. <br>However, for the rest of topics, we can expect students to achieve <br>the application and analysis levels, at least. </span></nobr></DIV>
<DIV style="position:absolute;top:247;left:81"><nobr><span class="ft1">3.2  Overlapping with Other Courses </span></nobr></DIV>
<DIV style="position:absolute;top:268;left:81"><nobr><span class="ft9">Some topics are also offered in other courses, either in the same <br>or in a subsequent year. Consequently, these topics can be <br>removed or dealt with more shallowly. The most probable <br>conflicts are: </span></nobr></DIV>
<DIV style="position:absolute;top:339;left:81"><nobr><span class="ft3">·  Imperative programming, either procedural or object-oriented. </span></nobr></DIV>
<DIV style="position:absolute;top:365;left:81"><nobr><span class="ft3">·  Grammars and formal languages. </span></nobr></DIV>
<DIV style="position:absolute;top:391;left:81"><nobr><span class="ft3">·  Language processors. </span></nobr></DIV>
<DIV style="position:absolute;top:417;left:81"><nobr><span class="ft9">In our case, there is an annual course on programming <br>methodology based on the imperative paradigm, but the other two <br>topics are not included in the curriculum. The programming <br>methodology course is offered in the first academic year. </span></nobr></DIV>
<DIV style="position:absolute;top:490;left:81"><nobr><span class="ft9">Consequently, we removed the imperative paradigm, except for <br>its use in some illustrating examples, mainly in part V. However, <br>we kept chapters on grammars and formal languages, and on <br>language processors. </span></nobr></DIV>
<DIV style="position:absolute;top:572;left:81"><nobr><span class="ft1">3.3  Preferences and Specialization of Faculty </span></nobr></DIV>
<DIV style="position:absolute;top:592;left:81"><nobr><span class="ft9">This factor is important in order to choose among equally eligible <br>options, or to give broader coverage of some topics. In particular, <br>faculty can be more familiar with some paradigms than with <br>others. This was over-riding for our choice of the programming <br>paradigm. </span></nobr></DIV>
<DIV style="position:absolute;top:680;left:81"><nobr><span class="ft9">In subsection 2.3 we discussed suitable paradigms for freshmen, <br>and we concluded that Computing Curricula 2001 fosters the <br>selection of the procedural, object-oriented, and functional <br>paradigms. We discarded the procedural paradigm as it is <br>concurrently taught in the programming methodology courses. <br>Finally, our specialization gave priority to the functional <br>paradigm over object-orientation. The reader can find many <br>experiences in the literature, but we recommend a monograph on <br>functional programming in education [13]. </span></nobr></DIV>
<DIV style="position:absolute;top:832;left:81"><nobr><span class="ft9">Functional programming is a paradigm with several advantages, <br>such as short definition of languages, simple and concise <br>programs, high level of abstraction, etc. However, its main <br>advantage for us is richness of elements. This allows us to deal <br>with many aspects of programming languages (e.g. data types, <br>recursion, polymorphism, etc.) in a natural and easy way. </span></nobr></DIV>
<DIV style="position:absolute;top:936;left:81"><nobr><span class="ft9">The use of tiny languages is another attractive choice in a course <br>for freshmen. However, we also discarded them in favor of the <br>functional paradigm because they have fewer language elements. </span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:81"><nobr><span class="ft1">3.4  Coherence and Unifying Themes </span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:81"><nobr><span class="ft9">A key issue in a course based on several approaches is to provide <br>contents coherence. A network of relationships among the <br>different parts makes possible their coherent integration. </span></nobr></DIV>
<DIV style="position:absolute;top:109;left:477"><nobr><span class="ft9">Part III (description and processing of languages) is the pragmatic <br>continuation of part II (formal grammars). Thus, EBNF and <br>syntactic charts are introduced in part III as more adequate <br>notations for language description than pure grammar definitions. <br>Language processing is given at a conceptual level, but the role of <br>regular and syntax-free grammars in the architecture of language <br>processors is highlighted. <br>Parts IV and V are both based on a functional language, which is <br>described with the tools given in part III, mainly EBNF and type <br>constraints. <br>Parts IV and V are also related because they are based on the <br>same language. In order to provide more homogeneity, language <br>elements studied in part V are introduced in a universal way, but <br>they are mainly illustrated with the functional paradigm. <br>Last, but not least, recursion is adopted as a recurring theme <br>during the course. In effect, it is found in grammars, functions and <br>data types. The recurrent presentation of this topic fosters deeper <br>understanding by students. </span></nobr></DIV>
<DIV style="position:absolute;top:421;left:477"><nobr><span class="ft9">The "pure" definition of recursion is given early in the course, but <br>its three instantiations enumerated above are studied later. For <br>each instantiation, the mechanisms that accompany a recursive <br>definition are clearly identified, in particular representation of <br>information and operational semantics [16]. For instance, <br>recursive grammars represent sentences as strings of terminal <br>symbols, and its operating semantics is defined in terms of <br>derivation of sentences. However, recursive functions represent <br>information as expressions, and its operating semantics is defined <br>in terms of term rewriting. </span></nobr></DIV>
<DIV style="position:absolute;top:598;left:477"><nobr><span class="ft1">3.5  Time Constraints </span></nobr></DIV>
<DIV style="position:absolute;top:618;left:477"><nobr><span class="ft9">As a final factor, time constraints limit the depth of study of those <br>topics that could be studied longer. A global view of the course <br>schedule is given in Table 2. </span></nobr></DIV>
<DIV style="position:absolute;top:675;left:567"><nobr><span class="ft3">Table 2  Schedule of the course </span></nobr></DIV>
<DIV style="position:absolute;top:698;left:538"><nobr><span class="ft3">Part </span></nobr></DIV>
<DIV style="position:absolute;top:698;left:593"><nobr><span class="ft3">Theory #hours </span></nobr></DIV>
<DIV style="position:absolute;top:698;left:709"><nobr><span class="ft3">Lab #hours </span></nobr></DIV>
<DIV style="position:absolute;top:723;left:527"><nobr><span class="ft3">Part I </span></nobr></DIV>
<DIV style="position:absolute;top:723;left:632"><nobr><span class="ft3">5 </span></nobr></DIV>
<DIV style="position:absolute;top:723;left:738"><nobr><span class="ft3">- </span></nobr></DIV>
<DIV style="position:absolute;top:748;left:527"><nobr><span class="ft3">Part II </span></nobr></DIV>
<DIV style="position:absolute;top:748;left:629"><nobr><span class="ft3">14 </span></nobr></DIV>
<DIV style="position:absolute;top:748;left:739"><nobr><span class="ft3">8 </span></nobr></DIV>
<DIV style="position:absolute;top:774;left:527"><nobr><span class="ft3">Part III </span></nobr></DIV>
<DIV style="position:absolute;top:774;left:629"><nobr><span class="ft3">10 </span></nobr></DIV>
<DIV style="position:absolute;top:774;left:738"><nobr><span class="ft3">- </span></nobr></DIV>
<DIV style="position:absolute;top:800;left:527"><nobr><span class="ft3">Part IV </span></nobr></DIV>
<DIV style="position:absolute;top:800;left:629"><nobr><span class="ft3">12 </span></nobr></DIV>
<DIV style="position:absolute;top:800;left:739"><nobr><span class="ft3">6 </span></nobr></DIV>
<DIV style="position:absolute;top:825;left:527"><nobr><span class="ft3">Part V </span></nobr></DIV>
<DIV style="position:absolute;top:825;left:632"><nobr><span class="ft3">8 </span></nobr></DIV>
<DIV style="position:absolute;top:825;left:739"><nobr><span class="ft3">6 </span></nobr></DIV>
<DIV style="position:absolute;top:851;left:527"><nobr><span class="ft3">Part VI </span></nobr></DIV>
<DIV style="position:absolute;top:851;left:632"><nobr><span class="ft3">4 </span></nobr></DIV>
<DIV style="position:absolute;top:851;left:739"><nobr><span class="ft3">2 </span></nobr></DIV>
<DIV style="position:absolute;top:876;left:477"><nobr><span class="ft9"> <br>In part II (formal grammars), regular and context-free grammars <br>are the only ones studied in depth because of their importance for <br>language description and processing. <br>Moreover, only one paradigm can be studied in depth. Even so, <br>the lack of time limits the presentation of functional programming <br>(parts IV and V) to the core elements of the paradigm. Other <br>elements, important for the functional programmer, can not be <br>addressed (e.g. higher-order, lazy evaluation, or currification). <br>However, this is not a serious drawback since the aim of including <br>functional programming in the course is teaching the essentials of <br>a new paradigm as well as illustrating language elements. </span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">274</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft13{font-size:7px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="16005.png" alt="background image">
<DIV style="position:absolute;top:109;left:81"><nobr><span class="ft1">4.  LABORATORY COURSEWARE </span></nobr></DIV>
<DIV style="position:absolute;top:130;left:81"><nobr><span class="ft9">A course on programming languages must have a laboratory <br>component. The laboratory schedule includes sessions for those <br>parts of the course where problem solving can be faced, mainly <br>formal grammars and functional programming. Laboratory tools <br>were selected carefully so that they are adequate for freshmen to <br>exercise non-trivial concepts; simple user interaction and <br>visualization facilities are of great help here. There are a number <br>of tools that fulfill these requirements. For formal grammars, we <br>require simulators that allow at least manipulating regular <br>expressions, finite automata, context-free grammars and <br>derivation trees. Our final selection was JFLAP [11]. For <br>functional programming, we require a programming environment <br>that shows term rewriting as the operational semantics. Our final <br>selection was WinHIPE [15]. </span></nobr></DIV>
<DIV style="position:absolute;top:367;left:81"><nobr><span class="ft1">5.  EXPERIENCE </span></nobr></DIV>
<DIV style="position:absolute;top:387;left:81"><nobr><span class="ft9">We have been teaching this course for seven years. Although the <br>basic structure has roughly been constant, it was refined <br>according to our experience. In particular, the emphasis on <br>recursion was introduced after several years as we noticed student <br>problems with this concept. We consider that we have succeeded, <br>at least in eliminating the magical connotation of recursion. </span></nobr></DIV>
<DIV style="position:absolute;top:492;left:81"><nobr><span class="ft9">A major change was the relative order of chapters on formal <br>grammars and the functional paradigm. During the first year, they <br>were given in reverse order. However, students had problems in <br>understanding the syntax of functional declarations that led us to <br>teach in the first place formal grammars (and therefore syntax <br>notations such as EBNF). Thus, a foundation to declare syntax <br>was laid and then used to introduce functional programming. </span></nobr></DIV>
<DIV style="position:absolute;top:611;left:81"><nobr><span class="ft9">The literature classifies the main difficulties for teaching <br>functional programming into syntactical, conceptual and <br>"psychological" problems [13]. In our approach, the two former <br>kinds of problems are avoided, but the latter remains. As <br>freshmen learn concurrently the functional and one imperative <br>language, they get the idea that functional is an exotic, useless <br>paradigm. </span></nobr></DIV>
<DIV style="position:absolute;top:741;left:81"><nobr><span class="ft1">6.  CONCLUSION </span></nobr></DIV>
<DIV style="position:absolute;top:761;left:81"><nobr><span class="ft9">We have described a course on programming languages for <br>freshmen. It comprises elements from four different approaches. <br>We have described the contents of the course, and we have <br>explained the factors that led us to its current design. The <br>experience has been very positive both for teachers and for <br>students. As the Denning report sought for CS1, we consider that <br>our course illustrates that it is feasible to offer some traditionally <br>intermediate or advanced matters in introductory courses. </span></nobr></DIV>
<DIV style="position:absolute;top:904;left:81"><nobr><span class="ft1">7.  ACKNOWLEDGMENTS </span></nobr></DIV>
<DIV style="position:absolute;top:924;left:81"><nobr><span class="ft9">This work is supported by the research project TIN2004-07568 of <br>the Spanish Ministry of Education and Science. </span></nobr></DIV>
<DIV style="position:absolute;top:974;left:81"><nobr><span class="ft1">8.  REFERENCES </span></nobr></DIV>
<DIV style="position:absolute;top:995;left:81"><nobr><span class="ft3">[1]  Abelson, H., and Sussman, G.J. Structure and Interpretation of </span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:108"><nobr><span class="ft3">Computer Programs. MIT Press, 2ª ed., 1996. </span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:81"><nobr><span class="ft3">[2]  Bloom, B., Furst, E., Hill, W., and Krathwohl, D.R. </span></nobr></DIV>
<DIV style="position:absolute;top:1048;left:108"><nobr><span class="ft9">Taxonomy of Educational Objectives: Handbook I, The <br>Cognitive Domain. Addison-Wesley, 1959. </span></nobr></DIV>
<DIV style="position:absolute;top:109;left:477"><nobr><span class="ft3">[3]  Curriculum Committee on Computer Science. Curriculum </span></nobr></DIV>
<DIV style="position:absolute;top:124;left:504"><nobr><span class="ft9">'68: Recommendations for academic programs in computer <br>science. Comm. ACM, 11, 3 (March 1968), 151-197. </span></nobr></DIV>
<DIV style="position:absolute;top:162;left:477"><nobr><span class="ft3">[4]  Denning, P. et al. Computing as a Discipline. ACM Press, </span></nobr></DIV>
<DIV style="position:absolute;top:178;left:504"><nobr><span class="ft3">New York, 1988. </span></nobr></DIV>
<DIV style="position:absolute;top:200;left:477"><nobr><span class="ft3">[5]  Fischer, A.E., and Grodzinsky, F.S. The Anatomy of </span></nobr></DIV>
<DIV style="position:absolute;top:216;left:504"><nobr><span class="ft3">Programming Languages. Prentice-Hall, 1993. </span></nobr></DIV>
<DIV style="position:absolute;top:238;left:477"><nobr><span class="ft3">[6]  Kamin, S.N. Programming Languages: An Interpreter-Based </span></nobr></DIV>
<DIV style="position:absolute;top:253;left:504"><nobr><span class="ft3">Approach. Addison-Wesley, 1990. </span></nobr></DIV>
<DIV style="position:absolute;top:275;left:477"><nobr><span class="ft3">[7]  King, K.N. The evolution of the programming languages </span></nobr></DIV>
<DIV style="position:absolute;top:291;left:504"><nobr><span class="ft3">course. In 23</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:574"><nobr><span class="ft13"><i>rd</i></span></nobr></DIV>
<DIV style="position:absolute;top:291;left:582"><nobr><span class="ft3"> SIGCSE Technical Symposium on Computer </span></nobr></DIV>
<DIV style="position:absolute;top:307;left:504"><nobr><span class="ft9">Science Education (SIGCSE'92). ACM Press, New York, <br>1992, 213-219. </span></nobr></DIV>
<DIV style="position:absolute;top:345;left:477"><nobr><span class="ft3">[8]  Kolesar, M.V., and Allan, V.H. Teaching computer science </span></nobr></DIV>
<DIV style="position:absolute;top:360;left:504"><nobr><span class="ft3">concepts and problem solving with a spreadsheet. In 26</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:804"><nobr><span class="ft13"><i>th</i></span></nobr></DIV>
<DIV style="position:absolute;top:360;left:811"><nobr><span class="ft3"> </span></nobr></DIV>
<DIV style="position:absolute;top:376;left:504"><nobr><span class="ft9">SIGCSE Technical Symposium on Computer Science <br>Education (SIGCSE'95). ACM Press, New York, 1995, 10-<br>13. </span></nobr></DIV>
<DIV style="position:absolute;top:430;left:477"><nobr><span class="ft3">[9]  Maurer, W.D. The comparative programming languages </span></nobr></DIV>
<DIV style="position:absolute;top:446;left:504"><nobr><span class="ft3">course: A new chain of development. In 33</span></nobr></DIV>
<DIV style="position:absolute;top:444;left:738"><nobr><span class="ft13"><i>rd</i></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:746"><nobr><span class="ft3"> SIGCSE </span></nobr></DIV>
<DIV style="position:absolute;top:462;left:504"><nobr><span class="ft9">Technical Symposium on Computer Science Education <br>(SIGCSE 2002). ACM Press, New York, 2002, 336-340. </span></nobr></DIV>
<DIV style="position:absolute;top:499;left:477"><nobr><span class="ft3">[10] Popyack, J.L., and Herrmann, N. Why everyone should </span></nobr></DIV>
<DIV style="position:absolute;top:515;left:504"><nobr><span class="ft9">know how to program a computer. In IFIP World <br>Conference on Computers in Education VI (WCCE'95). <br>Chapman &amp; Hall, 1995, 603-612. </span></nobr></DIV>
<DIV style="position:absolute;top:569;left:477"><nobr><span class="ft3">[11]  Hung, T., and Rodger, S.H. Increasing visualization and </span></nobr></DIV>
<DIV style="position:absolute;top:584;left:504"><nobr><span class="ft3">interaction in the automata theory course. In 31</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:761"><nobr><span class="ft13"><i>st</i></span></nobr></DIV>
<DIV style="position:absolute;top:584;left:767"><nobr><span class="ft3"> SIGCSE </span></nobr></DIV>
<DIV style="position:absolute;top:600;left:504"><nobr><span class="ft9">Technical Symposium on Computer Science Education <br>(SIGCSE 2000). ACM Press, New York, 2000, 6-10. </span></nobr></DIV>
<DIV style="position:absolute;top:638;left:477"><nobr><span class="ft3">[12] The Joint Task Force on Computing Curricula IEEE-</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:504"><nobr><span class="ft9">CS/ACM: Computing Curricula 2001­ Computer Science, <br>http://www.computer.org/education/cc2001/final, 2001. </span></nobr></DIV>
<DIV style="position:absolute;top:692;left:477"><nobr><span class="ft3">[13] Thomson, S., and Wadler, P. (eds.) Functional programming </span></nobr></DIV>
<DIV style="position:absolute;top:707;left:504"><nobr><span class="ft9">in education. Journal of Functional Programming, 3, 1 <br>(1993). </span></nobr></DIV>
<DIV style="position:absolute;top:745;left:477"><nobr><span class="ft3">[14] Tucker, A.B., and Noonan, R.E. Integrating formal models </span></nobr></DIV>
<DIV style="position:absolute;top:761;left:504"><nobr><span class="ft3">into the programming languages course. In 33</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:753"><nobr><span class="ft13"><i>rd</i></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:761"><nobr><span class="ft3"> SIGCSE </span></nobr></DIV>
<DIV style="position:absolute;top:777;left:504"><nobr><span class="ft9">Technical Symposium on Computer Science Education <br>(SIGCSE 2002). ACM Press, New York, 2002, 346-350. </span></nobr></DIV>
<DIV style="position:absolute;top:815;left:477"><nobr><span class="ft3">[15] Velázquez-Iturbide, J.Á.  Improving functional programming </span></nobr></DIV>
<DIV style="position:absolute;top:830;left:504"><nobr><span class="ft9">environments for education. In M. D. Brouwer-Hanse y T. <br>Harrington (eds.), Man-Machine Communication for <br>Educational Systems Design. Springer-Verlag, NATO ASI <br>Series F 124, 1994, 325-332. </span></nobr></DIV>
<DIV style="position:absolute;top:900;left:477"><nobr><span class="ft3">[16] Velázquez-Iturbide, J.Á. Recursion in gradual steps (is </span></nobr></DIV>
<DIV style="position:absolute;top:916;left:504"><nobr><span class="ft3">recursion really that difficult?). In 31</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:705"><nobr><span class="ft13"><i>st</i></span></nobr></DIV>
<DIV style="position:absolute;top:916;left:711"><nobr><span class="ft3"> SIGCSE Technical </span></nobr></DIV>
<DIV style="position:absolute;top:931;left:504"><nobr><span class="ft9">Symposium on Computer Science Education (SIGCSE 2000). <br>ACM Press, New York, 2000, 310-314. </span></nobr></DIV>
<DIV style="position:absolute;top:969;left:477"><nobr><span class="ft3">[17] Wick, M.R., and Stevenson, D.E. A reductionistic approach </span></nobr></DIV>
<DIV style="position:absolute;top:985;left:504"><nobr><span class="ft3">to a course on programming languages. In 32</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:749"><nobr><span class="ft13"><i>nd</i></span></nobr></DIV>
<DIV style="position:absolute;top:985;left:758"><nobr><span class="ft3"> SIGCSE </span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:504"><nobr><span class="ft9">Technical Symposium on Computer Science Education <br>(SIGCSE 2001). ACM Press, New York, 2001, 253-257.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">275</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
