<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Learning Query Languages of Web Interfaces</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="author" content="Bergholz, André; Chidlovskii, Boris">
<META name="date" content="2004-02-05T09:32:34+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1269;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Helvetica;color:#000000;}
	.ft1{font-size:15px;font-family:Helvetica;color:#000000;}
	.ft2{font-size:12px;font-family:Helvetica;color:#000000;}
	.ft3{font-size:15px;font-family:Times;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:9px;font-family:Times;color:#000000;}
	.ft6{font-size:9px;font-family:Times;color:#000000;}
	.ft7{font-size:14px;font-family:Helvetica;color:#000000;}
	.ft8{font-size:13px;font-family:Times;color:#000000;}
	.ft9{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft10{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1269" src="124001.png" alt="background image">
<DIV style="position:absolute;top:115;left:168"><nobr><span class="ft0"><b>Learning Query Languages of Web Interfaces</b></span></nobr></DIV>
<DIV style="position:absolute;top:183;left:226"><nobr><span class="ft1">Andr ´e Bergholz</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:184"><nobr><span class="ft2">Xerox Research Centre Europe</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:130"><nobr><span class="ft2">6 chemin de Maupertuis, 38240 Meylan, France</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:184"><nobr><span class="ft1">aberghol@xrce.xerox.com</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:561"><nobr><span class="ft1">Boris Chidlovskii</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:523"><nobr><span class="ft2">Xerox Research Centre Europe</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:469"><nobr><span class="ft2">6 chemin de Maupertuis, 38240 Meylan, France</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:517"><nobr><span class="ft1">chidlovskii@xrce.xerox.com</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:81"><nobr><span class="ft3"><b>ABSTRACT</b></span></nobr></DIV>
<DIV style="position:absolute;top:343;left:81"><nobr><span class="ft9">This paper studies the problem of automatic acquisition of<br>the query languages supported by a Web information re-<br>source. We describe a system that automatically probes the<br>search interface of a resource with a set of test queries and<br>analyses the returned pages to recognize supported query<br>operators.</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:155"><nobr><span class="ft4">The automatic acquisition assumes the avail-</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:81"><nobr><span class="ft9">ability of the number of matches the resource returns for<br>a submitted query. The match numbers are used to train<br>a learning system and to generate classification rules that<br>recognize the query operators supported by a provider and<br>their syntactic encodings. These classification rules are em-<br>ployed during the automatic probing of new providers to<br>determine query operators they support. We report on re-<br>sults of experiments with a set of real Web resources.</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:81"><nobr><span class="ft3"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:603;left:81"><nobr><span class="ft4">Hidden Web, search interface, query operators, learning</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:81"><nobr><span class="ft3"><b>1.</b></span></nobr></DIV>
<DIV style="position:absolute;top:635;left:112"><nobr><span class="ft3"><b>INTRODUCTION</b></span></nobr></DIV>
<DIV style="position:absolute;top:657;left:94"><nobr><span class="ft4">Searching for relevant information is a primary activity</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:81"><nobr><span class="ft4">on the Web.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:172"><nobr><span class="ft4">Often, people search for information using</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:81"><nobr><span class="ft9">general-purpose search engines, such as Google or Yahoo!,<br>which collect and index billions of Web pages. However,<br>there exists an important part of the Web that remains un-<br>available for centralized indexing. This so-called "hidden"<br>part of the Web includes the content of local databases and<br>document collections accessible through search interfaces of-<br>fered by various small- and middle-sized Web sites, including<br>company sites, university sites, media sites, etc. According<br>to the study conducted by BrightPlanet in 2000 [6], the size<br>of the Hidden Web is about 400 to 550 times larger than the<br>commonly defined (or "Visible") World Wide Web. This<br>surprising discovery has fed new research on collecting and<br>organizing the Hidden Web resources [1, 2, 15, 17, 19].</span></nobr></DIV>
<DIV style="position:absolute;top:893;left:94"><nobr><span class="ft4">Commercial approaches to the Hidden Web are usually in</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:81"><nobr><span class="ft9">the shape of Yahoo!-like directories which organize local sites<br>belonging to specific domains. Some important examples</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:81"><nobr><span class="ft10">Permission to make digital or hard copies of all or part of this work for<br>personal or classroom use is granted without fee provided that copies are<br>not made or distributed for profit or commercial advantage and that copies<br>bear this notice and the full citation on the first page. To copy otherwise, to<br>republish, to post on servers or to redistribute to lists, requires prior specific<br>permission and/or a fee.<br><i>SAC </i>'04, March 14-17, 2004, Nicosia, Cyprus<br>Copyright 2004 ACM 1-58113-812-1/03/04 ...</span></nobr></DIV>
<DIV style="position:absolute;top:1076;left:303"><nobr><span class="ft4">$</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:310"><nobr><span class="ft5">5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:475"><nobr><span class="ft9">of such directories are InvisibleWeb[1] and BrightPlanet[2]<br>whose gateway site, CompletePlanet[3], is a directory as<br>well as a meta-search engine. For each database incorpo-<br>rated into its search, the meta-search engine is provided with<br>a manually written "wrapper", a software component that<br>specifies how to submit queries and extract query answers<br>embedded into HTML-formatted result pages.</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:489"><nobr><span class="ft4">Similar to the Visible Web, search resources on the Hidden</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:475"><nobr><span class="ft9">Web are highly heterogeneous. In particular, they use dif-<br>ferent document retrieval models, such as Boolean or vector-<br>space models. They allow different operators for the query<br>formulation and, moreover, the syntax of supported oper-<br>ators can vary from one site to another. Conventionally,<br>query languages are determined manually; reading the help<br>pages associated with a given search interface, probing the<br>interface with sample queries and checking the result pages<br>is often the method of choice.</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:489"><nobr><span class="ft4">The manual acquisition of Web search interfaces has im-</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:475"><nobr><span class="ft9">portant drawbacks. First, the manual approach is hardly<br>scalable to thousands of search resources that compose the<br>Hidden Web. Second, the manual testing of Web resources<br>with probe queries is often error-prone due to the inability<br>to check results. Third, cases of incorrect or incomplete help<br>pages are frequent. Operators that are actually supported<br>by an engine may not be mentioned in the help pages, and<br>conversely, help pages might mention operators that are not<br>supported by the engine.</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:489"><nobr><span class="ft4">To overcome the shortcomings of the manual approach,</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:475"><nobr><span class="ft9">we address the problem of acquiring the query languages of<br>Web resources in an automatic manner. We develop a sys-<br>tem that automatically probes a resource's search interface<br>with a set of test queries and analyses the returned pages to<br>recognize supported query operators. The automatic acqui-<br>sition assumes the availability of the number of matches the<br>resource returns for a submitted query. The match numbers<br>are used to train a learning system and to generate classi-<br>fication rules that recognize the query operators supported<br>by a provider and their syntactic encodings.</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:489"><nobr><span class="ft4">New technologies surrounding the XML syntax standard,</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:475"><nobr><span class="ft9">in particular Web Services [18], establish a new basis for au-<br>tomatic discovery and information exchange and are becom-<br>ing widely employed in corporate applications.</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:779"><nobr><span class="ft4">However,</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:475"><nobr><span class="ft9">this has yet to happen for thousands of public information<br>providers. The question of when and how they will move<br>toward open cooperation using Web Service technologies re-<br>mains widely open [4]. Instead, the query-probing approach<br>for acquiring supported operators does not assume any co-<br>operation of Web providers; its only requirement is that they</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:441"><nobr><span class="ft7">1114</span></nobr></DIV>
<DIV style="position:absolute;top:48;left:587"><nobr><span class="ft8">2004 ACM Symposium on Applied Computing</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1269;">
<STYLE type="text/css">
<!--
	.ft11{font-size:6px;font-family:Times;color:#000000;}
	.ft12{font-size:11px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1269" src="124002.png" alt="background image">
<DIV style="position:absolute;top:92;left:81"><nobr><span class="ft4">provide an accessible interface and allow queries to be run.</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:94"><nobr><span class="ft4">This paper is organized as follows. In Section 2 we discuss</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:81"><nobr><span class="ft9">the heterogeneity of Web interfaces; we formalize the prob-<br>lem and show its connection with the concept of learning by<br>querying in Section 3. In Section 4 we design a classifier sys-<br>tem for the automatic acquisition of a query language and<br>investigate different aspects of the system. In Section 6 we<br>review the prior art; in Section 5 we present experimental<br>results to illustrate the performance of our system. Section 7<br>discusses open issues and Section 8 concludes the paper.</span></nobr></DIV>
<DIV style="position:absolute;top:266;left:81"><nobr><span class="ft3"><b>2.</b></span></nobr></DIV>
<DIV style="position:absolute;top:266;left:112"><nobr><span class="ft3"><b>QUERYING WEB RESOURCES</b></span></nobr></DIV>
<DIV style="position:absolute;top:288;left:94"><nobr><span class="ft4">Web resources vary considerably in the ways they retrieve</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:81"><nobr><span class="ft9">relevant documents. In the theory of information retrieval,<br>there exist at least five basic retrieval models, but only three<br>of these models are visible on the Web, namely the Boolean,<br>the extended Boolean and the vector-space models. In the<br>Boolean query model, a query is a condition, which docu-<br>ments either do or do not satisfy, with the query result being<br>a set of documents. In the vector-space model, a query is<br>a list of terms, and documents are assigned a score accord-<br>ing to how similar they are to the query. The query result<br>is a ranked list of documents. A document in the query re-<br>sult might not contain all query terms. Finally, the extended<br>Boolean model combines the advantages of both the Boolean<br>and the vector-space query model. In this model, keywords<br>can be preceded by special characters (like + and - ) re-<br>quiring an obligatory presence or absence of a given key-<br>word in a document. For example, the query +information<br>+provider will retrieve all documents containing both key-<br>words and rank them according to some similarity function.</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:94"><nobr><span class="ft4">Analysis of information providers suggests that the major-</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:81"><nobr><span class="ft9">ity of providers adopt one of the three basic models. More-<br>over, beyond query answers, many resources report the num-<br>ber of documents in their collections matching the query. If<br>a resource deploys the (extended) Boolean model, the match<br>number shows how many documents match the query. In the<br>case of the vector-space model, the match number refers to<br>documents containing at least one query term, thus being<br>equivalent to the Boolean disjunction.</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:94"><nobr><span class="ft4">In the following, we develop an approach for automatic</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:81"><nobr><span class="ft9">determination of query operators by reasoning on submit-<br>ted queries and corresponding match numbers. Though this<br>approach excludes resources that do not report match num-<br>bers, other ways of automatic detection of query operators<br>appear even more problematic and difficult to implement. A<br>method based on downloading answer documents and veri-<br>fying the query against their content often fails, either for le-<br>gal reasons, when the content of documents is unavailable or<br>password-protected, or for technical reasons, when a query<br>matches millions of documents and downloading even a part<br>of them requires prohibitive time and network resources.</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:81"><nobr><span class="ft3"><b>2.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:925;left:121"><nobr><span class="ft3"><b>Query language model</b></span></nobr></DIV>
<DIV style="position:absolute;top:947;left:94"><nobr><span class="ft4">A query language of a Web provider includes a set of basic</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:81"><nobr><span class="ft9">operators and the way of combining the operators to get<br>complex queries. Basic operators have different arities, in<br>particular, the default term processing and the unary and<br>binary operators. The default processing refers primarily<br>to case sensitivity in this paper, but we could also refer to<br>whether the query term is treated as a complete word or as a<br>substring in a possible matching document. Unary operators<br>include the Stem-operator, which replaces a query term with</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:475"><nobr><span class="ft9">its lexem; binary operators include the Boolean operators <br>(conjunction),  (disjunction), and ¬ (negation)</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:774"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:786"><nobr><span class="ft4">and the</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:475"><nobr><span class="ft9">operator P hrase which requires the adjacency of all terms<br>in a document.</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:489"><nobr><span class="ft4">Some other operators, like substring matching or word</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:475"><nobr><span class="ft9">proximity operators have been studied in various systems,<br>however the six query operators mentioned above are by far<br>the ones most frequently supported by Web interfaces. In<br>the following, we develop a method to cope with the operator<br>set O = {Case, Stem, , , ¬, P hrase}. Issues relevant<br>to the possible extension of set O with other operators are<br>delegated to Section 7.</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:475"><nobr><span class="ft3"><b>2.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:516"><nobr><span class="ft3"><b>Query interpretation</b></span></nobr></DIV>
<DIV style="position:absolute;top:312;left:489"><nobr><span class="ft4">Web providers are queried by filling their search forms</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:475"><nobr><span class="ft9">with query strings. CGI or JavaScript code linked to the<br>query form interprets the query strings according to certain<br>rules.</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:520"><nobr><span class="ft4">These rules allow syntactic encodings for the sup-</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:475"><nobr><span class="ft9">ported query operators. If correctly interpreted, the query<br>is executed on the document collection before a (full or par-<br>tial) answer is reported to the user.</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:489"><nobr><span class="ft4">Unfortunately, the same query operator may be encoded</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:475"><nobr><span class="ft9">differently by different providers. For example, the Boolean<br>conjunction is often encoded as A AND B , A B , or +A<br>+B , where A and B are query terms. Worse, two providers<br>can interpret the same query string differently. For example,<br>query string A B can be interpreted as a Boolean conjunc-<br>tion, Boolean disjunction, or P hrase.</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:490"><nobr><span class="ft4">Example 1. To illustrate the problem, consider the query</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:475"><nobr><span class="ft4">string q = Casablanca AND Bogart .</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:718"><nobr><span class="ft4">On Google, AND</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:475"><nobr><span class="ft4">is interpreted as the Boolean conjunction, that is, i</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:799"><nobr><span class="ft11">Google</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:475"><nobr><span class="ft9">( Casablanca AND Bogart ) = Casablanca  Bogart . As<br>a result, query q matches 24,500 pages at Google, as op-<br>posed to 551,000 for query q</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:659"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:665"><nobr><span class="ft4">= Casablanca and 263,000</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:475"><nobr><span class="ft4">for q</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:504"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:510"><nobr><span class="ft4">= Bogart . On the Internet Movie Database (IMDB)</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:475"><nobr><span class="ft9">(http://www.imdb.com/.), AND is taken literally and all<br>terms in a query are implicitly OR-connected. Therefore, the<br>IMDB interprets query q as follows: i</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:715"><nobr><span class="ft11">IM DB</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:757"><nobr><span class="ft4">( Casablanca</span></nobr></DIV>
<DIV style="position:absolute;top:701;left:475"><nobr><span class="ft9">AND Bogart ) = Casablanca  AND  Bogart . The<br>query returns 12,020 matches documents on IMDB, as op-<br>posed to only 22 for q</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:603"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:609"><nobr><span class="ft4">= Casablanca and 4 for q</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:765"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:771"><nobr><span class="ft4">= Bogart .</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:489"><nobr><span class="ft4">If we investigate an unknown query language, then Exam-</span></nobr></DIV>
<DIV style="position:absolute;top:775;left:475"><nobr><span class="ft9">ple 1 shows that observing match numbers for probe queries<br>can provide a good insight into the supported operators.<br>However, no definitive decision appears possible from the<br>three queries above q, q</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:619"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:625"><nobr><span class="ft4">, q</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:640"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:647"><nobr><span class="ft4">. An accurate decision on sup-</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:475"><nobr><span class="ft9">ported operators/syntaxes will require probing the provider<br>with other queries and comparing all match numbers in or-<br>der to confirm or reject various hypotheses.</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:490"><nobr><span class="ft4">Example 2. As in Example 1, let us compare match num-</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:475"><nobr><span class="ft4">bers for the queries q= Casablanca AND Bogart , q</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:778"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:785"><nobr><span class="ft4">= Casa-</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:475"><nobr><span class="ft4">blanca , and q</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:556"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:563"><nobr><span class="ft4">= Bogart . For Google, the fact that q matches</span></nobr></DIV>
<DIV style="position:absolute;top:944;left:475"><nobr><span class="ft4">less documents than any of q</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:642"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:944;left:652"><nobr><span class="ft4">and q</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:684"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:944;left:690"><nobr><span class="ft4">, favors the Conjunction-</span></nobr></DIV>
<DIV style="position:absolute;top:960;left:475"><nobr><span class="ft9">hypotheses, but is still insufficient to exclude other hypothe-<br>ses, like that of P hrase. Probing Google with query q</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:817"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:976;left:823"><nobr><span class="ft4">=</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:479"><nobr><span class="ft4">Bogart AND Casablanca returns the same number of matched</span></nobr></DIV>
<DIV style="position:absolute;top:1007;left:475"><nobr><span class="ft9">documents as q. This (most likely) discards the P hrase-<br>hypothesis, but not the hypothesis Casablanca  AND </span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:476"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:482"><nobr><span class="ft4">Negation is a binary operator in Web query languages and</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:475"><nobr><span class="ft12">its interpretation is given by 'AND NOT', that is, A ¬ B is<br>a synonym for A ¬ B (the latter using the unary ¬).</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:441"><nobr><span class="ft7">1115</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1269;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1269" src="124003.png" alt="background image">
<DIV style="position:absolute;top:92;left:85"><nobr><span class="ft4">Bogart . To exclude this one, even more queries should be</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft4">sent to Google, like q</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:206"><nobr><span class="ft11">4</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:212"><nobr><span class="ft4">= Casablanca AND , and so on. Sim-</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:81"><nobr><span class="ft9">ilarly in IMDB, the fact that query q matches more docu-<br>ments than q</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:160"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:172"><nobr><span class="ft4">and q</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:205"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:217"><nobr><span class="ft4">suggests that q is processed as a dis-</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:81"><nobr><span class="ft9">junction, but it can not tell whether AND is taken liter-<br>ally or ignored. A deeper analysis requires further probing<br>IMDB with, for example, queries q</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:289"><nobr><span class="ft11">4</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:296"><nobr><span class="ft4">= Casablanca AND or</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:81"><nobr><span class="ft4">q</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:87"><nobr><span class="ft11">5</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:93"><nobr><span class="ft4">= Casablanca Bogart to compare their match numbers to</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:81"><nobr><span class="ft4">the ones of previous queries and decide about the AND .</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:94"><nobr><span class="ft4">Our approach to the automatic acquisition of Web query</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:81"><nobr><span class="ft9">languages formalizes and generalizes the idea described in<br>Examples 1 and 2. We build a learning system that trains<br>a number of classifiers with data from manually annotated<br>sites to automatically determine supported operators and<br>their syntaxes at a new site. The training data from an-<br>notated sites includes an ensemble of test queries together<br>with the corresponding match numbers.</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:81"><nobr><span class="ft3"><b>3.</b></span></nobr></DIV>
<DIV style="position:absolute;top:401;left:112"><nobr><span class="ft3"><b>PROBLEM DEFINITION</b></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:94"><nobr><span class="ft4">Assume an information provider P supports some or all</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:81"><nobr><span class="ft4">query operators in O; these operators form a set O</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:388"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:397"><nobr><span class="ft4">, O</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:416"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:429"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:454;left:81"><nobr><span class="ft4">O and allow us to compose a set of complex queries Q(O</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:421"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:430"><nobr><span class="ft4">).</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:81"><nobr><span class="ft4">For any operator o</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:191"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:199"><nobr><span class="ft4"> O</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:223"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:232"><nobr><span class="ft4">, P accepts one or more syntactical</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:81"><nobr><span class="ft4">encodings, s</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:155"><nobr><span class="ft11">i1</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:166"><nobr><span class="ft4">, s</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:182"><nobr><span class="ft11">i2</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:192"><nobr><span class="ft4">, . . .. The set {s</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:292"><nobr><span class="ft11">ij</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:302"><nobr><span class="ft4">} of accepted syntaxes</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:81"><nobr><span class="ft4">for o</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:108"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:116"><nobr><span class="ft4"> O</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:140"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:153"><nobr><span class="ft4">is denoted S</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:226"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:231"><nobr><span class="ft4">. The interpretation I</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:360"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:373"><nobr><span class="ft4">of operator</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:81"><nobr><span class="ft4">set O</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:114"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:129"><nobr><span class="ft4">is defined as I</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:218"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:233"><nobr><span class="ft4">= {(o</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:269"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:274"><nobr><span class="ft4">, s</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:287"><nobr><span class="ft11">ij</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:296"><nobr><span class="ft4">)|o</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:312"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:323"><nobr><span class="ft4"> O</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:349"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:358"><nobr><span class="ft4">, s</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:371"><nobr><span class="ft11">ij</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:387"><nobr><span class="ft4"> S</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:411"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:416"><nobr><span class="ft4">} =</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:81"><nobr><span class="ft4">{(o</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:100"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:104"><nobr><span class="ft4">, S</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:119"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:124"><nobr><span class="ft4">)|o</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:140"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:149"><nobr><span class="ft4"> O</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:173"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:182"><nobr><span class="ft4">}. Interpretation I</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:296"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:310"><nobr><span class="ft4">is monovalued if each</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:81"><nobr><span class="ft4">operator has at most one syntax, i.e, |S</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:312"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:317"><nobr><span class="ft4">| = 1 for all o</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:394"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:403"><nobr><span class="ft4"> O</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:426"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:436"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:564;left:81"><nobr><span class="ft4">I</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:87"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:564;left:101"><nobr><span class="ft4">is multivalued, if it allows multiple syntaxes for at least</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:81"><nobr><span class="ft4">one operator, i.e., o</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:208"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:217"><nobr><span class="ft4"> O</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:241"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:255"><nobr><span class="ft4">such that |S</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:329"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:334"><nobr><span class="ft4">| &gt; 1. In Google,</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:81"><nobr><span class="ft4">the Boolean conjunction can be encoded by both AND and</span></nobr></DIV>
<DIV style="position:absolute;top:611;left:103"><nobr><span class="ft4">(whitespace). Therefore, for any query terms A and B,</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:81"><nobr><span class="ft9">both query strings A B and A AND B are interpreted<br>as A  B. I</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:151"><nobr><span class="ft11">Google</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:191"><nobr><span class="ft4">contains (, AND ) and (,</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:381"><nobr><span class="ft4">) and is a</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:81"><nobr><span class="ft4">multivalued interpretation.</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:94"><nobr><span class="ft4">We distinguish between ambiguous and unambiguous in-</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:81"><nobr><span class="ft4">terpretations. A pair of distinct operator encodings (o</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:407"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:412"><nobr><span class="ft4">, s</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:424"><nobr><span class="ft11">ij</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:434"><nobr><span class="ft4">)</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:81"><nobr><span class="ft4">and (o</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:119"><nobr><span class="ft11">k</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:125"><nobr><span class="ft4">, s</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:138"><nobr><span class="ft11">kl</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:148"><nobr><span class="ft4">) is ambiguous if the two operators have the same</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:81"><nobr><span class="ft4">syntax: o</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:138"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:147"><nobr><span class="ft4">= o</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:170"><nobr><span class="ft11">k</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:182"><nobr><span class="ft4">but s</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:214"><nobr><span class="ft11">ij</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:228"><nobr><span class="ft4">= s</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:250"><nobr><span class="ft11">kl</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:261"><nobr><span class="ft4">. An interpretation I</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:388"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:402"><nobr><span class="ft4">is am-</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:81"><nobr><span class="ft9">biguous, if it contains at least one ambiguous pair of encod-<br>ings. An interpretation I is unambiguous, if for any pair of<br>encodings (o</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:156"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:161"><nobr><span class="ft4">, s</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:174"><nobr><span class="ft11">ij</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:183"><nobr><span class="ft4">) and (o</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:232"><nobr><span class="ft11">k</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:239"><nobr><span class="ft4">, s</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:252"><nobr><span class="ft11">kl</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:262"><nobr><span class="ft4">) in I, o</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:311"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:319"><nobr><span class="ft4">= o</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:340"><nobr><span class="ft11">k</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:351"><nobr><span class="ft4"> s</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:376"><nobr><span class="ft11">ij</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:390"><nobr><span class="ft4">= s</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:411"><nobr><span class="ft11">kl</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:421"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:94"><nobr><span class="ft4">Ambiguous interpretations can be observed with Web pro-</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:81"><nobr><span class="ft9">viders that interpret query strings dynamically, when the fi-<br>nal decision depends on results of the query execution with<br>different retrieval models</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:230"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:236"><nobr><span class="ft4">. However, the major part of Web</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:81"><nobr><span class="ft9">providers interpret query strings unambiguously and our<br>method copes with unambiguous interpretations only. Fur-<br>ther discussion on ambiguous interpretations is in Section 7.</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:94"><nobr><span class="ft4">Like with the query operators, we select the most frequent</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:81"><nobr><span class="ft4">syntaxes on the Web, S = { Default</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:303"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:309"><nobr><span class="ft4">,  ,</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:359"><nobr><span class="ft4">, AND , + ,</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:85"><nobr><span class="ft4">OR , NOT , - , "" (quote marks)}. Like set O, these</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:81"><nobr><span class="ft9">syntaxes have been selected after verification of hundreds<br>of Web providers. Set S is easily extendable to alternative<br>syntaxes, like ones employed by non-English providers. For</span></nobr></DIV>
<DIV style="position:absolute;top:999;left:81"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:88"><nobr><span class="ft4">Citeseer at http://citeseer.nj.nec.com/cs is an exam-</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:81"><nobr><span class="ft12">ple of ambiguous interpretation. By default, it interprets A<br>B as a conjunction; however if A  B matches zero docu-<br>ments, the query is interpreted as disjunction.</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:81"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:88"><nobr><span class="ft4">'Default' refers to the absence of any syntax; it assumes</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:81"><nobr><span class="ft4">the processing of plain terms.</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:475"><nobr><span class="ft9">example, French providers may use ET for the Boolean<br>conjunction and OU for the disjunction.</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:489"><nobr><span class="ft4">The theoretical framework for the query language acqui-</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:475"><nobr><span class="ft9">sition is derived from the learning of an unknown concept<br>by querying [5]. Assume that provider P supports the basic<br>operators in O; complex queries composed from the basic<br>operators form a set Q(O). For the document collection at<br>P , query q  Q(O) constrains a subset P (q) of documents<br>matching q. An abstract query q  Q(O) is mapped into<br>a textual string with a mapping M : O  2</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:749"><nobr><span class="ft11">S</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:762"><nobr><span class="ft4">that defines</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:475"><nobr><span class="ft9">(possibly multiple) syntaxes for operators in O. The map-<br>ping of a complex query q is denoted m(q), the set of mapped<br>queries is denoted Q(S) = Q(M (O)).</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:489"><nobr><span class="ft4">The sets O and S are assumed to be known, whereas the</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:475"><nobr><span class="ft9">mapping M is unknown. We are given an oracle that can<br>be queried with a mapped query m(q)  Q(S) on the size<br>of subset P (q), oracle(m(q)) = |P (q)|. By observing the or-<br>acle's responses to queries, the learning system should pro-<br>duce a hypothesis on the mapping M , which should be as<br>close as possible to the correct one.</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:489"><nobr><span class="ft4">The identification of the mapping M may be simple under</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:475"><nobr><span class="ft9">certain circumstances. Below we show an example of recon-<br>struction when O</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:579"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:593"><nobr><span class="ft4">includes a particular subset of operators</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:475"><nobr><span class="ft4">and the oracle is noiseless.</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:490"><nobr><span class="ft4">Example 3. Let O include the three Boolean operators</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:475"><nobr><span class="ft9">(,  and ¬) and P hrase. Then, for a given syntax set S,<br>any unambiguous mapping M : O  2</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:704"><nobr><span class="ft11">S</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:717"><nobr><span class="ft4">can be exactly iden-</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:475"><nobr><span class="ft4">tified if the oracle is noise-less</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:656"><nobr><span class="ft11">4</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:662"><nobr><span class="ft4">. In such a case, subset sizes</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:475"><nobr><span class="ft9">returned by the oracle fit the Boolean logic on sets.Indeed,<br>when querying the oracle with terms A and B and syntaxes<br>from S, the disjunction is distinguishable from other opera-<br>tors by the fact that it constrains bigger subsets in a collec-<br>tion than any of terms does:</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:570"><nobr><span class="ft4">|A  B|  |A|, |A  B|  |B|</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:816"><nobr><span class="ft4">(1)</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:475"><nobr><span class="ft9">Furthermore, among three other operators, the conjunction<br>is recognized by its commutativity:</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:601"><nobr><span class="ft4">|A  B| = |B  A|</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:816"><nobr><span class="ft4">(2)</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:475"><nobr><span class="ft9">Finally, the difference between negation and phrases is de-<br>tected by the basic equation linking three Boolean operators:</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:546"><nobr><span class="ft4">|A  B| = |A¬B| + |A  B| + |B¬A|</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:816"><nobr><span class="ft4">(3)</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:475"><nobr><span class="ft9">Sizes of subsets constrained by the Boolean operators satisfy<br>the disequation (1) and equations (2), (3) for any pair of<br>A and B, so one can easily design a learning system that<br>exactly identifies an unambiguous mapping M after only a<br>few probing queries.</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:489"><nobr><span class="ft4">Unfortunately, easy identification of the mapping M is</span></nobr></DIV>
<DIV style="position:absolute;top:895;left:475"><nobr><span class="ft9">rather an exception on the real Web, where few if any of the<br>assumptions made in Example 3 become true. First, any<br>change in the operator set O</span></nobr></DIV>
<DIV style="position:absolute;top:931;left:652"><nobr><span class="ft11">p</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:663"><nobr><span class="ft4">makes the exact reconstruc-</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:475"><nobr><span class="ft9">tion less obvious. If the conjunction and/or disjunction are<br>not supported, then the size of A  B (or A  B) is un-<br>available and equation (3) cannot help distinguish negation<br>from phrases. In cases like this, the identification of sup-<br>ported syntaxes requires an analysis of the semantic corre-<br>lation between query terms A and B and guessing on their<br>co-occurrence in (unknown) document collections.</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:476"><nobr><span class="ft11">4</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:482"><nobr><span class="ft4">Oracle noiseless assumes the pure Boolean logics, with no</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:475"><nobr><span class="ft4">query preprocessing, like the stopword removal.</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:441"><nobr><span class="ft7">1116</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1269;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1269" src="124004.png" alt="background image">
<DIV style="position:absolute;top:92;left:94"><nobr><span class="ft4">Second, Web query interfaces that play the role of oracles</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft9">and return sizes of subsets constrained by queries m(q) <br>Q(S) are rarely noiseless.</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:253"><nobr><span class="ft4">When probing interfaces with</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:81"><nobr><span class="ft9">test queries, the match numbers may violate equations (2)<br>and (3). Most violations happen because converting query<br>strings into queries on collections hides the stop-word re-<br>moval and term stemming. It is not clear, whether queries<br>like A AND B are interpreted as one (A is a stopword),<br>two, or three terms. Moreover, for the performance reasons,<br>real match numbers are often replaced by their estimations<br>which are calculated using various collection statistics [13],<br>without the real retrieval of documents matching the query.</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:81"><nobr><span class="ft3"><b>4.</b></span></nobr></DIV>
<DIV style="position:absolute;top:297;left:112"><nobr><span class="ft3"><b>LEARNING SYSTEM</b></span></nobr></DIV>
<DIV style="position:absolute;top:319;left:94"><nobr><span class="ft4">To automatically determine supported query operators,</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:81"><nobr><span class="ft9">we reduce the overall problem to a set of classification tasks,<br>where each task is associated with recognizing a specific<br>query operator or syntax, and where some standard learning<br>algorithms like SVM, k-nearest neighbors or decision trees<br>can be applied. To build the classifiers, we collect and anno-<br>tate a set of Web providers. We develop a set of test queries<br>and probe all selected providers with the test queries. We<br>train the classifiers with query matches for test queries. For<br>any new provider, we first probe it with the test queries.<br>Query matches returned by the provider upon test queries<br>are used to automatically classify operators and syntaxes<br>and produce an unambiguous interpretation for P .</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:94"><nobr><span class="ft4">To achieve a good level of classification accuracy, we in-</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:81"><nobr><span class="ft9">vestigate different aspects of the learning system including<br>the target function, probe queries, data preparation, and<br>feature encoding and selection.</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:81"><nobr><span class="ft3"><b>4.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:595;left:121"><nobr><span class="ft3"><b>Target function</b></span></nobr></DIV>
<DIV style="position:absolute;top:617;left:94"><nobr><span class="ft4">Due to the multivalued relationships between query op-</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:81"><nobr><span class="ft9">erators and syntaxes, the target function for our learning<br>system has two alternatives, one for the direct mapping M<br>and the other one for the inverted mapping M</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:363"><nobr><span class="ft11">-1</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:378"><nobr><span class="ft4">:</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:101"><nobr><span class="ft4">· T</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:122"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:129"><nobr><span class="ft4">: O  2</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:186"><nobr><span class="ft11">S</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:194"><nobr><span class="ft4">. T</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:216"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:229"><nobr><span class="ft4">targets the unknown mapping M ;</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:114"><nobr><span class="ft9">it assigns zero or more syntaxes to each operator in<br>O. T</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:144"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:155"><nobr><span class="ft4">builds a multi-value classifier for every o</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:402"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:411"><nobr><span class="ft4"> O,</span></nobr></DIV>
<DIV style="position:absolute;top:738;left:114"><nobr><span class="ft9">or alternatively, a set of binary classifiers for all valid<br>combinations (o</span></nobr></DIV>
<DIV style="position:absolute;top:758;left:211"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:215"><nobr><span class="ft4">, s</span></nobr></DIV>
<DIV style="position:absolute;top:758;left:228"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:234"><nobr><span class="ft4">), o</span></nobr></DIV>
<DIV style="position:absolute;top:758;left:254"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:263"><nobr><span class="ft4"> O, s</span></nobr></DIV>
<DIV style="position:absolute;top:758;left:299"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:309"><nobr><span class="ft4"> S(o</span></nobr></DIV>
<DIV style="position:absolute;top:758;left:343"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:348"><nobr><span class="ft4">).</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:101"><nobr><span class="ft4">· T</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:122"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:129"><nobr><span class="ft4">: S  O. T</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:200"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:211"><nobr><span class="ft4">targets the inverted mapping M</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:407"><nobr><span class="ft11">-1</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:421"><nobr><span class="ft4">; it</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:114"><nobr><span class="ft4">assigns at most one operator to every syntax s</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:397"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:406"><nobr><span class="ft4"> S.</span></nobr></DIV>
<DIV style="position:absolute;top:822;left:94"><nobr><span class="ft4">Either target function gets implemented as a set of clas-</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:81"><nobr><span class="ft4">sifiers, operator classifiers for T</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:268"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:279"><nobr><span class="ft4">or syntax classifiers for T</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:429"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:436"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:81"><nobr><span class="ft9">Classifiers are trained with match numbers for probe queries<br>from annotated providers.</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:255"><nobr><span class="ft4">For a new provider P , either</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:81"><nobr><span class="ft4">function produces a hypothesis I</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:289"><nobr><span class="ft11">T</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:298"><nobr><span class="ft4">(P ) that approximates</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:81"><nobr><span class="ft4">the real interpretation I</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:231"><nobr><span class="ft11">P</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:240"><nobr><span class="ft4">. The major difference between</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:81"><nobr><span class="ft4">T</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:89"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:100"><nobr><span class="ft4">and T</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:135"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:146"><nobr><span class="ft4">is that the former can produce ambiguous inter-</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:81"><nobr><span class="ft4">pretations, while the output of T</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:284"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:296"><nobr><span class="ft4">is always unambiguous.</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:81"><nobr><span class="ft4">Indeed, two operator classifiers with T</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:308"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:318"><nobr><span class="ft4">can output the same</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:81"><nobr><span class="ft4">syntax leading to ambiguity, while each classifier in T</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:404"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:415"><nobr><span class="ft4">out-</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:81"><nobr><span class="ft9">puts at most, one operator for one syntax. In experiments<br>we tested both functions, though when building the learning<br>system we put an emphasis on T</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:271"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:278"><nobr><span class="ft4">, which is free of ambiguity.</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:94"><nobr><span class="ft4">To build syntax classifiers for the target function T</span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:408"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:414"><nobr><span class="ft4">, we</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:81"><nobr><span class="ft9">should consider beyond "good" classification cases for the<br>operators in O and include some "real-world" cases where<br>providers process syntaxes in S literally or simply ignore</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:475"><nobr><span class="ft9">them. For certain providers, it is difficult to find any valid<br>interpretation. In the learning system, we extend the set<br>of possible interpretations of syntaxes in S by three more<br>cases, O = O{Ignored, Literal, U nknown}. Syntaxes in<br>S have different alternatives for their interpretation; below<br>we revisit some syntaxes and report possible matches in O<br>as they are specified in the learning system.</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:475"><nobr><span class="ft4">Default : Case sensitivity for query terms: possible values</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:509"><nobr><span class="ft4">are case-insensitive (Case) or case-sensitive (Literal).</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:479"><nobr><span class="ft4">* : This unary operator can be interpreted as Stem, when</span></nobr></DIV>
<DIV style="position:absolute;top:273;left:509"><nobr><span class="ft9">i(A*) = Stem(A), Ignored when i(A*) = i(A), and<br>Literal, when A* is accepted as one term.</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:499"><nobr><span class="ft4">: Whitespace is often a default for another syntax in</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:509"><nobr><span class="ft9">S. Three possible interpretations include the Boolean<br>conjunction when i( A B )= A  B, the Boolean dis-<br>junction when i( A B )= A  B, and P hrase when<br>i( A B )= P hrase (A,B).</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:479"><nobr><span class="ft4">AND : Three alternatives here are the conjunction when</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:509"><nobr><span class="ft9">i( A AND B )= A  B, Ignored, when AND is ig-<br>nored and the interpretation goes with the whites-<br>pace meaning, i( A AND B )= i( A B )= M</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:791"><nobr><span class="ft11">-1</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:806"><nobr><span class="ft4">(' ')</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:509"><nobr><span class="ft4">(A, B), and Literal when i( A AND B )= M</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:791"><nobr><span class="ft11">-1</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:806"><nobr><span class="ft4">(</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:828"><nobr><span class="ft4">)</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:509"><nobr><span class="ft4">(A, AND ,B).</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:479"><nobr><span class="ft4">" " (Quote marks): Two possible interpretations are P hrase,</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:509"><nobr><span class="ft9">when i( "A B" )= P hrase(A,B), and Ignore when quote<br>marks are ignored and terms are interpreted with the<br>whitespace, i( "A B" )= i( A B ) = M</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:743"><nobr><span class="ft11">-1</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:758"><nobr><span class="ft4">(</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:781"><nobr><span class="ft4">) (A, B).</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:489"><nobr><span class="ft4">A similar analysis is done for the syntaxes + ,</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:805"><nobr><span class="ft4">OR ,</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:479"><nobr><span class="ft4">NOT and - . Additionally, all syntaxes for binary op-</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:475"><nobr><span class="ft4">erators can be labeled as U nknown.</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:475"><nobr><span class="ft3"><b>4.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:642;left:516"><nobr><span class="ft3"><b>Probing with test queries</b></span></nobr></DIV>
<DIV style="position:absolute;top:664;left:489"><nobr><span class="ft4">To train syntax classifiers for T</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:675"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:681"><nobr><span class="ft4">, we collect data from an-</span></nobr></DIV>
<DIV style="position:absolute;top:680;left:475"><nobr><span class="ft9">notated sites by probing their interfaces and extracting the<br>match numbers. Probing has a fairly low cost, but requires<br>a certain policy when selecting terms for test queries to pro-<br>vide meaningful data for the learning. We define a set R<br>of model queries that contain syntaxes in S and parameter<br>terms A and B, which are later bound with real terms.</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:489"><nobr><span class="ft4">We form the set R by first selecting well-formed queries</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:475"><nobr><span class="ft9">that contain all syntaxes we want to classify. Second, we add<br>queries that are term permutations of previously selected<br>queries, for example the permutation B A for query A<br>B . Finally, we add model queries that are not well-formed,<br>but appear helpful for building accurate classification rules.<br>Below, the set R of model queries is illustrated using the<br>pair of terms A and B; model queries are split into three<br>groups containing one, two or three words:</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:495"><nobr><span class="ft4">· One word queries: A , B ,UpperCase(A), A* , Stem(A).</span></nobr></DIV>
<DIV style="position:absolute;top:954;left:495"><nobr><span class="ft4">· Two word queries: A B , B A , "A B" , "B A" , +A</span></nobr></DIV>
<DIV style="position:absolute;top:970;left:509"><nobr><span class="ft4">+B , +B +A , A -B , A AND , A OR , A NOT .</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:495"><nobr><span class="ft4">· Three word queries: A AND B , B AND A , A OR</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:509"><nobr><span class="ft4">B , B OR A , A NOT B , B NOT A .</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:489"><nobr><span class="ft4">In total, the set R is composed of 22 model queries, all in</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:475"><nobr><span class="ft9">lower case, except UpperCase (A), which is an upper case of<br>term A. Six queries in R are permutations of other queries</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:441"><nobr><span class="ft7">1117</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1269;">
<STYLE type="text/css">
<!--
	.ft13{font-size:5px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1269" src="124005.png" alt="background image">
<DIV style="position:absolute;top:92;left:81"><nobr><span class="ft9">and three queries are (purposely) not well-formed. These<br>queries A AND , A OR , A NOT are selected to help<br>detect Literal-cases for AND , OR , NOT .</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:94"><nobr><span class="ft4">Probe queries are obtained from the model queries by re-</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:81"><nobr><span class="ft4">placing parameters A and B with specific query terms, like</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:85"><nobr><span class="ft4">knowledge and retrieval . These 22 probe queries form</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:81"><nobr><span class="ft4">a probe package denoted R</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:249"><nobr><span class="ft11">A,B</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:271"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:287"><nobr><span class="ft4">For a provider P , probe</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:81"><nobr><span class="ft9">queries together with corresponding match numbers form<br>the elementary feature set F</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:254"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:224;left:252"><nobr><span class="ft11">A,B</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:279"><nobr><span class="ft4">= {(m(q</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:330"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:335"><nobr><span class="ft4">), oracle(P (q</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:415"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:419"><nobr><span class="ft4">))),</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:81"><nobr><span class="ft4">w(q</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:103"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:107"><nobr><span class="ft4">)  R</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:145"><nobr><span class="ft11">A,B</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:167"><nobr><span class="ft4">}. Query terms are selected from a generic</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:81"><nobr><span class="ft9">English vocabulary with all standard stopwords excluded.<br>One site can be probed with one or more probe packages,<br>all packages using different term pairs (A,B).</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:94"><nobr><span class="ft4">To probe the sites with test queries, we bind model queries</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:81"><nobr><span class="ft9">in R with query terms. To obtain meaningful training data,<br>query terms should not be common stopwords, such as and<br>or the . As the term co-occurrence in a provider's document<br>collection is unknown, we select pairs with different degrees<br>of semantic correlation. Here, the term pairs fall into three<br>categories:</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:101"><nobr><span class="ft4">· C</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:124"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:130"><nobr><span class="ft4">: terms that form a phrase (such as A= information</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:114"><nobr><span class="ft4">and B= retrieval );</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:101"><nobr><span class="ft4">· C</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:124"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:130"><nobr><span class="ft4">: terms that do not form a phrase but occur in the</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:114"><nobr><span class="ft4">same document ( knowledge and wireless );</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:101"><nobr><span class="ft4">· C</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:124"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:130"><nobr><span class="ft4">: terms that rarely occur in the same document</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:114"><nobr><span class="ft4">(such as cancer and wireless ).</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:94"><nobr><span class="ft4">These three categories can be expressed through term co-</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:81"><nobr><span class="ft4">occurrence in some generic document collection P</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:394"><nobr><span class="ft11">G</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:404"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:420"><nobr><span class="ft4">We</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:81"><nobr><span class="ft9">re-use our query probing component to establish criteria for<br>term selection for the three categories. A pair of terms (A,<br>B) is in category C</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:205"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:218"><nobr><span class="ft4">(phrase co-occurrence) if the match</span></nobr></DIV>
<DIV style="position:absolute;top:610;left:81"><nobr><span class="ft4">number for P hrase(A, B) is comparable with the conjunc-</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:81"><nobr><span class="ft4">tion A  B, that is</span></nobr></DIV>
<DIV style="position:absolute;top:624;left:196"><nobr><span class="ft11">|P</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:206"><nobr><span class="ft13">G</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:215"><nobr><span class="ft11">(P hrase(A,B))|</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:216"><nobr><span class="ft11">|P</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:227"><nobr><span class="ft13">G</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:235"><nobr><span class="ft11">(AB)|</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:298"><nobr><span class="ft4">&gt; , for some threshold</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:81"><nobr><span class="ft4">0 &lt;  &lt; 1. A term pair (A, B) is in category C</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:375"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:386"><nobr><span class="ft4">(high co-</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:81"><nobr><span class="ft9">occurrence) if the terms are not co-occurred in a phrase,<br>but their conjunction is comparable with either A or B,</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:112"><nobr><span class="ft11">|P</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:123"><nobr><span class="ft13">G</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:131"><nobr><span class="ft11">(AB)|</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:82"><nobr><span class="ft11">min{|P</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:119"><nobr><span class="ft13">G</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:128"><nobr><span class="ft11">(A)|,|P</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:162"><nobr><span class="ft13">G</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:171"><nobr><span class="ft11">(B)|}</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:203"><nobr><span class="ft4">&gt; , for some 0 &lt;  &lt; 1. If pair (A,B)</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:81"><nobr><span class="ft4">does not fit the conditions for categories C</span></nobr></DIV>
<DIV style="position:absolute;top:717;left:337"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:348"><nobr><span class="ft4">and C</span></nobr></DIV>
<DIV style="position:absolute;top:717;left:384"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:391"><nobr><span class="ft4">, then it</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:81"><nobr><span class="ft4">is in category C</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:176"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:187"><nobr><span class="ft4">(low co-occurrence). For our experiments,</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:81"><nobr><span class="ft9">we have selected Google as generic document collection G<br>and set the values of  and  both to 0.01.</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:81"><nobr><span class="ft3"><b>4.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:784;left:121"><nobr><span class="ft3"><b>Elementary features</b></span></nobr></DIV>
<DIV style="position:absolute;top:806;left:94"><nobr><span class="ft4">Match numbers for probe queries in F</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:333"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:331"><nobr><span class="ft11">A,B</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:357"><nobr><span class="ft4">represent ele-</span></nobr></DIV>
<DIV style="position:absolute;top:822;left:81"><nobr><span class="ft9">mentary features that can be directly used to train classi-<br>fiers. Unfortunately, this often leads to poor results. The<br>reason is that Web resources considerably differ in size and,<br>therefore, the query matches from different resources are of<br>different magnitude and thus hardly comparable. A query<br>may match millions of documents on Google, but only a<br>few at a small local resource. To leverage the processing of<br>query matches from resources of different size, we develop<br>two alternative methods for the feature encoding.</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:94"><nobr><span class="ft4">In the first approach, we normalize the query matches in</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:81"><nobr><span class="ft4">F</span></nobr></DIV>
<DIV style="position:absolute;top:976;left:91"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:103"><nobr><span class="ft4">by the maximum number of matches for the two basic</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:81"><nobr><span class="ft4">queries A and B . We thus obtain features F</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:373"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:385"><nobr><span class="ft4">with val-</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:81"><nobr><span class="ft9">ues mostly between 0 and 1 (except for queries related to<br>the Boolean disjunction). The second approach F</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:391"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:402"><nobr><span class="ft4">to the</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:81"><nobr><span class="ft9">feature encoding, uses the "less-equal-greater"-relationship<br>between any two probe queries in a probe package. This<br>produces a three-value feature for each pair of test queries.</span></nobr></DIV>
<DIV style="position:absolute;top:90;left:475"><nobr><span class="ft3"><b>4.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:90;left:516"><nobr><span class="ft3"><b>Feature selection</b></span></nobr></DIV>
<DIV style="position:absolute;top:112;left:489"><nobr><span class="ft4">The refinement of raw features produces l=22 refined real</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:475"><nobr><span class="ft4">value features with F</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:601"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:610"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:637"><nobr><span class="ft11">l(l-1)</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:652"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:678"><nobr><span class="ft4">= 231 three-value features</span></nobr></DIV>
<DIV style="position:absolute;top:147;left:475"><nobr><span class="ft4">with F</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:517"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:147;left:524"><nobr><span class="ft4">. The basic approach is to train each classifier with</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:475"><nobr><span class="ft4">the entire feature set F</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:613"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:619"><nobr><span class="ft4">, F</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:638"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:648"><nobr><span class="ft4">or F</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:675"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:681"><nobr><span class="ft4">. However, because of the</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:475"><nobr><span class="ft9">noise in the data, building accurate classifiers may require a<br>lot of training data. To control the amount of training data<br>and enhance the quality of classification rules, we proceed<br>with two methods of feature selection. First, we distinguish<br>between relevant and irrelevant features for a given classi-<br>fier and remove irrelevant ones. Second, beyond the direct<br>feature filtering, we use prior knowledge and classify new<br>syntaxes using previously classified ones.</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:489"><nobr><span class="ft4">Removing irrelevant features. The definition of rele-</span></nobr></DIV>
<DIV style="position:absolute;top:319;left:475"><nobr><span class="ft9">vant features requires establishing syntactical dependencies<br>between model queries in R and semantic relationships be-<br>tween syntaxes in S. Model query r</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:697"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:706"><nobr><span class="ft4"> R syntactically de-</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:475"><nobr><span class="ft4">pends on model query r</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:621"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:633"><nobr><span class="ft4">if r</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:653"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:663"><nobr><span class="ft4">includes syntaxes present in</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:475"><nobr><span class="ft4">r</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:481"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:487"><nobr><span class="ft4">. Syntaxes s</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:563"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:573"><nobr><span class="ft4">and s</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:606"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:617"><nobr><span class="ft4">in S are semantically related if they</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:475"><nobr><span class="ft4">can be interpreted with the same operator in O.</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:489"><nobr><span class="ft4">We define the relevant feature set F</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:702"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:711"><nobr><span class="ft4">for syntax s</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:783"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:792"><nobr><span class="ft4">as con-</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:475"><nobr><span class="ft4">taining three parts, F S(s</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:633"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:638"><nobr><span class="ft4">) = F S</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:686"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:697"><nobr><span class="ft4">= F S</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:734"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:733"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:744"><nobr><span class="ft4">+ F S</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:779"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:778"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:789"><nobr><span class="ft4">+ F S</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:824"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:823"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:830"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:475"><nobr><span class="ft4">F S</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:495"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:494"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:507"><nobr><span class="ft4">simply contains all model queries r</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:721"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:444;left:732"><nobr><span class="ft4"> R that involve</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:475"><nobr><span class="ft4">syntax s</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:525"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:530"><nobr><span class="ft4">, for example F S</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:630"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:636"><nobr><span class="ft4">( AND )= { A AND B , B AND</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:475"><nobr><span class="ft4">A , A AND }. Next, F S</span></nobr></DIV>
<DIV style="position:absolute;top:474;left:631"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:631"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:643"><nobr><span class="ft4">contains model queries for syn-</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:475"><nobr><span class="ft4">tactically dependent syntaxes. Actually, F S</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:748"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:747"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:760"><nobr><span class="ft4">contains the</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:475"><nobr><span class="ft9">two model queries A B and B A for all binary syntaxes.<br>Finally, F S</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:544"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:544"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:555"><nobr><span class="ft4">contains the model queries for semantically re-</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:475"><nobr><span class="ft4">lated syntaxes. For example, F S</span></nobr></DIV>
<DIV style="position:absolute;top:536;left:673"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:679"><nobr><span class="ft4">( AND ) = F S</span></nobr></DIV>
<DIV style="position:absolute;top:536;left:768"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:774"><nobr><span class="ft4">( + ), and</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:475"><nobr><span class="ft4">vice versa, F S</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:562"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:569"><nobr><span class="ft4">( + )=F S</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:629"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:635"><nobr><span class="ft4">( AND ).</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:489"><nobr><span class="ft4">Use of prior knowledge. Beyond removing irrelevant</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:475"><nobr><span class="ft9">features, it is possible to benefit from the dependencies be-<br>tween syntaxes established in Section 4.1. For example, the<br>Literal-cases for OR and AND depend on the interpreta-<br>tion of whitespaces. The classification of AND as Literal<br>becomes simpler when the system already knows that, for<br>example,</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:555"><nobr><span class="ft4">is interpreted as conjunction. To use the prior</span></nobr></DIV>
<DIV style="position:absolute;top:680;left:475"><nobr><span class="ft9">knowledge, we alter the training and classification process.<br>We impose an order on the syntaxes in S. When training<br>or using syntax classifiers, we use the classification results<br>of previous syntaxes.</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:489"><nobr><span class="ft4">We convert the syntax set in the ordered list S</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:781"><nobr><span class="ft11">O</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:791"><nobr><span class="ft4">= (De-</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:475"><nobr><span class="ft4">fault,  ,</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:553"><nobr><span class="ft4">, "" , AND , + , OR ', NOT , - ) and im-</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:475"><nobr><span class="ft9">pose the order on how the classifiers are trained and used<br>for the classification. In the prior knowledge approach, the<br>feature set used to train the classifier for syntax s</span></nobr></DIV>
<DIV style="position:absolute;top:810;left:768"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:777"><nobr><span class="ft4"> S</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:799"><nobr><span class="ft11">O</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:812"><nobr><span class="ft4">will</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:475"><nobr><span class="ft4">include the classifications of all s</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:674"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:685"><nobr><span class="ft4">preceding s</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:753"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:763"><nobr><span class="ft4">in S</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:788"><nobr><span class="ft11">O</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:798"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:489"><nobr><span class="ft4">Removing irrelevant features and using prior knowledge</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:475"><nobr><span class="ft9">are two independent methods for feature selection and can<br>be applied separately or together. This allows us to consider<br>four feature selection methods for training classifiers and<br>classifying new sites:</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:489"><nobr><span class="ft4">1. Full feature set, F f s</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:626"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:634"><nobr><span class="ft4">= F , where F is a selected feature</span></nobr></DIV>
<DIV style="position:absolute;top:931;left:475"><nobr><span class="ft4">encoding, F</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:548"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:931;left:554"><nobr><span class="ft4">, F</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:573"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:931;left:584"><nobr><span class="ft4">or F</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:612"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:931;left:618"><nobr><span class="ft4">;</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:489"><nobr><span class="ft4">2. Relevant feature set, Rf s</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:658"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:667"><nobr><span class="ft4">= F S</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:701"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:705"><nobr><span class="ft4">;</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:489"><nobr><span class="ft4">3. Prior knowledge features, P Kf s</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:701"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:705"><nobr><span class="ft4">=F  M</span></nobr></DIV>
<DIV style="position:absolute;top:960;left:756"><nobr><span class="ft11">-1</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:771"><nobr><span class="ft4">(s</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:783"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:789"><nobr><span class="ft4">), j &lt; i.</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:489"><nobr><span class="ft4">4. Relevant prior knowledge feature set RP Kf s</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:775"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:784"><nobr><span class="ft4">= F S</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:818"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:825"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:994;left:475"><nobr><span class="ft4">M</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:490"><nobr><span class="ft11">-1</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:505"><nobr><span class="ft4">(s</span></nobr></DIV>
<DIV style="position:absolute;top:999;left:517"><nobr><span class="ft11">j</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:523"><nobr><span class="ft4">), j &lt; i.</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:475"><nobr><span class="ft3"><b>5.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:507"><nobr><span class="ft3"><b>EXPERIMENTAL EVALUATION</b></span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:489"><nobr><span class="ft4">To run experiments, we collected and annotated 36 Web</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:475"><nobr><span class="ft4">sites with search interfaces. All sites report the match num-</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:441"><nobr><span class="ft7">1118</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1269;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1269" src="124006.png" alt="background image">
<DIV style="position:absolute;top:92;left:81"><nobr><span class="ft9">bers for user queries and unambiguously interpret their query<br>languages. Selected sites represent a wide spectrum of sup-<br>ported operator sets. For each site, we annotated all sup-<br>ported operators and their syntaxes. For the extraction of<br>the match numbers from HTML pages we used the Xerox<br>IWrap wrapper toolkit [7, 12]. Out of 36 providers, only 4<br>support monovalued interpretations; in the other 32 cases,<br>at least one operator has two or more syntaxes.</span></nobr></DIV>
<DIV style="position:absolute;top:403;left:133"><nobr><span class="ft4">Figure 1: T</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:211"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:403;left:222"><nobr><span class="ft4">and T</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:261"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:403;left:272"><nobr><span class="ft4">target functions.</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:81"><nobr><span class="ft9">Figure 2: Three feature encodings for DT, KNN and<br>SVM.</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:81"><nobr><span class="ft3"><b>5.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:121"><nobr><span class="ft3"><b>Experimental framework</b></span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:94"><nobr><span class="ft4">In all experiments we estimate the classification accuracy</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:81"><nobr><span class="ft4">for the individual operators in O (with T</span></nobr></DIV>
<DIV style="position:absolute;top:1062;left:342"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:348"><nobr><span class="ft4">) and the syn-</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:81"><nobr><span class="ft4">taxes in S (with T</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:200"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:207"><nobr><span class="ft4">).</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:229"><nobr><span class="ft4">We also estimate the mean accu-</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:475"><nobr><span class="ft4">racy for the target functions T</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:665"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:677"><nobr><span class="ft4">and T</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:714"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:720"><nobr><span class="ft4">. Experiments are</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:475"><nobr><span class="ft9">conducted using the cross-validation method. 36 annotated<br>sites are split into N =9 groups, S</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:681"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:688"><nobr><span class="ft4">, S</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:705"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:711"><nobr><span class="ft4">,. . . , S</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:751"><nobr><span class="ft11">N</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:761"><nobr><span class="ft4">. We run N</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:475"><nobr><span class="ft9">experiments; in experiment i, classifiers are trained with the<br>groups S</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:529"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:535"><nobr><span class="ft4">,. . . ,S</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:570"><nobr><span class="ft11">i-1</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:588"><nobr><span class="ft4">, S</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:606"><nobr><span class="ft11">i+1</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:625"><nobr><span class="ft4">,. . . ,S</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:659"><nobr><span class="ft11">N</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:675"><nobr><span class="ft4">and then tested with sites</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:475"><nobr><span class="ft4">from group S</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:557"><nobr><span class="ft11">i</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:561"><nobr><span class="ft4">. Accuracy (precision) values over N experi-</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:475"><nobr><span class="ft9">ments are averaged for each operator/syntax classifier and<br>form the individual accuracies. The average of individual<br>accuracies over O/S gives the mean accuracy.</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:489"><nobr><span class="ft4">We test the learning system by varying the system pa-</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:475"><nobr><span class="ft9">rameters introduced in Section 4. We train and test classi-<br>fiers with three different learning algorithms: decision trees<br>from Borgelt's package (DT), k-nearest neighbors algorithm<br>(KNN), and support vector machines (SVM)</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:740"><nobr><span class="ft11">5</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:746"><nobr><span class="ft4">. The following</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:475"><nobr><span class="ft4">list recalls the test parameters and possible options.</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:491"><nobr><span class="ft4">1. Target function: T</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:625"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:638"><nobr><span class="ft4">includes |O |=9 operator classi-</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:509"><nobr><span class="ft9">fiers; multivalued interpretations are implemented as<br>classifications with subsets of |O |. For T</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:755"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:761"><nobr><span class="ft4">, the system</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:509"><nobr><span class="ft4">includes |S|=9 syntax classifiers.</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:491"><nobr><span class="ft4">2. Feature encoding: The three different feature encod-</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:509"><nobr><span class="ft9">ings (see Section 4.3) include the raw match numbers<br>given by F</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:575"><nobr><span class="ft11">0</span></nobr></DIV>
<DIV style="position:absolute;top:444;left:581"><nobr><span class="ft4">, the normalized match numbers given by</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:509"><nobr><span class="ft4">F</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:520"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:526"><nobr><span class="ft4">, and three-value feature comparison given by F</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:818"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:824"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:491"><nobr><span class="ft4">3. Feature selection: The four methods presented in Sec-</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:509"><nobr><span class="ft9">tion 4.4 include Ffs (full feature set), Rfs (relevant<br>feature set), PKfs (prior knowledge feature set) and<br>RPKfs (relevant prior knowledge feature set).</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:491"><nobr><span class="ft4">4. Term selection: We test three term selection cate-</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:509"><nobr><span class="ft4">gories, C</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:562"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:569"><nobr><span class="ft4">, C</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:587"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:599"><nobr><span class="ft4">and C</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:636"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:647"><nobr><span class="ft4">introduced in Section 4.2. Ad-</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:509"><nobr><span class="ft9">ditionally, we test the mixture of the three categories,<br>when three term pairs are used to probe a site, i.e. one<br>term pair from each category C</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:700"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:706"><nobr><span class="ft4">, C</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:724"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:735"><nobr><span class="ft4">and C</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:772"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:778"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:489"><nobr><span class="ft4">Experiments have been run for all parameter combina-</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:475"><nobr><span class="ft9">tions; most combinations achieve mean accuracy superior to<br>60%. The four system parameters appear to be uncorrelated<br>in their impact on the classification results. To figure out<br>the most interesting ones, we determine overall "winners"<br>for each parameter, except for the learning algorithm. The<br>winners are T</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:561"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:573"><nobr><span class="ft4">target function, F</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:687"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:699"><nobr><span class="ft4">feature encoding, and</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:475"><nobr><span class="ft4">M ixed term selection.</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:625"><nobr><span class="ft4">RP Kf s feature selection behaves</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:475"><nobr><span class="ft9">best for DT and KNN and P Kf s feature selection is the<br>winner for SVM. We report more detail below.</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:475"><nobr><span class="ft3"><b>5.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:815;left:516"><nobr><span class="ft3"><b>Experimental Results</b></span></nobr></DIV>
<DIV style="position:absolute;top:837;left:489"><nobr><span class="ft4">Decision trees are induced by the Borgelt's software; they</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:475"><nobr><span class="ft9">are then pruned using the confidence level (p=0.5) pruning<br>method. In SVM, linear kernel functions have been used.<br>For the KNN method, we report results for k=3 which be-<br>haves better that k=1, 5 and 10. Because the implemen-<br>tation of the KNN algorithm cannot process large sets of<br>features, we were not able to test the Ffs and PKfs feature<br>selection methods.</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:489"><nobr><span class="ft4">All three learning algorithms show a similar performance.</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:475"><nobr><span class="ft9">3NN slightly outperforms DT and SVM for the "winner"<br>combination (86.42% against 84.26% and 79.74%), however<br>it is often less accurate with other parameter combinations.</span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:476"><nobr><span class="ft11">5</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:482"><nobr><span class="ft4">Available</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:563"><nobr><span class="ft4">at</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:601"><nobr><span class="ft4">http://fuzzy.cs.uni-magdeburg.de/</span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:475"><nobr><span class="ft4">borgelt/software.html,</span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:657"><nobr><span class="ft4">http://www.dontveter.com/</span></nobr></DIV>
<DIV style="position:absolute;top:1060;left:475"><nobr><span class="ft4">nnsoft/nnsoft.html,</span></nobr></DIV>
<DIV style="position:absolute;top:1060;left:625"><nobr><span class="ft4">http://svmlight.joachims.org/,</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:475"><nobr><span class="ft4">respectively.</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:441"><nobr><span class="ft7">1119</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1269;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1269" src="124007.png" alt="background image">
<DIV style="position:absolute;top:92;left:94"><nobr><span class="ft4">Target functions and feature selection. The target func-</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft4">tions T</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:125"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:137"><nobr><span class="ft4">and T</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:174"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:187"><nobr><span class="ft4">implement alternative approaches to the</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:81"><nobr><span class="ft4">query language acquisition; T</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:255"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:265"><nobr><span class="ft4">uses operator classifiers while</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:81"><nobr><span class="ft4">T</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:89"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:100"><nobr><span class="ft4">uses syntax classifiers. As seen in Section 4, T</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:388"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:399"><nobr><span class="ft4">has an</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:81"><nobr><span class="ft4">advantage over T</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:185"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:197"><nobr><span class="ft4">because it avoids multivalued classifica-</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:81"><nobr><span class="ft9">tion and outputs only unambiguous interpretations, while<br>the output of T</span></nobr></DIV>
<DIV style="position:absolute;top:191;left:175"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:187"><nobr><span class="ft4">should be further tested for unambiguity.</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:81"><nobr><span class="ft4">Thus we have built the learning system for T</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:366"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:372"><nobr><span class="ft4">. Series of</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:81"><nobr><span class="ft4">experiments conducted with T</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:265"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:277"><nobr><span class="ft4">and T</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:312"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:323"><nobr><span class="ft4">confirm the superi-</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:81"><nobr><span class="ft4">ority of T</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:136"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:142"><nobr><span class="ft4">. As operator classifiers in T</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:309"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:319"><nobr><span class="ft4">are trained indepen-</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:81"><nobr><span class="ft9">dently, their combined output does not guarantee unambi-<br>guity. Unlike T</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:171"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:178"><nobr><span class="ft4">, high accuracy of individual classifiers may</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:81"><nobr><span class="ft9">not be translated into global good accuracy, because one<br>misclassification may produce an ambiguous interpretation<br>and undermine the good performance of other classifiers.</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:94"><nobr><span class="ft4">In practice, we test the output of operator classifiers of</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:81"><nobr><span class="ft4">T</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:89"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:100"><nobr><span class="ft4">and discard those that form ambiguous interpretations.</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:81"><nobr><span class="ft9">This gives a 2% to 10% drop in the mean accuracy. Figure 1<br>plots mean accuracies for T</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:245"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:256"><nobr><span class="ft4">and T</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:291"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:301"><nobr><span class="ft4">for all feature selection</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:81"><nobr><span class="ft4">methods (with fixed F</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:218"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:230"><nobr><span class="ft4">feature encoding and M ixed term</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:81"><nobr><span class="ft9">selection) and the three learning methods (only Rfs and RP-<br>Kfs could be measured for 3NN algorithm). Within feature<br>selection methods, keeping relevant features spurs the per-<br>formance of DT and 3NN better than the prior knowledge,<br>with their combination being the winner. For SVM, instead,<br>adding prior knowledge to the full feature set is the best<br>choice. In the following, all reported experiments refer to<br>the target function T</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:207"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:214"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:94"><nobr><span class="ft4">Feature encoding. Previous figures compared the mean</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:81"><nobr><span class="ft9">accuracies. We unfold the mean value and plot individual<br>accuracies for the syntaxes in S. Figure 2 plots accuracy val-<br>ues for the three feature encoding methods (for T</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:375"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:382"><nobr><span class="ft4">-RP Kf s-</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:81"><nobr><span class="ft4">M ixed combination for DT and 3NN and T</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:345"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:351"><nobr><span class="ft4">-P Kf s-M ixed</span></nobr></DIV>
<DIV style="position:absolute;top:610;left:81"><nobr><span class="ft9">combination for SVM). As the figure shows, the pair-wise<br>comparison F</span></nobr></DIV>
<DIV style="position:absolute;top:631;left:164"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:176"><nobr><span class="ft4">performs best with respect to the raw and</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:81"><nobr><span class="ft4">normalized match numbers.</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:94"><nobr><span class="ft4">Term selection. We complete the analysis of system pa-</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:81"><nobr><span class="ft9">rameters by testing four methods of term selection. They<br>include categories C</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:200"><nobr><span class="ft11">1</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:207"><nobr><span class="ft4">, C</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:224"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:234"><nobr><span class="ft4">and C</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:270"><nobr><span class="ft11">3</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:280"><nobr><span class="ft4">and M ixed. Figure 3 plots</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:81"><nobr><span class="ft9">mean accuracies for all learning algorithms and four term se-<br>lection methods, giving M ixed as the winner.</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:81"><nobr><span class="ft4">Figure 3:</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:162"><nobr><span class="ft4">Four term selection methods for DT,</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:81"><nobr><span class="ft4">KNN, and SVM.</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:81"><nobr><span class="ft3"><b>5.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:972;left:121"><nobr><span class="ft3"><b>Bias in training data</b></span></nobr></DIV>
<DIV style="position:absolute;top:994;left:94"><nobr><span class="ft4">Among the syntaxes in S, all methods show only little dif-</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:81"><nobr><span class="ft9">ference for the unary operators Def ault and Case. Among<br>the syntaxes for binary operators, certain (</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:363"><nobr><span class="ft4">, AND and</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:85"><nobr><span class="ft4">+ ) are easier to detect than others ( " " , OR and NOT ).</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:81"><nobr><span class="ft9">However, this phenomenon is not linked to the nature of the<br>operators or their syntaxes, but rather can be explained by</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:475"><nobr><span class="ft9">the bias in training data. In Table 1, we unfold the indi-<br>vidual accuracies and show results for each case (s, o), s <br>S, o  O in the annotated data. Each non-empty cell in<br>Table 1 reports the occurrence of the case (in brackets) and<br>its classification accuracy. We can observe a definitive bias<br>of high accuracy for more frequent cases; instead, rare cases<br>have a very low accuracy. This explains good results for</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:830"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:479"><nobr><span class="ft4">AND and + , where occurrences are fairly split between</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:475"><nobr><span class="ft9">two main cases. For other syntaxes instead, the high error<br>ratio for rare cases decreases the individual accuracy.</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:475"><nobr><span class="ft3"><b>6.</b></span></nobr></DIV>
<DIV style="position:absolute;top:270;left:507"><nobr><span class="ft3"><b>RELATED WORK</b></span></nobr></DIV>
<DIV style="position:absolute;top:292;left:489"><nobr><span class="ft4">The Hidden Web has emerged as a research trend and dif-</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:475"><nobr><span class="ft9">ferent research groups have started to address various prob-<br>lems relevant to organizing Hidden Web resources [15, 14,<br>17, 19, 20].</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:559"><nobr><span class="ft4">One focus is crawling; [17] presents a task-</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:475"><nobr><span class="ft9">specific and human-assisted approach to the crawling of the<br>Hidden Web.</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:571"><nobr><span class="ft4">The crawler searches for Hidden Web re-</span></nobr></DIV>
<DIV style="position:absolute;top:386;left:475"><nobr><span class="ft9">sources relevant to a specific domain. The identification is<br>achieved by selecting domain-specific keywords from a fuzzy<br>set and assigning them to elements of HTML forms; the<br>resource is judged relevant if it returns valid search results.</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:489"><nobr><span class="ft4">Another important task is the classification of Hidden</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:475"><nobr><span class="ft9">Web resources. [15, 14] and [19] have developed approaches<br>to this problem based on query probing.</span></nobr></DIV>
<DIV style="position:absolute;top:481;left:746"><nobr><span class="ft4">Moreover, [15]</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:475"><nobr><span class="ft9">makes use of the number of documents matching a submit-<br>ted conjunction query, as does our approach.</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:772"><nobr><span class="ft4">Instead of</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:475"><nobr><span class="ft9">query languages, they use match numbers to reason about<br>the relevance of a provider for a given category.</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:489"><nobr><span class="ft4">Originally, the query probing has been used for the auto-</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:475"><nobr><span class="ft9">matic language model discovery in [9], it probed documents<br>in a collection to analyze the content of the result pages.<br>[14] extends the work in [15] to the problem of database<br>selection by computing content summaries based on prob-<br>ing. Once query language interfaces are understood, mean-<br>ingful query transformation becomes possible. [11] describes<br>one way of transforming a front-end query into subsuming<br>queries that are supported by the sources and a way to fil-<br>ter out incorrectly returned documents. In [16], interaction<br>with online-vendors is automated.</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:489"><nobr><span class="ft4">In the close domain of meta-searching, the declaration of a</span></nobr></DIV>
<DIV style="position:absolute;top:747;left:475"><nobr><span class="ft9">search resource's query features is often coupled with meth-<br>ods of converting/translating meta-search queries into the<br>resource's native queries. Considerable research effort has<br>been devoted to minimizing the possible overheads of query<br>translation when the meta-search and search resource differ<br>in supporting basic query features [11]. In all these methods,<br>the manual discovery of the query features is assumed.</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:489"><nobr><span class="ft4">In information mediation systems that query Web resources</span></nobr></DIV>
<DIV style="position:absolute;top:873;left:475"><nobr><span class="ft9">to materialize views on hidden data [20], one approach is to<br>reconstruct an image of a resource's database. Because of<br>a restricted Web interface, a critical problem is the entire<br>or partial reconstruction of the database image without the<br>unnecessary overload of the Web servers. [8] builds efficient<br>query covers that are accessible through nearest-neighbor<br>interfaces for the specific domain of spatial databases.</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:475"><nobr><span class="ft3"><b>7.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:507"><nobr><span class="ft3"><b>OPEN QUESTIONS</b></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:489"><nobr><span class="ft4">The experiments have raised a number of open questions</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:475"><nobr><span class="ft4">that require further research. Below we list some of them.</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:489"><nobr><span class="ft4">Stopwords. In tests, common English stopwords were</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:475"><nobr><span class="ft4">excluded from probing. However, the set of stopwords is</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:441"><nobr><span class="ft7">1120</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1269;">
<STYLE type="text/css">
<!--
	.ft14{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1269" src="124008.png" alt="background image">
<DIV style="position:absolute;top:89;left:126"><nobr><span class="ft4">Operators</span></nobr></DIV>
<DIV style="position:absolute;top:89;left:477"><nobr><span class="ft4">Syntaxes</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:226"><nobr><span class="ft4">default</span></nobr></DIV>
<DIV style="position:absolute;top:104;left:322"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:105;left:448"><nobr><span class="ft4">""</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:496"><nobr><span class="ft4">AND</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:572"><nobr><span class="ft4">OR</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:644"><nobr><span class="ft4">+</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:688"><nobr><span class="ft4">NOT</span></nobr></DIV>
<DIV style="position:absolute;top:104;left:774"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:121;left:126"><nobr><span class="ft4">Case</span></nobr></DIV>
<DIV style="position:absolute;top:121;left:219"><nobr><span class="ft4">97.6(20)</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:126"><nobr><span class="ft4">Stemming</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:291"><nobr><span class="ft4">41.1(9)</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:126"><nobr><span class="ft4">Conjunction</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:352"><nobr><span class="ft4">92.9(15)</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:482"><nobr><span class="ft4">95.2(27)</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:613"><nobr><span class="ft4">100(16)</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:126"><nobr><span class="ft4">Disjunction</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:356"><nobr><span class="ft4">100(19)</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:548"><nobr><span class="ft4">87.8(17)</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:126"><nobr><span class="ft4">Negation</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:674"><nobr><span class="ft4">91.0(15)</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:740"><nobr><span class="ft4">94.9(26)</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:126"><nobr><span class="ft4">Phrase</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:376"><nobr><span class="ft4">0(1)</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:417"><nobr><span class="ft4">90.4(28)</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:126"><nobr><span class="ft4">Literal</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:222"><nobr><span class="ft4">100(16)</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:489"><nobr><span class="ft4">79.6(7)</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:548"><nobr><span class="ft4">91.7(11)</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:674"><nobr><span class="ft4">69.2(14)</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:126"><nobr><span class="ft4">Ignored</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:284"><nobr><span class="ft4">79.9(27)</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:424"><nobr><span class="ft4">18.5(4)</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:496"><nobr><span class="ft4">3.7(1)</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:555"><nobr><span class="ft4">55.6(4)</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:613"><nobr><span class="ft4">100(19)</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:681"><nobr><span class="ft4">25.0(4)</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:747"><nobr><span class="ft4">81.0(7)</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:126"><nobr><span class="ft4">Unknown</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:376"><nobr><span class="ft4">0(1)</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:431"><nobr><span class="ft4">4.1(4)</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:507"><nobr><span class="ft4">0(1)</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:555"><nobr><span class="ft4">19.4(4)</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:634"><nobr><span class="ft4">0(1)</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:699"><nobr><span class="ft4">0(3)</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:764"><nobr><span class="ft4">0(3)</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:81"><nobr><span class="ft4">Table 1: Classification accuracy and occurrence for all syntax+interpretation cases (DT,T</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:701"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:708"><nobr><span class="ft4">,F</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:721"><nobr><span class="ft11">2</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:727"><nobr><span class="ft4">,RPKfs,M ixed).</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:81"><nobr><span class="ft9">often domain-dependent; this should be taken into account<br>when generating test queries. A more difficult case is when<br>a resource treats terms as stopwords in a certain context.<br>For example, Google accepts the term "WWW" when it is<br>queried alone and ignores it when the term is conjuncted<br>with other terms. Such query-dependent treatment of stop-<br>words is considered as noise in the current system.</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:94"><nobr><span class="ft4">Acquiring other operators. We have addressed the</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:81"><nobr><span class="ft9">set of most frequently used query operators. Other oper-<br>ators defined by existing document retrieval models, like<br>proximity operators, can be added to the operator set and<br>processed in a similar manner. Two remarks concerning less<br>frequent operators are that their syntactical encodings may<br>vary even more than for Boolean operators, and, more im-<br>portantly, finding sufficient training data to build reliable<br>classifiers may be technically difficult.</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:94"><nobr><span class="ft4">Query composition. The next issue is the manner in</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:81"><nobr><span class="ft9">which basic query operators are combined to form complex<br>queries. The most frequent manner on the Web is the use<br>of parentheses or a certain operator priority. How to detect<br>this remains an open problem at this point.</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:94"><nobr><span class="ft4">Ambiguous interpretations. Recognizing ambiguous</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:81"><nobr><span class="ft9">interpretations is the most difficult problem. One example<br>is Citeseer, which interprets whitespaces as conjunction by<br>default, but switches to disjunction if the conjunction query<br>matches no documents. Some other Web providers behave<br>in the same or a similar manner. We will need to extend<br>the learning system to include a possibility of triggering the<br>retrieval model as a function of the oracle answers.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:81"><nobr><span class="ft3"><b>8.</b></span></nobr></DIV>
<DIV style="position:absolute;top:800;left:112"><nobr><span class="ft3"><b>CONCLUSION</b></span></nobr></DIV>
<DIV style="position:absolute;top:822;left:94"><nobr><span class="ft4">We have addressed the problem of automatic recognition</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:81"><nobr><span class="ft9">of operators and syntaxes supported by query languages of<br>Web resources. We have developed a machine learning ap-<br>proach based on reformulation of the entire problem as a set<br>of classification problems. By introducing various refined<br>solutions for the target function, feature encoding, and fea-<br>ture selection, we have achieved 86% mean accuracy for the<br>set of the most frequent operators and syntaxes. Further<br>improvement in the accuracy is possible with better prepa-<br>ration of annotated sites, but this is limited because of the<br>complexity of the a-priori unknown operator composition<br>and the noise produced by the hidden query preprocessing.</span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:81"><nobr><span class="ft3"><b>9.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:112"><nobr><span class="ft3"><b>REFERENCES</b></span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:88"><nobr><span class="ft14">[1] The InvisibleWeb, http://www.invisibleweb.com/.<br>[2] BrightPlanet, http://www.brightplanet.com/.<br>[3] CompletePlanet, http://www.completeplanet.com/.</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:482"><nobr><span class="ft4">[4] G. Alonso. Myths around web services. IEEE Bulletin</span></nobr></DIV>
<DIV style="position:absolute;top:338;left:503"><nobr><span class="ft4">on Data Engineering, 25(4):3­9, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:482"><nobr><span class="ft4">[5] D. Angluin. Queries and concept learning. Machine</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:503"><nobr><span class="ft4">Learning, 2(4):319­342, 1987.</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:482"><nobr><span class="ft4">[6] M. K. Bergman. The Deep Web: Surfacing hidden</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:503"><nobr><span class="ft4">value. Journal of Electronic Publishing, 7(1), 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:482"><nobr><span class="ft4">[7] D. Bredelet and B. Roustant. Java IWrap: Wrapper</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:503"><nobr><span class="ft12">induction by grammar learning. Master's thesis,<br>ENSIMAG Grenoble, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:482"><nobr><span class="ft4">[8] S. Byers, J. Freire, and C. T. Silva. Efficient</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:503"><nobr><span class="ft12">acquisition of web data through restricted query<br>interfaces. In Proc. WWW Conf., China, May 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:494;left:482"><nobr><span class="ft4">[9] J. P. Callan, M. Connell, and A. Du. Automatic</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:503"><nobr><span class="ft12">discovery of language models for text databases. In<br>Proc. ACM SIGMOD Conf., pp. 479­490, June 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:536;left:475"><nobr><span class="ft4">[10] C.-C. K. Chang and H Garcia-Molina. Approximate</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:503"><nobr><span class="ft12">query translation across heterogeneous information<br>sources. In Proc. VLDB Conf., pp. 566­577, Cairo,<br>Egypt, September 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:475"><nobr><span class="ft4">[11] C.-C. K. Chang, H. Garcia-Molina, and A. Paepcke.</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:503"><nobr><span class="ft12">Boolean query mapping across heterogeneous<br>information sources. IEEE TKDE, 8(4):515­521, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:475"><nobr><span class="ft4">[12] B. Chidlovskii. Automatic repairing of web wrappers</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:503"><nobr><span class="ft12">by combining redundant views. In Proc. of the IEEE<br>Intern. Conf. Tools with AI, USA, November 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:475"><nobr><span class="ft4">[13] L. Gravano, H. Garcia-Molina, and A. Tomasic. Gloss:</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:503"><nobr><span class="ft12">Text-source discovery over the internet. ACM TODS,<br>24(2):229­264, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:475"><nobr><span class="ft4">[14] P. G. Ipeirotis and L. Gravano. Distributed search</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:503"><nobr><span class="ft12">over the hidden web: Hierarchical database sampling<br>and selection. In Proc. VLDB Conf., pp. 394­405,<br>Hong Kong, China, August 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:475"><nobr><span class="ft4">[15] P. G. Ipeirotis, L. Gravano, and M. Sahami. Probe,</span></nobr></DIV>
<DIV style="position:absolute;top:785;left:503"><nobr><span class="ft12">count, and classify: Categorizing hidden-web<br>databases. In Proc. ACM SIGMOD Conf., pp. 67­78,<br>Santa Barbara, CA, USA, May 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:475"><nobr><span class="ft4">[16] M. Perkowitz, R. B. Doorenbos, O. Etzioni, and D. S.</span></nobr></DIV>
<DIV style="position:absolute;top:840;left:503"><nobr><span class="ft12">Weld. Learning to understand information on the<br>internet: An example-based approach. Journal of<br>Intelligent Information Systems, 8(2):133­153, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:475"><nobr><span class="ft4">[17] S. Raghavan and H. Garcia-Molina. Crawling the</span></nobr></DIV>
<DIV style="position:absolute;top:896;left:503"><nobr><span class="ft12">hidden web. In Proc. VLDB Conf., pp. 129­138,<br>Rome, Italy, September 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:475"><nobr><span class="ft4">[18] D. Tsur. Are web services the next revolution in</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:503"><nobr><span class="ft12">e-commerce? In Proc. VLDB Conf., pp. 614­617,<br>Rome, Italy, September 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:475"><nobr><span class="ft4">[19] W. Wang, W. Meng, and C. Yu. Concept hierarchy</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:503"><nobr><span class="ft12">based text database categorization. In Proc. Intern.<br>WISE Conf., pp. 283­290, China, June 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:475"><nobr><span class="ft4">[20] R. Yerneni, C. Li, H. Garcia-Molina, and J. Ullman.</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:503"><nobr><span class="ft12">Computing capabilities of mediators. In Proc. ACM<br>SIGMOD Conf., pp. 443­454, PA, USA, June 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:441"><nobr><span class="ft7">1121</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
