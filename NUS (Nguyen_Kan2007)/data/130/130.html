<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>D:\Paper\HTML\130</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2002-08-14T16:26:05+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
	.ft0{font-size:9px;font-family:Times;color:#000000;}
	.ft1{font-size:23px;font-family:Times;color:#000000;}
	.ft2{font-size:11px;font-family:Times;color:#000000;}
	.ft3{font-size:12px;font-family:Times;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:11px;font-family:Times;color:#000000;}
	.ft6{font-size:6px;font-family:Times;color:#0000ff;}
	.ft7{font-size:5px;font-family:Times;color:#000000;}
	.ft8{font-size:6px;font-family:Times;color:#000000;}
	.ft9{font-size:6px;font-family:Times;color:#000000;}
	.ft10{font-size:16px;font-family:Courier;color:#000000;}
	.ft11{font-size:19px;font-family:Times;color:#000000;}
	.ft12{font-size:9px;line-height:14px;font-family:Times;color:#000000;}
	.ft13{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft14{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft15{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1262" src="130001.png" alt="background image">
<DIV style="position:absolute;top:90;left:108"><nobr><span class="ft12">Graphics Hardware (2002)<br>Thomas Ertl, Wolfgang Heidrich, and Michael Doggett (Editors)</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:162"><nobr><span class="ft1"><b>Low Latency Photon Mapping Using Block Hashing</b></span></nobr></DIV>
<DIV style="position:absolute;top:257;left:334"><nobr><span class="ft2">Vincent C. H. Ma and Michael D. McCool</span></nobr></DIV>
<DIV style="position:absolute;top:291;left:318"><nobr><span class="ft0">Computer Graphics Lab, School of Computer Science,</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:327"><nobr><span class="ft0">University of Waterloo, Waterloo, Ontario, Canada</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:144"><nobr><span class="ft3"><b>Abstract</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:144"><nobr><span class="ft2"></b>For hardware accelerated rendering, photon mapping is especially useful for simulating caustic lighting effects on<br>non-Lambertian surfaces. However, an efficient hardware algorithm for the computation of the <i>k </i>nearest neigh-<br>bours to a sample point is required.<br>Existing algorithms are often based on recursive spatial subdivision techniques, such as <i>kd</i>-trees. However, hard-<br>ware implementation of a tree-based algorithm would have a high latency, or would require a large cache to avoid<br>this latency on average.<br>We present a neighbourhood-preserving hashing algorithm that is low-latency and has sub-linear access time.<br>This algorithm is more amenable to fine-scale parallelism than tree-based recursive spatial subdivision, and maps<br>well onto coherent block-oriented pipelined memory access. These properties make the algorithm suitable for<br>implementation using future programmable fragment shaders with only one stage of dependent texturing.</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:144"><nobr><span class="ft3">Categories and Subject Descriptors</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:347"><nobr><span class="ft0">(according to ACM CCS)</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:476"><nobr><span class="ft2">: I.3.7 [Computer Graphics]: Three-Dimensional</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:144"><nobr><span class="ft2">Graphics and Realism, Color, Shading, Shadowing, and Texture.</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:108"><nobr><span class="ft3"><b>1. Introduction</b></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:108"><nobr><span class="ft2">Photon mapping, as described by Jensen</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:335"><nobr><span class="ft6">25</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:344"><nobr><span class="ft2">, is a technique</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:108"><nobr><span class="ft15">for reconstructing the incoming light field at surfaces every-<br>where in a scene from sparse samples generated by forward<br>light path tracing. In conjunction with path tracing, photon<br>mapping can be used to accelerate the computation of both<br>diffuse and specular global illumination . It is most effective<br>for specular or glossy reflectance effects, such as caustics</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:417"><nobr><span class="ft6">24</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:426"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:807;left:122"><nobr><span class="ft2">The benefits of migrating photo-realistic rendering tech-</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:108"><nobr><span class="ft15">niques towards a real-time, hardware-assisted implementa-<br>tion are obvious. Recent work has shown that it is possi-<br>ble to implement complex algorithms, such as ray-tracing,<br>using the programmable features of general-purpose hard-<br>ware accelerators</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:203"><nobr><span class="ft6">35</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:217"><nobr><span class="ft2">and/or specialised hardware</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:374"><nobr><span class="ft6">41</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:384"><nobr><span class="ft2">. We are</span></nobr></DIV>
<DIV style="position:absolute;top:906;left:108"><nobr><span class="ft15">interested in hardware support for photon mapping: specif-<br>ically, the application of photon maps to the direct visuali-<br>sation of caustics on non-Lambertian surfaces, since diffuse<br>global illumination effects are probably best handled in a<br>real-time renderer using alternative techniques such as irra-<br>diance volumes</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:192"><nobr><span class="ft6">18</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:201"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:122"><nobr><span class="ft2">Central to photon mapping is the search for the set of pho-</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:108"><nobr><span class="ft2">tons nearest to the point being shaded. This is part of the in-</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:467"><nobr><span class="ft15">terpolation step that joins light paths propagated from light<br>sources with rays traced from the camera during rendering,<br>and it is but one application of the well-studied <i>k </i>nearest<br>neighbours (<i>k</i>NN) problem.</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:480"><nobr><span class="ft2">Jensen uses the <i>kd</i>-tree</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:603"><nobr><span class="ft6">5</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:607"><nobr><span class="ft7">,</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:611"><nobr><span class="ft6">6</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:619"><nobr><span class="ft2">data structure to find these near-</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:467"><nobr><span class="ft15">est photons. However, solving the <i>k</i>NN problem via <i>kd</i>-trees<br>requires a search that traverses the tree. Even if the tree is<br>stored as a heap, traversal still requires random-order mem-<br>ory access and memory to store a stack. More importantly,<br>a search-path pruning algorithm, based on the data already<br>examined, is required to avoid accessing all data in the tree.<br>This introduces serial dependencies between one memory<br>lookup and the next. Consequently, a hardware implementa-<br>tion of a <i>kd</i>-tree-based <i>k</i>NN solution would either have high<br>latency, or would require a large cache to avoid such latency.<br>In either case a custom hardware implementation would be<br>required. These properties motivated us to look at alterna-<br>tives to tree search.</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:480"><nobr><span class="ft2">Since photon mapping is already making an approxima-</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:467"><nobr><span class="ft15">tion by using <i>k</i>NN interpolation, we conjectured that an<br>approximate <i>k</i>NN (A<i>k</i>NN) solution should suffice so long<br>as visual quality is maintained. In this paper we investi-<br>gate a hashing-based A<i>k</i>NN solution in the context of high-</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:111"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">89</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
	.ft16{font-size:9px;font-family:Times;color:#000000;}
	.ft17{font-size:11px;font-family:Times;color:#0000ff;}
	.ft18{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1262" src="130002.png" alt="background image">
<DIV style="position:absolute;top:98;left:281"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:108"><nobr><span class="ft15">performance hardware-based (specifically, programmable<br>shader-based) photon mapping. Our major contribution is<br>an A<i>k</i>NN algorithm that has bounded query time, bounded<br>memory usage, and high potential for fine-scale parallelism.<br>Moreover, our algorithm results in coherent, non-redundant<br>accesses to block-oriented memory. The results of one mem-<br>ory lookup do not affect subsequent memory lookups, so ac-<br>cesses can take place in parallel within a pipelined mem-<br>ory system. Our algorithm is based on array access, and is<br>more compatible with current texture-mapping capabilities<br>than tree-based algorithms. Furthermore, any photon map-<br>ping acceleration technique that continues to rely on a form<br>of <i>k</i>NN (such as irradiance caching</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:302"><nobr><span class="ft6">7</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:307"><nobr><span class="ft2">) can still benefit from</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:108"><nobr><span class="ft2">our technique.</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:122"><nobr><span class="ft2">In Section</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:183"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:189"><nobr><span class="ft2">, we first review previous work on the <i>k</i>NN</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:108"><nobr><span class="ft15">and the approximate <i>k</i>-nearest neighbour (A<i>k</i>NN) problems.<br>Section</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:153"><nobr><span class="ft17">3</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:164"><nobr><span class="ft2">describes the context and assumptions of our re-</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:108"><nobr><span class="ft15">search and illustrates the basic hashing technique used in<br>our algorithm. Sections</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:241"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:252"><nobr><span class="ft2">and</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:276"><nobr><span class="ft17">5</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:287"><nobr><span class="ft2">describe the details of our</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:108"><nobr><span class="ft2">algorithm. Section</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:212"><nobr><span class="ft17">6</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:222"><nobr><span class="ft2">presents numerical, visual quality, and</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:108"><nobr><span class="ft2">performance results. Section</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:265"><nobr><span class="ft17">7</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:276"><nobr><span class="ft2">discusses the mapping of the</span></nobr></DIV>
<DIV style="position:absolute;top:481;left:108"><nobr><span class="ft15">algorithm onto a shader-based implementation. Finally, we<br>conclude in Section</span></nobr></DIV>
<DIV style="position:absolute;top:497;left:217"><nobr><span class="ft17">8</span></nobr></DIV>
<DIV style="position:absolute;top:497;left:224"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:108"><nobr><span class="ft3"><b>2. Previous Work</b></span></nobr></DIV>
<DIV style="position:absolute;top:563;left:108"><nobr><span class="ft2">Jensen's book</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:183"><nobr><span class="ft6">25</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:195"><nobr><span class="ft2">covers essentially all relevant previous work</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:108"><nobr><span class="ft15">leading up to photon mapping. Due to space limitations, we<br>will refer the reader to that book and focus our literature re-<br>view on previous approaches to the <i>k</i>NN and A<i>k</i>NN prob-<br>lems.</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:122"><nobr><span class="ft2">Any non-trivial algorithm that claims to be able to solve</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:108"><nobr><span class="ft15">the <i>k</i>NN problem faster than brute-force does so by reduc-<br>ing the number of candidates that have to be examined when<br>computing the solution set. Algorithms fall into the follow-<br>ing categories: <i>recursive spatial subdivision</i>, <i>point location</i>,<br><i>neighbourhood graphs</i>, and <i>hashing</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:122"><nobr><span class="ft2">Amongst algorithms based on recursive spatial subdivi-</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:108"><nobr><span class="ft2">sion, the <i>kd</i>-tree</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:202"><nobr><span class="ft6">5</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:211"><nobr><span class="ft2">method is the approach commonly used</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:108"><nobr><span class="ft2">to solve the <i>k</i>NN problem</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:249"><nobr><span class="ft6">14</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:259"><nobr><span class="ft2">. An advantage of the <i>kd</i>-tree is</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:108"><nobr><span class="ft15">that if the tree is balanced it can be stored as a heap in a<br>single array. While it has been shown that <i>kd</i>-trees have op-<br>timal expected-time complexity</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:281"><nobr><span class="ft6">6</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:286"><nobr><span class="ft2">, in the worst case finding</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:108"><nobr><span class="ft15">the <i>k </i>nearest neighbours may require an exhaustive search of<br>the entire data structure via recursive decent. This requires a<br>stack the same size as the depth of the tree. During the recur-<br>sion, a choice is made of which subtree to search next based<br>on a test at each internal node. This introduces a dependency<br>between one memory access and the next and makes it hard<br>to map this algorithm into high-latency pipelined memory<br>accesses.</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:122"><nobr><span class="ft2">Much work has been done to find methods to optimise</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:108"><nobr><span class="ft15">the <i>kd</i>-tree method of solving the <i>k</i>NN and A<i>k</i>NN problems.<br>See Christensen</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:197"><nobr><span class="ft6">26</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:207"><nobr><span class="ft2">, Vanco <i>et al.</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:287"><nobr><span class="ft6">44</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:296"><nobr><span class="ft2">, Havran</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:345"><nobr><span class="ft6">19</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:355"><nobr><span class="ft2">, and Sample</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:467"><nobr><span class="ft5"><i>et al.</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:494"><nobr><span class="ft6">39</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:504"><nobr><span class="ft2">. Many other recursive subdivision-based techniques</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:467"><nobr><span class="ft15">have also been proposed for the <i>k</i>NN and A<i>k</i>NN problems,<br>including <i>kd</i>-B-trees</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:579"><nobr><span class="ft6">36</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:588"><nobr><span class="ft2">, BBD-trees</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:654"><nobr><span class="ft6">4</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:659"><nobr><span class="ft2">, BAR-trees</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:724"><nobr><span class="ft6">9</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:729"><nobr><span class="ft2">, Principal-</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:467"><nobr><span class="ft2">Axis Trees</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:528"><nobr><span class="ft6">33</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:538"><nobr><span class="ft2">, the R-tree family of data structures</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:751"><nobr><span class="ft6">27</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:760"><nobr><span class="ft2">, and</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:467"><nobr><span class="ft2">ANN-trees</span></nobr></DIV>
<DIV style="position:absolute;top:192;left:526"><nobr><span class="ft6">30</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:535"><nobr><span class="ft2">. Unfortunately, all schemes based on recursive</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:467"><nobr><span class="ft15">search over a tree share the same memory dependency prob-<br>lem as the <i>kd</i>-tree.</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:480"><nobr><span class="ft2">The second category of techniques are based on build-</span></nobr></DIV>
<DIV style="position:absolute;top:266;left:467"><nobr><span class="ft15">ing and searching graphs that encode sample-adjacency in-<br>formation. The randomised neighbourhood graph approach</span></nobr></DIV>
<DIV style="position:absolute;top:282;left:784"><nobr><span class="ft6">3</span></nobr></DIV>
<DIV style="position:absolute;top:299;left:467"><nobr><span class="ft15">builds and searches an approximate local neighbourhood<br>graph. Eppstein <i>et al.</i></span></nobr></DIV>
<DIV style="position:absolute;top:314;left:580"><nobr><span class="ft6">11</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:593"><nobr><span class="ft2">investigated the fundamental proper-</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:467"><nobr><span class="ft15">ties of a nearest neighbour graph. Jaromczyk and Toussaint<br>surveyed data structures and techniques based on Relative<br>Neighbourhood Graphs</span></nobr></DIV>
<DIV style="position:absolute;top:364;left:595"><nobr><span class="ft6">23</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:605"><nobr><span class="ft2">. Graph-based techniques tend to</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:467"><nobr><span class="ft15">have the same difficulties as tree-based approaches: search-<br>ing a graph also involves stacks or queues, dependent mem-<br>ory accesses, and pointer-chasing unsuited to high-latency<br>pipelined memory access.</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:480"><nobr><span class="ft2">Voronoi diagrams can be used for optimal 1-nearest</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:467"><nobr><span class="ft2">neighbour searches in 2D and 3D</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:654"><nobr><span class="ft6">10</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:664"><nobr><span class="ft2">. This and other point-</span></nobr></DIV>
<DIV style="position:absolute;top:487;left:467"><nobr><span class="ft2">location based techniques</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:609"><nobr><span class="ft6">17</span></nobr></DIV>
<DIV style="position:absolute;top:487;left:625"><nobr><span class="ft2">for solving nearest neighbour</span></nobr></DIV>
<DIV style="position:absolute;top:503;left:467"><nobr><span class="ft15">problems do not need to calculate distances between the<br>query point and the candidates, but do need another data<br>structure (like a BSP tree) to test a query point for inclusion<br>in a region.</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:480"><nobr><span class="ft2">Hashing approaches to the <i>k</i>NN and A<i>k</i>NN problems</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:467"><nobr><span class="ft2">have recently been proposed by Indyk <i>et al.</i></span></nobr></DIV>
<DIV style="position:absolute;top:592;left:713"><nobr><span class="ft6">20</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:721"><nobr><span class="ft7">,</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:726"><nobr><span class="ft6">21</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:740"><nobr><span class="ft2">and Gio-</span></nobr></DIV>
<DIV style="position:absolute;top:609;left:467"><nobr><span class="ft2">nis <i>et al.</i></span></nobr></DIV>
<DIV style="position:absolute;top:608;left:515"><nobr><span class="ft6">16</span></nobr></DIV>
<DIV style="position:absolute;top:609;left:525"><nobr><span class="ft2">. These techniques have the useful property that</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:467"><nobr><span class="ft15">multi-level dependent memory lookups are not required. The<br>heart of these algorithms are simple hash functions that pre-<br>serve spatial locality, such as the one proposed by Linial<br>and Sasson</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:527"><nobr><span class="ft6">31</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:537"><nobr><span class="ft2">, and Gionis <i>et al.</i></span></nobr></DIV>
<DIV style="position:absolute;top:674;left:633"><nobr><span class="ft6">16</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:643"><nobr><span class="ft2">. We base our technique on</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:467"><nobr><span class="ft15">the latter. The authors also recognise recent work by Wald<br><i>et al.</i></span></nobr></DIV>
<DIV style="position:absolute;top:707;left:496"><nobr><span class="ft6">45</span></nobr></DIV>
<DIV style="position:absolute;top:708;left:511"><nobr><span class="ft2">on real-time global illumination techniques where</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:467"><nobr><span class="ft15">a hashing-based photon mapping technique was apparently<br>used (but not described in detail).</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:480"><nobr><span class="ft2">Numerous surveys and books</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:639"><nobr><span class="ft6">1</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:644"><nobr><span class="ft7">,</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:648"><nobr><span class="ft6">2</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:653"><nobr><span class="ft7">,</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:657"><nobr><span class="ft6">15</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:666"><nobr><span class="ft7">,</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:670"><nobr><span class="ft6">42</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:679"><nobr><span class="ft7">,</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:684"><nobr><span class="ft6">43</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:693"><nobr><span class="ft7">,</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:697"><nobr><span class="ft6">17</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:709"><nobr><span class="ft2">provide further</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:467"><nobr><span class="ft15">information on this family of problems and data structures<br>developed to solve them.</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:467"><nobr><span class="ft3"><b>3. Context</b></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:467"><nobr><span class="ft15">We have developed a novel technique called <i>Block Hashing<br></i>(BH) to solve the approximate <i>k</i>NN (A<i>k</i>NN) problem in the<br>context of, but not limited to, photon mapping.</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:480"><nobr><span class="ft2">Our algorithm uses hash functions to categorise photons</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:467"><nobr><span class="ft15">by their positions. Then, a <i>k</i>NN query proceeds by deciding<br>which hash bucket is matched to the query point and retriev-<br>ing the photons contained inside the hash bucket for analy-<br>sis. One attraction of the hashing approach is that evaluation<br>of hash functions takes constant time. In addition, once we<br>have the hash value, accessing data we want in the hash ta-<br>ble takes only a single access. These advantages permit us to</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:649"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">90</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
	.ft19{font-size:8px;font-family:Times;color:#000000;}
	.ft20{font-size:8px;font-family:Times;color:#000000;}
	.ft21{font-size:8px;font-family:Times;color:#000000;}
	.ft22{font-size:7px;font-family:Times;color:#000000;}
	.ft23{font-size:7px;font-family:Times;color:#000000;}
	.ft24{font-size:11px;font-family:Symbol;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1262" src="130003.png" alt="background image">
<DIV style="position:absolute;top:98;left:280"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:108"><nobr><span class="ft15">avoid operations that are serially dependent on one another,<br>such as those required by <i>kd</i>-trees, and are major stepping<br>stones towards a low-latency shader-based implementation.</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:122"><nobr><span class="ft2">Our technique is designed under two assumptions on the</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:108"><nobr><span class="ft15">behaviour of memory systems in (future) accelerators. First,<br>we assume that memory is allocated in fixed-sized blocks .<br>Second, we assume that access to memory is via burst trans-<br>fer of blocks that are then cached. Under this assumption,<br>if any part of a fixed-sized memory block is "touched", ac-<br>cess to the rest of this block will be virtually zero-cost. This<br>is typical even of software implementations on modern ma-<br>chines which rely heavily on caching and burst-mode trans-<br>fers from SDRAM or RDRAM. In a hardware implementa-<br>tion with a greater disparity between processing power and<br>memory speed, using fast block transfers and caching is even<br>more important. Due to these benefits, in BH all memory<br>used to store photon data is broken into fixed-sized blocks.</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:108"><nobr><span class="ft3"><b>3.1. Locality-Sensitive Hashing</b></span></nobr></DIV>
<DIV style="position:absolute;top:464;left:108"><nobr><span class="ft15">Since our goal is to solve the <i>k</i>NN problem as efficiently as<br>possible in a block-oriented cache-based context, our hash-<br>ing technique requires hash functions that preserve spatial<br>neighbourhoods. These hash functions take points that are<br>close to each other in the domain space and hash them close<br>to each other in hash space. By using such hash functions,<br>photons within the same hash bucket as a query point can be<br>assumed to be close to the query point in the original domain<br>space. Consequently, these photons are good candidates for<br>the <i>k</i>NN search. More than one such scheme is available; we<br>chose to base our technique on the Locality-Sensitive Hash-<br>ing (LSH) algorithm proposed by Gionis <i>et al.</i></span></nobr></DIV>
<DIV style="position:absolute;top:644;left:367"><nobr><span class="ft6">16</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:376"><nobr><span class="ft2">, but have</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:108"><nobr><span class="ft2">added several refinements (which we describe in Section</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:416"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:423"><nobr><span class="ft2">).</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:122"><nobr><span class="ft2">The hash function in LSH groups one-dimensional real</span></nobr></DIV>
<DIV style="position:absolute;top:702;left:108"><nobr><span class="ft15">numbers in hash space by their spatial location. It does so<br>by partitioning the domain space and assigning a unique<br>hash value to each partition. Mathematically, let</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:403"><nobr><span class="ft4">T =</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:108"><nobr><span class="ft4">{<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:755;left:118"><nobr><span class="ft19"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:750;left:126"><nobr><span class="ft4">| 0  <i>i </i> <i>P</i>} be a monotonically increasing sequence</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:108"><nobr><span class="ft2">of <i>P </i>+ 1 thresholds between 0 and 1. Assume <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:772;left:368"><nobr><span class="ft20">0</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:382"><nobr><span class="ft4">= 0 and</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:108"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:788;left:111"><nobr><span class="ft19"><i>P</i></span></nobr></DIV>
<DIV style="position:absolute;top:784;left:127"><nobr><span class="ft4">= 1, so there are <i>P</i></span></nobr></DIV>
<DIV style="position:absolute;top:783;left:241"><nobr><span class="ft4">- 1 degrees of freedom in this se-</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:108"><nobr><span class="ft15">quence. Define a one-dimensional Locality-Sensitive Hash<br>Function <i>h</i></span></nobr></DIV>
<DIV style="position:absolute;top:821;left:166"><nobr><span class="ft21">T</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:179"><nobr><span class="ft2">: [0, 1]</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:214"><nobr><span class="ft4"> {0 . . . <i>P </i>- 1} to be <i>h</i></span></nobr></DIV>
<DIV style="position:absolute;top:821;left:340"><nobr><span class="ft21">T</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:351"><nobr><span class="ft4">(<i>t</i>) = <i>i</i>, where</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:108"><nobr><span class="ft5"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:838;left:111"><nobr><span class="ft19"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:832;left:124"><nobr><span class="ft4"> <i>t </i>&lt; <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:838;left:178"><nobr><span class="ft19"><i>i</i>+1</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:195"><nobr><span class="ft2">. In other words, the hash value <i>i </i>can take</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:108"><nobr><span class="ft15">on <i>P </i>different values, one for each "bucket" defined by the<br>threshold pair [<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:870;left:193"><nobr><span class="ft19"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:866;left:196"><nobr><span class="ft4">,<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:871;left:205"><nobr><span class="ft19"><i>i</i>+1</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:222"><nobr><span class="ft4">). An example is shown in Figure</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:405"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:412"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:154"><nobr><span class="ft20">t</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:157"><nobr><span class="ft22">1</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:231"><nobr><span class="ft20">t</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:234"><nobr><span class="ft22">2</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:339"><nobr><span class="ft20">t</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:342"><nobr><span class="ft22">3</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:423"><nobr><span class="ft20">t</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:426"><nobr><span class="ft22">4</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:108"><nobr><span class="ft20">t</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:111"><nobr><span class="ft22">0</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:108"><nobr><span class="ft3"><b>Figure 1: </b><i>An example of h</i></span></nobr></DIV>
<DIV style="position:absolute;top:945;left:247"><nobr><span class="ft21">T</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:258"><nobr><span class="ft5"><i>. The circles and boxes represent</i></span></nobr></DIV>
<DIV style="position:absolute;top:957;left:108"><nobr><span class="ft18"><i>values to be hashed, while the vertical lines are the thresh-<br>olds in</i></span></nobr></DIV>
<DIV style="position:absolute;top:973;left:146"><nobr><span class="ft4">T <i>. The boxes lie between t</i></span></nobr></DIV>
<DIV style="position:absolute;top:978;left:285"><nobr><span class="ft20">1</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:294"><nobr><span class="ft5"><i>and t</i></span></nobr></DIV>
<DIV style="position:absolute;top:978;left:320"><nobr><span class="ft20">2</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:326"><nobr><span class="ft5"><i>, thus they are given</i></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:108"><nobr><span class="ft5"><i>a hash value of 1.</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:122"><nobr><span class="ft2">The function <i>h</i></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:203"><nobr><span class="ft21">T</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:217"><nobr><span class="ft2">can be interpreted as a monotonic non-</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:467"><nobr><span class="ft15">uniform quantisation of spatial position, and is characterised<br>by <i>P </i>and the sequence</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:586"><nobr><span class="ft4">T . It is important to note that <i>h</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:749"><nobr><span class="ft21">T</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:762"><nobr><span class="ft2">gives</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:467"><nobr><span class="ft2">each partition of the domain space delineated by</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:744"><nobr><span class="ft4">T equal</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:467"><nobr><span class="ft15">representation in hash space. Depending on the location of<br>the thresholds, <i>h</i></span></nobr></DIV>
<DIV style="position:absolute;top:197;left:558"><nobr><span class="ft21">T</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:573"><nobr><span class="ft2">will contract some parts of the domain</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:467"><nobr><span class="ft15">space and expand other parts. If we rely on only a single<br>hash table to classify a data set, a query point will only hash<br>to a single bucket within this table, and the bucket may rep-<br>resent only a subset of the true neighbourhood we sought.<br>Therefore, multiple hash tables with different thresholds are<br>necessary for the retrieval of a more complete neighbour-<br>hood around the query point (See Figure</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:688"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:695"><nobr><span class="ft2">.)</span></nobr></DIV>
<DIV style="position:absolute;top:352;left:775"><nobr><span class="ft0">h</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:780"><nobr><span class="ft23"><i>T1</i></span></nobr></DIV>
<DIV style="position:absolute;top:410;left:775"><nobr><span class="ft0">h</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:780"><nobr><span class="ft23"><i>T3</i></span></nobr></DIV>
<DIV style="position:absolute;top:381;left:775"><nobr><span class="ft0">h</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:780"><nobr><span class="ft23"><i>T2</i></span></nobr></DIV>
<DIV style="position:absolute;top:365;left:510"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:513"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:583"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:586"><nobr><span class="ft8">2</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:686"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:688"><nobr><span class="ft8">3</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:766"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:769"><nobr><span class="ft8">4</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:467"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:470"><nobr><span class="ft8">0</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:766"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:769"><nobr><span class="ft8">4</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:467"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:470"><nobr><span class="ft8">0</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:766"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:769"><nobr><span class="ft8">4</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:467"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:470"><nobr><span class="ft8">0</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:499"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:502"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:544"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:547"><nobr><span class="ft8">1</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:560"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:563"><nobr><span class="ft8">2</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:627"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:630"><nobr><span class="ft8">2</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:677"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:680"><nobr><span class="ft8">3</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:697"><nobr><span class="ft22">t</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:700"><nobr><span class="ft8">3</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:467"><nobr><span class="ft18"><b>Figure 2: </b><i>An example of multiple hash functions classify-<br>ing a dataset. The long vertical line represents the query<br>value. The union of results multiple hash tables with different<br>thresholds represents a more complete neighbourhood.</i></span></nobr></DIV>
<DIV style="position:absolute;top:543;left:480"><nobr><span class="ft2">To deal with <i>n</i>-dimensional points, each hash table will</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:467"><nobr><span class="ft15">have one hash function per dimension. Each hash function<br>generates one hash value per coordinate of the point (See<br>Figure</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:506"><nobr><span class="ft17">3</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:513"><nobr><span class="ft2">.) The final hash value is calculated by</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:732"><nobr><span class="ft24"></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:742"><nobr><span class="ft19"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:587;left:747"><nobr><span class="ft21">-1</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:742"><nobr><span class="ft19"><i>i</i>=0</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:764"><nobr><span class="ft5"><i>h</i></span></nobr></DIV>
<DIV style="position:absolute;top:596;left:771"><nobr><span class="ft19"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:592;left:774"><nobr><span class="ft5"><i>P</i></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:782"><nobr><span class="ft19"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:592;left:786"><nobr><span class="ft2">,</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:467"><nobr><span class="ft2">where <i>h</i></span></nobr></DIV>
<DIV style="position:absolute;top:613;left:510"><nobr><span class="ft19"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:608;left:517"><nobr><span class="ft2">are the hash values and <i>P </i>is the number of thresh-</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:467"><nobr><span class="ft15">olds. If <i>P </i>were a power of two, then this amounts to concate-<br>nating the bits. The only reason we use the same number of<br>thresholds for each dimension is simplicity. It is conceiv-<br>able that a different number of thresholds could be used for<br>each dimension to better adapt to the data. We defer the dis-<br>cussion of threshold generation and query procedures until<br>Sections</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:516"><nobr><span class="ft17">4.2</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:536"><nobr><span class="ft2">and</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:559"><nobr><span class="ft17">4.4</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:575"><nobr><span class="ft2">, respectively.</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:538"><nobr><span class="ft20">h</span></nobr></DIV>
<DIV style="position:absolute;top:822;left:544"><nobr><span class="ft22">x</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:471"><nobr><span class="ft20">h</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:476"><nobr><span class="ft22">y</span></nobr></DIV>
<DIV style="position:absolute;top:775;left:504"><nobr><span class="ft20">P</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:554"><nobr><span class="ft18"><b>Figure 3: </b><i>Using two hash functions to han-<br>dle a 2D point. Each hash function will be<br>used to hash one coordinate.</i></span></nobr></DIV>
<DIV style="position:absolute;top:855;left:480"><nobr><span class="ft2">LSH is very similar to grid files</span></nobr></DIV>
<DIV style="position:absolute;top:854;left:652"><nobr><span class="ft6">34</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:662"><nobr><span class="ft2">. However, the grid file</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:467"><nobr><span class="ft15">was specifically designed to handle dynamic data. Here, we<br>assume that the data is static during the rendering pass. Also,<br>the grid file is more suitable for range searches than it is for<br>solving the <i>k</i>NN problem.</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:467"><nobr><span class="ft3"><b>3.2. Block-Oriented Memory Model</b></span></nobr></DIV>
<DIV style="position:absolute;top:982;left:467"><nobr><span class="ft15">It has been our philosophy that hardware implementations of<br>algorithms should treat off-chip memory the same way soft-<br>ware implementations treat disk: as a relatively slow, "out-<br>of-core", high-latency, block-oriented storage device. This</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:111"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">91</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
	.ft25{font-size:6px;font-family:Times;color:#000000;}
	.ft26{font-size:5px;font-family:Times;color:#000000;}
	.ft27{font-size:6px;line-height:11px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1262" src="130004.png" alt="background image">
<DIV style="position:absolute;top:98;left:281"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:108"><nobr><span class="ft15">analogy implies that algorithms and data structures designed<br>to optimise for disk access are potentially applicable to hard-<br>ware design. It also drove us to employ fixed-sized blocks to<br>store the data involved in the <i>k</i>NN search algorithm, which<br>are photons in the context of this application.</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:122"><nobr><span class="ft2">In our prototype software implementation of BH, each</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:108"><nobr><span class="ft15">photon is stored in a structure similar to Jensen's "extended"<br>photon representation</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:226"><nobr><span class="ft6">25</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:236"><nobr><span class="ft2">. As shown in Figure</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:359"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:366"><nobr><span class="ft2">, each com-</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:108"><nobr><span class="ft15">ponent of the 3D photon location is represented by a 32-<br>bit fixed-point number. The unit vectors representing incom-<br>ing direction ^<b>d </b>and surface normal ^<b>n </b>are quantised to 16-bit<br>values using Jensen's polar representation. Photon power is<br>stored in four channels using sixteen-bit floating point num-<br>bers. This medium-precision signed representation permits<br>other A<i>k</i>NN applications beyond that of photon mapping.<br>Four colour channels are also included to better match the<br>four-vectors supported in fragment shaders. For the photon<br>mapping application specifically, our technique is compati-<br>ble with the replacement of the four colour channels with a<br>Ward RGBE colour representation</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:295"><nobr><span class="ft6">46</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:305"><nobr><span class="ft2">. Likewise, another im-</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:108"><nobr><span class="ft15">plementation might use a different representation for the nor-<br>mal and incident direction unit vectors.</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:108"><nobr><span class="ft8">|</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:130"><nobr><span class="ft8">32</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:159"><nobr><span class="ft8">|</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:132"><nobr><span class="ft27"><b>x<br>y<br>z</b></span></nobr></DIV>
<DIV style="position:absolute;top:555;left:120"><nobr><span class="ft25"><b>^</b></span></nobr></DIV>
<DIV style="position:absolute;top:557;left:119"><nobr><span class="ft25"><b>d</b></span></nobr></DIV>
<DIV style="position:absolute;top:557;left:146"><nobr><span class="ft25"><b>^</b></span></nobr></DIV>
<DIV style="position:absolute;top:557;left:145"><nobr><span class="ft25"><b>n</b></span></nobr></DIV>
<DIV style="position:absolute;top:568;left:117"><nobr><span class="ft25"><b>c</b></span></nobr></DIV>
<DIV style="position:absolute;top:571;left:121"><nobr><span class="ft26"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:568;left:143"><nobr><span class="ft25"><b>c</b></span></nobr></DIV>
<DIV style="position:absolute;top:571;left:147"><nobr><span class="ft26"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:580;left:117"><nobr><span class="ft25"><b>c</b></span></nobr></DIV>
<DIV style="position:absolute;top:583;left:121"><nobr><span class="ft26"><b>3</b></span></nobr></DIV>
<DIV style="position:absolute;top:580;left:143"><nobr><span class="ft25"><b>c</b></span></nobr></DIV>
<DIV style="position:absolute;top:583;left:147"><nobr><span class="ft26"><b>4</b></span></nobr></DIV>
<DIV style="position:absolute;top:591;left:108"><nobr><span class="ft8">| 16 |</span></nobr></DIV>
<DIV style="position:absolute;top:518;left:169"><nobr><span class="ft18"><b>Figure 4: </b><i>Representation of a photon record.<br>The 32-bit values </i>(<i>x</i>, <i>y</i>, <i>z</i>) <i>denote the position of<br>a photon and are used as keys. Two quantised<br>16-bit unit vectors </i>^<b>d</b><i>, </i>^<b>n </b><i>and four 16-bit floating<br>point values are carried as data.</i></span></nobr></DIV>
<DIV style="position:absolute;top:626;left:122"><nobr><span class="ft2">All photon records are stored in fixed-sized memory</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:108"><nobr><span class="ft15">blocks. BH uses a 64 32-bit-word block size, chosen to<br>permit efficient burst-mode transfers over a wide bus to<br>transaction-oriented DRAM. Using a 128-bit wide path to<br>DDR SDRAM, for instance, transfer of this block would<br>take eight cycles, not counting the overhead of command<br>cycles to specify the operation and the address. Using next-<br>generation QDR SDRAM this transfer would take only four<br>cycles (or eight on a 64-bit bus, etc.)</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:122"><nobr><span class="ft2">Our photon representation occupies six 32-bit words.</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:108"><nobr><span class="ft15">Since photon records are not permitted to span block bound-<br>aries, ten photons will fit into a 64-word block with four<br>words left over. Some of this extra space is used in our imple-<br>mentation to record how many photons are actually stored in<br>each block. For some variants of the data structures we de-<br>scribe, this extra space could also be used for flags or point-<br>ers to other blocks. It might be possible or desirable in other<br>implementations to support more or fewer colour channels,<br>or channels with greater or lesser precision, in which case<br>some of our numerical results would change.</span></nobr></DIV>
<DIV style="position:absolute;top:990;left:108"><nobr><span class="ft3"><b>4. Block Hashing</b></span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:108"><nobr><span class="ft15">Block Hashing (BH) contains a preprocessing phase and a<br>query phase. The preprocessing phase consists of three steps.</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:467"><nobr><span class="ft15">After photons have been traced into the scene, the algorithm<br>organises the photons into fixed-sized memory blocks, cre-<br>ates a set of hash tables, and inserts photon blocks into the<br>hash tables.</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:480"><nobr><span class="ft2">In the second phase, the hash tables will be queried for a</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:467"><nobr><span class="ft15">set of candidate photons from which the <i>k </i>nearest photons<br>will be selected for each point in space to be shaded by the<br>renderer.</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:467"><nobr><span class="ft3"><b>4.1. Organizing Photons into Blocks</b></span></nobr></DIV>
<DIV style="position:absolute;top:316;left:467"><nobr><span class="ft15">Due to the coherence benefits associated with block-oriented<br>memory access, BH starts by grouping photons and storing<br>them into fixed-sized memory blocks. However, these bene-<br>fits are maximised when the photons within a group are close<br>together spatially.</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:480"><nobr><span class="ft2">We chose to use the Hilbert curve</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:660"><nobr><span class="ft6">13</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:673"><nobr><span class="ft2">to help group photons</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:467"><nobr><span class="ft15">together. The advantage of the Hilbert curve encoding of po-<br>sition is that points mapped near each other on the Hilbert<br>curve are guaranteed to be within a certain distance of each<br>other in the original domain</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:618"><nobr><span class="ft6">22</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:628"><nobr><span class="ft2">. Points nearby in the original</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:467"><nobr><span class="ft15">domain space have a high probability of being nearby on the<br>curve, although there is a non-zero probability of them be-<br>ing far apart on the curve. If we sort photons by their Hilbert<br>curve order before packing them into blocks, then the pho-<br>tons in each block will have a high probability of being spa-<br>tially coherent. Each block then corresponds to an interval of<br>the Hilbert curve, which in turn covers some compact region<br>of the domain (see Figure</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:609"><nobr><span class="ft17">7</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:616"><nobr><span class="ft2">a). Each region of domain space</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:467"><nobr><span class="ft15">represented by the blocks is independent, and regions do not<br>overlap.</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:480"><nobr><span class="ft2">BH sorts photons and inserts them into a B</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:719"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:726"><nobr><span class="ft2">-tree</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:751"><nobr><span class="ft6">8</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:760"><nobr><span class="ft2">using</span></nobr></DIV>
<DIV style="position:absolute;top:678;left:467"><nobr><span class="ft15">the Hilbert curve encoding of the position of each photon as<br>the key. This method of spatially grouping points was first<br>proposed by Faloutsos and Rong</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:648"><nobr><span class="ft6">12</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:662"><nobr><span class="ft2">for a different purpose.</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:467"><nobr><span class="ft2">Since a B</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:521"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:528"><nobr><span class="ft2">-tree stores photon records only at leaves, with</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:467"><nobr><span class="ft2">a compatible construction the leaf nodes of the B</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:736"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:742"><nobr><span class="ft2">-tree can</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:467"><nobr><span class="ft15">serve as the photon blocks used in the later stages of BH.<br>One advantage of using a B</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:622"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:629"><nobr><span class="ft2">-tree for sorting is that inser-</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:467"><nobr><span class="ft15">tion cost is bounded: the tree is always balanced, and in the<br>worst case we may have to split <i>h </i>nodes in the tree, when<br>the height of the tree is <i>h</i>. Also, B</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:655"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:662"><nobr><span class="ft2">-trees are optimised for</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:467"><nobr><span class="ft2">block-oriented storage, as we have assumed.</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:480"><nobr><span class="ft2">The B</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:516"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:522"><nobr><span class="ft2">-tree used by BH has index and leaf nodes that</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:467"><nobr><span class="ft15">are between half full to completely full. To minimise the fi-<br>nal number of blocks required to store the photons, the leaf<br>nodes can be compacted (see Figure</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:673"><nobr><span class="ft17">5</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:680"><nobr><span class="ft2">.) After the photons</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:467"><nobr><span class="ft15">are sorted and compacted, the resulting photon blocks are<br>ready to be used by BH, and the B</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:655"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:661"><nobr><span class="ft2">-tree index and any leaf</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:467"><nobr><span class="ft15">nodes that are made empty by compaction are discarded. If<br>the complete set of photons is known <i>a priori</i>, the compact<br>B</span></nobr></DIV>
<DIV style="position:absolute;top:999;left:476"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:482"><nobr><span class="ft2">-tree</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:507"><nobr><span class="ft6">37</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:520"><nobr><span class="ft2">for static data can be used instead. This data struc-</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:467"><nobr><span class="ft15">ture maintains full nodes and avoids the extra compaction<br>step.</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:649"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">92</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
	.ft28{font-size:4px;font-family:Times;color:#000000;}
	.ft29{font-size:4px;font-family:Times;color:#000000;}
	.ft30{font-size:7px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1262" src="130005.png" alt="background image">
<DIV style="position:absolute;top:98;left:280"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:181;left:108"><nobr><span class="ft8">(b)</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:362"><nobr><span class="ft28">Index node</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:362"><nobr><span class="ft28">Empty cell in leaf node</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:362"><nobr><span class="ft28">Occupied cell in leaf node</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:108"><nobr><span class="ft8">(a)</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:108"><nobr><span class="ft3"><b>Figure 5: </b><i>Compaction of photon blocks. (a) B</i></span></nobr></DIV>
<DIV style="position:absolute;top:209;left:353"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:360"><nobr><span class="ft5"><i>-tree after in-</i></span></nobr></DIV>
<DIV style="position:absolute;top:225;left:108"><nobr><span class="ft18"><i>serting all photons. Many leaf nodes have empty cells. (b) All<br>photon records are compacted in the leaf nodes.</i></span></nobr></DIV>
<DIV style="position:absolute;top:301;left:122"><nobr><span class="ft2">Regardless, observe that each photon block contains a</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:108"><nobr><span class="ft15">spatially clustered set of photons disjoint from those con-<br>tained in other blocks. This is the main result we are af-<br>ter; any other data structures that can group photons into<br>spatially-coherent groups, such as grid files</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:348"><nobr><span class="ft6">34</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:357"><nobr><span class="ft2">, can be used</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:108"><nobr><span class="ft2">in place of the B</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:197"><nobr><span class="ft7">+</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:203"><nobr><span class="ft2">-tree and space-filling curve.</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:108"><nobr><span class="ft3"><b>4.2. Creating the Hash Tables</b></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:108"><nobr><span class="ft15">The hash tables used in BH are based on the LSH scheme de-<br>scribed in Section</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:206"><nobr><span class="ft17">3.1</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:223"><nobr><span class="ft2">. BH generates <i>L </i>tables in total, serving</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:108"><nobr><span class="ft15">as parallel and complementary indices to the photon data.<br>Each table has three hash functions (since photons are classi-<br>fied by their 3D positions), and each hash function has <i>P </i>+ 1<br>thresholds.</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:122"><nobr><span class="ft2">BH employs an adaptive method that generates the thresh-</span></nobr></DIV>
<DIV style="position:absolute;top:573;left:108"><nobr><span class="ft15">olds based on the photon positions. For each dimension, a<br>histogram of photon positions is built. Then, the histogram is<br>integrated to obtain a cumulative distribution function (<i>cdf </i>).<br>Lastly, stratified samples are taken from the inverse of the <i>cdf<br></i>to obtain threshold locations. The resulting thresholds will<br>be far apart where there are few photons, and close together<br>where photons are numerous. Ultimately this method at-<br>tempts to have a similar number of photons into each bucket.</span></nobr></DIV>
<DIV style="position:absolute;top:712;left:122"><nobr><span class="ft2">Hash tables are stored as a one-dimensional array struc-</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:108"><nobr><span class="ft2">ture, shown in Figure</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:225"><nobr><span class="ft17">6</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:232"><nobr><span class="ft2">. The hash key selects a bucket out of</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:108"><nobr><span class="ft2">the <i>P</i></span></nobr></DIV>
<DIV style="position:absolute;top:742;left:136"><nobr><span class="ft19"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:745;left:145"><nobr><span class="ft2">available buckets in the hash table. Each bucket refers</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:108"><nobr><span class="ft15">up to <i>B </i>blocks of photons, and has space for a validity flag<br>per reference, and storage for a priority value. We defer the<br>discussion on the choice of <i>P</i>, <i>L </i>and <i>B </i>until Section</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:389"><nobr><span class="ft17">5</span></nobr></DIV>
<DIV style="position:absolute;top:795;left:396"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:136"><nobr><span class="ft25"><b>B</b></span></nobr></DIV>
<DIV style="position:absolute;top:845;left:111"><nobr><span class="ft29"><b>V V V</b></span></nobr></DIV>
<DIV style="position:absolute;top:845;left:163"><nobr><span class="ft29"><b>V</b></span></nobr></DIV>
<DIV style="position:absolute;top:832;left:123"><nobr><span class="ft30"><b>Priority</b></span></nobr></DIV>
<DIV style="position:absolute;top:840;left:260"><nobr><span class="ft18"><b>Figure 6: </b><i>Hash table bucket<br>layout</i></span></nobr></DIV>
<DIV style="position:absolute;top:925;left:108"><nobr><span class="ft3"><b>4.3. Inserting Photon Blocks</b></span></nobr></DIV>
<DIV style="position:absolute;top:949;left:108"><nobr><span class="ft15">In BH, references to entire photon blocks, rather than indi-<br>vidual photons, are inserted into the hash tables. One reason<br>for doing so is to reduce the memory required per bucket.<br>Another, more important, reason is that when merging re-<br>sults from multiple hash tables (Section</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:344"><nobr><span class="ft17">3.1</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:361"><nobr><span class="ft2">), BH needs</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:108"><nobr><span class="ft2">to compare only block addresses instead of photons when</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:467"><nobr><span class="ft15">weeding out duplicates as each block contains a unique set of<br>photons. This means fewer comparisons have to be made and<br>the individual photons are only accessed once per query, dur-<br>ing post-processing of the merged candidate set to find the<br><i>k </i>nearest photons. Consequently, the transfer of each photon<br>block through the memory system happens at most once per<br>query. All photons accessed in a block are potentially useful<br>contributions to the candidate set, since photons within a sin-<br>gle block are spatially coherent. Due to our memory model<br>assumptions, once we have looked at one photon in a block<br>it should be relatively inexpensive to look at the rest.</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:513"><nobr><span class="ft25"><b>(a)</b></span></nobr></DIV>
<DIV style="position:absolute;top:425;left:624"><nobr><span class="ft25"><b>(b)</b></span></nobr></DIV>
<DIV style="position:absolute;top:425;left:736"><nobr><span class="ft25"><b>(c)</b></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:467"><nobr><span class="ft18"><b>Figure 7: </b><i>Block hashing illustrated. (a) Each block corre-<br>sponds to an interval of the Hilbert curve, which in turn cov-<br>ers some compact region of the domain. Consequently, each<br>bucket (b) represents all photons (highlighted with squares)<br>in each block with at least one photon hashed into it (c).</i></span></nobr></DIV>
<DIV style="position:absolute;top:556;left:480"><nobr><span class="ft2">Each bucket in a hash table corresponds to a rectangular</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:467"><nobr><span class="ft2">region in a non-uniform grid as shown in Figure</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:742"><nobr><span class="ft17">7</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:748"><nobr><span class="ft2">b. Each</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:467"><nobr><span class="ft15">block is inserted into the hash tables once for each photon<br>within that block, using the position of these photons to cre-<br>ate the keys. Each bucket of the hash table refers to not only<br>the photons that have been hashed into that bucket, but also<br>all the other photons that belong to the same blocks as the<br>hashed photons (see Figure</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:617"><nobr><span class="ft17">7</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:624"><nobr><span class="ft2">c.)</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:480"><nobr><span class="ft2">Since each photon block is inserted into each hash ta-</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:467"><nobr><span class="ft15">ble multiple times, using different photons as keys, a block<br>may be hashed into multiple buckets in the same hash ta-<br>ble. Of course, a block should not be inserted into a bucket<br>more than once. More importantly, our technique ensures<br>that each block is inserted into at least one hash table. Or-<br>phaned blocks are very undesirable since the photons within<br>will never be considered in the subsequent A<i>k</i>NN evaluation<br>and will cause a constant error overhead. Hence, our tech-<br>nique does not navely drop a block that causes a bucket to<br>overflow.</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:480"><nobr><span class="ft2">However, there may be collisions that cause buckets to</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:467"><nobr><span class="ft15">overflow, especially when a large bucket load factor is cho-<br>sen to give a compact hash table size, or there exists a large<br>variation in photon density (which, of course, is typical in<br>this application). Our algorithm uses two techniques to ad-<br>dress this problem. The first technique attempts to insert <i>ev-<br>ery </i>block into <i>every </i>hash table, but in different orders on<br>different hash tables, such that blocks that appear earlier in<br>the ordering are not favoured for insertion in all tables. BH<br>uses a technique similar to disk-striping</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:682"><nobr><span class="ft6">38</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:692"><nobr><span class="ft2">, illustrated by the</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:111"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">93</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
	.ft31{font-size:9px;font-family:Courier;color:#000000;}
	.ft32{font-size:2px;font-family:Times;color:#000000;}
	.ft33{font-size:2px;font-family:Times;color:#000000;}
	.ft34{font-size:8px;line-height:10px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1262" src="130006.png" alt="background image">
<DIV style="position:absolute;top:98;left:281"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:108"><nobr><span class="ft2">pseudo code in Figure</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:229"><nobr><span class="ft17">8</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:236"><nobr><span class="ft2">. An example is given in the diagram</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:108"><nobr><span class="ft2">in the same figure.</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:108"><nobr><span class="ft31">for h from 0 to (number_of_hash_tables-1)</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:137"><nobr><span class="ft31">for b from 0 to (number_of_blocks-1)</span></nobr></DIV>
<DIV style="position:absolute;top:220;left:165"><nobr><span class="ft31">idx = (h+b) modulo L</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:165"><nobr><span class="ft31">insert block[b] into hashtable[idx]</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:137"><nobr><span class="ft31">endfor</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:108"><nobr><span class="ft31">endfor</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:197"><nobr><span class="ft32">0</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:209"><nobr><span class="ft32">1</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:221"><nobr><span class="ft32">2</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:281"><nobr><span class="ft32">0</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:293"><nobr><span class="ft32">1</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:305"><nobr><span class="ft32">2</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:125"><nobr><span class="ft33"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:137"><nobr><span class="ft33"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:113"><nobr><span class="ft33"><b>0</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:209"><nobr><span class="ft33"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:221"><nobr><span class="ft33"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:197"><nobr><span class="ft33"><b>0</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:293"><nobr><span class="ft33"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:305"><nobr><span class="ft33"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:281"><nobr><span class="ft33"><b>0</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:125"><nobr><span class="ft33"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:137"><nobr><span class="ft33"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:113"><nobr><span class="ft33"><b>0</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:209"><nobr><span class="ft33"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:221"><nobr><span class="ft33"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:197"><nobr><span class="ft33"><b>0</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:293"><nobr><span class="ft33"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:305"><nobr><span class="ft33"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:281"><nobr><span class="ft33"><b>0</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:318"><nobr><span class="ft33"><b>3</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:330"><nobr><span class="ft33"><b>4</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:342"><nobr><span class="ft33"><b>5</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:233"><nobr><span class="ft33"><b>3</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:245"><nobr><span class="ft33"><b>4</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:257"><nobr><span class="ft33"><b>5</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:149"><nobr><span class="ft33"><b>3</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:161"><nobr><span class="ft33"><b>4</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:173"><nobr><span class="ft33"><b>5</b></span></nobr></DIV>
<DIV style="position:absolute;top:294;left:378"><nobr><span class="ft29"><b>Photon Block</b></span></nobr></DIV>
<DIV style="position:absolute;top:312;left:378"><nobr><span class="ft29"><b>Hash Table Bucket</b></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:127"><nobr><span class="ft29"><b>1st iteration</b></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:210"><nobr><span class="ft29"><b>2nd iteration</b></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:294"><nobr><span class="ft29"><b>3rd iteration</b></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:171"><nobr><span class="ft3"><b>Figure 8: </b><i>Striping insertion strategy</i></span></nobr></DIV>
<DIV style="position:absolute;top:405;left:122"><nobr><span class="ft2">The second technique involves a strategy to deal with</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:108"><nobr><span class="ft15">overflow in a bucket. For each photon block, BH keeps the<br>count of buckets that the block has been hashed into so far.<br>When a block causes overflow in a bucket, the block in the<br>bucket that has the maximum count will be bumped if that<br>count is larger than one, and larger than that of the incoming<br>block. This way we ensure that all blocks are inserted into<br>at least one bucket, given adequate hash table sizes, and no<br>block is hashed into an excessive number of buckets.</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:108"><nobr><span class="ft3"><b>4.4. Querying</b></span></nobr></DIV>
<DIV style="position:absolute;top:597;left:108"><nobr><span class="ft15">A query into the BH data structure proceeds by delegating<br>the query to each of the <i>L </i>hash tables. These parallel ac-<br>cesses will yield as candidates all photon blocks represented<br>by buckets that matched the query. The final approximate<br>nearest neighbour set comes from scanning the unified can-<br>didate set for the nearest neighbours to the query point (see<br>Figure</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:148"><nobr><span class="ft17">9</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:154"><nobr><span class="ft2">.) Note that unlike <i>k</i>NN algorithms based on hier-</span></nobr></DIV>
<DIV style="position:absolute;top:712;left:108"><nobr><span class="ft15">archical data structures, where candidates for the <i>k</i>NN set<br>trickle in as the traversal progresses, in BH all candidates are<br>available once the parallel queries are completed. Therefore,<br>BH can use algorithms like <i>selection</i></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:307"><nobr><span class="ft6">29</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:320"><nobr><span class="ft2">(instead of a priority</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:108"><nobr><span class="ft2">queue) when selecting the <i>k </i>nearest photons.</span></nobr></DIV>
<DIV style="position:absolute;top:801;left:122"><nobr><span class="ft2">Each query will retrieve one bucket from each of the <i>L</i></span></nobr></DIV>
<DIV style="position:absolute;top:818;left:108"><nobr><span class="ft15">hash tables. If the application can tolerate elevated inaccu-<br>racy in return for increased speed of query (for example, to<br>pre-visualise a software rendering), it may be worthwhile to<br>consider using only a subset of the <i>L </i>candidate sets. Block<br>hashing is equipped with a user-specified accuracy setting:<br>Let <i>A</i></span></nobr></DIV>
<DIV style="position:absolute;top:899;left:143"><nobr><span class="ft4"> <b>IN </b>be an integer multiplier. The block hashing al-</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:108"><nobr><span class="ft15">gorithm will only consider <i>Ak </i>candidate photons in the final<br>scan to determine the <i>k </i>nearest photons to a query. Obvi-<br>ously the smaller <i>A </i>is, the fewer photons will be processed<br>in the final step; as such, query time is significantly reduced,<br>but with an accuracy cost. Conversely, a higher <i>A </i>will lead<br>to a more accurate result, but it will take more time. Exper-<br>imental results that demonstrate the impact of the choice of<br><i>A </i>will be explored in Section</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:268"><nobr><span class="ft17">6</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:274"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:716"><nobr><span class="ft34">Query point<br>Matched point</span></nobr></DIV>
<DIV style="position:absolute;top:253;left:716"><nobr><span class="ft20">Data point</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:467"><nobr><span class="ft20">(a)</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:501"><nobr><span class="ft20">(b)</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:623"><nobr><span class="ft20">(c)</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:467"><nobr><span class="ft18"><b>Figure 9: </b><i>Merging the results from multiple hash tables.<br>(a) the query point retrieves different candidates sets from<br>different hash tables, (b) the union set of candidates after<br>merging, and (c) the two closest neighbours selected.</i></span></nobr></DIV>
<DIV style="position:absolute;top:426;left:480"><nobr><span class="ft2">There needs to be a way to select the buckets from which</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:467"><nobr><span class="ft15">the <i>Ak </i>candidate photons are obtained. Obviously, we want<br>to devise a heuristic to pick the "best" candidates. Suppose<br>every bucket in every hash table has a <i>priority </i>given by</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:503"><nobr><span class="ft24"></span></nobr></DIV>
<DIV style="position:absolute;top:500;left:514"><nobr><span class="ft4">=</span></nobr></DIV>
<DIV style="position:absolute;top:499;left:528"><nobr><span class="ft4">|bucket_capacity - #entries - #overflows|</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:467"><nobr><span class="ft15">where "#overflows" is the number of insertion attempts af-<br>ter the bucket became full. The priority can be pre-computed<br>and stored in each bucket of each hash table during the in-<br>sertion phase. The priority of a bucket is smallest when the<br>bucket is full but never overflowed. Conversely, when the<br>hash bucket is underutilised or overflow has occurred,</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:757"><nobr><span class="ft24"></span></nobr></DIV>
<DIV style="position:absolute;top:607;left:769"><nobr><span class="ft2">will</span></nobr></DIV>
<DIV style="position:absolute;top:623;left:467"><nobr><span class="ft15">be larger. If a bucket is underutilised, it is probably too small<br>spatially (relative to local sample density). If it has experi-<br>enced overflow, it is likely too large spatially, and covers too<br>many photon block regions.</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:480"><nobr><span class="ft2">During each query, BH will sort the <i>L </i>buckets returned</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:467"><nobr><span class="ft15">from the hash tables by their priority values, smallest values<br>of</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:481"><nobr><span class="ft24"></span></nobr></DIV>
<DIV style="position:absolute;top:729;left:492"><nobr><span class="ft2">first. Subsequently, buckets are considered in this order,</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:467"><nobr><span class="ft15">one by one, until the required <i>Ak </i>photons are found. In this<br>way the more "useful" buckets will be considered first.</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:467"><nobr><span class="ft3"><b>5. Choice of Parameter Values</b></span></nobr></DIV>
<DIV style="position:absolute;top:826;left:467"><nobr><span class="ft15">Block Hashing is a scheme that requires several parameters:<br><i>B</i>, the bucket capacity; <i>L</i>, the number of hash tables whose<br>results are merged; and <i>P</i>, the number of thresholds per di-<br>mension. We would like to determine reasonable values for<br>these parameters as functions of <i>k</i>, the number of nearest<br>neighbours sought, and <i>N</i>, the number of photons involved.</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:480"><nobr><span class="ft2">It is important to realize the implications of these param-</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:467"><nobr><span class="ft15">eters. The total number of 32-bit pointers to photon blocks<br>is given by <i>LP</i></span></nobr></DIV>
<DIV style="position:absolute;top:962;left:543"><nobr><span class="ft20">3</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:549"><nobr><span class="ft5"><i>B</i>. Along with the number of thresholds 3<i>LP</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:467"><nobr><span class="ft15">this gives the memory overhead required for BH. The up-<br>per bound for this value is 6<i>N</i>, the number of photons mul-<br>tiplied by the six 32-bit words each photon takes up in our<br>implementation. If we allow <i>B </i>to be a fixed constant for now,</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:649"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">94</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1262" src="130007.png" alt="background image">
<DIV style="position:absolute;top:98;left:280"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:108"><nobr><span class="ft2">the constraint <i>LP</i></span></nobr></DIV>
<DIV style="position:absolute;top:124;left:200"><nobr><span class="ft20">3</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:207"><nobr><span class="ft4">+ 3<i>LP</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:245"><nobr><span class="ft4"> <i>N </i>arises from the reasonable as-</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:108"><nobr><span class="ft15">sumption that we do not want to have more references to<br>blocks than there are photons, or more memory used in the<br>index than in the data.</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:122"><nobr><span class="ft2">Empirically, <i>L </i>= <i>P </i>= ln <i>N </i>has turned out to be a good</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:108"><nobr><span class="ft15">choice. The value ln <i>N </i>remains sub-linear as <i>N </i>increases,<br>and this value gives a satisfactory index memory overhead<br>ratio: There are a total of <i>B</i>(ln <i>N</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:291"><nobr><span class="ft20">4</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:302"><nobr><span class="ft2">block references. Being</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:108"><nobr><span class="ft2">four bytes each, the references require 4<i>B</i>(ln <i>N</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:361"><nobr><span class="ft20">4</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:370"><nobr><span class="ft2">bytes. With</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:108"><nobr><span class="ft2">each hash table, there needs to be 3<i>LP </i>= 3(ln <i>N</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:383"><nobr><span class="ft20">2</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:393"><nobr><span class="ft2">thresh-</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:108"><nobr><span class="ft15">olds. Represented by a 4-byte value each, the thresholds take<br>another 12(ln <i>N</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:199"><nobr><span class="ft20">2</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:209"><nobr><span class="ft2">bytes. Next, assuming one photon block</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:108"><nobr><span class="ft15">can hold ten photons, <i>N </i>photons requires <i>N</i>/10 blocks; each<br>block requires 64 words, so the blocks require 25.6<i>N </i>bytes<br>in total. The total memory required for <i>N </i>photons, each oc-<br>cupying 6 words, is 24<i>N </i>bytes. This gives an overhead ratio<br>of</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:145"><nobr><span class="ft4">(4<i>B</i>(ln <i>N</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:197"><nobr><span class="ft20">4</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:205"><nobr><span class="ft4">+ 12(ln <i>N</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:263"><nobr><span class="ft20">2</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:271"><nobr><span class="ft4">+ 25.6<i>N</i></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:319"><nobr><span class="ft4">- 24<i>N</i>)/24<i>N</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:415"><nobr><span class="ft2">(1)</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:122"><nobr><span class="ft2">The choice of <i>B </i>is also dependent on the value of <i>k </i>spec-</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:108"><nobr><span class="ft15">ified by the situation or the user. However, since it is usual<br>in photon mapping that <i>k </i>is known ahead of time, <i>B </i>can be<br>set accordingly. <i>B </i>should be set such that the total number of<br>photons retrieved from the <i>L </i>buckets for each query will be<br>larger than <i>k</i>. Mathematically speaking, each photon block<br>in our algorithm has ten photons, hence 10<i>LB</i></span></nobr></DIV>
<DIV style="position:absolute;top:555;left:380"><nobr><span class="ft5"><i>k</i>. In par-</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:108"><nobr><span class="ft14">ticular, 10<i>LB </i>&gt; <i>Ak </i>should also be satisfied. Since we choose<br><i>L </i>= ln <i>N</i>, rearranging the equation yields: <i>B </i>&gt; <i>Ak</i>/(10 ln <i>N</i>)<br>For example, assuming <i>A </i>= 16, <i>N </i>= 2000000, <i>k </i>= 50, then</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:114"><nobr><span class="ft5"><i>B </i>= 6.</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:122"><nobr><span class="ft2">If we substitute <i>B </i>back into Equation</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:320"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:327"><nobr><span class="ft2">, we obtain the final</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:108"><nobr><span class="ft2">overhead equation</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:149"><nobr><span class="ft4">(4(<i>Ak</i>/10)(ln <i>N</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:683;left:238"><nobr><span class="ft20">3</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:246"><nobr><span class="ft4">+ 12(ln <i>N</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:683;left:304"><nobr><span class="ft20">2</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:312"><nobr><span class="ft4">+ 1.6<i>N</i>)/24<i>N</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:415"><nobr><span class="ft2">(2)</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:122"><nobr><span class="ft2">Figure</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:161"><nobr><span class="ft17">10</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:179"><nobr><span class="ft2">plots the number of photons versus the mem-</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:108"><nobr><span class="ft15">ory overhead. For the usual range of photon count in a pho-<br>ton mapping application, we see that the memory overhead,<br>while relative large for small numbers of photons, becomes<br>reasonable for larger numbers of photons, and has an asymp-<br>tote of about 6%. Of course, if we assumed different block<br>size (cache line size), these results would vary, but the anal-<br>ysis is the same.</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:115"><nobr><span class="ft20">Memory Overhead</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:125"><nobr><span class="ft20">Ratio (%)</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:136"><nobr><span class="ft20">5</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:131"><nobr><span class="ft20">15</span></nobr></DIV>
<DIV style="position:absolute;top:899;left:131"><nobr><span class="ft20">20</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:131"><nobr><span class="ft20">25</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:131"><nobr><span class="ft20">30</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:197"><nobr><span class="ft20">0.50</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:234"><nobr><span class="ft20">0.75</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:272"><nobr><span class="ft20">1.00</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:309"><nobr><span class="ft20">1.25</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:346"><nobr><span class="ft20">1.50</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:384"><nobr><span class="ft20">1.75</span></nobr></DIV>
<DIV style="position:absolute;top:873;left:369"><nobr><span class="ft20">A=16</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:374"><nobr><span class="ft34">A=8<br>A=4</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:131"><nobr><span class="ft20">10</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:159"><nobr><span class="ft20">0.25</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:414"><nobr><span class="ft20">2.00</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:247"><nobr><span class="ft20">Number of Photons</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:108"><nobr><span class="ft18"><b>Figure 10: </b><i>Plot of photon count vs. memory overhead in-<br>curred by BH, assuming k </i>= 50<i>.</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:467"><nobr><span class="ft3"><b>6. Results</b></span></nobr></DIV>
<DIV style="position:absolute;top:152;left:467"><nobr><span class="ft15">For BH to be a useful A<i>k</i>NN algorithm, it must have sat-<br>isfactory algorithmic accuracy. Moreover, in the context of<br>photon mapping, BH must also produce good visual accu-<br>racy. This section will demonstrate that BH satisfies both re-<br>quirements, while providing a speed-up in terms of the time<br>it takes to render an image, even in a software implementa-<br>tion.</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:480"><nobr><span class="ft2">To measure algorithmic accuracy, our renderer was rigged</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:467"><nobr><span class="ft15">to use both the <i>kd</i>-tree and BH based photon maps. For each<br><i>k</i>NN query the result sets were compared for the following<br>metrics:</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:467"><nobr><span class="ft3"><b>False negatives:</b></span></nobr></DIV>
<DIV style="position:absolute;top:349;left:564"><nobr><span class="ft2"># photons incorrectly excluded from the</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:467"><nobr><span class="ft5"><i>k</i>NN set.</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:467"><nobr><span class="ft3"><b>Maximum distance dilation:</b></span></nobr></DIV>
<DIV style="position:absolute;top:390;left:639"><nobr><span class="ft2">the ratio of bounding radii</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:467"><nobr><span class="ft2">around the neighbours reported by the two algorithms.</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:467"><nobr><span class="ft3"><b>Average distance dilation:</b></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:617"><nobr><span class="ft2">the ratio of the average distances</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:467"><nobr><span class="ft15">between the query point and each of the nearest neighbours<br>reported by the two algorithms.</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:480"><nobr><span class="ft2">To gauge visual accuracy, we calculate a <b>Caustic RMS</b></span></nobr></DIV>
<DIV style="position:absolute;top:505;left:467"><nobr><span class="ft3"><b>Error</b></span></nobr></DIV>
<DIV style="position:absolute;top:505;left:503"><nobr><span class="ft2">metric, which compares the screen space radiance dif-</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:467"><nobr><span class="ft15">ference between the caustic radiance values obtained from<br><i>kd</i>-tree and BH.</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:480"><nobr><span class="ft2">A timing-related <b>Time Ratio </b>metric is calculated as a ra-</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:467"><nobr><span class="ft15">tio of the time taken for a query into the BH data structure<br>versus that for the <i>kd</i>-tree data structure. Obviously, as <i>A<br></i>increases, the time required for photon mapping using BH<br>approaches that for a <i>kd</i>-tree based photon mapping.</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:480"><nobr><span class="ft2">Our first test scene, shown in Figure</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:695"><nobr><span class="ft17">11</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:708"><nobr><span class="ft2">, with numeri-</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:467"><nobr><span class="ft2">cal results in Figure</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:583"><nobr><span class="ft17">12</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:596"><nobr><span class="ft2">, consists of a highly specular ring</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:467"><nobr><span class="ft2">placed on top of a plane with a Modified Phong</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:719"><nobr><span class="ft6">28</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:731"><nobr><span class="ft2">reflectance</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:467"><nobr><span class="ft15">model. This scene tests the ability of BH to handle a caustic<br>of varying density, and a caustic that has been cast onto a<br>non-Lambertian surface.</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:480"><nobr><span class="ft2">Figure</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:520"><nobr><span class="ft17">13</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:538"><nobr><span class="ft2">shows a second scene consisting of the Venus</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:467"><nobr><span class="ft15">bust, with a highly specular ring placed around the neck of<br>Venus. Figure</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:547"><nobr><span class="ft17">14</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:564"><nobr><span class="ft2">shows the numerical statistics of this test</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:467"><nobr><span class="ft15">scene. The ring casts a cardioid caustic onto the (non-planar)<br>chest of the Venus. This scene demonstrates a caustic on a<br>highly tessellated curved surface. Global illumination is also<br>used for both scenes, however the times given are only for<br>the query time of the caustic maps.</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:480"><nobr><span class="ft2">The general trend to notice is that for extremely low accu-</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:467"><nobr><span class="ft15">racy (<i>A</i>) settings the visual and algorithmic performance of<br>BH is not very good. The candidate set is simply not large<br>enough in these cases. However, as <i>A </i>increases, these per-<br>formance indicators drop to acceptable levels very quickly,<br>especially between values of <i>A </i>between 2 and 8. After <i>A </i>= 8<br>diminishing returns set in, and the increase in accuracy in-<br>curs a significant increase in the cost of the query time re-<br>quired. This numerical error comparison is parallelled by the</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:111"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">95</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
	.ft35{font-size:6px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1262" src="130008.png" alt="background image">
<DIV style="position:absolute;top:98;left:281"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:240;left:170"><nobr><span class="ft8">(a) <i>kd</i>-tree</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:327"><nobr><span class="ft8">(b) BH, A=4</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:164"><nobr><span class="ft8">(c) BH, A=16</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:327"><nobr><span class="ft8">(d) BH, A=8</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:200"><nobr><span class="ft3"><b>Figure 11: </b><i>"Ring" image</i></span></nobr></DIV>
<DIV style="position:absolute;top:518;left:124"><nobr><span class="ft8"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:118"><nobr><span class="ft8"> 0.2</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:118"><nobr><span class="ft8"> 0.4</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:118"><nobr><span class="ft8"> 0.6</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:118"><nobr><span class="ft8"> 0.8</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:124"><nobr><span class="ft8"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:131"><nobr><span class="ft8"> 0  2  4  6  8  10  12  14  16  18  20</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:164"><nobr><span class="ft8">Accuracy Setting (A)</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:214"><nobr><span class="ft8">False-</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:114"><nobr><span class="ft8">Average #errors</span></nobr></DIV>
<DIV style="position:absolute;top:518;left:284"><nobr><span class="ft8"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:503;left:278"><nobr><span class="ft8"> 1.1</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:278"><nobr><span class="ft8"> 1.2</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:278"><nobr><span class="ft8"> 1.3</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:278"><nobr><span class="ft8"> 1.4</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:278"><nobr><span class="ft8"> 1.5</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:278"><nobr><span class="ft8"> 1.6</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:291"><nobr><span class="ft8"> 0  2  4  6  8  10  12  14  16  18  20</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:324"><nobr><span class="ft8">Accuracy Setting (A)</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:327"><nobr><span class="ft8">Max Radius Dilation</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:328"><nobr><span class="ft8">Avg Radius Dilation</span></nobr></DIV>
<DIV style="position:absolute;top:497;left:275"><nobr><span class="ft8">Dilation Ratio</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:130"><nobr><span class="ft8"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:116"><nobr><span class="ft8"> 0.005</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:120"><nobr><span class="ft8"> 0.01</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:116"><nobr><span class="ft8"> 0.015</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:120"><nobr><span class="ft8"> 0.02</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:137"><nobr><span class="ft8"> 0  2  4  6  8  10  12  14  16  18  20</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:168"><nobr><span class="ft8">Accuracy Setting (A)</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:201"><nobr><span class="ft8">RMS error</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:114"><nobr><span class="ft8">Radiance RMS Error</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:284"><nobr><span class="ft8"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:624;left:277"><nobr><span class="ft8"> 0.2</span></nobr></DIV>
<DIV style="position:absolute;top:611;left:277"><nobr><span class="ft8"> 0.4</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:277"><nobr><span class="ft8"> 0.6</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:277"><nobr><span class="ft8"> 0.8</span></nobr></DIV>
<DIV style="position:absolute;top:573;left:284"><nobr><span class="ft8"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:277"><nobr><span class="ft8"> 1.2</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:277"><nobr><span class="ft8"> 1.4</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:291"><nobr><span class="ft8"> 0  2  4  6  8  10  12  14  16  18  20</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:324"><nobr><span class="ft8">Accuracy Setting (A)</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:352"><nobr><span class="ft8">Timing Ratio</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:275"><nobr><span class="ft8">Time Ratio</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:164"><nobr><span class="ft3"><b>Figure 12: </b><i>"Ring" numerical statistics</i></span></nobr></DIV>
<DIV style="position:absolute;top:735;left:108"><nobr><span class="ft15">visual comparison of the images: the image rendered with<br><i>A </i>= 8 and <i>A </i>= 16 are virtually indistinguishable. These re-<br>sults suggest that intermediate values of <i>A</i>, between 8 to 10,<br>should be used as a good compromise between query speed<br>and solution accuracy.</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:122"><nobr><span class="ft2">It is apparent from the query time ratio plots that there</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:108"><nobr><span class="ft15">exists a close-to-linear relationship between values of <i>A </i>and<br>time required for a query into BH. This is consistent with<br>the design of the <i>A </i>parameter; it corresponds directly to the<br>number of photons accessed and processed for each query.</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:122"><nobr><span class="ft2">Another important observation that can be made from the</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:108"><nobr><span class="ft15">visual comparisons is that images with greater approxima-<br>tion value <i>A </i>look darker. This is because the density estimate<br>is based on the inverse square of the radius of the sphere en-<br>closing the <i>k </i>nearest neighbours. The approximate radius is<br>always larger than the true radius. This is an inherent prob-<br>lem with any approximate solution to the <i>k</i>NN problem, and<br>indeed even with the exact <i>k</i>NN density estimator: as <i>k </i>goes</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:488"><nobr><span class="ft8">(a) <i>kd</i>-tree</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:563"><nobr><span class="ft8">(b) BH, A=16</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:646"><nobr><span class="ft8">(c) BH, A=8</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:726"><nobr><span class="ft8">(d) BH, A=4</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:525"><nobr><span class="ft3"><b>Figure 13: </b><i>"Venus with Ring" images</i></span></nobr></DIV>
<DIV style="position:absolute;top:442;left:485"><nobr><span class="ft8"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:479"><nobr><span class="ft8"> 0.5</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:485"><nobr><span class="ft8"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:479"><nobr><span class="ft8"> 1.5</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:485"><nobr><span class="ft8"> 2</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:479"><nobr><span class="ft8"> 2.5</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:485"><nobr><span class="ft8"> 3</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:479"><nobr><span class="ft8"> 3.5</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:485"><nobr><span class="ft8"> 4</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:492"><nobr><span class="ft8"> 0  2  4  6  8  10  12  14  16  18  20</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:525"><nobr><span class="ft8">Accuracy Setting (A)</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:573"><nobr><span class="ft8">False-</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:472"><nobr><span class="ft8">Average #errors</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:647"><nobr><span class="ft8"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:637"><nobr><span class="ft8"> 1.02</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:637"><nobr><span class="ft8"> 1.04</span></nobr></DIV>
<DIV style="position:absolute;top:389;left:637"><nobr><span class="ft8"> 1.06</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:637"><nobr><span class="ft8"> 1.08</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:641"><nobr><span class="ft8"> 1.1</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:654"><nobr><span class="ft8"> 0  2  4  6  8  10  12  14  16  18  20</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:686"><nobr><span class="ft8">Accuracy Setting (A)</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:689"><nobr><span class="ft8">Max Radius Dilation</span></nobr></DIV>
<DIV style="position:absolute;top:368;left:690"><nobr><span class="ft8">Avg Radius Dilation</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:634"><nobr><span class="ft8">Dilation Ratio</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:486"><nobr><span class="ft8"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:476"><nobr><span class="ft8"> 0.01</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:476"><nobr><span class="ft8"> 0.02</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:476"><nobr><span class="ft8"> 0.03</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:476"><nobr><span class="ft8"> 0.04</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:476"><nobr><span class="ft8"> 0.05</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:493"><nobr><span class="ft8"> 0  2  4  6  8  10  12  14  16  18  20</span></nobr></DIV>
<DIV style="position:absolute;top:577;left:525"><nobr><span class="ft8">Accuracy Setting (A)</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:559"><nobr><span class="ft8">RMS error</span></nobr></DIV>
<DIV style="position:absolute;top:551;left:472"><nobr><span class="ft8">Radiance RMS Error</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:642"><nobr><span class="ft8"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:636"><nobr><span class="ft8"> 0.2</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:636"><nobr><span class="ft8"> 0.4</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:636"><nobr><span class="ft8"> 0.6</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:636"><nobr><span class="ft8"> 0.8</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:642"><nobr><span class="ft8"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:636"><nobr><span class="ft8"> 1.2</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:649"><nobr><span class="ft8"> 0  2  4  6  8  10  12  14  16  18  20</span></nobr></DIV>
<DIV style="position:absolute;top:577;left:683"><nobr><span class="ft8">Accuracy Setting (A)</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:711"><nobr><span class="ft8">Timing Ratio</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:633"><nobr><span class="ft8">Time Ratio</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:492"><nobr><span class="ft3"><b>Figure 14: </b><i>"Venus with Ring" numerical statistics</i></span></nobr></DIV>
<DIV style="position:absolute;top:660;left:467"><nobr><span class="ft15">to infinity, the <i>k</i>NN density estimator does converge on the<br>true density, but always from below.</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:467"><nobr><span class="ft3"><b>7. Hardware Implementation</b></span></nobr></DIV>
<DIV style="position:absolute;top:743;left:467"><nobr><span class="ft15">There are two ways to approach a hardware implementation<br>of an algorithm in a hardware accelerator: with a custom<br>hardware implementation, or as an extension or exploita-<br>tion of current hardware support. While there would be cer-<br>tain advantages in a full custom hardware implementation of<br>BH, this would probably lead to a large chunk of hardware<br>with low utilisation rates. Although there are many potential<br>applications of A<i>k</i>NN search beyond photon mapping (we<br>list several in the conclusions), it seems more reasonable to<br>consider first if BH can be implemented using current hard-<br>ware and programmable shader features, and if not, what the<br>smallest incremental changes would be. We have concluded<br>that BH, while not quite implementable on today's graphics<br>hardware, should be implementable in the near future.</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:480"><nobr><span class="ft2">We consider only the lookup phase here, since the prepro-</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:467"><nobr><span class="ft15">cessing would indeed require some custom hardware sup-<br>port, but support which perhaps could be shared with other<br>useful features. In the lookup phase, (1) we compute hash</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:649"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">96</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1262" src="130009.png" alt="background image">
<DIV style="position:absolute;top:98;left:280"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:108"><nobr><span class="ft15">keys, (2) look up buckets in multiple hash tables, (3) merge<br>and remove duplicates from the list of retrieved blocks and<br>optionally sorting by priority, (4) retrieve the photon records<br>stored in these blocks, and (5) process the photons. Steps<br>(1) and (5) could be performed with current shader capabili-<br>ties, although the ability to loop would be useful for the last<br>step to avoid replicating the code to process each photon.<br>Computing the hash function amounts to doing a number of<br>comparisons, then adding up the zero-one results. This can<br>be done in linear time with a relatively small number of in-<br>structions using the proposed DX9 fragment shader instruc-<br>tion set. If conditional assignment and array lookups into the<br>register file are supported, this could be done in logarithmic<br>time using binary search.</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:122"><nobr><span class="ft2">Steps (2) and (4) amount to table lookups and can be im-</span></nobr></DIV>
<DIV style="position:absolute;top:386;left:108"><nobr><span class="ft15">plemented as nearest-neighbour texture-mapping operations<br>with suitable encoding of the data. For instance, the hash<br>tables might be supported with one texture map giving the<br>priority and number of valid entries in the bucket, while an-<br>other texture map or set of texture maps might give the block<br>references, represented by texture coordinates pointing into<br>another set of texture maps holding the photon records.</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:122"><nobr><span class="ft2">Step (3) is difficult to do efficiently without true condi-</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:108"><nobr><span class="ft15">tionals and conditional looping. Sorting is not the problem,<br>as it could be done with conditional assignment. The prob-<br>lem is that removal of a duplicate block reduces the number<br>of blocks in the candidate set. We would like in this case to<br>avoid making redundant photon lookups and executing the<br>instructions to process them. Without true conditionals, an<br>inefficient work-around is to make these redundant texture<br>accesses and process the redundant photons anyhow, but dis-<br>card their contribution by multiplying them by zero.</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:122"><nobr><span class="ft2">We have not yet attempted an implementation of BH on an</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:108"><nobr><span class="ft15">actual accelerator. Without looping, current accelerators do<br>not permit nearly enough instructions in shaders to process<br><i>k </i>photons for adequate density estimation. However, we feel<br>that it might be feasible to implement our algorithm on a<br>next-generation shader unit using the "multiply redundant<br>photons by zero" approach, if looping (a constant number of<br>times) were supported at the fragment level.</span></nobr></DIV>
<DIV style="position:absolute;top:834;left:122"><nobr><span class="ft2">We expect that the generation that follows DX9-class ac-</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:108"><nobr><span class="ft15">celerators will probably have true conditional execution and<br>looping, in which case implementation of BH will be both<br>straightforward and efficient, and will not require any ad-<br>ditional hardware or special shader instructions. It will also<br>only require two stages of conditional texture lookup, and<br>lookups in each stage can be performed in parallel. In com-<br>parison, it would be nearly impossible to implement a tree-<br>based search algorithm on said hardware due to the lack of a<br>stack and the large number of dependent lookups that would<br>be required. With a sufficiently powerful shading unit, of<br>course, we could implement any algorithm we wanted, but<br>BH makes fewer demands than a tree-based algorithm does.</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:467"><nobr><span class="ft3"><b>8. Conclusion and Future Work</b></span></nobr></DIV>
<DIV style="position:absolute;top:153;left:467"><nobr><span class="ft15">We have presented an efficient, scalable, coherent and<br>highly parallelisable A<i>k</i>NN scheme suitable for the high-<br>performance implementation of photon mapping.</span></nobr></DIV>
<DIV style="position:absolute;top:211;left:480"><nobr><span class="ft2">The coherent memory access patterns of BH lead to im-</span></nobr></DIV>
<DIV style="position:absolute;top:227;left:467"><nobr><span class="ft15">proved performance even for a software implementation.<br>However, in the near future we plan to implement the lookup<br>phase of BH on an accelerator. Accelerator capabilities are<br>not quite to the point where they can support this algorithm,<br>but they are very close. What is missing is some form of<br>true run-time conditional execution and looping, as well as<br>greater capacity in terms of numbers of instructions. How-<br>ever, unlike tree-based algorithms, block hashing requires<br>only bounded execution time and memory.</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:480"><nobr><span class="ft2">An accelerator-based implementation would be most in-</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:467"><nobr><span class="ft15">teresting if it is done in a way that permits other applications<br>to make use of the fast A<i>k</i>NN capability it would provide.<br>A<i>k</i>NN has many potential applications in graphics beyond<br>photon maps. For rendering, it could also be used for sparse<br>data interpolation (with many applications: visualisation of<br>sparse volume data, BRDF and irradiance volume repre-<br>sentation, and other sampled functions), sparse and multi-<br>resolution textures, procedural texture generation (specif-<br>ically, Worley's texture</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:596"><nobr><span class="ft6">47</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:612"><nobr><span class="ft2">functions), direct ray-tracing of</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:467"><nobr><span class="ft2">point-based objects</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:572"><nobr><span class="ft6">40</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:582"><nobr><span class="ft2">, and gap-filling in forward projection</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:467"><nobr><span class="ft2">point-based rendering</span></nobr></DIV>
<DIV style="position:absolute;top:564;left:587"><nobr><span class="ft6">48</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:597"><nobr><span class="ft2">. A<i>k</i>NN could also potentially be</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:467"><nobr><span class="ft15">used for non-rendering purposes: collision detection, sur-<br>face reconstruction, and physical simulation (for interact-<br>ing particle systems). Unlike the case with tree-based algo-<br>rithms, we feel that it will be feasible to implement BH as<br>a shader subroutine in the near future, which may make it a<br>key component in many potential applications of advanced<br>programmable graphics accelerators.</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:480"><nobr><span class="ft2">For a more detailed description of the block hashing algo-</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:467"><nobr><span class="ft2">rithm, please refer to the author's technical report</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:733"><nobr><span class="ft6">32</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:742"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:467"><nobr><span class="ft3"><b>9. Acknowledgements</b></span></nobr></DIV>
<DIV style="position:absolute;top:794;left:467"><nobr><span class="ft15">This research was funded by grants from the National<br>Science and Engineering Research Council of Canada<br>(NSERC), the Centre for Information Technology of Ontario<br>(CITO), the Canadian Foundation for Innovation (CFI), the<br>Ontario Innovation Trust (OIT), and the Bell University Labs<br>initiative.</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:467"><nobr><span class="ft3"><b>References</b></span></nobr></DIV>
<DIV style="position:absolute;top:947;left:467"><nobr><span class="ft2">1.</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:494"><nobr><span class="ft18">P. K. Agarwal. Range Searching. In J. E. Goodman and<br>J. O'Rourke, editors, <i>Handbook of Discrete and Com-<br>putational Geometry</i>. CRC Press, July 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:742"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:467"><nobr><span class="ft2">2.</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:494"><nobr><span class="ft18">P. K. Agarwal and J. Erickson. Geometric range search-<br>ing and its relatives. <i>Advances in Discrete and Compu-<br>tational Geometry</i>, 23:156, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:688"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:111"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">97</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1262" src="130010.png" alt="background image">
<DIV style="position:absolute;top:98;left:281"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:108"><nobr><span class="ft2">3.</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:135"><nobr><span class="ft18">S. Arya and D. M. Mount. Approximate Nearest Neigh-<br>bor Queries in Fixed Dimensions. In <i>Proc. ACM-SIAM<br>SODA</i>, 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:214"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:108"><nobr><span class="ft2">4.</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:135"><nobr><span class="ft18">S. Arya, D. M. Mount, N. S. Netanyahu, R. Silverman,<br>and A. Y. Wu. An Optimal Algorithm for Approxi-<br>mate Nearest Neighbor Searching. In <i>Proc. ACM-SIAM<br>SODA</i>, pages 573582, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:302"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:108"><nobr><span class="ft2">5.</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:135"><nobr><span class="ft2">J. L. Bentley.</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:224"><nobr><span class="ft2">Multidimensional binary search trees</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:135"><nobr><span class="ft18">used for associative searching. <i>Communications of the<br>ACM</i>, 18(9), September 1975.</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:305"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:312"><nobr><span class="ft2">,</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:318"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:108"><nobr><span class="ft2">6.</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:135"><nobr><span class="ft15">J. L. Bentley, B. W. Weide, and A. C. Chow. Optimal<br>Expected-Time Algorithms for Closest Point Problems.<br><i>ACM TOMS</i>, 6(4), December 1980.</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:334"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:341"><nobr><span class="ft2">,</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:348"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:108"><nobr><span class="ft2">7.</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:135"><nobr><span class="ft15">Per H. Christensen. Faster Photon Map Global Illumi-<br>nation. <i>Journal of Graphics Tools</i>, 4(3):110, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:422"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:108"><nobr><span class="ft2">8.</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:135"><nobr><span class="ft18">D. Comer. The Ubiquitous B-Tree. <i>ACM Computing<br>Surveys</i>, 11(2):121137, June 1979.</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:336"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:108"><nobr><span class="ft2">9.</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:135"><nobr><span class="ft15">C. A. Duncan, M. T. Goodrich, and S. G. Kobourov.<br>Balanced aspect ratio trees: Combining the advantages<br>of k-d trees and octrees. In <i>Proc. ACM-SIAM SODA</i>,<br>volume 10, pages 300309, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:325"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:108"><nobr><span class="ft2">10. H. Edelsbrunner. <i>Algorithms in Combinatorial Geom-</i></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:135"><nobr><span class="ft5"><i>etry</i>. Springer-Verlag, 1987.</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:295"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:108"><nobr><span class="ft2">11. D. Eppstein, M. S. Paterson, and F. F. Yao. On nearest</span></nobr></DIV>
<DIV style="position:absolute;top:536;left:135"><nobr><span class="ft15">neighbor graphs. <i>Discrete &amp; Computational Geometry</i>,<br>17(3):263282, April 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:292"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:108"><nobr><span class="ft2">12. C. Faloutsos and Y. Rong.</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:297"><nobr><span class="ft2">DOT: A Spatial Access</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:135"><nobr><span class="ft18">Method Using Fractals. In <i>Proc. 7th Int. Conf. on Data<br>Engineering,</i>, pages 152159, Kobe, Japan, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:410"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:108"><nobr><span class="ft2">13. C. Faloutsos and S. Roseman. Fractals for Secondary</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:135"><nobr><span class="ft15">Key Retrieval. In <i>Proc. 8th ACM PODS</i>, pages 247<br>252, Philadelphia, PA, 1989.</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:297"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:108"><nobr><span class="ft2">14. J. H. Freidman, J. L. Bentley, and R. A. Finkel. An Al-</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:135"><nobr><span class="ft15">gorithm for Finding Best Matches in Logarithmic Ex-<br>pected Time. <i>ACM TOMS</i>, 3(3):209226, 1977.</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:401"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:108"><nobr><span class="ft2">15. V. Gaede and O. Gnther.</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:311"><nobr><span class="ft2">Multidimensional ac-</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:135"><nobr><span class="ft2">cess methods.</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:233"><nobr><span class="ft5"><i>ACM Computing Surveys (CSUR)</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:135"><nobr><span class="ft2">30(2):170231, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:260"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:108"><nobr><span class="ft2">16. A. Gionis, P. Indyk, and R. Motwani. Similarity Search</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:135"><nobr><span class="ft15">in High Dimensions via Hashing. In <i>Proc. VLDB</i>, pages<br>518529, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:227"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:234"><nobr><span class="ft2">,</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:241"><nobr><span class="ft17">3</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:108"><nobr><span class="ft2">17. J. E. Goodman and J. O'Rourke, editors. <i>Handbook</i></span></nobr></DIV>
<DIV style="position:absolute;top:843;left:135"><nobr><span class="ft15"><i>of Discrete and Computational Geometry</i>. CRC Press,<br>July 1997. ISBN: 0849385245.</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:312"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:108"><nobr><span class="ft2">18. G. Greger, P. Shirley, P. Hubbard, and D. Greenberg.</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:135"><nobr><span class="ft2">The irradiance volume.</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:279"><nobr><span class="ft5"><i>IEEE CG&amp;A</i>, 18(2):3243,</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:135"><nobr><span class="ft2">1998.</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:173"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:108"><nobr><span class="ft2">19. V. Havran. Analysis of Cache Sensitive Representa-</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:135"><nobr><span class="ft15">tion for Binary Space Partitioning Trees. <i>Informatica</i>,<br>23(3):203210, May 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:288"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:108"><nobr><span class="ft2">20. P. Indyk and R. Motwani. Approximate Nearest Neigh-</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:135"><nobr><span class="ft15">bors: Towards Removing the Curse of Dimensionality.<br>In <i>Proc. ACM STOC</i>, pages 604613, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:379"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:108"><nobr><span class="ft2">21. P. Indyk, R. Motwani, P. Raghavan, and S. Vem-</span></nobr></DIV>
<DIV style="position:absolute;top:127;left:494"><nobr><span class="ft15">pala. Locality-Preserving Hashing in Multidimensional<br>Spaces. In <i>Proc. ACM STOC</i>, pages 618625, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:783"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:467"><nobr><span class="ft2">22. H. V. Jagadish. Linear clustering of objects with mul-</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:494"><nobr><span class="ft15">tiple attributes. In <i>Proc. Acm-sigmod</i>, pages 332342,<br>May 1990.</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:560"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:467"><nobr><span class="ft2">23. J. W. Jaromczyk and G. T. Toussaint. Relative Neigh-</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:494"><nobr><span class="ft2">borhood Graphs and Their Relatives.</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:721"><nobr><span class="ft5"><i>Proc. IEEE</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:494"><nobr><span class="ft2">80(9):15021517, September 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:693"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:467"><nobr><span class="ft2">24. H. W. Jensen. Rendering Caustics on Non-Lambertian</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:494"><nobr><span class="ft2">Surfaces.</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:558"><nobr><span class="ft5"><i>Computer Graphics Forum</i>, 16(1):5764,</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:494"><nobr><span class="ft2">1997. ISSN 0167-7055.</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:631"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:467"><nobr><span class="ft2">25. H. W. Jensen. <i>Realistic Image Synthesis Using Photon</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:494"><nobr><span class="ft5"><i>Mapping</i>. A.K. Peters, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:658"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:665"><nobr><span class="ft2">,</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:671"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:678"><nobr><span class="ft2">,</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:685"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:467"><nobr><span class="ft2">26. H. W. Jensen, F. Suykens, and P. H. Christensen. A</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:494"><nobr><span class="ft15">Practical Guide to Global Illumination using Photon<br>Mapping. In <i>SIGGRAPH 2001 Course Notes</i>, num-<br>ber 38. ACM, August 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:652"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:467"><nobr><span class="ft2">27. J. K. P. Kuan and P. H. Lewis. Fast k Nearest Neigh-</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:494"><nobr><span class="ft18">bour Search for R-tree Family. In <i>Proc. of First Int.<br>Conf. on Information, Communication and Signal Pro-<br>cessing</i>, pages 924928, Singapore, 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:727"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:467"><nobr><span class="ft2">28. E. P. Lafortune and Y. D. Willems. Using the Modified</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:494"><nobr><span class="ft15">Phong BRDF for Physically Based Rendering. Techni-<br>cal Report CW197, Department of Computer Science,<br>K.U.Leuven, November 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:665"><nobr><span class="ft17">7</span></nobr></DIV>
<DIV style="position:absolute;top:554;left:467"><nobr><span class="ft2">29. C. E. Leiserson, R. L. Rivest, and C. Stein. <i>Introduction</i></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:494"><nobr><span class="ft5"><i>to Algorithms</i>. MIT Press, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:677"><nobr><span class="ft17">6</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:467"><nobr><span class="ft2">30. K.-I. Lin and C. Yang. The ANN-Tree: An Index for</span></nobr></DIV>
<DIV style="position:absolute;top:605;left:494"><nobr><span class="ft15">Efficient Approximate Nearest-Neighbour Search. In<br><i>Conf. on Database Systems for Advanced Applications</i>,<br>2001.</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:532"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:656;left:467"><nobr><span class="ft2">31. N. Linial and O. Sasson. Non-Expansive Hashing. In</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:494"><nobr><span class="ft5"><i>Proc. acm stoc</i>, pages 509518, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:706"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:467"><nobr><span class="ft2">32. V. Ma.</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:545"><nobr><span class="ft2">Low Latency Photon Mapping using Block</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:494"><nobr><span class="ft2">Hashing.</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:557"><nobr><span class="ft2">Technical Report CS-2002-15, School of</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:494"><nobr><span class="ft2">Computer Science, University of Waterloo, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:768"><nobr><span class="ft17">9</span></nobr></DIV>
<DIV style="position:absolute;top:742;left:467"><nobr><span class="ft2">33. J. McNames.</span></nobr></DIV>
<DIV style="position:absolute;top:742;left:584"><nobr><span class="ft2">A Fast Nearest-Neighbor Algorithm</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:494"><nobr><span class="ft15">Based on a Principal Axis Search Tree. <i>IEEE Trans-<br>actions on Pattern Analysis and Machine Intelligence</i>,<br>23(9):964976, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:792;left:619"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:810;left:467"><nobr><span class="ft2">34. J. Nievergelt, H. Hinterberger, and K. C. Sevcik. The</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:494"><nobr><span class="ft15">Grid File: an adaptable, symmetric multikey file struc-<br>ture. <i>ACM TODS</i>, 9(1):3871, March 1984.</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:738"><nobr><span class="ft17">3</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:744"><nobr><span class="ft2">,</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:751"><nobr><span class="ft17">5</span></nobr></DIV>
<DIV style="position:absolute;top:861;left:467"><nobr><span class="ft2">35. T. J. Purcell, I. Buck, W. R. Mark, and P. Hanrahan.</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:494"><nobr><span class="ft15">Ray Tracing on Programmable Graphics Hardware. In<br><i>to appear in Proc. SIGGRAPH</i>, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:705"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:912;left:467"><nobr><span class="ft2">36. J. T. Robinson. The K-D-B-tree: A Search Structure</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:494"><nobr><span class="ft18">for Large Multidimensional Dynamic Indexes. In <i>Proc.<br>acm sigmod</i>, pages 1018, 1981.</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:678"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:467"><nobr><span class="ft2">37. Arnold L. Rosenberg and Lawrence Snyder. Time- and</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:494"><nobr><span class="ft15">space-optimality in b-trees. <i>ACM TODS</i>, 6(1):174193,<br>1981.</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:532"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:467"><nobr><span class="ft2">38. K. Salem and H. Garcia-Molina. Disk striping. In <i>IEEE</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:494"><nobr><span class="ft5"><i>ICDE</i>, pages 336342, 1986.</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:658"><nobr><span class="ft17">5</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:649"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">98</span></nobr></DIV>
</DIV>
<!-- Page 11 -->
<a name="11"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1262" src="130011.png" alt="background image">
<DIV style="position:absolute;top:98;left:280"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:108"><nobr><span class="ft2">39. N. Sample, M. Haines, M. Arnold, and T. Purcell. Op-</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:135"><nobr><span class="ft2">timizing Search Strategies in kd-Trees. May 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:416"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:108"><nobr><span class="ft2">40. G. Schaufler and H. W. Jensen.</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:328"><nobr><span class="ft2">Ray Tracing Point</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:135"><nobr><span class="ft15">Sampled Geometry. <i>Rendering Techniques 2000</i>, pages<br>319328, June 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:255"><nobr><span class="ft17">9</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:108"><nobr><span class="ft2">41. J. Schmittler, I. Wald, and P. Slusallek. SaarCOR - A</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:135"><nobr><span class="ft18">Hardware Architecture for Ray Tracing. In <i>to appear<br>at EUROGRAPHICS Graphics Hardware</i>, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:404"><nobr><span class="ft17">1</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:108"><nobr><span class="ft2">42. M. Smid.</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:200"><nobr><span class="ft2">Closest-Point Problems in Computational</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:135"><nobr><span class="ft15">Geometry. In J. R. Sack and J. Urrutia, editors, <i>Hand-<br>book on Computational Geometry</i>. Elsevier Science,<br>Amsterdam, North Holland, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:328"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:108"><nobr><span class="ft2">43. P. Tsaparas. Nearest neighbor search in multidimen-</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:135"><nobr><span class="ft2">sional spaces.</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:228"><nobr><span class="ft2">Qualifying Depth Oral Report 319-</span></nobr></DIV>
<DIV style="position:absolute;top:364;left:135"><nobr><span class="ft15">02, Dept. of Computer Science, University of Toronto,<br>1999.</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:173"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:108"><nobr><span class="ft2">44. M. Vanco, G. Brunnett, and T. Schreiber. A Hashing</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:135"><nobr><span class="ft15">Strategy for Efficient k-Nearest Neighbors Computa-<br>tion. In <i>Computer Graphics International</i>, pages 120<br>128. IEEE, June 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:264"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:108"><nobr><span class="ft2">45. I. Wald, T. Kollig, C. Benthin, A. Keller, and</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:135"><nobr><span class="ft15">P. Slusallek. Interactive global illumination. Technical<br>report, Computer Graphics Group, Saarland University,<br>2002. to be published at EUROGRAPHICS Workshop<br>on Rendering 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:250"><nobr><span class="ft17">2</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:108"><nobr><span class="ft2">46. G. Ward. Real Pixels. In James Arvo, editor, <i>Graphics</i></span></nobr></DIV>
<DIV style="position:absolute;top:566;left:135"><nobr><span class="ft5"><i>Gems II</i>, pages 8083. Academic Press, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:390"><nobr><span class="ft17">4</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:108"><nobr><span class="ft2">47. Steven Worley. A cellular texture basis function. In</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:135"><nobr><span class="ft15"><i>Proc. SIGGRAPH 1996</i>, pages 291294. ACM Press,<br>1996.</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:173"><nobr><span class="ft17">9</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:108"><nobr><span class="ft2">48. M. Zwicker, H. Pfister, J. van Baar, and M. Gross. Sur-</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:135"><nobr><span class="ft15">face Splatting. <i>Proc. SIGGRAPH 2001</i>, pages 371378,<br>2001.</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:173"><nobr><span class="ft17">9</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:111"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1144;left:435"><nobr><span class="ft11">99</span></nobr></DIV>
</DIV>
<!-- Page 12 -->
<a name="12"></a>
<DIV style="position:relative;width:892;height:1262;">
<STYLE type="text/css">
<!--
	.ft36{font-size:16px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1262" src="130012.png" alt="background image">
<DIV style="position:absolute;top:98;left:280"><nobr><span class="ft16"><i>Ma and McCool / Low Latency Photon Mapping Using Block Hashing</i></span></nobr></DIV>
<DIV style="position:absolute;top:244;left:168"><nobr><span class="ft0">(a) <i>kd</i>-tree</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:330"><nobr><span class="ft0">(b) BH, A=16</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:504"><nobr><span class="ft0">(c) BH, A=8</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:674"><nobr><span class="ft0">(d) BH, A=4</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:397"><nobr><span class="ft3"><b>Figure 13: </b><i>"Ring"</i></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:168"><nobr><span class="ft0">(a) <i>kd</i>-tree</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:330"><nobr><span class="ft0">(b) BH, A=16</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:504"><nobr><span class="ft0">(c) BH, A=8</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:674"><nobr><span class="ft0">(d) BH, A=4</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:367"><nobr><span class="ft3"><b>Figure 14: </b><i>"Venus with Ring"</i></span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:111"><nobr><span class="ft8">c The Eurographics Association 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:1123;left:432"><nobr><span class="ft36">158</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
