<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Robustness Analysis of Cognitive Information Complexity Measure using Weyuker Properties</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="author" content="shobha dixit">
<META name="date" content="2005-12-28T12:47:53+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:18px;font-family:Times;color:#000000;}
	.ft1{font-size:16px;font-family:Times;color:#000000;}
	.ft2{font-size:14px;font-family:Times;color:#000000;}
	.ft3{font-size:7px;font-family:Times;color:#000000;}
	.ft4{font-size:16px;font-family:Helvetica;color:#000000;}
	.ft5{font-size:13px;line-height:17px;font-family:Times;color:#000000;}
	.ft6{font-size:16px;line-height:18px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="169001.png" alt="background image">
<DIV style="position:absolute;top:82;left:98"><nobr><span class="ft0"><b>Robustness Analysis of Cognitive Information Complexity Measure using </b></span></nobr></DIV>
<DIV style="position:absolute;top:106;left:366"><nobr><span class="ft0"><b>Weyuker Properties </b></span></nobr></DIV>
<DIV style="position:absolute;top:130;left:285"><nobr><span class="ft1">Dharmender Singh Kushwaha and A.K.Misra </span></nobr></DIV>
<DIV style="position:absolute;top:150;left:296"><nobr><span class="ft2">Department of Computer Science and Engineering </span></nobr></DIV>
<DIV style="position:absolute;top:167;left:307"><nobr><span class="ft2">Moti Lal Nehru National Institute Of Technology </span></nobr></DIV>
<DIV style="position:absolute;top:185;left:409"><nobr><span class="ft2">Allahabad, India. </span></nobr></DIV>
<DIV style="position:absolute;top:202;left:277"><nobr><span class="ft2">Email:dharkush@yahoo.com,arun_kmisra@hotmail.com </span></nobr></DIV>
<DIV style="position:absolute;top:220;left:464"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:240;left:54"><nobr><span class="ft2"> <br>Abstract <br> </span></nobr></DIV>
<DIV style="position:absolute;top:240;left:54"><nobr><span class="ft5">Cognitive information complexity measure is based on cognitive <br>informatics, which helps in comprehending the software <br>characteristics. For any complexity measure to be robust, Weyuker <br>properties must be satisfied to qualify as good and comprehensive <br>one. In this paper, an attempt has also been made to evaluate <br>cognitive information complexity measure in terms of nine <br>Weyuker properties, through examples. It has been found that all <br>the nine properties have been satisfied by cognitive information <br>complexity measure and hence establishes cognitive information <br>complexity measure based on information contained in the <br>software as a robust and well-structured one. <br> <br>Keywords: Weighted information count, cognitive information <br>complexity unit, cognitive weight,  cognitive information <br>complexity measure, basic control structures. <br> </span></nobr></DIV>
<DIV style="position:absolute;top:551;left:57"><nobr><span class="ft2">1. Introduction </span></nobr></DIV>
<DIV style="position:absolute;top:568;left:54"><nobr><span class="ft5">Many well known software complexity measures have been <br>proposed such as McCabe's cyclomatic number [8], Halstead <br>programming effort[5], Oviedo's data flow complexity <br>measures[9], Basili's measure[3][4], Wang's cognitive complexity <br>measure[11] and others[7].  All the reported complexity measures <br>are supposed to cover the correctness, effectiveness and clarity of <br>software and also to provide good estimate of these parameters. <br>Out of the numerous proposed measures, selecting a particular <br>complexity measure is again a problem, as every measure has its <br>own advantages and disadvantages. There is an ongoing effort to <br>find such a comprehensive complexity measure, which addresses <br>most of the parameters of software. Weyuker[14] has suggested <br>nine properties, which are used to determine the effectiveness of <br>various software complexity measures. A good complexity <br>measure should satisfy most of the Weyuker's  properties. A new <br>complexity measure based on weighted information count of a <br>software and cognitive weights has been developed by Kushwaha <br>and Misra[2]. In this paper an effort has been made to estimate this <br>cognitive information complexity measure as robust and <br>comprehensive one by evaluating this against the nine Weyuker's <br>properties. <br> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:965;left:57"><nobr><span class="ft2">2. Cognitive Weights of a Software </span></nobr></DIV>
<DIV style="position:absolute;top:982;left:54"><nobr><span class="ft5"> <br>Basic control structures [BCS] such as sequence, branch and <br>iteration [10][13] are the basic logic building blocks of any <br>software and the cognitive weights (W</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:292"><nobr><span class="ft3">c </span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:299"><nobr><span class="ft2">) of a software [11] is the </span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:54"><nobr><span class="ft5">extent of difficulty or relative time and effort for comprehending a <br>given software modeled by a number of BCS's. These cognitive <br>weights for BCS's measure the complexity of logical structures of <br>the software. Either all the BCS's are in a linear layout or some </span></nobr></DIV>
<DIV style="position:absolute;top:257;left:471"><nobr><span class="ft5">BCS's are embedded in others. For the former case, we sum the <br>weights of all the BCS's and for the latter, cognitive weights of <br>inner BCS's are multiplied with the weight of external BCS's.</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:471"><nobr><span class="ft2"><br>3. Cognitive Information Complexity Measure (CICM) </span></nobr></DIV>
<DIV style="position:absolute;top:344;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:364;left:471"><nobr><span class="ft5">Since software represents computational information and is a <br>mathematical entity, the amount of information contained in the <br>software is a function of the identifiers that hold the information <br>and the operators that perform the operations on the information <br>i.e. <br>Information = f (Identifiers, Operators)   <br> <br>Identifiers are variable names, defined constants and other labels <br>in a software. Therefore information contained in one  line of code <br>is the number of all operators and operands in that line of code. <br>Thus in k</span></nobr></DIV>
<DIV style="position:absolute;top:544;left:528"><nobr><span class="ft3">th</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:536"><nobr><span class="ft2"> line of code the Information contained is: </span></nobr></DIV>
<DIV style="position:absolute;top:554;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:575;left:471"><nobr><span class="ft2">I</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:477"><nobr><span class="ft3">k</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:483"><nobr><span class="ft2"> = (Identifiers + Operands)</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:655"><nobr><span class="ft3">k   </span></nobr></DIV>
<DIV style="position:absolute;top:599;left:471"><nobr><span class="ft3">       </span></nobr></DIV>
<DIV style="position:absolute;top:592;left:488"><nobr><span class="ft2">= (ID</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:523"><nobr><span class="ft3">k  </span></nobr></DIV>
<DIV style="position:absolute;top:592;left:533"><nobr><span class="ft2">+  OP</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:570"><nobr><span class="ft3">k</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:575"><nobr><span class="ft2">) IU</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:600"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:610;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:630;left:471"><nobr><span class="ft2">Where  ID   = Total number of identifiers in the k</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:769"><nobr><span class="ft3">th</span></nobr></DIV>
<DIV style="position:absolute;top:630;left:777"><nobr><span class="ft2"> LOC of  </span></nobr></DIV>
<DIV style="position:absolute;top:647;left:471"><nobr><span class="ft5">software, <br>            OP   = Total number of operators in the k</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:765"><nobr><span class="ft3">th</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:773"><nobr><span class="ft2"> LOC of  </span></nobr></DIV>
<DIV style="position:absolute;top:682;left:471"><nobr><span class="ft5">software, <br>IU is the Information Unit representing that at least any identifier <br>or operator has one unit information in them. <br> <br>Total Information contained in a software (ICS) is sum of <br>information contained in each line of code i.e. </span></nobr></DIV>
<DIV style="position:absolute;top:785;left:471"><nobr><span class="ft6"> <br>       </span></nobr></DIV>
<DIV style="position:absolute;top:806;left:503"><nobr><span class="ft2">  LOCS </span></nobr></DIV>
<DIV style="position:absolute;top:824;left:471"><nobr><span class="ft2">ICS  =   </span></nobr></DIV>
<DIV style="position:absolute;top:823;left:524"><nobr><span class="ft2">  (I</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:551"><nobr><span class="ft3">k</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:556"><nobr><span class="ft2">)  </span></nobr></DIV>
<DIV style="position:absolute;top:842;left:471"><nobr><span class="ft5">             k=1 <br>Where  I</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:524"><nobr><span class="ft3">k </span></nobr></DIV>
<DIV style="position:absolute;top:859;left:531"><nobr><span class="ft2"> = Information contained in k</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:708"><nobr><span class="ft3">th </span></nobr></DIV>
<DIV style="position:absolute;top:859;left:718"><nobr><span class="ft2">line of code, </span></nobr></DIV>
<DIV style="position:absolute;top:876;left:471"><nobr><span class="ft2">     LOCS  = Total lines of code in the software. </span></nobr></DIV>
<DIV style="position:absolute;top:873;left:761"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:893;left:471"><nobr><span class="ft5"> <br>Thus, it is the information contained in the identifiers and the <br>necessary operations carried out by the operators in achieving the <br>desired goal of the software, which makes software difficult to <br>understand.  </span></nobr></DIV>
<DIV style="position:absolute;top:980;left:471"><nobr><span class="ft1">   </span></nobr></DIV>
<DIV style="position:absolute;top:1000;left:471"><nobr><span class="ft5">Once we have established that software can be comprehended as <br>information defined in information units (IU's) [2], the weighted <br>information count is  defined as :  <br> <br>The Weighted Information Count of a line of code (WICL) of a <br>software is a function of identifiers, operands and LOC and is <br>defined as : </span></nobr></DIV>
<DIV style="position:absolute;top:21;left:45"><nobr><span class="ft4">ACM SIGSOFT Software Engineering Notes      Page 1              January 2006    Volume 31 Number 1</span></nobr></DIV>
<DIV style="position:absolute;top:21;left:45"><nobr><span class="ft4">ACM SIGSOFT Software Engineering Notes      Page 1              January 2006    Volume 31 Number 1</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft7{font-size:16px;line-height:20px;font-family:Times;color:#000000;}
	.ft8{font-size:13px;line-height:18px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="169002.png" alt="background image">
<DIV style="position:absolute;top:82;left:216"><nobr><span class="ft1">          </span></nobr></DIV>
<DIV style="position:absolute;top:102;left:54"><nobr><span class="ft2"> WICL</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:100"><nobr><span class="ft3">k</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:105"><nobr><span class="ft2"> = ICS</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:146"><nobr><span class="ft3">k </span></nobr></DIV>
<DIV style="position:absolute;top:102;left:154"><nobr><span class="ft2"> / [LOCS ­ k] </span></nobr></DIV>
<DIV style="position:absolute;top:120;left:54"><nobr><span class="ft1">                                                               </span></nobr></DIV>
<DIV style="position:absolute;top:140;left:54"><nobr><span class="ft2">Where  WIC</span></nobr></DIV>
<DIV style="position:absolute;top:147;left:131"><nobr><span class="ft3">k     </span></nobr></DIV>
<DIV style="position:absolute;top:140;left:148"><nobr><span class="ft2">=  Weighted Information Count for the  k</span></nobr></DIV>
<DIV style="position:absolute;top:147;left:396"><nobr><span class="ft3">th</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:404"><nobr><span class="ft2"> line, </span></nobr></DIV>
<DIV style="position:absolute;top:157;left:54"><nobr><span class="ft2">              ICS</span></nobr></DIV>
<DIV style="position:absolute;top:164;left:130"><nobr><span class="ft3">k </span></nobr></DIV>
<DIV style="position:absolute;top:157;left:137"><nobr><span class="ft2">   = Information contained in a software for the  k</span></nobr></DIV>
<DIV style="position:absolute;top:164;left:434"><nobr><span class="ft3">th</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:441"><nobr><span class="ft2"> </span></nobr></DIV>
<DIV style="position:absolute;top:175;left:54"><nobr><span class="ft2">line. </span></nobr></DIV>
<DIV style="position:absolute;top:192;left:54"><nobr><span class="ft7"> <br>The </span></nobr></DIV>
<DIV style="position:absolute;top:215;left:86"><nobr><span class="ft2">Weighted Information Count  of the Software (WICS)</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:433"><nobr><span class="ft1"> is </span></nobr></DIV>
<DIV style="position:absolute;top:233;left:54"><nobr><span class="ft1">defined as : </span></nobr></DIV>
<DIV style="position:absolute;top:251;left:54"><nobr><span class="ft1">            </span></nobr></DIV>
<DIV style="position:absolute;top:254;left:108"><nobr><span class="ft2">LOCS       </span></nobr></DIV>
<DIV style="position:absolute;top:272;left:54"><nobr><span class="ft2">WICS  =   </span></nobr></DIV>
<DIV style="position:absolute;top:271;left:121"><nobr><span class="ft2">     WICL</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:191"><nobr><span class="ft3">k </span></nobr></DIV>
<DIV style="position:absolute;top:290;left:54"><nobr><span class="ft5">                 k = 1 <br>In order to be a complete and robust measure, the measure of <br>complexity should also consider the internal control structure of <br>the software. These basic control structures have also been <br>considered as the Newton's law in software engineering [10, 11]. <br>These are a set of fundamental and essential flow control <br>mechanisms that are used for building the logical architectures of <br>software.  <br>Using the above definitions, Cognitive Information Complexity <br>Measure (CICM) is defined as the product of weighted <br>information count of software(WICS) and the cognitive weight <br>(W</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:73"><nobr><span class="ft3">c</span></nobr></DIV>
<DIV style="position:absolute;top:479;left:77"><nobr><span class="ft2">) of the BCS  in the software i.e. </span></nobr></DIV>
<DIV style="position:absolute;top:497;left:54"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:517;left:54"><nobr><span class="ft2">CICM = WICS * W</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:182"><nobr><span class="ft3">c </span></nobr></DIV>
<DIV style="position:absolute;top:517;left:189"><nobr><span class="ft2">    </span></nobr></DIV>
<DIV style="position:absolute;top:535;left:54"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:555;left:54"><nobr><span class="ft5">This complexity measure encompasses all the major parameters <br>that have a bearing on the difficulty in comprehending software or <br>the cognitive complexity of the software. It clearly establishes a <br>relationship between difficulty in understanding software and its <br>cognitive complexity. It introduces a method to measure the <br>amount of information contained in the software thus enabling us <br>to calculate the coding efficiency (E</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:271"><nobr><span class="ft3">I</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:274"><nobr><span class="ft2">) as</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:296"><nobr><span class="ft3">  </span></nobr></DIV>
<DIV style="position:absolute;top:659;left:300"><nobr><span class="ft2">ICS  / LOCS [2]. </span></nobr></DIV>
<DIV style="position:absolute;top:676;left:54"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:696;left:57"><nobr><span class="ft2">4. Evaluation of Cognitive Information Complexity <br>Measure <br> </span></nobr></DIV>
<DIV style="position:absolute;top:748;left:54"><nobr><span class="ft8">Weyuker[14] proposed the nine properties to evaluate any <br>software complexity measure. These properties also evaluate the <br>weakness of a measure in a concrete way. With the help of these <br>properties one can determine the most suitable measure among the <br>different available complexity measures. In the following <br>paragraphs, the cognitive information complexity measure has <br>been evaluated against the nine Weyuker properties for <br>establishing itself as a comprehensive measure. <br> <br>Property 1: (</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:136"><nobr><span class="ft2">P)( Q)(|P|  |Q|) Where P and Q are program body. </span></nobr></DIV>
<DIV style="position:absolute;top:922;left:54"><nobr><span class="ft5"> <br>This property states that a measure should not rank all programs as <br>equally complex. Now consider the following two examples given <br>in Fig. 1 and Fig. 2.  For the program given in Fig. 1 in Appendix <br>I, there are two control structures: a sequential and a iteration. <br>Thus cognitive weight of these two BCS's is 1 + 3 = 4. </span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:54"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:54"><nobr><span class="ft5">Weighted information count for the above program is as under: <br>WICS = 3/6 + 1/4 + 6/3+ 4/2 = 4.75 <br>Hence Cognitive information complexity measure (CICM) is: <br>CICM = WICS * W</span></nobr></DIV>
<DIV style="position:absolute;top:1105;left:175"><nobr><span class="ft3">c</span></nobr></DIV>
<DIV style="position:absolute;top:1098;left:179"><nobr><span class="ft2"> = 4.75 * 4 = 19.0 </span></nobr></DIV>
<DIV style="position:absolute;top:81;left:471"><nobr><span class="ft5"> <br>For the program given in Fig. 2 in Appendix I there is only one <br>sequential structure and hence the cognitive weight W</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:799"><nobr><span class="ft3">c</span></nobr></DIV>
<DIV style="position:absolute;top:116;left:804"><nobr><span class="ft2"> is 1. WICS </span></nobr></DIV>
<DIV style="position:absolute;top:133;left:471"><nobr><span class="ft8">for the above program is 2.27. Hence CICM for the above program <br>is 2.27 * 1 = 2.27. <br> <br>From the complexity measure of the above two programs, it can be <br>seen that the CICM is different for the two programs and hence <br>satisfies this property. <br> <br>Property 2: Let c be a non-negative number. Then there are only <br>finitely many programs of complexity c. <br> <br>Calculation of WICS depends on the number of identifiers and <br>operators in a given program statement as well as on the number of <br>statements remaining that very statement in a given program. Also <br>all the programming languages consist of only finite number of <br>BCS's. Therefore CICM cannot rank complexity of all programs <br>as c. Hence CICM holds for this property. <br> <br>Property 3: There are distinct programs P and Q such that |P| = |Q|. <br> <br>For the program given in Fig. 3 in Appendix I, the CICM for the <br>program is 19, which is same as that of program in Fig. 1. <br>Therefore this property holds for CICM. <br> <br> <br>Property 4: (</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:554"><nobr><span class="ft2">P)( Q) (PQ &amp; |P|  |Q|) </span></nobr></DIV>
<DIV style="position:absolute;top:565;left:471"><nobr><span class="ft8"> <br>Referring to program illustrated in Fig.1, we have replaced the <br>while loop by the formula "sum = (b+1)*b/2" and have illustrated <br>the same in Fig.2. Both the programs are used to calculate the sum <br>of first n integer.  The CICM for both the programs is different, <br>thus establishing this property for CICM. <br> <br>Property 5: (</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:554"><nobr><span class="ft2">P)( Q)(|P|  |P;Q| and |Q|  |P;Q|). </span></nobr></DIV>
<DIV style="position:absolute;top:705;left:471"><nobr><span class="ft5"> <br>Consider the program body given in Fig.4 in Appendix I: The <br>program body for finding out the factorial of a number consists of <br>one sequential and one branch BCS's. Therefore W</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:791"><nobr><span class="ft3">c</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:795"><nobr><span class="ft2"> = 3. For the </span></nobr></DIV>
<DIV style="position:absolute;top:774;left:471"><nobr><span class="ft5">program body for finding out the prime number, there are one <br>sequential, one iteration and two branch BCS's. Therefore W</span></nobr></DIV>
<DIV style="position:absolute;top:798;left:846"><nobr><span class="ft3">c </span></nobr></DIV>
<DIV style="position:absolute;top:791;left:854"><nobr><span class="ft2">= 1 </span></nobr></DIV>
<DIV style="position:absolute;top:808;left:471"><nobr><span class="ft5">+ 2*3*2 = 13. For the main program body for finding out the <br>prime and factorial of the number, there are one sequential, two <br>call and one branch BCS's. Therefore W</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:741"><nobr><span class="ft3">c</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:745"><nobr><span class="ft2"> = 1+5+15+2 = 23. </span></nobr></DIV>
<DIV style="position:absolute;top:860;left:471"><nobr><span class="ft5">WICS for the program is  5.1. Therefore the Cognitive Information <br>Complexity Measure for the above program  = 5.1 * 23 = 117.3. <br> <br>Now consider the program given in Fig.5 in Appendix I to check <br>for prime. There is one sequential, one iteration and three branch <br>BCS's. Therefore W</span></nobr></DIV>
<DIV style="position:absolute;top:953;left:600"><nobr><span class="ft3">c</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:604"><nobr><span class="ft2"> = 1 + 2*3*2 + 2 = 15. WICS = 1.85. So </span></nobr></DIV>
<DIV style="position:absolute;top:963;left:471"><nobr><span class="ft5">CICM = 1.85 * 15 = 27.79.  <br>For the program given in Fig.6 in Appendix I, there is one <br>sequential, one iteration and one branch BCS's . <br>Wc for this program is 7 and WICS is .5.11. Hence  CICM = <br>WICS * W</span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:538"><nobr><span class="ft3">c</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:542"><nobr><span class="ft2"> = 5.11 * 7 = 35.77. </span></nobr></DIV>
<DIV style="position:absolute;top:1050;left:471"><nobr><span class="ft5"> <br>It is clear from the above example that if we take the two-program <br>body, one for calculating the factorial and another for checking for </span></nobr></DIV>
<DIV style="position:absolute;top:21;left:45"><nobr><span class="ft4">ACM SIGSOFT Software Engineering Notes      Page 2              January 2006    Volume 31 Number 1</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft9{font-size:13px;line-height:19px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="169003.png" alt="background image">
<DIV style="position:absolute;top:81;left:54"><nobr><span class="ft5">prime whose CICM are 27.79 and 35.77 that are less than 117.3. <br>So property 5 also holds for CICM. </span></nobr></DIV>
<DIV style="position:absolute;top:116;left:54"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:141;left:54"><nobr><span class="ft2">Property 6(a)</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:142"><nobr><span class="ft1"> : (</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:162"><nobr><span class="ft1">P)( Q)(R)(|P| = |Q|) &amp; (|P;R|   </span></nobr></DIV>
<DIV style="position:absolute;top:159;left:54"><nobr><span class="ft7">|Q;R|) <br> </span></nobr></DIV>
<DIV style="position:absolute;top:200;left:54"><nobr><span class="ft5">Let P be the program illustrated in Fig.1 and Q is the program <br>illustrated in Fig.3. The CICM of both the programs is 19. Let R <br>be the program illustrated in Fig.6. Appending R to P we have the <br>program illustrated in Fig.7 in Appendix I. <br> <br>Cognitive weight for the above program is 9 and WICS is 8.3. <br>Therefore CICM = 8.3*9=74.7. <br> <br>Similarly appending R to Q we have W</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:301"><nobr><span class="ft3">c</span></nobr></DIV>
<DIV style="position:absolute;top:338;left:305"><nobr><span class="ft2"> = 9 and WICS = 8.925. </span></nobr></DIV>
<DIV style="position:absolute;top:356;left:54"><nobr><span class="ft2">Therefore CICM = 8.925*9 = 80.325 and 74.7 </span></nobr></DIV>
<DIV style="position:absolute;top:355;left:363"><nobr><span class="ft2"> 80.325. This </span></nobr></DIV>
<DIV style="position:absolute;top:374;left:54"><nobr><span class="ft8">proves that Property 6(a) holds for CICM. <br> <br>Property 6(b): (</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:155"><nobr><span class="ft2">P)( Q)(R)(|P| = |Q|) &amp; (|R;P|   |R:Q|) </span></nobr></DIV>
<DIV style="position:absolute;top:427;left:54"><nobr><span class="ft8"> <br>To illustrate the above property let us arbitrarily append three <br>program statements in the programs given in Fig.1, we have the <br>program given in Fig.8 in Appendix I. There is only one sequential <br>and one iteration BCS. Hence cognitive weight is 1 + 3 = 4. There <br>is only one sequential and one iteration BCS. Hence cognitive <br>weight is 1 + 3 = 4 and WICS =  5.58. So CICM = 5.58 * 4  = <br>22.32. <br> <br>Similarly appending the same three statements to program in Fig.3 <br>we again have cognitive weights = 4 and WICS = 5.29. Therefore <br>CICM = 21.16 </span></nobr></DIV>
<DIV style="position:absolute;top:616;left:146"><nobr><span class="ft2"> 22.32. Hence this property also holds for CICM. </span></nobr></DIV>
<DIV style="position:absolute;top:635;left:54"><nobr><span class="ft8"> <br>Property 7: There are program bodies P and Q such that Q is <br>formed by permuting the order of the statement of P and (|P| </span></nobr></DIV>
<DIV style="position:absolute;top:669;left:419"><nobr><span class="ft2"> |Q|). </span></nobr></DIV>
<DIV style="position:absolute;top:688;left:54"><nobr><span class="ft8"> <br>Since WICS is dependent on the number of operators and operands <br>in a given program statement and the number of statements <br>remaining after this very program statement, hence permuting the <br>order of statement in any program will change the value of WICS. <br>Also cognitive weights of BCS's depend on the sequence of the <br>statement[1]. Hence CICM will be different for the two programs. <br>Thus CICM holds for this property also. <br> <br>Property 8 : If P is renaming of Q, then |P| = |Q|. <br> <br>CICM is measured in numeric and naming or renaming of any <br>program has no impact on CICM. Hence CICM holds for this <br>property also. <br> <br>Property 9: (</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:136"><nobr><span class="ft2">P)( Q)(|P| + |Q|) &lt; (|P;Q|) </span></nobr></DIV>
<DIV style="position:absolute;top:965;left:54"><nobr><span class="ft8">OR <br>(</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:59"><nobr><span class="ft2">P)( Q)(R)(|P| + |Q| + |R|) &lt; (|P;Q;R|) </span></nobr></DIV>
<DIV style="position:absolute;top:1000;left:54"><nobr><span class="ft5"> <br>For the program illustrated in Fig.4, if we separate the main <br>program body P by segregating Q (prime check) and R (factorial), <br>we have the program illustrated in Fig.9 as shown in Appendix I. <br>The above program has one sequential and one branch BCS. Thus <br>cognitive weight is 4 and WICS is 1.475. Therefore CICM = </span></nobr></DIV>
<DIV style="position:absolute;top:81;left:471"><nobr><span class="ft5">4.425. Hence 4.425 + 27.79 + 35.77 &lt; 117.3. This proves that <br>CICM also holds for this property. </span></nobr></DIV>
<DIV style="position:absolute;top:116;left:475"><nobr><span class="ft2"> </span></nobr></DIV>
<DIV style="position:absolute;top:133;left:471"><nobr><span class="ft2">5. Comparative Study of Cognitive Information <br>Complexity Measure and Other Measures in Terms of <br>Weyuker Properties </span></nobr></DIV>
<DIV style="position:absolute;top:185;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:206;left:471"><nobr><span class="ft5">In this section cognitive information complexity measure has been <br>compared with other complexity measures in terms of all nine <br>Weyuker's properties. <br>  <br>P.N.- Property Number, S.C.-  Statement Count, C N. - <br>Cyclomatic Number, E.M.- Effort Measure, D.C.-Dataflow <br>Complexity, C.C.M. - Cognitive Complexity Measure, CICM ­ <br>Cognitive Information Complexity Measure, Y- Yes, N ­ NO <br> </span></nobr></DIV>
<DIV style="position:absolute;top:362;left:479"><nobr><span class="ft1">   </span></nobr></DIV>
<DIV style="position:absolute;top:382;left:479"><nobr><span class="ft5">P<br>N </span></nobr></DIV>
<DIV style="position:absolute;top:362;left:506"><nobr><span class="ft2">SC  CN EM DC CCM CICM. </span></nobr></DIV>
<DIV style="position:absolute;top:417;left:479"><nobr><span class="ft2">1 </span></nobr></DIV>
<DIV style="position:absolute;top:417;left:506"><nobr><span class="ft2">Y Y Y Y Y  Y </span></nobr></DIV>
<DIV style="position:absolute;top:435;left:479"><nobr><span class="ft2">2 </span></nobr></DIV>
<DIV style="position:absolute;top:435;left:506"><nobr><span class="ft2">Y N Y N Y  Y </span></nobr></DIV>
<DIV style="position:absolute;top:453;left:479"><nobr><span class="ft2">3 </span></nobr></DIV>
<DIV style="position:absolute;top:453;left:506"><nobr><span class="ft2">Y Y Y Y Y  Y </span></nobr></DIV>
<DIV style="position:absolute;top:471;left:479"><nobr><span class="ft2">4 </span></nobr></DIV>
<DIV style="position:absolute;top:471;left:506"><nobr><span class="ft2">Y Y Y Y Y  Y </span></nobr></DIV>
<DIV style="position:absolute;top:489;left:479"><nobr><span class="ft2">5 </span></nobr></DIV>
<DIV style="position:absolute;top:489;left:506"><nobr><span class="ft2">Y Y N N Y  Y </span></nobr></DIV>
<DIV style="position:absolute;top:507;left:479"><nobr><span class="ft2">6 </span></nobr></DIV>
<DIV style="position:absolute;top:507;left:506"><nobr><span class="ft2">N N Y Y N  Y </span></nobr></DIV>
<DIV style="position:absolute;top:525;left:479"><nobr><span class="ft2">7 </span></nobr></DIV>
<DIV style="position:absolute;top:525;left:506"><nobr><span class="ft2">N N N Y Y  Y </span></nobr></DIV>
<DIV style="position:absolute;top:543;left:479"><nobr><span class="ft2">8 </span></nobr></DIV>
<DIV style="position:absolute;top:543;left:506"><nobr><span class="ft2">Y Y Y Y Y  Y </span></nobr></DIV>
<DIV style="position:absolute;top:561;left:479"><nobr><span class="ft2">9 </span></nobr></DIV>
<DIV style="position:absolute;top:561;left:506"><nobr><span class="ft2">N N Y Y Y  Y </span></nobr></DIV>
<DIV style="position:absolute;top:580;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:600;left:471"><nobr><span class="ft2">Table 1: Comparison of complexity measures with Weyuker    </span></nobr></DIV>
<DIV style="position:absolute;top:598;left:871"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:615;left:471"><nobr><span class="ft1">             </span></nobr></DIV>
<DIV style="position:absolute;top:618;left:530"><nobr><span class="ft2">properties. </span></nobr></DIV>
<DIV style="position:absolute;top:635;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:655;left:471"><nobr><span class="ft5">It may be observed from the table 1 that complexity of a program <br>using effort measure, data flow measure and Cognitive <br>Information Complexity Measure depend directly on the <br>placement of statement and therefore all these measures hold for <br>property 6 also. All the complexity measure intend to rank all the <br>programs differently  </span></nobr></DIV>
<DIV style="position:absolute;top:759;left:471"><nobr><span class="ft1">                      </span></nobr></DIV>
<DIV style="position:absolute;top:780;left:471"><nobr><span class="ft2">6. Conclusion </span></nobr></DIV>
<DIV style="position:absolute;top:797;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:817;left:471"><nobr><span class="ft9">  Software complexity measures serves both as an analyzer and a <br>predicator in quantitative software engineering. Software quality is <br>defined as the completeness, correctness, consistency, no <br>misinterpretation, and no ambiguity, feasible verifiable in both <br>specification and implementation. For a good complexity measure <br>it is very necessary that the particular complexity measure not only <br>satisfies the above-mentioned property of software quality but also <br>satisfies the nine Weyuker properties. The software complexity in <br>terms of cognitive information complexity measure thus has been <br>established as a well- structured complexity measure</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:788"><nobr><span class="ft1">.  </span></nobr></DIV>
<DIV style="position:absolute;top:994;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:471"><nobr><span class="ft2">References</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:1052;left:471"><nobr><span class="ft5">[1] Misra,S and Misra,A.K.(2005): Evaluating Cognitive <br>Complexity measure with Weyuker Properties, Proceeding of the3 </span></nobr></DIV>
<DIV style="position:absolute;top:1085;left:471"><nobr><span class="ft3">rd</span></nobr></DIV>
<DIV style="position:absolute;top:1087;left:480"><nobr><span class="ft2"> IEEE International Conference on Cognitive </span></nobr></DIV>
<DIV style="position:absolute;top:1104;left:471"><nobr><span class="ft2">Informatics(ICCI'04). </span></nobr></DIV>
<DIV style="position:absolute;top:21;left:45"><nobr><span class="ft4">ACM SIGSOFT Software Engineering Notes      Page 3              January 2006    Volume 31 Number 1</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="169004.png" alt="background image">
<DIV style="position:absolute;top:81;left:54"><nobr><span class="ft5"> <br>[2] Kushwaha,D.S and Misra,A.K.(2005): A Modified Cognitive <br>Information Complexity Measure of Software, Proceeding of the <br>7</span></nobr></DIV>
<DIV style="position:absolute;top:131;left:62"><nobr><span class="ft3">th</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:69"><nobr><span class="ft2"> International Conference on Cognitive Systems(ICCS'05) </span></nobr></DIV>
<DIV style="position:absolute;top:150;left:54"><nobr><span class="ft5">(accepted for presentation) <br> <br>[3]  Basili,V.R. and Phillips(1983): T.Y,Metric analysis and data <br>validation across fortran projection .IEEE Trans.software Eng.,SE <br>­9(6):652-663,1983. <br> <br>[4] Basili,V.R.(1980): Qualitative software complexity model: A <br>summary in tutorial on models and method for software <br>management and engineering .IEEE Computer Society Press ,Los <br>Alamitos,CA,1980 <br>. <br>[5] Halstead,M.(1977): Elements of software science,Elsevier <br>North Holland,New York.1997. <br> <br>[6] Klemola, T. and Rilling, J.(2003): A Cognitive Complexity <br>Metric Based on Category Learning, , Proceeding of the 2</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:410"><nobr><span class="ft3">nd</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:420"><nobr><span class="ft2"> IEEE </span></nobr></DIV>
<DIV style="position:absolute;top:426;left:54"><nobr><span class="ft5">International Conference on Cognitive Informatics(ICCI'03). <br> <br>[7] Kearney, J.K., Sedlmeyer, R. L., Thompson, W.B., Gray, M. <br>A. and Adler, M. A.(1986): Software complexity measurement. <br>ACM Press, Newyork, 28:1044-1050,1986 <br> <br>[8] McCabe, T.A.(1976): Complexity measure. IEEE <br>trans.software engg.,(se-2,6):308-320,1976. <br> <br>[9] Oviedo, E.(1980): Control flow, data and program complexity <br>.in Proc. IEEE COMPSAC, Chicago, lL, pages 146-152,November <br>1980. <br> <br>[10] Wang. and Shao,J.(2002): On cognitive informatics, keynote <br>lecture, proceeding of the .1</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:231"><nobr><span class="ft3">st</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:238"><nobr><span class="ft2"> IEEE International Conference on </span></nobr></DIV>
<DIV style="position:absolute;top:685;left:54"><nobr><span class="ft5">Cognitive Informatics, pages 34-42,August 2002. <br> <br>[11] Wang ,Y .and Shao,J.(2004): Measurement of the Cognitive <br>Functional Complexity of Software, Proceeding of the 3 </span></nobr></DIV>
<DIV style="position:absolute;top:735;left:411"><nobr><span class="ft3">rd</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:419"><nobr><span class="ft2"> IEEE </span></nobr></DIV>
<DIV style="position:absolute;top:754;left:54"><nobr><span class="ft5">International Conference on Cognitive Informatics(ICCI'04) <br>  <br>[12] Wang,Y .and Shao,J.(2003): On cognitive informatics, <br>Proceeding of the 2</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:173"><nobr><span class="ft3">nd</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:183"><nobr><span class="ft2"> IEEE International Conference on Cognitive </span></nobr></DIV>
<DIV style="position:absolute;top:823;left:54"><nobr><span class="ft5">Informatics(ICCI'03),London,England,IEEE CS Press, pages 67-<br>71,August 2003 . <br> <br>[13] Wang, Y.(2002): The real time process algebra (rtpa). Annals <br>of Software Engineering, an international journal, and 14:235-<br>247,2002. <br> <br>[14] Weyuker, E.(1988): Evaluating software complexity measure. <br>IEEE Transaction on Software Complexity Measure, 14(9): 1357-<br>1365,september1988. <br> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:21;left:45"><nobr><span class="ft4">ACM SIGSOFT Software Engineering Notes      Page 4              January 2006    Volume 31 Number 1</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="169005.png" alt="background image">
<DIV style="position:absolute;top:81;left:54"><nobr><span class="ft5">Appendix I <br> <br>/*Calculate the sum of first n integer*/ <br>main() { <br>int i, n, sum=0; <br>printf(&quot;enter the number&quot;);                       //BCS1 <br>scanf(&quot;%d&quot; , &amp;n); <br>for (i=1;i&lt;=n;i++)                                      //BCS2 <br>sum=sum+i; <br>printf(&quot;the sum is %d&quot; ,sumssss); <br>getch();} </span></nobr></DIV>
<DIV style="position:absolute;top:271;left:54"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:292;left:54"><nobr><span class="ft5">Fig. 1 : Source code of the sum of first n integers. <br> <br>main()  <br>{ <br> int b; <br>int sum = 0; <br>Printf("Enter the Number"); <br>Scanf("%d", &amp;n); <br>Sum = (b+1)*b/2; <br>Printf("The sum is %d",sum); <br>getch(); <br>} <br> <br>Fig. 2 : Source code to calculate sum of first n integers. <br> <br># define N 10 <br>main( ) <br>{ <br>int count <br>float, sum,average,number; <br>sum = count =0; <br>while (count &lt; N ) <br>{ <br>scanf (" %f",&amp; number); <br>sum = sum+ number; <br>count = count+1; <br>} <br>average = sum / N; <br>printf ("Average =%f",average); <br>} <br> <br>Fig. 3 : Source code to calculate the average of a set of N <br>numbers. <br> <br>#include&lt; stdio.h &gt; <br>#include&lt; stdlib.h &gt; <br>int main() { <br>long fact(int n); <br>int isprime(int n); <br>int n; <br>long int temp; <br>clrscr(); <br>printf(&quot;\n input the number&quot;);                 //BCS11 <br>scanf(&quot;%d&quot;,&amp;n); <br>temp=fact(n);                                         //BCS12 <br>{printf(&quot;\n is prime&quot;);} <br>int flag1=isprime(n);                            //BCS13 <br>if (flag1= =1)                                       //BCS14 </span></nobr></DIV>
<DIV style="position:absolute;top:81;left:471"><nobr><span class="ft5">else <br>{printf(&quot;\n is not prime&quot;)}; <br>printf(&quot;\n factorial(n)=%d&quot;,temp); <br>getch(); <br>long fact(int n) { <br>long int facto=1;                                //BCS21 <br>if (n= =0)                                           //BCS22 <br>facto=1;else <br>facto=n*fact(n-1); <br>return(facto); } <br>int isprime(int n) <br>{ int flag;                                         //BCS31 <br>if (n= =2) <br>flag=1;                                            //BCS32 <br>else <br>for (int i=2;i&lt;n;i++)                       //BCS33 <br>{ if (n%i= =0)                               //BCS34 <br>{ flag=0; Therefore Wc = 3 <br> <br> <br>break; } <br>else { <br>flag=1 ;}} <br>return (flag);}} <br> <br>Fig.  4:  Source  code  to  check prime number and to calculate <br>factorial of the number <br> <br>#include&lt; stdio.h &gt; <br>#include&lt; stdlib.h &gt; <br>#include&lt; conio.h &gt; <br>int main() {                                  //BCS1 <br>int flag = 1,n; <br>clrscr(); <br>printf(&quot;\ n enter the number&quot;); <br>scanf(&quot;%d&quot;,&amp;n); <br>if (n= =2) <br>flag=1;                                        //BCS21 <br>else <br>{for (int i=2;i&lt;n;i++)                 //BCS22 <br>if (n%i= =0)                               //BCS23 <br>{ flag=0; <br>break;} <br>else{ <br>flag=1; <br>continue;} } <br>if(flag)                                    //BCS3 <br>printf(&quot;the number is prime&quot;); <br>else <br>printf(&quot;the number is not prime&quot;); <br>grtch();} <br>Fig.5 : Source code for checking prime number </span></nobr></DIV>
<DIV style="position:absolute;top:978;left:471"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:999;left:471"><nobr><span class="ft5">#include&lt; stdio.h &gt; <br>#include&lt; stdlib.h &gt; <br>#include&lt; conio.h &gt; <br>int main () { <br>long int fact=1; <br>int n; <br>clrscr(); </span></nobr></DIV>
<DIV style="position:absolute;top:21;left:45"><nobr><span class="ft4">ACM SIGSOFT Software Engineering Notes      Page 5              January 2006    Volume 31 Number 1</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="169006.png" alt="background image">
<DIV style="position:absolute;top:81;left:54"><nobr><span class="ft5">printf(&quot;\ input the number&quot;);        //BCS1 <br>scanf(&quot;%d&quot;,&amp;n);                        <br>if (n==0)                                      //BCS21 <br>else <br>for(int i=n;i&gt;1;i--)                        //BCS22 <br>fact=fact*i; <br>printf(&quot;\n factorial(n)=%1d&quot;,fact); <br>getch();}  </span></nobr></DIV>
<DIV style="position:absolute;top:219;left:54"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:240;left:54"><nobr><span class="ft2">Fig.6 : Source code for calculating factorial of a number </span></nobr></DIV>
<DIV style="position:absolute;top:257;left:54"><nobr><span class="ft7"> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:299;left:54"><nobr><span class="ft5"> <br>Int main() { <br>long fact(int n); <br>int i, n, sum=0; <br>printf(&quot;enter the number&quot;);                        <br>scanf(&quot;%d&quot; , &amp;n); <br>temp = fact(n);                                            <br>for (i=1;i&lt;=n;i++)                                       <br>sum=sum+i; <br>printf(&quot;the sum is %d&quot; ,sum); <br>getch(); <br>long fact(int n){                                          <br>long int facto = 1; <br>if (n == 0)                                                   <br>facto = 1 else <br>facto = n*fact(n-1); <br>return(facto);}} <br> <br>Fig.7: Source code of sum of first n integer and factorial of n. </span></nobr></DIV>
<DIV style="position:absolute;top:627;left:54"><nobr><span class="ft1"> </span></nobr></DIV>
<DIV style="position:absolute;top:647;left:54"><nobr><span class="ft5">main() { <br>int a,b,result; <br>result = a/b; <br>printf(the result is %d",result); <br>int i, n, sum=0; <br>printf(&quot;enter the number&quot;);                        <br>scanf(&quot;%d&quot; , &amp;n); <br>for (i=1;i&lt;=n;i++)                                       <br>sum=sum+i; <br>printf(&quot;the sum is %d&quot; ,sum); <br>getch();} </span></nobr></DIV>
<DIV style="position:absolute;top:837;left:54"><nobr><span class="ft7"> <br>Fig. 8 : Source code of division and the sum of first <br>n integers. </span></nobr></DIV>
<DIV style="position:absolute;top:899;left:54"><nobr><span class="ft5"> <br>int main(){ <br>int n; <br>long int temp; <br>clrscr(); <br>printf("\n input the number"); <br>scanf("%d",&amp;n); <br>temp = fact(n); <br>{printf("\ is prime");} <br>int flag1 = isprime(n); <br>if (flag1 == 1) <br>else <br>{printf("\n is not prime)}; </span></nobr></DIV>
<DIV style="position:absolute;top:81;left:471"><nobr><span class="ft5">printf("\n factorial(n) = %d",temp); <br>getch();} <br> <br>Fig.9 : Source code of main program body of program in Fig.4 <br> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:21;left:45"><nobr><span class="ft4">ACM SIGSOFT Software Engineering Notes      Page 6              January 2006    Volume 31 Number 1</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
