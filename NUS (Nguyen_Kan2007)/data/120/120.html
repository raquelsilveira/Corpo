<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>D:\Paper\HTML\120</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2006-11-30T08:09:13+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Times;color:#000000;}
	.ft1{font-size:6px;font-family:Times;color:#000000;}
	.ft2{font-size:15px;font-family:Times;color:#000000;}
	.ft3{font-size:12px;font-family:Times;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:9px;font-family:Times;color:#000000;}
	.ft6{font-size:16px;font-family:Courier;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft9{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="120001.png" alt="background image">
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft0"><b>KDDCS: A Load-Balanced In-Network Data-Centric Storage</b></span></nobr></DIV>
<DIV style="position:absolute;top:138;left:268"><nobr><span class="ft0"><b>Scheme for Sensor Networks</b></span></nobr></DIV>
<DIV style="position:absolute;top:143;left:641"><nobr><span class="ft1"></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:248"><nobr><span class="ft2">Mohamed Aly, Kirk Pruhs, and Panos K. Chrysanthis</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:286"><nobr><span class="ft3">Dept. of Computer Science, University of Pittsburgh</span></nobr></DIV>
<DIV style="position:absolute;top:239;left:391"><nobr><span class="ft3">Pittsburgh, PA, USA</span></nobr></DIV>
<DIV style="position:absolute;top:260;left:240"><nobr><span class="ft2">maly@cs.pitt.edu, kirk@cs.pitt.edu, panos@cs.pitt.edu</span></nobr></DIV>
<DIV style="position:absolute;top:314;left:81"><nobr><span class="ft2">ABSTRACT</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:81"><nobr><span class="ft8">We propose an In-Network Data-Centric Storage (INDCS) scheme<br>for answering ad-hoc queries in sensor networks. Previously pro-<br>posed In-Network Storage (INS) schemes suffered from Storage<br>Hot-Spots that are formed if either the sensors' locations are not<br>uniformly distributed over the coverage area, or the distribution<br>of sensor readings is not uniform over the range of possible read-<br>ing values. Our K-D tree based Data-Centric Storage (KDDCS)<br>scheme maintains the invariant that the storage of events is dis-<br>tributed reasonably uniformly among the sensors. KDDCS is com-<br>posed of a set of distributed algorithms whose running time is<br>within a poly-log factor of the diameter of the network. The num-<br>ber of messages any sensor has to send, as well as the bits in those<br>messages, is poly-logarithmic in the number of sensors. Load bal-<br>ancing in KDDCS is based on defining and distributively solving<br>a theoretical problem that we call the Weighted Split Median prob-<br>lem. In addition to analytical bounds on KDDCS individual algo-<br>rithms, we provide experimental evidence of our scheme's general<br>efficiency, as well as its ability to avoid the formation of storage<br>hot-spots of various sizes, unlike all previous INDCS schemes.</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:81"><nobr><span class="ft2">Categories and Subject Descriptors</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:81"><nobr><span class="ft8">H.2.4 [Database Management]: Systems--Distributed<br>databases, Query processing</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:81"><nobr><span class="ft2">General Terms</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:81"><nobr><span class="ft4">Algorithms, Design, Experimentation, Performance</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:81"><nobr><span class="ft2">Keywords</span></nobr></DIV>
<DIV style="position:absolute;top:801;left:81"><nobr><span class="ft4">Sensor Network, Power-Aware, Distributed Algorithms</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:81"><nobr><span class="ft2">1.</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:112"><nobr><span class="ft2">INTRODUCTION</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:94"><nobr><span class="ft4">Sensor networks provide us with the means of effectively mon-</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:81"><nobr><span class="ft8">itoring and interacting with the physical world. As an illustrative<br>example of the type of sensor network application that concerns<br>us here, consider an emergency/disaster scenario where sensors are</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:87"><nobr><span class="ft4">This work has been funded in part by NSF grants ANI-0325353,</span></nobr></DIV>
<DIV style="position:absolute;top:939;left:81"><nobr><span class="ft4">CCF-0448196, CCF-0514058, and IIS-0534531.</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:81"><nobr><span class="ft9">Permission to make digital or hard copies of all or part of this work for<br>personal or classroom use is granted without fee provided that copies are<br>not made or distributed for profit or commercial advantage and that copies<br>bear this notice and the full citation on the first page. To copy otherwise, to<br>republish, to post on servers or to redistribute to lists, requires prior specific<br>permission and/or a fee.<br>CIKM'06, November 5­11, 2006, Arlington, Virginia, USA.<br>Copyright 2006 ACM 1-59593-433-2/06/0011 ...</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:315"><nobr><span class="ft4">$</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:321"><nobr><span class="ft5">5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:475"><nobr><span class="ft8">deployed in the area of the disaster [17]. It is the responsibility of<br>the sensor network to sense and store events of potential interest.<br>An event is composed of one or more attributes (e.g. temperature,<br>carbon monoxide level, etc.), the identity of the sensor that sensed<br>the event, and the time when the event was sensed. As first respon-<br>ders move through the disaster area with hand-held devices, they<br>issue queries about recent events in the network. For example, the<br>first responder might ask for the location of all sensor nodes that<br>recorded high carbon monoxide levels in the last 15 minutes, or<br>he might ask whether any sensor node detected movement in the<br>last minute. Queries are picked up by sensors in the region of the<br>first responder. The sensor network is then responsible for answer-<br>ing these queries. The first responders use these query answers to<br>make decisions on how to best manage the emergency.</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:489"><nobr><span class="ft4">The ad-hoc queries of the first responders will generally be multi-</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:475"><nobr><span class="ft8">dimensional range queries [9], that is, the queries concern sensor<br>readings that were sensed over a small time window in the near past<br>and that fall in a given range of the attribute values. In-Network<br>Storage (INS) is a storage technique that has been specifically pre-<br>sented to efficiently process this type of queries. INS involves stor-<br>ing events locally in the sensor nodes. Storage may be in-network<br>because it is more efficient than shipping all the data (i.e., raw sen-<br>sor readings) out of the network (for example to base stations), or<br>simply because no out-of-network storage is available. All INS<br>schemes already presented in literature were Data-Centric Storage<br>(DCS) schemes [15]. In any In-Network Data-Centric Storage (IN-<br>DCS) scheme, there exists a function from events to sensors that<br>maps each event to an owner sensor based on the value of the at-<br>tributes of that event. The owner sensor will be responsible for<br>storing this event. The owner may be different than the sensor that<br>originally generated the event. To date, the Distributed Index for<br>Multi-dimensional data (DIM) scheme [9] has been shown to ex-<br>hibit the best performance among all proposed INDCS schemes in<br>dealing with sensor networks whose query loads are basically com-<br>posed of ad-hoc queries .</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:489"><nobr><span class="ft4">In DIM [9], the events-to-sensors mapping is based on a K-D tree</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:475"><nobr><span class="ft4">[3], where the leaves</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:592"><nobr><span class="ft4">R form a partition of the coverage area, and</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:475"><nobr><span class="ft4">each element of</span></nobr></DIV>
<DIV style="position:absolute;top:895;left:565"><nobr><span class="ft4">R contains either zero or one sensor. The forma-</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:475"><nobr><span class="ft4">tion of the K-D tree consists of rounds. Initially,</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:734"><nobr><span class="ft4">R is a one element</span></nobr></DIV>
<DIV style="position:absolute;top:930;left:475"><nobr><span class="ft8">set containing the whole coverage area. In each odd/even round r,<br>each region R  R that contains more than one sensor is bisected<br>horizontally/vertically. Each time that a region is split, each sensor<br>in that region has a bit appended to its address specifying which<br>side of the split the sensor was on. Thus, the length of a sensor's<br>address (bit-code) is its depth in the underlying K-D tree. When a<br>sensor generates an event, it maps such event to a binary code based<br>on a repetitive fixed uniform splitting of the attributes' ranges in a<br>round robin fashion. For our purposes, it is sufficient for now to</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">317</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="120002.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">consider the cases that the event consists of only one attribute, say<br>temperature. Then, the high order bits of the temperature are used<br>to determine a root-to-leaf path in the K-D tree, and if there is a<br>sensor in the region of the leaf, then this sensor is the owner of this<br>event. Due to the regularity of regions in this K-D tree, the routing<br>of an event from the generating sensor to the owner sensor is partic-<br>ularly easy using Greedy Perimeter Stateless Routing (GPSR) [6].<br>Full description of DIM is presented in Section 2.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:94"><nobr><span class="ft4">Though it is the best DCS scheme so far, DIM suffers from sev-</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:81"><nobr><span class="ft8">eral problems. One problem is that events may well be mapped to<br>orphan regions that contain no sensors. Thus, DIM requires some<br>kludge to assign orphan regions to neighboring sensors.</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:94"><nobr><span class="ft4">Another major problem in DIM is that of storage hot-spots. Stor-</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:81"><nobr><span class="ft8">age hot-spots may occur if the sensors are not uniformly distributed.<br>A storage hot-spot occurs when relatively many events are assigned<br>to a relatively small number of the sensors. For example, if there<br>was only one sensor on one side of the first bisection, then half of<br>the events would be mapped to this sensor if the events were uni-<br>formly distributed over the range of possible events. Due to their<br>storage constraints, the presence of a storage hot-spot leads to in-<br>creasing the dropping rate of events by overloaded sensors. Clearly,<br>this has a significant impact on the quality of data (QoD) generated<br>by the sensor network. Queries for events in a storage hot-spot may<br>be delayed due to contention at the storage sensors and the sur-<br>rounding sensors. More critically, the sensors in and near the hot-<br>spot may quickly run out of energy, due to the high insertion/query<br>load imposed to them. This results in a loss of the events generated<br>at these sensors, the events stored at these sensors, and possibly a<br>decrease in network connectivity. Increased death of sensors results<br>in decreasing the coverage area and causes the formation of cover-<br>age gaps within such area. Both of which consequently decrease<br>QoD. Certainly, it is not desirable to have a storage scheme whose<br>performance and QoD guarantees rest on the assumption that the<br>sensors are uniformly distributed geographically.</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:94"><nobr><span class="ft4">Storage hot-spots may also occur in DIM if the distribution of</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:81"><nobr><span class="ft8">events is not uniform over the range of possible events. It is difficult<br>to imagine any reasonable scenario where the events are uniformly<br>distributed over the range of all possible events. Consider the sit-<br>uation where the only attribute sensed is temperature. One would<br>expect that most temperature readings would be clustered within a<br>relatively small range rather than uniform over all possible temper-<br>atures. Without any load balancing, those sensors responsible for<br>temperatures outside this range would store no events.</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:94"><nobr><span class="ft4">In this paper, we provide a load-balanced INDCS scheme based</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:81"><nobr><span class="ft8">on K-D trees, that we, not surprisingly, call K-D tree based DCS<br>(KDDCS). In our KDDCS scheme, the refinement of regions in the<br>formation of the K-D tree has the property that the numbers of sen-<br>sors on both sides of the partition are approximately equal. As a<br>result of this, our K-D tree will be balanced, there will be no or-<br>phan regions, and, regardless of the geographic distribution of the<br>sensors, the ownership of events will uniformly distributed over<br>the sensors if the events are uniformly distributed over the range<br>of possible events. We present a modification of GPSR routing,<br>namely Logical Stateless Routing (LSR), for the routing of events<br>from their generating sensors to their owner sensors, that is com-<br>petitive with the GPSR routing used in DIM. In order to maintain<br>load balance in the likely situation that the events are not uniformly<br>distributed, we present a re-balancing algorithm that we call K-D<br>Tree Re-balancing (KDTR). Our re-balancing algorithm guarantees<br>load balance even if the event distribution is not uniform. KDTR<br>has essentially minimal overhead. We identify a problem, that we<br>call the weighted split median problem, that is at the heart of both<br>the construction of the initial K-D tree, and the re-balancing of the</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">K-D tree. In the weighted split median problem, each sensor has an<br>associated weight/multiplicity, and the sensors' goal is to distribu-<br>tively determine a vertical line with the property that the aggregate<br>weight on each side of the line is approximately equal. We give a<br>distributed algorithm for the weighted split median problem, and<br>show how to use this algorithm to construct our initial K-D tree,<br>and to re-balance the tree throughout the network lifetime.</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:489"><nobr><span class="ft4">We are mindful of the time, message complexity, and node stor-</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:475"><nobr><span class="ft8">age requirements, in the design and implementation of all of our<br>algorithms. The time for all of our algorithms is within a poly-log<br>factor of the diameter of the network. Obviously, no algorithm can<br>have time complexity less than the diameter of the network. The<br>number of messages, and number of bits in those messages, that<br>any particular node is required to send by our algorithms is poly-<br>logarithmic in number of sensors. The amount of information that<br>each node must store to implement one of our algorithms is loga-<br>rithmic in the number of sensors.</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:489"><nobr><span class="ft4">Experimental evaluation shows that the main advantages of KD-</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:475"><nobr><span class="ft4">DCS, when compared to the pure DIM, are:</span></nobr></DIV>
<DIV style="position:absolute;top:393;left:495"><nobr><span class="ft4">· Achieving a better data persistence by balancing the storage</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:509"><nobr><span class="ft4">responsibility among sensor nodes.</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:495"><nobr><span class="ft4">· Increasing the QoD by distributing the storage hot-spot events</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:509"><nobr><span class="ft4">among a larger number of sensors.</span></nobr></DIV>
<DIV style="position:absolute;top:462;left:495"><nobr><span class="ft4">· Increasing the energy savings by achieving a well balanced</span></nobr></DIV>
<DIV style="position:absolute;top:481;left:509"><nobr><span class="ft4">energy consumption overhead among sensor nodes.</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:489"><nobr><span class="ft4">The rest of the paper is organized as follows. Section 2 presents</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:475"><nobr><span class="ft8">an overview of the differences between DIM and KDDCS. Section<br>3 describes the weighted split median problem, and our distributed<br>solution. Section 4 describes the components of KDDCS. Section 5<br>presents our K-D tree re-balancing algorithm. Experimental results<br>are discussed in Section 6. Section 7 presents the related work.</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:475"><nobr><span class="ft2">2.</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:507"><nobr><span class="ft2">OVERVIEW OF DIM VS. KDDCS</span></nobr></DIV>
<DIV style="position:absolute;top:644;left:489"><nobr><span class="ft4">In this section, we will briefly describe the components of both</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:475"><nobr><span class="ft8">schemes, DIM and KDDCS, and highlight the differences between<br>the two schemes using a simple example.</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:489"><nobr><span class="ft4">We assume that the sensors are arbitrarily deployed in the con-</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:475"><nobr><span class="ft8">vex bounded region R. We assume also that each sensor is able to<br>determine its geographic location (i.e., its x and y coordinates), as<br>well as, the boundaries of the service area R. Each node is assumed<br>to have a unique NodeID, like a MAC address. Sensor nodes are<br>assumed to have the capacity for wireless communication, basic<br>processing and storage, and they are associated with the standard<br>energy limitations.</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:489"><nobr><span class="ft4">The main components of any DCS scheme are: the sensor to</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:475"><nobr><span class="ft8">address mapping that gives a logical address to each sensor, and<br>the event to owner-sensor mapping that determines which sensor<br>will store the event. The components of DIM and KDDCS are:</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:495"><nobr><span class="ft4">· Repetitive splitting of the geographic region to form the un-</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:509"><nobr><span class="ft4">derlying K-D tree, and the logical sensor addresses.</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:495"><nobr><span class="ft4">· Repetitive splitting of the attribute ranges to form the bit-</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:509"><nobr><span class="ft4">code for an event.</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:495"><nobr><span class="ft4">· The routing scheme to route an event from the generating</span></nobr></DIV>
<DIV style="position:absolute;top:976;left:509"><nobr><span class="ft4">sensor to the owner sensor.</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:475"><nobr><span class="ft4">We now explain how DIM implements these components.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:489"><nobr><span class="ft4">Let us start with the formation of the K-D tree in DIM. DIM</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:475"><nobr><span class="ft8">starts the network operation with a static node to bit-code mapping<br>phase. In such phase, each sensor locally determines its binary<br>address by uniformly splitting the overall service area in a round</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">318</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft10{font-size:5px;font-family:Times;color:#000000;}
	.ft11{font-size:15px;line-height:20px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="120003.png" alt="background image">
<DIV style="position:absolute;top:211;left:148"><nobr><span class="ft4">Figure 1: Initial network configuration</span></nobr></DIV>
<DIV style="position:absolute;top:374;left:191"><nobr><span class="ft4">Figure 2: DIM K-D tree</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:81"><nobr><span class="ft8">robin fashion, horizontally then vertically, and left shifting its bit-<br>code with every split by 0 (or 1) bit when falling above (or below)<br>the horizontal split line (similarly, by a 0 bit if falling on the left<br>of the vertical split line, or a 1 bit otherwise). Considering the<br>region as partitioned into zones, the process ends when every sensor<br>lies by itself in a zone, such that the sensor address is the zone bit<br>code. Thus, the length of the binary address of each sensor (in bits)<br>represents its depth in the underlying K-D tree. Note that from<br>a sensor address, one can determine the physical location of the<br>sensor. In case any orphan zones exist (zones physically containing<br>no sensors in their geographic area), the ownership of each of these<br>zones is delegated to one of its neighbor sensors. As an example,<br>consider the simple input shown in Figure 1. The K-D tree formed<br>by DIM is shown in Figure 2. In this figure, the orphan zone (01)<br>is assumed to be delegated to node 001, which is the least loaded<br>among its neighbors.</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:94"><nobr><span class="ft4">We now turn to the construction of an event bit-code in DIM.</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:81"><nobr><span class="ft8">The generation of the event bit-code proceeds in rounds. As we<br>proceed, there is a range R</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:226"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:236"><nobr><span class="ft4">associated with each attribute j of the</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:81"><nobr><span class="ft4">event. Initially, the range R</span></nobr></DIV>
<DIV style="position:absolute;top:708;left:229"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:238"><nobr><span class="ft4">is the full range of possible values for</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:81"><nobr><span class="ft8">attribute j. We now describe how a round i  0 works. Round i,<br>determines the (i+1)</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:195"><nobr><span class="ft1">th</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:210"><nobr><span class="ft4">high order bit in the code. Round i depends</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:81"><nobr><span class="ft8">on attribute j = i mod k of the event, where k is the number of<br>attributes in the event. Assume the current value of R</span></nobr></DIV>
<DIV style="position:absolute;top:771;left:365"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:374"><nobr><span class="ft4">is [a, c], and</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:81"><nobr><span class="ft4">let b = (a + c)/2 be the midpoint of the range R</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:349"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:355"><nobr><span class="ft4">. If the value of</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:81"><nobr><span class="ft4">attribute j is in the lower half of the range R</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:320"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:326"><nobr><span class="ft4">, that is in [a, b], then</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:81"><nobr><span class="ft4">the i</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:105"><nobr><span class="ft1">th</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:120"><nobr><span class="ft4">bit is 0, and R</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:195"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:204"><nobr><span class="ft4">is set to be the lower half of R</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:366"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:372"><nobr><span class="ft4">. If the value</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:81"><nobr><span class="ft4">of attribute j is in the upper half of the range R</span></nobr></DIV>
<DIV style="position:absolute;top:834;left:345"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:350"><nobr><span class="ft4">, that is in [b, c],</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:81"><nobr><span class="ft4">then the i</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:132"><nobr><span class="ft1">th</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:147"><nobr><span class="ft4">bit is 1, and R</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:224"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:233"><nobr><span class="ft4">is set to be the upper half of R</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:396"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:402"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:94"><nobr><span class="ft4">To show the events to bit-code mapping in DIM, consider that</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:81"><nobr><span class="ft8">the events in our example (shown in Figure 2) are composed of<br>two attributes, temperature and pressure, with ranges (30, 70) and<br>(0, 2), respectively. Let an event with values (55, 0.6) be generated<br>by Node N3(11). The 4 high-order bits of the bit-code for this<br>event are 1001. This is because temperature is in the top half of<br>the range [30, 70], pressure is in the bottom half of the range [0, 2],<br>then temperature is in the bottom half of the range [50, 70], and<br>pressure is in the top half of the range [0, 1]. Thus, the event should<br>be routed toward the geometric location specified by code 1001.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:94"><nobr><span class="ft4">In DIM, an event is routed using Greedy Perimeter Stateless</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft8">Routing (GPSR) [6] to the geographic zone with an address match-<br>ing the high order bits of the event bit-code. In our example, the<br>sensor 10 will store this event since this is the sensor that matches</span></nobr></DIV>
<DIV style="position:absolute;top:236;left:576"><nobr><span class="ft4">Figure 3: KDDCS K-D tree</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:475"><nobr><span class="ft8">the high order bits of the bit-code 1001. If there is no sensor in this<br>region, then, the event is stored in a neighboring region.</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:489"><nobr><span class="ft4">We now highlight the differences between our proposed KDDCS</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:475"><nobr><span class="ft8">scheme, and DIM. The first difference is how the splitting is accom-<br>plished during the formation of the K-D tree. In KDDCS, the split<br>line is chosen so that there are equal numbers of sensors on each<br>side of the split line. Recall that, in DIM, the split line was the ge-<br>ometric bisector of the region. Thus, in KDDCS, the address of a<br>sensor is a logical address and does not directly specify the location<br>of the sensor. Also, note that the K-D tree in KDDCS will be bal-<br>anced, while this will not be the case in DIM if the sensors are not<br>uniformly distributed. This difference is illustrated by the K-D tree<br>formed by KDDCS shown in Figure 3 for the same simple input<br>shown in Figure 1. The second difference is that in determining the<br>owner sensor for an event, the range split point b need not be the<br>midpoint of the range R</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:606"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:611"><nobr><span class="ft4">. The value of b is selected to balance the</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:475"><nobr><span class="ft8">number of events in the ranges [a, b] and [b, c]. Thus, in KDDCS,<br>the storage of events will be roughly uniform over the sensors. The<br>third difference is that, since addresses are not geographic, KDDCS<br>needs a routing scheme that is more sophisticated than GPSR.</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:475"><nobr><span class="ft2">3.</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:507"><nobr><span class="ft11">THE WEIGHTED SPLIT MEDIAN<br>PROBLEM</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:489"><nobr><span class="ft4">Before presenting our KDDCS scheme, we first define the weighted</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:475"><nobr><span class="ft8">split median problem in the context of sensor networks and present<br>an efficient distributed algorithm to solve the problem. Each sen-<br>sor s</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:502"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:511"><nobr><span class="ft4">initially knows w</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:606"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:615"><nobr><span class="ft4">associated values v</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:720"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:726"><nobr><span class="ft4">, . . . v</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:757"><nobr><span class="ft1">w</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:765"><nobr><span class="ft10">i</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:770"><nobr><span class="ft4">. Let W =</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:475"><nobr><span class="ft4">P</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:490"><nobr><span class="ft1">n</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:490"><nobr><span class="ft1">i=1</span></nobr></DIV>
<DIV style="position:absolute;top:701;left:511"><nobr><span class="ft4">w</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:521"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:701;left:530"><nobr><span class="ft4">be the number of values. The goal for the sensors is to</span></nobr></DIV>
<DIV style="position:absolute;top:717;left:475"><nobr><span class="ft8">come to agreement on a split value V with the property that approx-<br>imately half of the values are larger than V and half of the values<br>are smaller than V .</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:489"><nobr><span class="ft4">We present a distributed algorithm to solve this problem. The</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:475"><nobr><span class="ft8">time complexity of our algorithm is O(log n) times the diameter of<br>the communication network in general, and O(1) times the diam-<br>eter if n is known a priori within a constant factor. Each node is<br>required to send only O(log n) sensor ID's. The top level steps of<br>this algorithm are:</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:492"><nobr><span class="ft4">1. Elect a leader sensor s , and form a breadth first search (BFS)</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:509"><nobr><span class="ft4">tree T of the communication network that is rooted at s .</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:492"><nobr><span class="ft4">2. The number of sensors n, and the aggregate number of values</span></nobr></DIV>
<DIV style="position:absolute;top:918;left:509"><nobr><span class="ft4">W is reported to s .</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:492"><nobr><span class="ft4">3. The leader s collects a logarithmically-sized uniform ran-</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:509"><nobr><span class="ft8">dom sample L of the values. The expected number of times<br>that a value from sensor s</span></nobr></DIV>
<DIV style="position:absolute;top:970;left:648"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:656"><nobr><span class="ft4">is included in this sample is</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:509"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:969;left:522"><nobr><span class="ft4">"</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:532"><nobr><span class="ft1">w</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:540"><nobr><span class="ft10">i</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:546"><nobr><span class="ft1">log n</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:545"><nobr><span class="ft1">W</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:571"><nobr><span class="ft4">"</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:580"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:492"><nobr><span class="ft4">4. The value of V is then the median of the reported values in</span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:509"><nobr><span class="ft4">L, which s reports to all of the sensors.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:475"><nobr><span class="ft8">We need to explain how these steps are accomplished, and why the<br>algorithm is correct.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">319</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft12{font-size:15px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="120004.png" alt="background image">
<DIV style="position:absolute;top:86;left:94"><nobr><span class="ft4">We start with the first step. We assume that each sensor has a</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:81"><nobr><span class="ft8">lower bound k on the number of sensors in R. If a sensor has no<br>idea of the number of other sensors, it may take k = 2.</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:94"><nobr><span class="ft4">Then, each sensor decides independently, with probability  `</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:426"><nobr><span class="ft1">ln k</span></nobr></DIV>
<DIV style="position:absolute;top:139;left:431"><nobr><span class="ft1">k</span></nobr></DIV>
<DIV style="position:absolute;top:119;left:445"><nobr><span class="ft4">´,</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:81"><nobr><span class="ft4">to become a candidate for the leader. Each candidate sensor s</span></nobr></DIV>
<DIV style="position:absolute;top:151;left:411"><nobr><span class="ft1">c</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:421"><nobr><span class="ft4">ini-</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:81"><nobr><span class="ft8">tiates the construction of a BFS tree of the communication graph<br>rooted at s</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:140"><nobr><span class="ft1">c</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:149"><nobr><span class="ft4">by sending a message Construct(s</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:336"><nobr><span class="ft1">c</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:342"><nobr><span class="ft4">)</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:351"><nobr><span class="ft4">to its neighbors.</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:81"><nobr><span class="ft4">Assume a sensor s</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:183"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:192"><nobr><span class="ft4">gets a message Construct(s</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:341"><nobr><span class="ft1">c</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:346"><nobr><span class="ft4">) from sensor s</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:430"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:436"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:81"><nobr><span class="ft4">If this is the first Construct(s</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:242"><nobr><span class="ft1">c</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:248"><nobr><span class="ft4">) message that it has received, and</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:81"><nobr><span class="ft4">s</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:87"><nobr><span class="ft1">c</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:93"><nobr><span class="ft4">'s ID is larger than the ID of any previous candidates in prior</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:81"><nobr><span class="ft4">Construct messages, then:</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:101"><nobr><span class="ft4">· s</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:121"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:129"><nobr><span class="ft4">makes s</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:173"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:182"><nobr><span class="ft4">its tentative parent in the BFS tree T , and</span></nobr></DIV>
<DIV style="position:absolute;top:279;left:101"><nobr><span class="ft4">· forwards the Construct(s</span></nobr></DIV>
<DIV style="position:absolute;top:285;left:248"><nobr><span class="ft1">c</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:254"><nobr><span class="ft4">) message to its neighbors.</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:94"><nobr><span class="ft4">If the number of candidates was positive, then, after time pro-</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:81"><nobr><span class="ft8">portional to the diameter of the communication network, there will<br>be a BFS tree T rooted at the candidate with the largest ID. Each<br>sensor may estimate an upper bound for the diameter of the com-<br>munication graph to be the diameter of R divided by the broadcast<br>radius of a sensor. After this time, the sensors know that they have<br>reached an agreement on T , or that there were no candidates. If<br>there were no candidates, each sensor can double its estimate of<br>k, and repeat this process. After O(log n) rounds, it will be the<br>case that k = (n). Once k = (n), then, with high probability<br>(that is, with probability 1</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:231"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:264"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:248"><nobr><span class="ft1">poly(n)</span></nobr></DIV>
<DIV style="position:absolute;top:462;left:286"><nobr><span class="ft4">), the number of candidates</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:81"><nobr><span class="ft8">is (log n). Thus, the expected time complexity to accomplish<br>the first step is O(n log n). Assuming that each ID has O(log n)<br>bits, the expected number of bits that each sensors has to send is<br>O(log</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:115"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:123"><nobr><span class="ft4">n) since there are are likely only O(log n) candidates on</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:81"><nobr><span class="ft8">the first and only round in which there is a candidate. A log n fac-<br>tor can be removed if each sensor initially knows an estimate of n<br>that is accurate to within a multiplicative constant factor.</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:94"><nobr><span class="ft4">The rest of the steps will be accomplished by waves of root-to-</span></nobr></DIV>
<DIV style="position:absolute;top:606;left:81"><nobr><span class="ft8">leaves and leaves-to-root messages in T . The second step is easily<br>accomplished by a leave-to-root wave of messages reporting on the<br>number of sensors and number of values in each subtree. Let T</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:418"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:427"><nobr><span class="ft4">be</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:81"><nobr><span class="ft4">the subtree of T rooted at sensor s</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:267"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:271"><nobr><span class="ft4">, and W</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:314"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:323"><nobr><span class="ft4">the aggregate number</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:81"><nobr><span class="ft4">of values in T</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:158"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:162"><nobr><span class="ft4">. The value W</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:245"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:254"><nobr><span class="ft4">that s</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:285"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:294"><nobr><span class="ft4">reports to its parents is w</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:435"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:684;left:81"><nobr><span class="ft4">plus the aggregate values reported to s</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:292"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:684;left:301"><nobr><span class="ft4">by its children in T . The</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:81"><nobr><span class="ft4">sensor count that s</span></nobr></DIV>
<DIV style="position:absolute;top:702;left:187"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:197"><nobr><span class="ft4">reports to its parents is one plus the sensor</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:81"><nobr><span class="ft4">counts reported to s</span></nobr></DIV>
<DIV style="position:absolute;top:718;left:188"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:196"><nobr><span class="ft4">by its children in T .</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:94"><nobr><span class="ft4">The third step is also accomplished by a root-to-leaves wave and</span></nobr></DIV>
<DIV style="position:absolute;top:747;left:81"><nobr><span class="ft4">then a leaves-to-root wave of messages. Assume a sensor s</span></nobr></DIV>
<DIV style="position:absolute;top:749;left:400"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:747;left:408"><nobr><span class="ft4">wants</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:81"><nobr><span class="ft4">to generate a uniform random sample of L</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:320"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:330"><nobr><span class="ft4">of the values stored</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:81"><nobr><span class="ft4">in the sensors in T</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:184"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:189"><nobr><span class="ft4">. The value of L for the leader is (log n).</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:81"><nobr><span class="ft4">Let s</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:109"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:113"><nobr><span class="ft10">1</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:120"><nobr><span class="ft4">, . . . , s</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:157"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:161"><nobr><span class="ft10">d</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:172"><nobr><span class="ft4">be the children of s</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:278"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:287"><nobr><span class="ft4">in T . Node s</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:360"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:368"><nobr><span class="ft4">generates the</span></nobr></DIV>
<DIV style="position:absolute;top:810;left:81"><nobr><span class="ft4">results to L</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:143"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:810;left:152"><nobr><span class="ft4">Bernoulli trials, where each trial has d + 1 outcomes</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:81"><nobr><span class="ft4">corresponding to s</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:185"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:195"><nobr><span class="ft4">and its d children. The probability that the</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:81"><nobr><span class="ft4">outcome of a trial is s</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:198"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:207"><nobr><span class="ft4">is</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:222"><nobr><span class="ft1">w</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:230"><nobr><span class="ft10">i</span></nobr></DIV>
<DIV style="position:absolute;top:846;left:221"><nobr><span class="ft1">W</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:231"><nobr><span class="ft10">i</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:238"><nobr><span class="ft4">, and the probability that the outcome</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:81"><nobr><span class="ft4">is the child s</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:149"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:153"><nobr><span class="ft10">j</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:162"><nobr><span class="ft4">is</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:176"><nobr><span class="ft1">w</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:184"><nobr><span class="ft10">ij</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:178"><nobr><span class="ft1">W</span></nobr></DIV>
<DIV style="position:absolute;top:873;left:188"><nobr><span class="ft10">i</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:197"><nobr><span class="ft4">. Then, s</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:244"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:252"><nobr><span class="ft4">informs each child s</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:362"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:366"><nobr><span class="ft10">j</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:375"><nobr><span class="ft4">how often it</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:81"><nobr><span class="ft4">was selected, which becomes the value of L</span></nobr></DIV>
<DIV style="position:absolute;top:881;left:314"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:318"><nobr><span class="ft10">j</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:325"><nobr><span class="ft4">·s</span></nobr></DIV>
<DIV style="position:absolute;top:881;left:337"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:341"><nobr><span class="ft4">, then waits until it</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:81"><nobr><span class="ft4">receives samples back from all of its children. s</span></nobr></DIV>
<DIV style="position:absolute;top:896;left:338"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:346"><nobr><span class="ft4">then unions these</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:81"><nobr><span class="ft8">samples, plus a sample of values of the desired size from itself, and<br>then passes that sample back to its parent. Thus, each sensor has to<br>send O(log n) ID's.</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:94"><nobr><span class="ft4">The leader s then sets V to be the median of the values of the</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:81"><nobr><span class="ft8">sample L, then, in a root-to-leaves message wave, informs the other<br>sensors of the value of V .</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:94"><nobr><span class="ft4">We now argue that, with high probability, the computed median</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft4">of the values is close to the true median. Consider a value ^</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:400"><nobr><span class="ft4">V such</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft4">that only a fraction  &lt;</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:229"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:229"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:241"><nobr><span class="ft4">of the values are less than ^</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:393"><nobr><span class="ft4">V . One</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft8">can think of each sampled value as being a Bernoulli trial with out-<br>comes less and more depending on whether the sampled value is</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:517"><nobr><span class="ft4">Figure 4: Logical address assignment algorithm</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:475"><nobr><span class="ft4">less than ^</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:525"><nobr><span class="ft4">V . The number of less outcomes is binomially distributed</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:475"><nobr><span class="ft4">with mean L. In order for the computed median to be less than</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:477"><nobr><span class="ft4">^</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:475"><nobr><span class="ft8">V , one needs the number of less outcomes to be at least L/2, or<br>equivalently (</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:551"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:551"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:560"><nobr><span class="ft4">-)L more than the mean L. But the probability</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:475"><nobr><span class="ft4">that a binomially distributed variable exceeds its mean  by a factor</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:475"><nobr><span class="ft4">of 1 +  is at most e</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:584"><nobr><span class="ft10">-2</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:594"><nobr><span class="ft10">3</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:612"><nobr><span class="ft4">. Thus, by picking the multiplicative con-</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:475"><nobr><span class="ft8">stant in the sample size to be sufficiently large (as a function of ),<br>one can guarantee that, with high probability, the number of values<br>less than the computed median V cannot be much more than L/2.<br>A similar argument shows that the number more than the computed<br>median V can not be much more than L/2.</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:489"><nobr><span class="ft4">If the leader finds that n is small in step 2, it may simply ask all</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:475"><nobr><span class="ft8">sensors to report on their identities and locations, and then compute<br>V directly.</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:489"><nobr><span class="ft4">Now that we solved the weighted split median problem, we present</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:475"><nobr><span class="ft4">the components of the KDDCS scheme in the next section.</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:475"><nobr><span class="ft2">4.</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:507"><nobr><span class="ft2">KDDCS</span></nobr></DIV>
<DIV style="position:absolute;top:610;left:489"><nobr><span class="ft4">We now present our KDDCS scheme in details. We explain how</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:475"><nobr><span class="ft8">the initial K-D tree is constructed, how events are mapped to sen-<br>sors, and how events are routed to their owner sensors.</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:475"><nobr><span class="ft2">4.1</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:516"><nobr><span class="ft12">Distributed Logical Address Assignment<br>Algorithm</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:489"><nobr><span class="ft4">The main idea of the algorithm is that the split lines used to con-</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:475"><nobr><span class="ft8">struct the K-D tree are selected so that each of the two resulting<br>regions contain an equal number of sensors. The split line can be<br>determined using our weighted split median algorithm with each<br>sensor having unit weight, and the value for each sensor is either<br>its x coordinate or its y coordinate. The recursive steps of the al-<br>gorithm are shown in Figure 4. We now describe in some greater<br>detail how a recursive step works.</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:489"><nobr><span class="ft4">The algorithm starts by partitioning the complete region R hor-</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:475"><nobr><span class="ft8">izontally. Thus, the distributed weighted split median algorithm<br>(presented in section 3) is applied for R using the y-coordinates of<br>the sensors to be sent to the BFS root. Upon determining weighted<br>split median of R, sensors having lower y-coordinate than the me-<br>dian value (we refer to these sensors as those falling in the lower<br>region of R) assign their logical address to 0. On the other hand,<br>those sensor falling on the upper region of R assign themselves a 1<br>logical address. At the end of the first recursive step, the terrain can<br>be looked at as split into two equally logically loaded partitions (in<br>terms of the number of sensors falling in each partition).</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:489"><nobr><span class="ft4">At the next step, the weighted split median algorithm is applied</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:475"><nobr><span class="ft8">locally in each of the sub-regions (lower/upper), while using the<br>sensors' x-coordinates, thus, partitioning the sub-regions vertically<br>rather than horizontally. Similarly, sensors' logical addresses are<br>updated by left-shifting them with a 0 bit for those sensors falling</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">320</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft13{font-size:11px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="120005.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">in the lower regions (in other words, sensor nodes falling on the<br>left of the weighted median line), or with a 1 bit for sensor nodes<br>falling in the upper regions (i.e., sensor nodes falling on the right<br>of the weighted median line).</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:94"><nobr><span class="ft4">The algorithm continues to be applied distributively by the dif-</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:81"><nobr><span class="ft8">ferent subtrees until each sensor obtains a unique logical address,<br>using x and y coordinates of sensors, in a round robin fashion, as<br>the criterion of the split. The algorithm is applied in parallel on<br>the different subtrees whose root nodes fall at the same tree level.<br>At the i</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:121"><nobr><span class="ft1">th</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:135"><nobr><span class="ft4">recursive step, the algorithm is applied at all intermediate</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:81"><nobr><span class="ft8">nodes falling at level i- 1 of the tree. Based on the definition of the<br>weighted split median problem, the algorithm results in forming a<br>balanced binary tree, such that sensors represent leaf nodes of this<br>tree (intermediate nodes of the tree are logical nodes, not physical<br>sensors). The algorithm terminates in log n recursive steps. At the<br>end of the algorithm, the size of the logical address given to each<br>sensor will be log n bits.</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:94"><nobr><span class="ft4">Recall that the time complexity of our weight split median algo-</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:81"><nobr><span class="ft8">rithm is O(d log n), where d is the diameter of the region. Thus,<br>as the depth of our K-D tree is O(log n), we get that the time com-<br>plexity for building the tree is O(d log</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:290"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:298"><nobr><span class="ft4">n). If the sensors are uni-</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:81"><nobr><span class="ft8">formly distributed, then, as the construction algorithm recurses, the<br>diameters of the regions will be geometrically decreasing. Thus,<br>in the case of uniformly distributed sensors, one would expect the<br>tree construction to take time O(d log n). As our weighted split<br>median algorithm requires each sensor to send O(log n) ID's, and<br>our K-D tree has depth O(log n), we can conclude that during the<br>construction of our K-D tree, the number of ID's sent by any node<br>is O(log</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:127"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:136"><nobr><span class="ft4">n).</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:81"><nobr><span class="ft2">4.2</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:121"><nobr><span class="ft2">Event to Bit-code Mapping</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:94"><nobr><span class="ft4">In this section, we explain how the event to bit-code mapping</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:81"><nobr><span class="ft8">function is determined. Recall that the main idea is to set the split<br>points of the ranges so that the storage of events is roughly uniform<br>among sensor nodes. To construct this mapping requires a proba-<br>bility distribution on the events. In some situations, this distribution<br>might be known. For example, if the network has been operational<br>for some period of time, a sampling of prior events might be used<br>to estimate a distribution. In cases where it is not known, say when<br>a network is first deployed, we can temporarily assume a uniform<br>distribution.</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:94"><nobr><span class="ft4">In both cases, we use the balanced binary tree as the base tree</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:81"><nobr><span class="ft8">to overlay the attribute-specific K-D tree on (Recall that a K-D tree<br>is formed by k attributes). This is basically done by assigning a<br>range for each of the k attributes to every intermediate node in the<br>tree. Note that the non-leaf nodes in the K-D tree are logical nodes<br>that do not correspond to any particular sensor. One may think of<br>non-leaf nodes as regions. Any split point p of a node x of tree<br>level l, where l%k = i, represents a value of attribute i. Such split<br>point partitions the range of attribute i falling under responsibility<br>of node x into two subranges such that the the subrange lower than<br>p is assigned to the left child of x, while the other range is assigned<br>to x's right child. Note that the other k - 1 ranges of node x,<br>corresponding to the remaining k-1 attributes, are simply inherited<br>by both children of x.</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:94"><nobr><span class="ft4">Knowing the data distribution, the split points of the tree should</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:81"><nobr><span class="ft8">be predefined in a way to cope with any expected irregularity in<br>the load distribution among the K-D tree leaf nodes. For example,<br>given an initial temperature range (30, 70) and knowing that 50%<br>of the events will fall in the temperature range (65, 70), the root<br>split point should be defined as 65 (assuming that the temperature<br>is the first attribute in the event). Therefore, based on the selected<br>root split point, the left child subtree of the root will be respon-</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">sible of storing events falling in the temperature range (30, 65),<br>while the right child subtree will store events falling in the range<br>(65, 70). Figure 3 gives an example of non-uniform initialization<br>of split points.</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:489"><nobr><span class="ft4">We finish by describing what information is stored in each sensor</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:475"><nobr><span class="ft8">node. Each sensor node corresponds to a leaf in the K-D tree. Each<br>sensor knows its logical address in the tree. Further, each leaf in<br>the K-D tree knows all the pertinent information about each of its<br>ancestors in the tree. The pertinent information about each node is:</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:495"><nobr><span class="ft13">· The geographic region covered.<br>· The split line separating its two children.<br>· The attribute range, and attribute split point, associated with</span></nobr></DIV>
<DIV style="position:absolute;top:288;left:509"><nobr><span class="ft4">this region.</span></nobr></DIV>
<DIV style="position:absolute;top:314;left:475"><nobr><span class="ft8">From this information, each leaf/sensor can determine the range of<br>events that will be stored at this sensor. Note that each sensor only<br>stores O(log n) information about the K-D tree.</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:475"><nobr><span class="ft2">4.3</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:516"><nobr><span class="ft2">Incremental Event Hashing and Routing</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:489"><nobr><span class="ft4">Strictly speaking, the events-to-sensors mapping in DIM actually</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:475"><nobr><span class="ft8">produces a geographic location. GPSR routing can then be used to<br>route that event towards that geographic location. If the destination<br>is contained in a leaf region with one sensor, then that sensor stores<br>the event. If the leaf region is an orphan, then one of the sensors in<br>the neighboring regions will store this event.</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:489"><nobr><span class="ft4">In our scheme, the events-to-sensors mapping provides a logical</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:475"><nobr><span class="ft8">address. Essentially, all that the sensor generating the event can<br>determine from this logical address is a general direction of the<br>owner sensor. Thus, our routing protocol, which we call Logical<br>Stateless Routing (LSR), is in some sense less direct.</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:489"><nobr><span class="ft4">LSR operates in O(log n) rounds. We explain how a round</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:475"><nobr><span class="ft8">works. Assume that a source sensor with a logical address s wants<br>to route an event e to a sensor with logical address t. However,<br>s does not know the identity of the sensor t. Recall that s knows<br>the pertinent information about its ancestors in the K-D tree. In<br>particular, s knows the range split values of its ancestors. Thus, s<br>can compute the least common ancestor (LCA) of s and t in the<br>K-D tree. Assume that the first bit of disagreement between s and<br>t is the</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:525"><nobr><span class="ft1">th</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:540"><nobr><span class="ft4">bit. So, the least common ancestor (LCA) of s and t</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:475"><nobr><span class="ft8">in the K-D tree has depth . Let R be the region corresponding to<br>the LCA of s and t, L the split line corresponding to this region,<br>and R</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:510"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:521"><nobr><span class="ft4">and R</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:555"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:567"><nobr><span class="ft4">the two subregions of R formed by L. Without</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:475"><nobr><span class="ft4">loss of generality, assume that s  R</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:679"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:689"><nobr><span class="ft4">and t  R</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:746"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:752"><nobr><span class="ft4">. From its own</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:475"><nobr><span class="ft8">address, and the address of t, the sensor s can conclude that t is in<br>the region R</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:544"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:550"><nobr><span class="ft4">. Recall that s knows the location of the split line L.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:475"><nobr><span class="ft4">The sensor s computes a location x in the region R</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:748"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:755"><nobr><span class="ft4">. For concrete-</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:475"><nobr><span class="ft4">ness here, let us assume that x is some point in R</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:744"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:754"><nobr><span class="ft4">that lies on the</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:475"><nobr><span class="ft8">line intersecting s and perpendicular to L (Although there might be<br>some advantages to selecting x to be the geometric center of the re-<br>gion R</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:513"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:519"><nobr><span class="ft4">). LSR then directs a message toward the location x using</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:475"><nobr><span class="ft8">GPSR. The message contains an additional field noting that this is<br>a</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:490"><nobr><span class="ft1">th</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:505"><nobr><span class="ft4">round message. The</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:624"><nobr><span class="ft1">th</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:639"><nobr><span class="ft4">round terminates when this message</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:475"><nobr><span class="ft8">first reaches a sensor s whose address agrees with the address of t<br>in the first + 1 bits. The sensor s will be the first sensor reached<br>in R</span></nobr></DIV>
<DIV style="position:absolute;top:943;left:499"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:505"><nobr><span class="ft4">. Round + 1 then starts with s being the new source sensor.</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:489"><nobr><span class="ft4">We explain how range queries are routed by means of an exam-</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:475"><nobr><span class="ft8">ple. This example also essentially illustrates how events are stored.<br>Figure 5 gives an example of a multi-dimensional range query and<br>shows how to route it to its final destination. In this example, a<br>multi-dimensional range query arises at node N 7(111) asking for<br>the number of events falling in the temperature range (30, 32) and<br>pressure range (0.4, 1) that were generated throughout the last 2<br>minutes. Node N 7 knows that the range split point for the root</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">321</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="120006.png" alt="background image">
<DIV style="position:absolute;top:245;left:119"><nobr><span class="ft4">Figure 5: Example of routing a query on KDDCS</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:81"><nobr><span class="ft8">was temperature 40, and thus, this query needs to be routed to-<br>ward the left subtree of the root, or geometrically toward the top<br>of the region, using GPSR. The first node in this region that this<br>event reaches is say N 3. Node N 3 knows that the first relevant<br>split point is pressure = 0.5. Thus, the query is partitioned into two<br>sub-queries, ((30, 32), (0.4, 0.5)) and ((30, 32), (0.5, 1)). When<br>processing the first subquery, node N 3 forwards it to the left using<br>GPSR. N 3 can then tell that the second query should be routed to<br>the other side of its parent in the K-D tree since the range split for<br>its parent is temperature 34. The logical routing of this query is<br>shown on the right in Figure 5, and a possible physical routing of<br>this query is shown on the left in Figure 5.</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:94"><nobr><span class="ft4">As LSR does not initially know the geometric location of the</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:81"><nobr><span class="ft8">owner sensor, the route to the owner sensor cannot possibly be as<br>direct as it is in DIM. But, we argue that the length of the route in<br>LSR should be at most twice the length of the route in DIM. As-<br>sume for the moment that all messages are routed by GPSR along<br>the direct geometric line between the source sensor and the destina-<br>tion location. Let us assume, without loss of generality, that LSR is<br>routing horizontally in the odd rounds. Then, the routes used in the<br>odd rounds do not cross any vertical line more than once. Hence,<br>the sum of the route distances used by LSR in the odd rounds is<br>at most the diameter of the region. Similarly, the sum of the route<br>distances used by LSR in the even rounds is at most the diameter of<br>the region. Thus, the sum of the route distances for LSR, over all<br>rounds, is at most twice the diameter. The geometric distance be-<br>tween the source-destination pair in DIM is obviously at most the<br>diameter. So we can conclude that the length of the route found by<br>LSR is at most twice the length of the route found by DIM, assum-<br>ing that GPSR is perfect. In fact, the only assumption that we need<br>about GPSR to reach this conclusion is that the length of the path<br>found by GPSR is roughly a constant multiple times the geomet-<br>ric distance between the source and destination. Even this factor<br>of two can probably be improved significantly in expectation if the<br>locations of the sensors are roughly uniform. A simple heuristic<br>would be to make the location of the target x equal to the location<br>of the destination sensor t if the sensors in R</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:318"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:327"><nobr><span class="ft4">where uniformly dis-</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:81"><nobr><span class="ft8">tributed. The location of x can easily be calculated by the source<br>sensor s given information local to s.</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:81"><nobr><span class="ft2">5.</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:112"><nobr><span class="ft11">KDTR: K-D TREE RE-BALANCING<br>ALGORITHM</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:94"><nobr><span class="ft4">Based on the KDDCS components presented so far, KDDCS</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:81"><nobr><span class="ft8">avoids the formation of storage hot-spots resulting from skewed<br>sensor deployments, and from skewed events distribution if the dis-<br>tribution of events was known a priori. However, storage hot-spots<br>may be formed if the initial presumed events distribution was not<br>correct, or if events distribution evolves over times. We present a<br>K-D tree re-balancing algorithm, KDTR, to re-balance the load.</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:94"><nobr><span class="ft4">In the next subsections, we first explain how to determine the</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">roots of the subtrees that will re-balance, and then show how a re-<br>balancing operation on a subtree works. We assume that this re-<br>balancing is performed periodically with a fixed period.</span></nobr></DIV>
<DIV style="position:absolute;top:146;left:475"><nobr><span class="ft2">5.1</span></nobr></DIV>
<DIV style="position:absolute;top:146;left:516"><nobr><span class="ft2">Selection of Subtrees to be Re-Balanced</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:489"><nobr><span class="ft4">The main idea is to find the highest unbalanced node in the K-</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:475"><nobr><span class="ft8">D tree. A node is unbalanced if the ratio of the number of events<br>in one of the child subtrees over the number of events stored in<br>the other child subtree exceeds some threshold h. This process of<br>identifying nodes to re-balance proceeds in O(log n) rounds from<br>the leaves to the root of the K-D tree.</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:489"><nobr><span class="ft4">We now describe how round i  1 works. Intuitively, round i</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:475"><nobr><span class="ft8">occurs in parallel on all subtrees rooted at nodes of height i + 1<br>in the K-D tree. Let x be a node of height i + 1. Let the region<br>associated with x be R, the split line be L, and the two subregions<br>of R be R</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:532"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:543"><nobr><span class="ft4">and R</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:577"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:583"><nobr><span class="ft4">. At the start of this round, each sensor in R</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:828"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:475"><nobr><span class="ft4">and R</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:509"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:519"><nobr><span class="ft4">knows the number of stored events C</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:725"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:735"><nobr><span class="ft4">and C</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:769"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:779"><nobr><span class="ft4">in R</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:804"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:814"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:475"><nobr><span class="ft4">R</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:486"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:492"><nobr><span class="ft4">, respectively. The count C</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:645"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:656"><nobr><span class="ft4">is then flooded to the sensors in</span></nobr></DIV>
<DIV style="position:absolute;top:373;left:475"><nobr><span class="ft4">R</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:486"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:373;left:492"><nobr><span class="ft4">, and the count C</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:589"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:373;left:600"><nobr><span class="ft4">is flooded to the sensors in R</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:764"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:373;left:770"><nobr><span class="ft4">. After this</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:475"><nobr><span class="ft8">flooding, each sensor in R knows the number of events stored in R,<br>and also knows whether the ratio max(</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:689"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:697"><nobr><span class="ft10">0</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:689"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:697"><nobr><span class="ft10">1</span></nobr></DIV>
<DIV style="position:absolute;top:404;left:704"><nobr><span class="ft4">,</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:712"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:720"><nobr><span class="ft10">1</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:712"><nobr><span class="ft1">C</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:720"><nobr><span class="ft10">0</span></nobr></DIV>
<DIV style="position:absolute;top:404;left:728"><nobr><span class="ft4">)</span></nobr></DIV>
<DIV style="position:absolute;top:404;left:736"><nobr><span class="ft4">exceeds h.</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:489"><nobr><span class="ft4">The time complexity per round is linear in the diameter of a re-</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:475"><nobr><span class="ft8">gion considered in that round. Thus, the total time complexity is<br>O(D log n), where D is the diameter of the network, as there are<br>O(log n) rounds. The number of messages sent per node i in a<br>round is O(d</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:547"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:552"><nobr><span class="ft4">)</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:557"><nobr><span class="ft4">, where d</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:608"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:617"><nobr><span class="ft4">is the degree of node i in the communi-</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:475"><nobr><span class="ft8">cation network. Thus, the total number of messages sent by a node<br>i is O(d</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:519"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:526"><nobr><span class="ft4">log n).</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:489"><nobr><span class="ft4">Re-Balancing is then performed in parallel on all unbalanced</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:475"><nobr><span class="ft8">nodes, that have no unbalanced ancestors. Note that every leaf<br>knows if an ancestor will re-balance, and is so, the identity of the<br>unique ancestor that will balance. All the leaves of a node that will<br>re-balance, will be aware of this at the same time.</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:475"><nobr><span class="ft2">5.2</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:516"><nobr><span class="ft2">Tree Re-balancing Algorithm</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:489"><nobr><span class="ft4">Let x be an internal node to the K-D tree that needs to be re-</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:475"><nobr><span class="ft8">balanced. Let the region associated with x be R. Let the attribute<br>associated with node x be the j'th attribute. So, we need to find a<br>new attribute split L for the j'th attribute for node x. To accom-<br>plish this, we apply the weighted split median procedure, where the<br>weight w</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:526"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:535"><nobr><span class="ft4">associated with sensor i is the number of events stored</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:475"><nobr><span class="ft4">at sensor i, and the values are the j'th attributes of the w</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:791"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:737;left:800"><nobr><span class="ft4">events</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:475"><nobr><span class="ft8">stored at that sensor. Thus, the computed attribute split L has the<br>property that, in expectation, half of the events stored in R have<br>their j'th attribute larger than L, and half of the events stored in R<br>have their j'th attribute smaller than L.</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:489"><nobr><span class="ft4">Let R</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:520"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:530"><nobr><span class="ft4">and R</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:563"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:572"><nobr><span class="ft4">be the two subregions of R. Eventually, we want</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:475"><nobr><span class="ft4">to recursively apply this process in parallel to the regions R</span></nobr></DIV>
<DIV style="position:absolute;top:834;left:804"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:814"><nobr><span class="ft4">and</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:475"><nobr><span class="ft4">R</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:486"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:492"><nobr><span class="ft4">. But before recursing, we need to route some events from one</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:475"><nobr><span class="ft4">of R</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:501"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:511"><nobr><span class="ft4">or R</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:536"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:547"><nobr><span class="ft4">to the other. The direction of the routing depends on</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:475"><nobr><span class="ft8">whether the attribute split value became larger or smaller. Let us<br>assume, without loss of generality, that events need to be routed<br>from R</span></nobr></DIV>
<DIV style="position:absolute;top:912;left:515"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:525"><nobr><span class="ft4">to R</span></nobr></DIV>
<DIV style="position:absolute;top:912;left:549"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:555"><nobr><span class="ft4">. Consider an event e stored at a sensor s in R</span></nobr></DIV>
<DIV style="position:absolute;top:912;left:804"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:814"><nobr><span class="ft4">that</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:475"><nobr><span class="ft4">needs to be routed to R</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:604"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:610"><nobr><span class="ft4">. The sensor s picks a destination logical</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:475"><nobr><span class="ft8">address t, uniformly at random, from the possible addresses in the<br>region R</span></nobr></DIV>
<DIV style="position:absolute;top:959;left:523"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:529"><nobr><span class="ft4">. The event e is then routed to t using the routing scheme</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:475"><nobr><span class="ft4">described in section 4.3. The final owner for e in R</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:769"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:780"><nobr><span class="ft4">cannot be</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:475"><nobr><span class="ft4">determined until our process is recursively applied to R</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:780"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:786"><nobr><span class="ft4">, but this</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:475"><nobr><span class="ft8">process cannot be recursively applied until the events that should<br>be stored in R</span></nobr></DIV>
<DIV style="position:absolute;top:1022;left:554"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:565"><nobr><span class="ft4">are contained in R</span></nobr></DIV>
<DIV style="position:absolute;top:1022;left:667"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:674"><nobr><span class="ft4">. The fact the the destination</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:475"><nobr><span class="ft4">addresses in R</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:553"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:563"><nobr><span class="ft4">were picked uniformly at random ensures load bal-</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:475"><nobr><span class="ft4">ance.</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:489"><nobr><span class="ft4">This process can now be recursively applied to R</span></nobr></DIV>
<DIV style="position:absolute;top:1069;left:754"><nobr><span class="ft1">0</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:763"><nobr><span class="ft4">and R</span></nobr></DIV>
<DIV style="position:absolute;top:1069;left:797"><nobr><span class="ft1">1</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:803"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">322</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="120007.png" alt="background image">
<DIV style="position:absolute;top:274;left:157"><nobr><span class="ft4">Figure 6: KDDCS original K-D tree</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:94"><nobr><span class="ft4">We now discuss the complexity of this procedure. We break the</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:81"><nobr><span class="ft8">complexity into two parts: the cost of performing the weighted split<br>median operation, and the cost of migrating the events. One appli-<br>cation of the weighted split median has time complexity O(D log n),<br>where D is the diameter of the region, and messages sent per node<br>of O(log</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:129"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:137"><nobr><span class="ft4">n) messages. Thus, we get time complexity O(D log</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:419"><nobr><span class="ft1">2</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:428"><nobr><span class="ft4">n)</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:81"><nobr><span class="ft4">and messages sent per node of O(log</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:280"><nobr><span class="ft1">3</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:288"><nobr><span class="ft4">n) for all of the applications</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:81"><nobr><span class="ft8">of weighted split median. Every period re-balance requires each<br>event to travel at most twice the diameter of the network (assuming<br>that GPSR routes on a direct line). The total number of events that<br>can be forced to migrate as a result of k new events being stored<br>is O(k log k). Thus, the amortized number of migrations per event<br>is logarithmic, O(log k) in the number of insertions. This amount<br>of re-balancing per insertion is required for any standard dynamic<br>data structure (e.g. 2-3 trees, AVL trees, etc.).</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:94"><nobr><span class="ft4">Figures 6 and 7 show a detailed example illustrating how KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:81"><nobr><span class="ft8">works. Continuing on the same example we presented in Section<br>4.2, we monitor how KDTR maintains the K-D tree balancing in<br>the course of successive insertions. Starting with an equal number<br>of 3 events stored at each sensor, a storage hot-spot arises in node<br>N 7 after 6 event insertions. By checking the ratio of N 7 storage<br>to that of N 7, KDTR identifies the subtree rooted at node 11 as<br>an unbalanced subtree. As none of node 11's ancestors is unbal-<br>anced at this point, KDTR selects 11 to be re-balanced. However,<br>the storage load remains skewed toward subtree 1, thus, after an-<br>other 6 insertions, KDTR re-balances the subtree rooted at 1. After<br>12</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:98"><nobr><span class="ft4">more insertions aiming the right subtree of the root, KDTR re-</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:81"><nobr><span class="ft8">balances the root of the tree, basically changing the attribute-based<br>split points of almost all internal nodes, in order to maintain the bal-<br>ance of the tree. Note that, as long as the average loads of sensors<br>which are falling outside the hot-spot area increases, the frequency<br>of re-balancing decreases.</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:94"><nobr><span class="ft4">We digress slightly to explain a method that one might use to</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:81"><nobr><span class="ft8">trigger re-balancing, as opposed to fixed time period re-balancing.<br>Each sensor s</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:156"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:854;left:164"><nobr><span class="ft4">knows the number of events that are stored in each</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:81"><nobr><span class="ft4">region corresponding to an ancestor of s</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:296"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:304"><nobr><span class="ft4">in the K-D tree when this</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:81"><nobr><span class="ft4">region was re-balanced. Let C</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:245"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:255"><nobr><span class="ft4">be the number of events at the last</span></nobr></DIV>
<DIV style="position:absolute;top:901;left:81"><nobr><span class="ft4">re-balancing of the region R</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:234"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:901;left:244"><nobr><span class="ft4">corresponding to node of depth j on</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:81"><nobr><span class="ft4">the path from the root to s</span></nobr></DIV>
<DIV style="position:absolute;top:919;left:220"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:228"><nobr><span class="ft4">in the K-D tree. Assume that the region</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:81"><nobr><span class="ft4">R</span></nobr></DIV>
<DIV style="position:absolute;top:935;left:91"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:101"><nobr><span class="ft4">has elected a leader s</span></nobr></DIV>
<DIV style="position:absolute;top:935;left:219"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:225"><nobr><span class="ft4">. Then, the number of events that have</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:81"><nobr><span class="ft4">to be stored in R</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:172"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:178"><nobr><span class="ft4">, since the last re-balancing, to cause another re-</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:81"><nobr><span class="ft4">balancing in R</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:160"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:170"><nobr><span class="ft4">is something like hC</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:282"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:288"><nobr><span class="ft4">, where h is the unbalancing</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:81"><nobr><span class="ft4">ratio that we are willing to tolerate. Then, each insertion to s</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:421"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:431"><nobr><span class="ft4">is</span></nobr></DIV>
<DIV style="position:absolute;top:999;left:81"><nobr><span class="ft4">reported by s</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:156"><nobr><span class="ft1">i</span></nobr></DIV>
<DIV style="position:absolute;top:999;left:166"><nobr><span class="ft4">to s</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:188"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:999;left:199"><nobr><span class="ft4">with probability something like </span></nobr></DIV>
<DIV style="position:absolute;top:981;left:393"><nobr><span class="ft4">"</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:403"><nobr><span class="ft1">log n</span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:404"><nobr><span class="ft1">hC</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:419"><nobr><span class="ft10">j</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:428"><nobr><span class="ft4">"</span></nobr></DIV>
<DIV style="position:absolute;top:999;left:436"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft4">Thus, after seeing (log n) such notifications, the leader s</span></nobr></DIV>
<DIV style="position:absolute;top:1022;left:396"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:405"><nobr><span class="ft4">can be</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft4">confident that there have been very close to hC</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:334"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:343"><nobr><span class="ft4">insertions into the</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft4">region R</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:130"><nobr><span class="ft1">j</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:136"><nobr><span class="ft4">, and a re-balancing might be warranted. Note that the</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:81"><nobr><span class="ft4">role of leader requires only receiving O(log n) messages.</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:581"><nobr><span class="ft4">Figure 7: KDTR example</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:475"><nobr><span class="ft2">6.</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:506"><nobr><span class="ft2">EXPERIMENTAL RESULTS</span></nobr></DIV>
<DIV style="position:absolute;top:612;left:489"><nobr><span class="ft4">In order to evaluate our KDDCS scheme, we compared its per-</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:475"><nobr><span class="ft8">formance with that of the DIM scheme, that has been shown to be<br>the best among current INDCS schemes [9].</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:489"><nobr><span class="ft4">In our simulation, we assumed having sensors of limited buffer</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:475"><nobr><span class="ft8">and constrained energy. We simulated networks of sizes ranging<br>from 50 to 500 sensors, each having an initial energy of 50 units,<br>a radio range of 40m, and a storage capacity of 10 units. For sim-<br>plicity, we assumed that the size of a message is equal to the size<br>of a storage unit. We also assumed that the size of a storage unit<br>is equal to the size of an event. When sent from a sensor to its<br>neighbor, a message consumes 1 energy unit from the sender en-<br>ergy and 0.5 energy unit from the receiver energy. The service area<br>was computed such that each node has on average 20 nodes within<br>its nominal radio range.</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:489"><nobr><span class="ft4">As each sensor has a limited storage capacity, it is assumed to</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:475"><nobr><span class="ft8">follow a FIFO storage approach to handle its cache. Thus, a sen-<br>sor replaces the oldest event in its memory by the newly incoming<br>event to be stored in case it is already full when receiving this new<br>event.</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:489"><nobr><span class="ft4">We modeled a network of temperature sensors. The range of pos-</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:475"><nobr><span class="ft8">sible reading values was [30, 70]. We modeled storage hot-spots by<br>using a random uniform distribution to represent sensors' locations,<br>while using a skewed distribution of events among the attributes<br>ranges. Note that the regular sensor deployment assumption does<br>not affect our ability to assess the effectiveness of KDDCS as the<br>storage hot-spot can result from either skewed sensor deployments,<br>or skewed data distributions, or both. The storage hot-spot size is<br>characterized by the skewness dimensions, which are the percent-<br>age of the storage hot-spot events to the total number of events<br>generated by the sensor network and the percentage of the read-</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">323</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft14{font-size:2px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="120008.png" alt="background image">
<DIV style="position:absolute;top:235;left:157"><nobr><span class="ft14"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:220;left:152"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:152"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:152"><nobr><span class="ft14"> 600</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:152"><nobr><span class="ft14"> 800</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:149"><nobr><span class="ft14"> 1000</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:149"><nobr><span class="ft14"> 1200</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:149"><nobr><span class="ft14"> 1400</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:149"><nobr><span class="ft14"> 1600</span></nobr></DIV>
<DIV style="position:absolute;top:100;left:149"><nobr><span class="ft14"> 1800</span></nobr></DIV>
<DIV style="position:absolute;top:85;left:149"><nobr><span class="ft14"> 2000</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:160"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:182"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:205"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:228"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:252"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:275"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:298"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:321"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:344"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:367"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:143"><nobr><span class="ft14">Dropped Events</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:254"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:89;left:339"><nobr><span class="ft14">DIM</span></nobr></DIV>
<DIV style="position:absolute;top:95;left:317"><nobr><span class="ft14">KDDCS/KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:81"><nobr><span class="ft8">Figure 8: Number of dropped events for networks with a 80%-<br>10% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:157"><nobr><span class="ft14"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:152"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:152"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:152"><nobr><span class="ft14"> 600</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:152"><nobr><span class="ft14"> 800</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:149"><nobr><span class="ft14"> 1000</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:149"><nobr><span class="ft14"> 1200</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:149"><nobr><span class="ft14"> 1400</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:149"><nobr><span class="ft14"> 1600</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:149"><nobr><span class="ft14"> 1800</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:149"><nobr><span class="ft14"> 2000</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:160"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:182"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:205"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:228"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:252"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:275"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:298"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:321"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:344"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:367"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:143"><nobr><span class="ft14">Dropped Events</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:254"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:339"><nobr><span class="ft14">DIM</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:317"><nobr><span class="ft14">KDDCS/KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:81"><nobr><span class="ft8">Figure 9: Number of dropped events for networks with a 80%-<br>5% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:81"><nobr><span class="ft8">ings' range in which the hot-spot events fall to the total possible<br>range of temperature readings. We assumed that a single storage<br>hot-spot is imposed on the sensor network. To follow the behavior<br>of KDDCS toward storage hot-spots of various sizes, we simulated,<br>for each network size, a series of hot-spots where a percentage of<br>10</span></nobr></DIV>
<DIV style="position:absolute;top:631;left:94"><nobr><span class="ft4">% to 80% of the events fell into a percentage of 5% to 10% of</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:81"><nobr><span class="ft8">the reading' range. Note that we always use the term x%-y% hot-<br>spot to describe a storage hot-spot where x% of the total generated<br>events fall into y% of the readings' range.</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:94"><nobr><span class="ft4">We used a uniform split points initialization to setup the attribute</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:81"><nobr><span class="ft8">range responsibilities of all internal nodes of the K-D tree. For the<br>re-balancing threshold, we used a value of 3 to determine that a<br>specific subtree is unbalanced. Node failures were handled in the<br>same way as DIM. When a node fails, its stored events are consid-<br>ered lost. Futher events directed to the range responsibility of such<br>node are directed to one of its close neighbors.</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:94"><nobr><span class="ft4">We ran the simulation for each network size and storage hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:81"><nobr><span class="ft8">size pair. Each simulation run consisted of two phases: the inser-<br>tion phase and the query phase. During the insertion phase, each<br>sensor generates (i.e. reads) 5 events, according to the predefined<br>hot-spot size and distribution, and forward each of these event to<br>its owner sensor. In the query phase, each sensor generates queries<br>of sizes ranging from 10% to 90% of the [30, 70] range. The query<br>phase is meant to measure the damages, in terms of QoD and en-<br>ergy losses, caused by the storage hot-spot.</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:94"><nobr><span class="ft4">The results of the simulations are shown in the Figures 8 to 17. In</span></nobr></DIV>
<DIV style="position:absolute;top:961;left:81"><nobr><span class="ft8">these figures, we compare the performance of our KDDCS scheme<br>versus that the DIM scheme with respect to various performance<br>measures. Note that we only show some of our findings due to<br>space constraints.</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:81"><nobr><span class="ft8">R1. Data Persistence: Figures 8 and 9 present the total number<br>events dropped by all network nodes in networks with 80%-10%<br>and 80%-5% hot-spots, respectively. By analyzing the difference</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:552"><nobr><span class="ft14"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:546"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:192;left:546"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:546"><nobr><span class="ft14"> 600</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:546"><nobr><span class="ft14"> 800</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:544"><nobr><span class="ft14"> 1000</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:544"><nobr><span class="ft14"> 1200</span></nobr></DIV>
<DIV style="position:absolute;top:85;left:544"><nobr><span class="ft14"> 1400</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:555"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:577"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:600"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:623"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:646"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:669"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:692"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:715"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:739"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:762"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:538"><nobr><span class="ft14">Events Returned for (0.5 * attribute range) Query</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:648"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:89;left:734"><nobr><span class="ft14">DIM</span></nobr></DIV>
<DIV style="position:absolute;top:95;left:712"><nobr><span class="ft14">KDDCS/KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:475"><nobr><span class="ft8">Figure 10: Query size of a 50% query for networks with a 80%-<br>10% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:463;left:552"><nobr><span class="ft14"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:546"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:546"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:546"><nobr><span class="ft14"> 600</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:546"><nobr><span class="ft14"> 800</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:544"><nobr><span class="ft14"> 1000</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:544"><nobr><span class="ft14"> 1200</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:544"><nobr><span class="ft14"> 1400</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:555"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:577"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:600"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:623"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:646"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:669"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:692"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:715"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:739"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:762"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:538"><nobr><span class="ft14">Events Returned for (0.8 * attribute range) Query</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:648"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:734"><nobr><span class="ft14">DIM</span></nobr></DIV>
<DIV style="position:absolute;top:323;left:712"><nobr><span class="ft14">KDDCS/KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:475"><nobr><span class="ft8">Figure 11: Query size of a 80% query for networks with a 80%-<br>5% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:475"><nobr><span class="ft8">between KDDCS and DIM, we can find out that the number of<br>dropped events in the first is around 40% to 60% of that in the<br>second. This can be interpreted by the fact that KDDCS achieves<br>a better load balancing of storage among the sensors. This leads to<br>decreasing the number of sensors reaching their maximum storage,<br>and decreasing the total number of such nodes compared to that in<br>the pure DIM. This directly results in decreasing the total number<br>of dropped events and achieving a better data persistence.</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:489"><nobr><span class="ft4">Another important remark to be noted based on the two figures is</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:475"><nobr><span class="ft8">that decreasing the size of the hot-spot by making the same number<br>of events to fall into a smaller attributes' range does not highly<br>affect the overall performance of KDDCS compared to that of DIM.</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:475"><nobr><span class="ft8">R2. Quality of Data: Figures 10 and 11 show the average query<br>sizes of 50% and 80% of the attribute ranges for networks with<br>a 80%-10% and 80%-5% hot-spots, respectively. It is clear that<br>KDDCS remarkebly improves the QoD provided by the sensor net-<br>work. This is mainly due to dropping less information (as pointed<br>at in R1), thus, increasing the number of events resulting in each<br>query. The gap between DIM and KDDCS, in terms of resulting<br>query sizes, is really huge for in both graphs, which indicates that<br>KDDCS outperforms DIM for different storage hot-spot sizes.</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:489"><nobr><span class="ft4">This result has a very important implication on the data accu-</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:475"><nobr><span class="ft8">racy of the sensor readings output from a network experiencing a<br>hot-spot. The success of the KDDCS in avoiding hot-spots results<br>in improving the network ability to keep a higher portion of the<br>hot-spot data. This ameliorates the degree of correctness of any ag-<br>gregate functions on the network readings, for example, an average<br>of the temperature or pressure values where a high percentage of<br>the data is falling within a small range of the total attributes' range.<br>We consider this to be a good achievement compared to the pure<br>DIM scheme.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:475"><nobr><span class="ft8">R3. Load Balancing: Figures 12 and 13 show the average node<br>storage level for networks with 70%-10% and 60%-5% hot-spots,</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">324</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft15{font-size:2px;line-height:5px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="120009.png" alt="background image">
<DIV style="position:absolute;top:235;left:148"><nobr><span class="ft14"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:148"><nobr><span class="ft14"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:148"><nobr><span class="ft14"> 2</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:148"><nobr><span class="ft14"> 3</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:148"><nobr><span class="ft14"> 4</span></nobr></DIV>
<DIV style="position:absolute;top:85;left:148"><nobr><span class="ft14"> 5</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:152"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:175"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:199"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:223"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:247"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:271"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:295"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:319"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:343"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:367"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:182;left:143"><nobr><span class="ft14">Average Storage Level</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:250"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:89;left:339"><nobr><span class="ft14">DIM</span></nobr></DIV>
<DIV style="position:absolute;top:95;left:317"><nobr><span class="ft14">KDDCS/KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:81"><nobr><span class="ft8">Figure 12: Average node storage level for networks with a 70%-<br>10% hot-spot (numbers rounded to ceiling integer)</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:148"><nobr><span class="ft14"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:148"><nobr><span class="ft14"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:397;left:148"><nobr><span class="ft14"> 2</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:148"><nobr><span class="ft14"> 3</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:148"><nobr><span class="ft14"> 4</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:148"><nobr><span class="ft14"> 5</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:152"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:175"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:199"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:223"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:247"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:271"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:295"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:319"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:343"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:367"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:404;left:143"><nobr><span class="ft14">Average Storage Level</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:250"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:339"><nobr><span class="ft14">DIM</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:317"><nobr><span class="ft14">KDDCS/KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:81"><nobr><span class="ft8">Figure 13: Average node storage level for networks with a 60%-<br>5% hot-spot (numbers rounded to ceiling integer)</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:81"><nobr><span class="ft8">respectively. By a node storage level, we mean the number of<br>events stored in the node's cache. The figures show that KDDCS<br>has a higher average storage level than DIM, especially for less<br>skewed hot-spots. This can be interpreted as follows. When a stor-<br>age hot-spot arises in DIM, the hot-spot load is directed to a small<br>number of sensors. These nodes rapidly reach their storage maxi-<br>mum, while almost all other sensor nodes are nearly empty. There-<br>fore, the load distribution is highly skewed among nodes leadind to<br>a low average storage level value. However, in KDDCS, the num-<br>ber of nodes effectively storing events increases. Subsequently, the<br>average storage load value increases. This gives us a truthful figure<br>about the better storage balancing the network. It is worth mention-<br>ing that each of the values in both figures is rounded to the ceiling<br>integer. Thus, in both cases, the average in DIM does not exceed<br>one event per sensor for all network sizes.</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:81"><nobr><span class="ft8">R4. Energy Consumption Balancing: Figures 14 and 15 show<br>the average node energy level at the end of the simulation for net-<br>works with 70%-10% and 50%-5% hot-spots, respectively. The<br>figures show that this average generally decreases with the increase</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:149"><nobr><span class="ft14"> 30</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:149"><nobr><span class="ft14"> 35</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:149"><nobr><span class="ft14"> 40</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:149"><nobr><span class="ft14"> 45</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:149"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:155"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:177"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:201"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:225"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:248"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:272"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:296"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:320"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:343"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:367"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:143"><nobr><span class="ft14">Average Energy Level</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:251"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:339"><nobr><span class="ft14">DIM</span></nobr></DIV>
<DIV style="position:absolute;top:884;left:317"><nobr><span class="ft14">KDDCS/KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft8">Figure 14: Average sensors' energy levels for networks with a<br>70%-10% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:543"><nobr><span class="ft14"> 30</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:543"><nobr><span class="ft14"> 35</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:543"><nobr><span class="ft14"> 40</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:543"><nobr><span class="ft14"> 45</span></nobr></DIV>
<DIV style="position:absolute;top:85;left:543"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:549"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:572"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:596"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:619"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:643"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:667"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:690"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:714"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:738"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:762"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:182;left:538"><nobr><span class="ft14">Average Energy Level</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:646"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:89;left:734"><nobr><span class="ft14">DIM</span></nobr></DIV>
<DIV style="position:absolute;top:95;left:712"><nobr><span class="ft14">KDDCS/KDTR</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:475"><nobr><span class="ft8">Figure 15: Average sensors' energy levels for networks with a<br>50%-5% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:552"><nobr><span class="ft14"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:546"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:544"><nobr><span class="ft14"> 1000</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:544"><nobr><span class="ft14"> 1500</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:544"><nobr><span class="ft14"> 2000</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:544"><nobr><span class="ft14"> 2500</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:544"><nobr><span class="ft14"> 3000</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:544"><nobr><span class="ft14"> 3500</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:555"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:577"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:600"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:623"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:646"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:669"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:692"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:715"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:739"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:762"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:538"><nobr><span class="ft14">Moved Events for x%-10% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:648"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:732"><nobr><span class="ft15">x=40<br>x=60<br>x=80</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:475"><nobr><span class="ft8">Figure 16: Number of event movements for networks with a<br>x%-10% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:475"><nobr><span class="ft8">of the network size for both schemes. The interesting result that<br>these figures show is that both KDDCS and DIM result in fairly<br>close average energy consumption among the sensors. However,<br>as we mentioned in R3 and based on the way DIM works, most of<br>the energy consumed in DIM is effectively consumed by a small<br>number of nodes, namely those falling in the hot-spot region. On<br>the other hand, the number of nodes consuming energy increases in<br>KDDCS due to the better load balancing KDDCS achieves, while<br>the average energy consumed by each sensor node decreases. Thus,<br>although the overall energy consumption is the same in both KD-<br>DCS and DIM, this result is considered as a positive result in terms<br>of increasing the overall network lifetime, as well as avoiding the<br>early death of sensor nodes, which leads to avoid network parti-<br>tioning.</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:475"><nobr><span class="ft8">R5. Events Movements: Figures 16 and 17 show the number of<br>migrated events for networks with x% - 10% and x% - 5% hot-<br>spots, respectively, where x varies from 40 to 80. For both sets of<br>hot-spot sizes, the number of event movements lineraly increases<br>with the network size. The important result to be noted in both</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:552"><nobr><span class="ft14"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:546"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:544"><nobr><span class="ft14"> 1000</span></nobr></DIV>
<DIV style="position:absolute;top:960;left:544"><nobr><span class="ft14"> 1500</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:544"><nobr><span class="ft14"> 2000</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:544"><nobr><span class="ft14"> 2500</span></nobr></DIV>
<DIV style="position:absolute;top:895;left:544"><nobr><span class="ft14"> 3000</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:544"><nobr><span class="ft14"> 3500</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:555"><nobr><span class="ft14"> 50</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:577"><nobr><span class="ft14"> 100</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:600"><nobr><span class="ft14"> 150</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:623"><nobr><span class="ft14"> 200</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:646"><nobr><span class="ft14"> 250</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:669"><nobr><span class="ft14"> 300</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:692"><nobr><span class="ft14"> 350</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:715"><nobr><span class="ft14"> 400</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:739"><nobr><span class="ft14"> 450</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:762"><nobr><span class="ft14"> 500</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:538"><nobr><span class="ft14">Moved Events for x%-5% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:648"><nobr><span class="ft14">Network Size</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:732"><nobr><span class="ft15">x=40<br>x=60<br>x=80</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:475"><nobr><span class="ft8">Figure 17: Number of event movements for networks with a<br>x%-5% hot-spot</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">325</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="120010.png" alt="background image">
<DIV style="position:absolute;top:86;left:81"><nobr><span class="ft8">figure is that the total number of movements is not highly depen-<br>dent on the hot-spot size. This is mainly because KDDCS avoids<br>storage hot-spots in their early stages instead of waiting for a large<br>storage hot-spot to be formed, and then try to decompose it. There-<br>fore, most of the event movements are really done at the start of<br>the formation of the storage hot-spot. This leads to the fact that,<br>for highly skewed data distributions, (i.e. large hot-spot sizes), the<br>number of event movements does not highly change with changing<br>the exact storage hot-spot size.</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:81"><nobr><span class="ft2">7.</span></nobr></DIV>
<DIV style="position:absolute;top:248;left:112"><nobr><span class="ft2">RELATED WORK</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:94"><nobr><span class="ft4">Many approaches have been presented in literature defining how</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:81"><nobr><span class="ft8">to store the data generated by a sensor network. In the early age of<br>sensor networks research, the main storage trend used consisted of<br>sending all the data to be stored in base stations, which lie within,<br>or outside, the network. However, this approach may be more ap-<br>propriate to answer continuous queries, which are queries running<br>on servers and mostly processing events generated by all the sensor<br>nodes over a large period of time [4, 10, 18, 14, 12, 11].</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:94"><nobr><span class="ft4">In order to improve the lifetime of the sensor network, as well</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:81"><nobr><span class="ft8">as the QoD of ad-hoc queries, INS techniques have been proposed.<br>All INS schemes presented so far were based on the idea of DCS<br>[15]. These INDCS schemes differ from each other based on the<br>events-to-sensors mapping used. The mapping was done using hash<br>tables in DHT [15] and GHT [13], or using K-D trees in DIM [9].</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:94"><nobr><span class="ft4">The formation of storage hot-spots due to irregularity, in terms of</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:81"><nobr><span class="ft8">sensor deployment or events distribution, represent a vital issue in<br>current INDCS techniques [5]. Some possible solutions for irreg-<br>ular sensors deployments were highlighted by [5], such as routing<br>based on virtual coordinates, or using heuristics to locally adapt to<br>irregular sensor densities. Recently, some load balancing heuris-<br>tics for the irregular events distribution problem were presented<br>by [2, 8]. Such techniques were limited in their capability to deal<br>with storage hot-spots of large sizes as they were basically acting<br>like storage hot-spots detection and decomposition schemes, rather<br>than storage hot-spots avoidance schemes like KDDCS. To the best<br>of our knowledge, no techniques have been provided to cope with<br>both types of irregularities at the same time. A complentary work<br>to our paper is that on exploting similarities in processing queries<br>issued by neighboring sensors in a DCS scheme [16].</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:94"><nobr><span class="ft4">Query Hot-Spots is another important problem that is orthogonal</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:81"><nobr><span class="ft8">to the storage hot-spots problem. The problem arizes when a large<br>percentage of queries ask for data stored in few sensors. We iden-<br>tified the problem in an earlier paper [1] and presented two algo-<br>rithms, Zone Partitioning (ZP) and Zone Partial Replication (ZPR),<br>to locally detect and decompose query hot-spots in DIM. We be-<br>lieve that KDDCS is able to cope with query hot-spots provided<br>minor changes are added to the scheme. We aim at addressing this<br>problem in the KDDCS testbed that we plan to develop.</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:94"><nobr><span class="ft4">Recently, Krishnamurthy et al. [7] presented a novel DCS scheme,</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:81"><nobr><span class="ft8">called RESTORE, that is characterized by real time event correla-<br>tion. It would be interesting to compare the performance of both<br>KDDCS and RESTORE in terms of load balacing.</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:81"><nobr><span class="ft2">8.</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:112"><nobr><span class="ft2">CONCLUSIONS</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:94"><nobr><span class="ft4">Sensor databases are becoming embedded in every aspect of our</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:81"><nobr><span class="ft8">life from merchandise tracking, healthcare, to disaster responds. In<br>the particular application of disaster management, it has been ar-<br>gued that it is more energy efficient to store the sensed data locally<br>in the sensor nodes rather than shipping it out of the network, even<br>if out-of-network storage is available.</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:94"><nobr><span class="ft4">The formation of Storage Hot-Spots is a major problem with the</span></nobr></DIV>
<DIV style="position:absolute;top:86;left:475"><nobr><span class="ft8">current INDCS techniques in sensor networks. In this paper, we<br>presented a new load-balanced INDCS scheme, namely KDDCS,<br>that avoids the formation of storage hot-spots arising in the sensor<br>network due to irregular sensor deployment and/or irregular events<br>distribution. Further, we proposed a new routing algorithm called<br>Logical Stateless Routing, for routing events from the generating<br>sensors to the storage sensors, that is competitive with the popular<br>GPSR routing. Our experimental evaluation has confirmed that our<br>proposed KDDCS both increases the quality of data and the en-<br>ergy savings by distributing events of the storage hot-spots among<br>a larger number of sensors.</span></nobr></DIV>
<DIV style="position:absolute;top:276;left:480"><nobr><span class="ft2">Acknowledgments</span></nobr></DIV>
<DIV style="position:absolute;top:301;left:475"><nobr><span class="ft8">We would like to thank Mohamed Sharaf for his useful feedback.<br>We would also like to thank the anonymous referees for their help-<br>ful comments.</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:475"><nobr><span class="ft2">9.</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:507"><nobr><span class="ft2">REFERENCES</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:481"><nobr><span class="ft5">[1] M. Aly, P. K. Chrysanthis, and K. Pruhs. Decomposing data-centric</span></nobr></DIV>
<DIV style="position:absolute;top:393;left:502"><nobr><span class="ft9">storage query hot-spots in sensor networks. In Proc. of<br>MOBIQUITOUS, 2006.</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:481"><nobr><span class="ft5">[2] M. Aly, N. Morsillo, P. K. Chrysanthis, and K. Pruhs. Zone Sharing:</span></nobr></DIV>
<DIV style="position:absolute;top:435;left:502"><nobr><span class="ft9">A hot-spots decomposition scheme for data-centric storage in sensor<br>networks. In Proc. of DMSN, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:463;left:481"><nobr><span class="ft5">[3] J. L. Bentley. Multidimensional binary search trees used for</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:502"><nobr><span class="ft5">associative searching. In CACM, 18(9), 1975.</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:481"><nobr><span class="ft5">[4] P. Bonnet, J. Gehrke, and P. Seshadri. Towards sensor database</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:502"><nobr><span class="ft5">systems. In Proc. of MDM, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:481"><nobr><span class="ft5">[5] D. Ganesan, S. Ratnasamy, H. Wang, and D. Estrin. Coping with</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:502"><nobr><span class="ft9">irregular spatio-temporal sampling in sensor networks. In Proc. of<br>HotNets-II, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:481"><nobr><span class="ft5">[6] B. Karp and H. T. Kung. GPSR: Greedy perimeter stateless routing</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:502"><nobr><span class="ft5">for wireless sensor networks. In Proc. of ACM Mobicom, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:481"><nobr><span class="ft5">[7] S. Krishnamurthy, T. He, G. Zhou, J. A. Stankovic, and S. H. Son.</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:502"><nobr><span class="ft9">Restore: A real-time event correlation and storage service for sensor<br>networks. In Proc. of INSS, 2006.</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:481"><nobr><span class="ft5">[8] X. Li, F. Bian, R. Govidan, and W. Hong. Rebalancing distributed</span></nobr></DIV>
<DIV style="position:absolute;top:645;left:502"><nobr><span class="ft9">data storage in sensor networks. Technical Report No. 05-852, CSD,<br>USC, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:481"><nobr><span class="ft5">[9] X. Li, Y. J. Kim, R. Govidan, and W. Hong. Multi-dimensional range</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:502"><nobr><span class="ft5">queries in sensor networks. In Proc. of ACM SenSys, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:702;left:475"><nobr><span class="ft5">[10] S. Madden, M. Franklin, J. Hellerstein, and W. Hong. TAG: a tiny</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:502"><nobr><span class="ft9">aggregation service for ad-hoc sensor networks. In Proc. of OSDI,<br>2002.</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:475"><nobr><span class="ft5">[11] S.-J. Park, R. Vedantham, R. Sivakumar, and I. F. Akyildiz. A</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:502"><nobr><span class="ft9">scalable approach for reliable downstream data delivery in wireless<br>sensor networks. In Proc. of MobiHoc, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:475"><nobr><span class="ft5">[12] T. Pham, E. J. Kim, and W. M. Moh. On data aggregation quality and</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:502"><nobr><span class="ft9">energy efficiency of wireless sensor network protocols. In Proc. of<br>BROADNETS, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:475"><nobr><span class="ft5">[13] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govidan, and</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:502"><nobr><span class="ft9">S. Shenker. GHT: A grographic hash table for data-centric storage. In<br>Proc. of WSNA, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:475"><nobr><span class="ft5">[14] M. A. Sharaf, J. Beaver, A. Labrinidis, and P. K. Chrysanthis. TiNA:</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:502"><nobr><span class="ft9">A scheme for temporal coherency-aware in-network aggregation. In<br>Proc. of MobiDE, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:912;left:475"><nobr><span class="ft5">[15] S. Shenker, S. Ratnasamy, B. Karp, R. Govidan, and D. Estrin.</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:502"><nobr><span class="ft5">Data-centric storage in sensornets. In Proc. of HotNets-I, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:940;left:475"><nobr><span class="ft5">[16] P. Xia, P. K. Chrysanthis, and A. Labrinidis. Similarity-aware query</span></nobr></DIV>
<DIV style="position:absolute;top:953;left:502"><nobr><span class="ft5">processing in sensor networks. In Proc. of WPDRTS, 2006.</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:475"><nobr><span class="ft5">[17] T. Yan, T. He, and J. A. Stankovic. Differentiated surveillance for</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:502"><nobr><span class="ft5">sensor networks. In Proc. of SenSys, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:475"><nobr><span class="ft5">[18] Y. Yao and J. Gehrke. Query processing for sensor networks. In Proc.</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:502"><nobr><span class="ft5">of CIDR, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:449"><nobr><span class="ft7">326</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
