<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>2005-07-24-PM.fm</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="author" content="reiser">
<META name="date" content="2005-12-19T11:50:50+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:12px;font-family:Helvetica;color:#0000ff;}
	.ft1{font-size:25px;font-family:Helvetica;color:#000000;}
	.ft2{font-size:16px;font-family:Helvetica;color:#000000;}
	.ft3{font-size:12px;font-family:Helvetica;color:#000000;}
	.ft4{font-size:16px;font-family:Times;color:#000000;}
	.ft5{font-size:11px;font-family:Times;color:#000000;}
	.ft6{font-size:11px;font-family:Times;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:9px;font-family:Times;color:#000000;}
	.ft9{font-size:12px;line-height:17px;font-family:Helvetica;color:#000000;}
	.ft10{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft11{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft12{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft13{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft14{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft15{font-size:9px;line-height:15px;font-family:Times;color:#000000;}
	.ft16{font-size:9px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="9001.png" alt="background image">
<DIV style="position:absolute;top:850;left:595"><nobr><span class="ft0">1</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:169"><nobr><span class="ft1"><b>A Flexible and Extensible Object Middleware:</b></span></nobr></DIV>
<DIV style="position:absolute;top:139;left:329"><nobr><span class="ft1"><b>CORBA and Beyond</b></span></nobr></DIV>
<DIV style="position:absolute;top:180;left:113"><nobr><span class="ft2">Franz J. Hauck</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:93"><nobr><span class="ft3">Distributed Systems Lab</span></nobr></DIV>
<DIV style="position:absolute;top:220;left:117"><nobr><span class="ft3">University of Ulm</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:143"><nobr><span class="ft3">Germany</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:112"><nobr><span class="ft3">+49-731-50-24143</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:81"><nobr><span class="ft2">franz.hauck@uni-ulm.de</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:300"><nobr><span class="ft2">Rüdiger Kapitza</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:274"><nobr><span class="ft3">Dept. of Computer Science</span></nobr></DIV>
<DIV style="position:absolute;top:220;left:288"><nobr><span class="ft3">University of Erlangen-</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:298"><nobr><span class="ft9">Nürnberg, Germany<br>+49-9131-85-27269</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:294"><nobr><span class="ft2">kapitza@cs.fau.de</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:494"><nobr><span class="ft2">Hans P. Reiser</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:473"><nobr><span class="ft3">Distributed Systems Lab</span></nobr></DIV>
<DIV style="position:absolute;top:220;left:497"><nobr><span class="ft3">University of Ulm</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:523"><nobr><span class="ft3">Germany</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:492"><nobr><span class="ft3">+49-731-50-24145</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:463"><nobr><span class="ft2">hans.reiser@uni-ulm.de</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:666"><nobr><span class="ft2">Andreas I. Schmied</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:663"><nobr><span class="ft3">Distributed Systems Lab</span></nobr></DIV>
<DIV style="position:absolute;top:220;left:688"><nobr><span class="ft3">University of Ulm</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:713"><nobr><span class="ft3">Germany</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:682"><nobr><span class="ft3">+49-731-50-24146</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:679"><nobr><span class="ft2">andreas.schmied</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:696"><nobr><span class="ft2">@uni-ulm.de</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:81"><nobr><span class="ft4"><b>ABSTRACT</b></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:81"><nobr><span class="ft10">This paper presents a CORBA-compliant middleware architecture<br>that is more flexible and extensible compared to standard CORBA.<br>The portable design of this architecture is easily integrated in any<br>standard CORBA middleware; for this purpose, mainly the han-<br>dling of object references (IORs) has to be changed. To encapsulate<br>those changes, we introduce the concept of a generic <i>reference<br>manager</i> with <i>portable profile managers</i>. Profile managers are<br>pluggable and in extreme can be downloaded on demand. To illus-<br>trate the use of this approach, we present a profile manager imple-<br>mentation for fragmented objects and another one for bridging<br>CORBA to the Jini world. The first profile manager supports truly<br>distributed objects, which allow seamless integration of partition-<br>ing, scalability, fault tolerance, end-to-end quality of service, and<br>many more implementation aspects into a distributed object without<br>losing distribution and location transparency. The second profile<br>manager illustrates how our architecture enables fully transparent<br>access from CORBA applications to services on non-CORBA plat-<br>forms.</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:81"><nobr><span class="ft4"><b>Categories and Subject Descriptors</b></span></nobr></DIV>
<DIV style="position:absolute;top:672;left:81"><nobr><span class="ft13">D.1.5 [<b>Programming Techniques</b>]: Object-oriented Program-<br>ming; D.2.7 [<b>Software Engineering</b>]: Distribution, Maintenance,<br>and Enhancement - e<i>xtensibility, portability</i>; D.2.12 [<b>Software En-<br>gineering</b></span></nobr></DIV>
<DIV style="position:absolute;top:717;left:135"><nobr><span class="ft5">]: Interoperability - <i>distributed objects</i>; </span></nobr></DIV>
<DIV style="position:absolute;top:753;left:81"><nobr><span class="ft4"><b>General Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:774;left:81"><nobr><span class="ft5">Design, Management, Standardization</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:81"><nobr><span class="ft4"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:825;left:81"><nobr><span class="ft11">Software architecture for middleware; extensible and reconfigura-<br>ble middleware; middleware interoperability; CORBA</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:477"><nobr><span class="ft4"><b>1. INTRODUCTION</b></span></nobr></DIV>
<DIV style="position:absolute;top:368;left:477"><nobr><span class="ft11">Middleware systems are heavily used for the implementation of<br>complex distributed applications. Current developments like mo-<br>bile environments and ubiquitous computing lead to new require-<br>ments that future middleware systems will have to meet. Examples<br>for such requirements are the support for self-adaptation and self-<br>optimisation as well as scalability, fault-tolerance, and end-to-end<br>quality of service in the context of high dynamics. Heterogeneity in<br>terms of various established middleware platforms calls for cross-<br>platform interoperability. In addition, not all future requirements<br>can be predicted today. A proper middleware design should be well-<br>prepared for such future extensions.<br>CORBA is a well-known standard providing an architecture for ob-<br>ject-based middleware systems [5]. CORBA-based applications are<br>built from distributed objects that can transparently interact with<br>each other, even if they reside on different nodes in a distributed en-<br>vironment. CORBA objects can be implemented in different pro-<br>gramming languages. Their interface has to be defined in a single,<br>language-independent interface description language (IDL). Prob-<br>lem-specific extensions allow to add additional features to the un-<br>derlying base architecture.<br>This paper discusses existing approaches towards a more flexible<br>middleware infrastructure and proposes a novel modularisation pat-<br>tern that leads to a flexible and extensible object middleware. Our<br>design separates the handling of remote references from the object<br>request broker (ORB) core and introduces the concept of ORB-in-<br>dependent <i>portable profile managers</i>, which are managed by a ge-<br>neric  <i>reference manager</i>. The profile managers encapsulate all<br>tasks related to reference handling, i.e., reference creation, refer-<br>ence marshalling and unmarshalling, external representation of ref-<br>erences as strings, and type casting of representatives of remote ob-<br>jects. The profile managers are independent from a specific ORB,<br>and may even be loaded dynamically into the ORB. Only small<br>modifications to existing CORBA implementations are necessary<br>to support such a design.<br>Our architecture enables the integration of a fragmented object<br>model into CORBA middleware platforms, which allows transpar-<br>ent support of many implementation aspects of complex distributed<br>systems, like partitioning, scalability, fault-tolerance, and end-to-<br>end quality-of-service guarantees. It also provides a simple mecha-<br>nism for the integration of cross-platform interoperability, e.g., the<br>integration with services running on non-CORBA middleware plat-<br>forms, like Jini or .NET remoting. Our design was named <i>AspectIX<br></i>and implemented as an extension to the open-source CORBA im-<br>plementation <i>JacORB</i>, but is easily ported to other systems.<br>This paper is organised as follows: The following section discusses<br>the monolithic design of most current middleware systems in more<br>detail. It addresses the extension features of CORBA and discusses</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:81"><nobr><span class="ft16">Permission to make digial or hard copies of all or part of this work for<br>personal or classroom use is granted without fee provided that copies are<br>not made or distributed for profit or commercial advantage and that copies<br>bear this notice and the full citation on the first page. To copy otherwise, to<br>republish, to post on servers or to redistributed to lists, requires prior<br>specific permission and/or a fee.<br>SEM 2005, September 2005, Lisbon, Portugal<br>Copyright 2005 ACM, 1-59593-204-4/05/09...$5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:1092;left:439"><nobr><span class="ft3">69</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft17{font-size:12px;font-family:Courier;color:#000000;}
	.ft18{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="9002.png" alt="background image">
<DIV style="position:absolute;top:850;left:595"><nobr><span class="ft0">2</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft11">their lack of flexibility. Section 3 explains our novel approach to<br>middleware extensibility based on a generic reference manager<br>with pluggable profile managers. In Section 4, two CORBA exten-<br>sions and the corresponding profile managers are presented: One<br>for integrating the powerful fragmented-object model into the sys-<br>tem, and one for transparently accessing Jini services from CORBA<br>applications. Section 5 evaluates the implementation effort and run-<br>time overhead of our approach, and Section 6 presents some con-<br>cluding remarks. </span></nobr></DIV>
<DIV style="position:absolute;top:262;left:81"><nobr><span class="ft4"><b>2. MIDDLEWARE ARCHITECTURE AND </b></span></nobr></DIV>
<DIV style="position:absolute;top:283;left:102"><nobr><span class="ft4"><b>EXTENSION POINTS</b></span></nobr></DIV>
<DIV style="position:absolute;top:306;left:81"><nobr><span class="ft4"><b>2.1 Standard CORBA Architecture</b></span></nobr></DIV>
<DIV style="position:absolute;top:328;left:81"><nobr><span class="ft14">CORBA uses a monolithic object model: CORBA objects have to<br>reside on a specific node and are transparently accessed by client-<br>side proxies called stubs. The stubs use an RPC-based communica-<br>tion protocol to contact the actual object, to pass parameters, and to<br>receive results from object invocations. A CORBA-based middle-<br>ware implementation is free to choose the actual protocol, but has<br>to support the Internet Inter-ORB Protocol (IIOP) for interoperabil-<br>ity.<br>CORBA uses <i>interoperable object references</i> (IORs) to address re-<br>mote objects. The IOR is a data structure composed of a set of <i>pro-<br>files</i>. According to the standard, each profile may specify contact<br>information of the remote object for one specific interaction proto-<br>col; for interoperability between ORBs of different vendors, an<br>IIOP profile needs to be present. In addition to protocol profiles, the<br>IOR may contain a set of <i>tagged components</i>. Each tagged compo-<br>nent is a name-value pair with a unique tag registered with the OMG<br>and arbitrary associated data; these components define protocol-in-<br>dependent information, like a unique object ID.<br>In standard CORBA, IORs are created internally at the server ORB.<br>A server application creates a servant instance and registers the<br>servant with the ORB (or, to be more specific, with an object adapt-<br>er of the ORB). Usually this IOR contains an automatically created<br>IIOP profile that contains hostname, port, object adapter name, and<br>object ID for accessing the object via IIOP. Additionally, it may<br>contain other profiles representing alternative ways to access the<br>object.<br>An IOR can be passed to remote clients, either implicitly or explic-<br>itly. If a reference to a remote object is passed as a parameter or re-<br>turn value, the IOR data structure will be implicitly serialised and<br>transferred. Upon deserialisation, the receiving client ORB auto-<br>matically instantiates a local stub for accessing the remote object,<br>initialised with the information available in the IOR. If multiple<br>profiles exist in the IOR, the ORB may use a vendor-specific strat-<br>egy to select a single profile that is understood by the ORB. The<br>IIOP profile should be understood by all ORBs. Beside implicit<br>transfer, an explicit transfer is possible. The server application may<br>call a </span></nobr></DIV>
<DIV style="position:absolute;top:873;left:113"><nobr><span class="ft17">object_to_string</span></nobr></DIV>
<DIV style="position:absolute;top:873;left:257"><nobr><span class="ft5"> method at the ORB, which serial-</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:81"><nobr><span class="ft14">ises the IOR and transforms it to a string, an IOR-URL. This string<br>can be transferred to a client; the client application may call the lo-<br>cal ORB method </span></nobr></DIV>
<DIV style="position:absolute;top:919;left:178"><nobr><span class="ft17">string_to_object</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:322"><nobr><span class="ft5"> to create the stub for</span></nobr></DIV>
<DIV style="position:absolute;top:935;left:81"><nobr><span class="ft5">the remote object referenced by the IOR. </span></nobr></DIV>
<DIV style="position:absolute;top:969;left:81"><nobr><span class="ft4"><b>2.2 Status Quo of Extensible Middleware</b></span></nobr></DIV>
<DIV style="position:absolute;top:991;left:81"><nobr><span class="ft10">Many practical tasks--e.g., authorisation, security, load balancing,<br>fault tolerance, or special communication protocols--require ex-<br>tensions to the basic CORBA model. For example, fault-tolerant<br>replication requires that multiple communication addresses (i.e., of<br>all replicas) are known to a client. Typically this means that these<br>addresses have to be encoded into the remote reference; binding to</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:477"><nobr><span class="ft11">and invoking methods at such a remote object require a more com-<br>plex handling at the client side compared to the simple stub-service<br>design. As a second example, a peer-to-peer-like interaction be-<br>tween users of a service might sometimes be desired. In this case,<br>the client-server structure needs to be completely abandoned.<br>A good example for the lack of extensibility of standard CORBA is<br>the fault-tolerant CORBA standard (FT-CORBA) [5, Chapter 23].<br>It was not possible to define this standard in a way that all platform<br>implementations are portable across different ORBs. Instead, each<br>FT-CORBA-compliant middleware has its vendor-specific imple-<br>mentation inside of a single ORB. A system design such as we en-<br>vision allows to implement a generic "FT-CORBA plugin" that<br>makes any ORB, independent of its vendor, aware of fault-tolerance<br>mechanisms.<br>Existing concepts for interception, custom object adapters, and<br>smart proxies provide some mechanisms for such extensions. In<br>part, they are included in the CORBA standard; in part, they are<br>only available in non-standardised middleware implementations.<br>The portable interceptor specification supports interception within<br>the official CORBA standard. The specification defines request in-<br>terceptors and IOR interceptors as standardised way to extend the<br>middleware functionality. Using request interceptors, several hooks<br>may be inserted both at client and at server side to intercept remote<br>method calls. These hooks allow to redirect the call (e.g., for load<br>balancing), abort it with an exception (e.g., for access restriction),<br>extract and modify context information embedded in the request,<br>and perform monitoring tasks. A direct manipulation of the request<br>is not permitted by the specification. Multiple request interceptors<br>may be used simultaneously. Interceptors add additional overhead<br>on each remote method invocation; furthermore, they do not allow<br>to modify the remote invocations completely. IOR interceptors, on<br>the other hand, are called when a POA needs to create an IOR for a<br>service. This allows to insert additional data into the IOR (e.g., a<br>tagged component for context information that is later used in a re-<br>quest interceptor).<br>CORBA allows to define custom POA implementations. The POA<br>is responsible for forwarding incoming invocation requests to a<br>servant implementation. This extension point allows to integrate<br>server-side mechanisms like access control, persistence, and life-<br>cycle management. It has, however, no influence on the interaction<br>of clients with a remote service.<br>Beside the standardised IIOP protocol, any CORBA implementa-<br>tion may support custom invocation protocols. Additional IOR pro-<br>files may be used for this purpose. However, establishing such ex-<br>tensions is not standardised and every vendor may include his own<br>proprietary variant, which limits the interoperability of this ap-<br>proach.<br>Smart proxies are a concepts for extending ORB flexibility, which<br>is not yet standardised by the OMG, but which is implemented by<br>some ORB vendors, e.g., in the <i>ACE ORB/Tao</i> [11]. They allow to<br>replace the default CORBA stub by a custom proxy that may imple-<br>ment some extended functionality. As such, they allow to imple-<br>ment parts of the object's functionality at the client side.<br>Closely related to our research is the work on <i>OpenORB</i> at Lancas-<br>ter University [1]. This middleware project uses reflection to define<br>dynamic (re)configuration of componentised middleware services.<br>The main difference to our design is that it completely restructures<br>the middleware architecture, whereas our concept with a reference<br>manager and pluggable profile managers is integrated in any exist-<br>ing CORBA implementation with only minimal modifications. It<br>nevertheless provides equal flexibility forreconfigurations. Compo-<br>nent technology could be used in the internal design of complex<br>profile managers.</span></nobr></DIV>
<DIV style="position:absolute;top:1094;left:440"><nobr><span class="ft3">70</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft19{font-size:11px;font-family:Courier;color:#000000;}
	.ft20{font-size:8px;font-family:Times;color:#221f1f;}
	.ft21{font-size:8px;line-height:12px;font-family:Times;color:#221f1f;}
-->
</STYLE>
<IMG width="918" height="1188" src="9003.png" alt="background image">
<DIV style="position:absolute;top:850;left:595"><nobr><span class="ft0">3</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft11"><i>PolyORB</i> [10] is a generic middleware system that aims at provid-<br>ing a uniform solution to build distributed applications. It supports<br>several <i>personalities</i> both at the application-programming interface<br>(API) level and the network-protocol level. The personalities are<br>compliant to several existing standards. This way, it provides mid-<br>dleware-to-middleware interoperability. Implementations of per-<br>sonalities are specific to PolyORB, unlike our profile managers,<br>which are intended to be portable between different ORB imple-<br>mentations. We do not address the issue of genericity at the API lev-<br>el. </span></nobr></DIV>
<DIV style="position:absolute;top:276;left:81"><nobr><span class="ft4"><b>3. DESIGNING A GENERIC REFERENCE </b></span></nobr></DIV>
<DIV style="position:absolute;top:297;left:102"><nobr><span class="ft4"><b>MANAGER</b></span></nobr></DIV>
<DIV style="position:absolute;top:319;left:81"><nobr><span class="ft10">The fundamental extension point of an object middleware is the<br>central handling of remote references. It is the task of any object<br>middleware to provide mechanisms to create remote references, to<br>pass them across host boundaries, and to use them for remote invo-<br>cations. As explained above, merely providing extension points at<br>the invocation level is insufficient for several complex tasks. The<br>essential point of our work is to provide a very early extension point<br>by completely separating the reference handling from the middle-<br>ware core.<br>The impact of such a design is not only that a single middleware im-<br>plementation gets more flexible. It is also highly desirable to pro-<br>vide this extensibility in an vendor-independent way. That is, an ex-<br>tension module should be portable across different middleware im-<br>plementations. Furthermore, these extensions should be dynami-<br>cally pluggable and, in the extreme, be loaded on demand by the<br>middleware ORB.<br>Our design provides such a middleware architecture. It is currently<br>designed as an extension to standard CORBA, and maintains inter-<br>operability with any legacy CORBA system. Our design represents,<br>however, a generic design pattern that easily applies to any other<br>object middleware.<br>The only prerequisite made is that remote references are represent-<br>ed by a sufficiently extensible data structure. In CORBA, the Inter-<br>operable Object Reference (IOR) provides such a data structure.<br>Each profile of the IOR represents an alternative way to contact the<br>object. Each profile type has its own data-type definition, described<br>in CORBA IDL. Hence, at the IOR level, CORBA is open to arbi-<br>trary extensions. The IOR handling, however, is typically encapsu-<br>lated in the internals of a CORBA-compliant ORB implementation.<br>Currently, if a vendor uses the power of IORs for custom exten-<br>sions, these will only be implemented internally in the respective<br>ORB. The extension will not be portable.</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:81"><nobr><span class="ft4"><b>3.1 Overview of our Design</b></span></nobr></DIV>
<DIV style="position:absolute;top:841;left:81"><nobr><span class="ft10">Our approach introduces a generic interface for plugging in portable<br>extension modules for all tasks related to IOR profile handling. This<br>makes it easy to support extended features like fault-tolerant repli-<br>cation, a fragmented object model, or transparent interaction with<br>other middleware systems. This improves the flexibility of a<br>CORBA middleware. We factored out the IOR handling of the<br>ORB and put it into pluggable modules. This way, custom handlers<br>for IOR profiles may be added to the ORB without modifying the<br>ORB itself. Dynamically downloading and installing such handlers<br>at run-time further contributes to the richness of this approach. <br>Factoring out the basic remote-reference handling of the ORB core<br>into a pluggable module affects five core functions of the middle-<br>ware: first, the creation of new object references; second, the mar-<br>shalling process, which converts object references into an external-<br>ly meaningful representation (i.e., a serialised IOR); third, the un-<br>marshalling process, which has to convert such representation into</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:477"><nobr><span class="ft11">a local representation (e.g., a stub, a smart proxy, or a fragment);<br>and fourth, the explicit binding operation, which turns some sym-<br>bolic reference (e.g., a stringified IOR) into a local representation<br>and vice versa. A fifth function is not as obvious as the others: The<br>type of a remote object reference can be changed as long as the re-<br>mote object supports the new type. In CORBA this is realised by a<br>special <i>narrow</i> operation. As in some cases the narrow operation<br>needs to create a new local representation for a remote object, this<br>operation has to be considered too.<br>An extension to CORBA will have to change all five functions for<br>its specific needs. Thus, we collect those function in a module that<br>we call a <i>profile manager</i>. A profile manager is usually responsible<br>for a single type of IOR profile, but there may be reasons to allow<br>profile managers to manage multiple profile types. Profile manag-<br>ers are pluggable modules. A part of the ORB called <i>reference man-<br>ager</i> manages all available profile managers and allows for registra-<br>tion of new profile-manager modules.<br>The basic design can be found as a UML class diagram in Fig. Fig-<br>ure. Sometimes an application needs to access the reference manag-<br>er directly. By calling </span></nobr></DIV>
<DIV style="position:absolute;top:710;left:602"><nobr><span class="ft19">resolve_initial_references()</span></nobr></DIV>
<DIV style="position:absolute;top:709;left:823"><nobr><span class="ft5">, a</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:477"><nobr><span class="ft10">generic operation for resolving references to system-dependent ob-<br>jects, it can retrieve a reference to the reference manager pseudo ob-<br>ject from the ORB. At the reference manager, profile managers can<br>be registered. As profile managers are responsible for a single or for<br>multiple IOR profile types, the registration requires a parameter<br>identifying those profile types. For identification a unique profile<br>tag is used. Those tags are registered with the OMG to ensure their<br>uniqueness. With the registration at the reference manager, it is ex-<br>actly known which profile managers can handle what profile types.<br>Several tasks of reference handling are invoked at the reference<br>manager and forwarded to the appropriate profile manager. The ar-<br>chitecture resembles the chain-of-responsibility pattern introduced<br>by Gamma et al. [2].</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:477"><nobr><span class="ft4"><b>3.2 Refactoring the Handling of References</b></span></nobr></DIV>
<DIV style="position:absolute;top:960;left:477"><nobr><span class="ft14">In the following, we describe the handling of the five core functions<br>of reference handling in our architecture:<br><b>Creating object references.</b></span></nobr></DIV>
<DIV style="position:absolute;top:991;left:643"><nobr><span class="ft5">In traditional CORBA, new object</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:477"><nobr><span class="ft10">references are created by registering a servant at a POA of the serv-<br>er. The POA usually maintains a socket for accepting incoming in-<br>vocation requests, e.g., in form of IIOP messages. The POA en-<br>codes the contact address of the socket into an IIOP profile and cre-<br>ates an appropriate IOR. The details of the POA implementation</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:734"><nobr><span class="ft20">ProfileManager</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:709"><nobr><span class="ft20">+insertProfile: void</span></nobr></DIV>
<DIV style="position:absolute;top:211;left:709"><nobr><span class="ft20">+profileToObject:</span></nobr></DIV>
<DIV style="position:absolute;top:224;left:734"><nobr><span class="ft20">CORBA::Object</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:709"><nobr><span class="ft20">+objectToIor: IOR</span></nobr></DIV>
<DIV style="position:absolute;top:266;left:709"><nobr><span class="ft21">+iriToIor: IOR<br>+iorToIri: string</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:709"><nobr><span class="ft20">+narrow: CORBA::Object</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:528"><nobr><span class="ft20">ReferenceManager</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:482"><nobr><span class="ft21">+setObjID: void<br>+getObjID: string<br>+createNewIor: IOR</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:482"><nobr><span class="ft21">+registerProfileManager: void<br>+getProfileManager: ProfileManager<br>+getProfileManagers: ProfileManager[]</span></nobr></DIV>
<DIV style="position:absolute;top:288;left:482"><nobr><span class="ft21">+iorToObject: CORBA::Object<br>+objectToIor: IOR<br>+objectToIri: string<br>+iorToString: string<br>+stringToIor: IOR<br>+narrow: CORBA::Object</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:563"><nobr><span class="ft20">ORB</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:672"><nobr><span class="ft20">1</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:695"><nobr><span class="ft20">n</span></nobr></DIV>
<DIV style="position:absolute;top:389;left:502"><nobr><span class="ft7"><b>Figure 1: UML class diagram of the CORBA extension</b></span></nobr></DIV>
<DIV style="position:absolute;top:1092;left:438"><nobr><span class="ft3">71</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft22{font-size:8px;font-family:Helvetica;color:#000000;}
	.ft23{font-size:13px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="9004.png" alt="background image">
<DIV style="position:absolute;top:850;left:595"><nobr><span class="ft0">4</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:81"><nobr><span class="ft11">varies from ORB to ORB. In general, the registration at the POA<br>creates an IOR and an internal data structure containing all neces-<br>sary information for invocation handling.<br>To be as flexible as possible our extension completely separates the<br>creation of the IOR from the handling in a POA. The creation of an<br>IOR requires the invocation of </span></nobr></DIV>
<DIV style="position:absolute;top:524;left:257"><nobr><span class="ft19">createNewIor()</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:370"><nobr><span class="ft5"> at the refer-</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:81"><nobr><span class="ft11">ence manager. As standard CORBA is not able to clearly identify<br>object references referring to the same object, we added some oper-<br>ations to the reference manager that allow for integrating a univer-<br>sally unique identifier (UUID) into the IOR. The UUID is stored as<br>a tagged component and in principle can be used by any profile<br>manager.<br>For filling the IOR with profiles, an appropriate profile manager<br>must be identified. Operations at the reference manager allow the<br>retrieval of profile managers being able to handle a specific profile<br>type. A profile manager has to provide an operation </span></nobr></DIV>
<DIV style="position:absolute;top:680;left:360"><nobr><span class="ft19">insertPro-</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:81"><nobr><span class="ft19">file()</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:129"><nobr><span class="ft5"> that adds a profile of a specific type into a given IOR. This</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:81"><nobr><span class="ft14">operation has manager-dependent parameters so that each manager<br>is able to create its specific profile. Instead of creating the IOR it-<br>self, the POA of our extended ORB has to create the IOR by asking<br>the IIOP profile manger for adding the appropriate information<br>(host, port, POA name and object ID) to a newly created IOR. As<br>an object may be accessible by multiple profiles, an object adapter<br>can ask multiple profile managers for inserting profiles into an IOR.<br><b>Marshalling of object references</b></span></nobr></DIV>
<DIV style="position:absolute;top:819;left:269"><nobr><span class="ft5">. A CORBA object passed as a</span></nobr></DIV>
<DIV style="position:absolute;top:834;left:81"><nobr><span class="ft11">method parameter in a remote invocation needs to be serialised as<br>an IOR. In classic CORBA, this is done ,,magically" by the ORB by<br>accessing internal data structures. In the Java language mapping, for<br>example, a CORBA object reference is represented as a stub that<br>delegates to a sub-type of </span></nobr></DIV>
<DIV style="position:absolute;top:897;left:238"><nobr><span class="ft19">org.omg.CORBA.Delegate</span></nobr></DIV>
<DIV style="position:absolute;top:896;left:416"><nobr><span class="ft5">. In-</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:81"><nobr><span class="ft11">stances of this type store the IOR.<br>In our architecture, we cannot assume any specific implementation<br>of an object reference as each profile manager may need a different<br>one. Thus, there is no generic way to retrieve the IOR to be serial-<br>ised. Instead, the reference manager is asked to convert the object<br>reference into an IOR that in the end can be serialised. Therefore,<br>the reference manager provides an operation called </span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:385"><nobr><span class="ft19">object-</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:81"><nobr><span class="ft19">ToIor()</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:137"><nobr><span class="ft5">. The reference manager, in turn, will ask all known pro-</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:81"><nobr><span class="ft11">file managers to do the job. Profile managers will usually check<br>whether the object reference is an implementation of their middle-<br>ware extension. If so, the manager will know how to retrieve the</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:477"><nobr><span class="ft14">IOR. If not, the profile manager will return a null reference, and the<br>reference manager will turn to the next profile manager.<br><b>Unmarshalling of object references.</b></span></nobr></DIV>
<DIV style="position:absolute;top:476;left:690"><nobr><span class="ft5">If a standard ORB receives</span></nobr></DIV>
<DIV style="position:absolute;top:491;left:477"><nobr><span class="ft11">a serialised IOR as a method parameter or return result, it implicitly<br>converts it into a local representation and passes this representation<br>(typically a stub) to the application. This creation of the stub needs<br>to be factored out of the marshalling system of the ORB to handle<br>arbitrary reference types.<br>Our design delegates the object creation within unmarshalling to the<br>reference manager by calling </span></nobr></DIV>
<DIV style="position:absolute;top:583;left:646"><nobr><span class="ft19">iorToObject()</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:751"><nobr><span class="ft5">. The reference</span></nobr></DIV>
<DIV style="position:absolute;top:597;left:477"><nobr><span class="ft11">manager maintains an ordered list of profile types and correspond-<br>ing profile managers. According to this list, each profile manager is<br>asked to convert the IOR in a local representation by calling </span></nobr></DIV>
<DIV style="position:absolute;top:628;left:805"><nobr><span class="ft19">pro-</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:477"><nobr><span class="ft19">fileToObject()</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:590"><nobr><span class="ft5">. This way the reference manager already anal-</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:477"><nobr><span class="ft14">yses the contents of the IOR and only asks those managers that are<br>likely to be able to convert the IOR into an object reference. A pro-<br>file manager checks the profile and the tagged components, and<br>tries to create a local representation of the object reference. For ex-<br>ample, an IIOP profile manager will analyse the IIOP profile. A<br>CORBA-compliant stub is created and initialised with the IOR. The<br>stub is returned to the reference manager, which returns it to the ap-<br>plication. If a profile manager is not able to convert the profile or<br>not able to contact the object for arbitrary reasons, it will throw an<br>exception. In this case the reference manager will follow its list and<br>ask the next profile manager. If none of the managers can deal with<br>the IOR, an exception is thrown to the caller. This is compatible<br>with standard CORBA for the case that no profile is understood by<br>the ORB.<br>The order of profile types and managers defines the ORB-depend-<br>ent strategy of referencing objects. As the first matching profile<br>type and manager wins, generic managers (e.g., for IIOP) should be<br>at the end of the list whereas more specific managers should be at<br>the beginning.<br><b>Explicit binding to remote references.</b></span></nobr></DIV>
<DIV style="position:absolute;top:944;left:707"><nobr><span class="ft5">A user application may</span></nobr></DIV>
<DIV style="position:absolute;top:960;left:477"><nobr><span class="ft5">explicitly call the ORB method </span></nobr></DIV>
<DIV style="position:absolute;top:960;left:647"><nobr><span class="ft17">string_to_object</span></nobr></DIV>
<DIV style="position:absolute;top:960;left:790"><nobr><span class="ft5">, passing</span></nobr></DIV>
<DIV style="position:absolute;top:975;left:477"><nobr><span class="ft10">some kind of stringified representation of the references. Usually,<br>this may either be a string representation of the marshalled IOR, or<br>a <i>corbaloc</i> or <i>corbaname</i> URI.<br>This ORB operation can be split into two steps: First, the string is<br>parsed and converted into an IOR object. As the stringified IOR can<br>have an extension-specific IRI format--an IRI is the international-<br>ised version of an URI--each profile manager is asked for conver-</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:308"><nobr><span class="ft7"><b>Figure 2: Sequence chart for ORB::object_to_string</b></span></nobr></DIV>
<DIV style="position:absolute;top:191;left:455"><nobr><span class="ft22">objectToIor</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:507"><nobr><span class="ft22">objectToIor</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:338"><nobr><span class="ft22">objectToIor</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:203"><nobr><span class="ft22">object_to_string</span></nobr></DIV>
<DIV style="position:absolute;top:161;left:603"><nobr><span class="ft22">:ProfileManager2</span></nobr></DIV>
<DIV style="position:absolute;top:161;left:491"><nobr><span class="ft22">:ProfileManager1</span></nobr></DIV>
<DIV style="position:absolute;top:132;left:292"><nobr><span class="ft22">:ORB</span></nobr></DIV>
<DIV style="position:absolute;top:132;left:380"><nobr><span class="ft22">:ReferenceManager</span></nobr></DIV>
<DIV style="position:absolute;top:308;left:326"><nobr><span class="ft22">return IOR string</span></nobr></DIV>
<DIV style="position:absolute;top:323;left:202"><nobr><span class="ft22">return IOR string</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:510"><nobr><span class="ft22">return IOR</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:458"><nobr><span class="ft22">return null</span></nobr></DIV>
<DIV style="position:absolute;top:1091;left:439"><nobr><span class="ft23">72</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft24{font-size:9px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="9005.png" alt="background image">
<DIV style="position:absolute;top:850;left:595"><nobr><span class="ft0">5</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft5">sion by using </span></nobr></DIV>
<DIV style="position:absolute;top:109;left:156"><nobr><span class="ft19">iriToIor()</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:237"><nobr><span class="ft5">. The generic IOR format will be han-</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:81"><nobr><span class="ft14">dled by the reference manager itself. Second, this IOR object is con-<br>verted into a local representation using the same process as used<br>with unmarshalling.<br>Calling </span></nobr></DIV>
<DIV style="position:absolute;top:173;left:127"><nobr><span class="ft19">object_to_string()</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:272"><nobr><span class="ft5"> is handled in a similar way.</span></nobr></DIV>
<DIV style="position:absolute;top:188;left:81"><nobr><span class="ft11">First, the reference passed as parameter is converted into an IOR<br>object in the same way as for marshalling. Second, the IOR object<br>is converted into a string. The IOR is encoded as a hex string repre-<br>senting an URI in the IOR schema. The complete interaction is<br>shown as sequence chart in Fig. 2.<br>As sometimes an application may want to convert an object refer-<br>ence into a more-readable IRI, our extension also provides an oper-<br>ation called </span></nobr></DIV>
<DIV style="position:absolute;top:301;left:146"><nobr><span class="ft19">objectToIri()</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:252"><nobr><span class="ft5">. In a first step, the object reference</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:81"><nobr><span class="ft11">is once again converted into an IOR. The second step, the conver-<br>sion into an IRI, is done with the help of the profile managers by in-<br>voking </span></nobr></DIV>
<DIV style="position:absolute;top:349;left:124"><nobr><span class="ft19">iorToIri()</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:204"><nobr><span class="ft5">. Those may provide profile-specific URL</span></nobr></DIV>
<DIV style="position:absolute;top:364;left:81"><nobr><span class="ft14">schemes that may not be compatible to standard CORBA. As the<br>conversion of an IRI into an object reference can be handled in the<br>profile manager this is not a problem.<br><b>Narrow operation.</b></span></nobr></DIV>
<DIV style="position:absolute;top:412;left:197"><nobr><span class="ft5">The narrow operation is difficult to imple-</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:81"><nobr><span class="ft14">ment. In the Java language mapping the operation is located in a<br>helper class of the appropriate type, expecting an object reference<br>of arbitrary other type. The implementation in a standard ORB as-<br>sumes an instance compatible to the basic stub class, which knows<br>a delegate to handle the actual invocations. After successfully<br>checking the type conformance, the helper class will create a new<br>stub instance of the appropriate type and connect it to the same del-<br>egate. With any CORBA extension it cannot be assumed that object<br>references conform to the basic stub class.<br>In our extension the helper class invokes the operation </span></nobr></DIV>
<DIV style="position:absolute;top:573;left:377"><nobr><span class="ft19">narrow()</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:81"><nobr><span class="ft11">at the reference manager. Beside the existing object reference a<br>qualified type name of the new type is passed to the operation as a<br>string. The reference manager once again will call every profile<br>manager for the narrow operation. A profile manager can check<br>whether the object reference belongs to its CORBA extension. If<br>yes, the manager will take care of the narrow operation. If not, a null<br>result is returned and the reference manager will turn to the next<br>profile manager.<br>As a profile manager has to create a type-specific instance, it can<br>use the passed type name to create that instance. In languages that<br>provide a reflection API (e.g., Java) this is not difficult to realise. In<br>other languages a generic implementation in a profile manager may<br>be impossible. Another drawback is that reflection is not very effi-<br>cient. An alternative implementation is the placement of profile-<br>specific code into the helper class (or in other classes and functions<br>of other language mappings). Our own IDL compiler called<br>IDLflex [8] can easily be adapted to generate slightly different help-<br>er classes. As a compromise helper classes may have profile-specif-<br>ic code for the most likely profiles, but if other profiles are used, the<br>above mentioned control flow through reference and profile manag-<br>ers is used. Thus, most object references can be narrowed very fast<br>and the ORB is still open to object-reference implementations of<br>profile managers that may have even be downloaded on demand.</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:81"><nobr><span class="ft4"><b>4. EXTENSIONS TO CORBA BASED ON </b></span></nobr></DIV>
<DIV style="position:absolute;top:996;left:102"><nobr><span class="ft4"><b>PROFILE MANAGERS</b></span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:81"><nobr><span class="ft11">This section illustrates two applications of our design. The first ex-<br>ample presents the AspectIX profile manager, which integrates<br>fragmented object into a CORBA middleware. The second exam-<br>ples provides a transparent gateway from CORBA to Jini.</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:477"><nobr><span class="ft4"><b>4.1 AspectIX Profile Manager</b></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:477"><nobr><span class="ft14">The AspectIX middleware supports a fragmented object model<br>[4,7]. Unlike the traditional RPC-based client-server model, the<br>fragmented object model does no longer distinguish between client<br>stubs and the server object. From an abstract point of view, a frag-<br>mented object is an entity with unique identity, interface, behav-<br>iour, and state, as in classic object-oriented design. The implemen-<br>tation, however, is not bound to a certain location, but may be dis-<br>tributed arbitrarily over various fragments. Any client that wants to<br>access the fragmented object needs a local fragment, which pro-<br>vides an interface identical to that of a traditional stub. This local<br>fragment may be specific for this object and this client. Two objects<br>with the same interface may lead to completely different local frag-<br>ments.<br>This internal structure gives a high degree of freedom on where<br>state and functionality of the object is located and how the interac-<br>tion between fragments is done. The internal distribution and inter-<br>action is not only transparent on the external interface, but may<br>even change dynamically at run-time. Fragmented objects can eas-<br>ily simulate the traditional client-server structure by using the same<br>fragment type at all client locations that works as a simple stub.<br>Similarly, the fragmented object model allows a simple implemen-<br>tation of smart proxies by using the smart proxy as fragment type<br>for all clients. Moreover, this object model allows arbitrary internal<br>configurations that partition the object, migrate it dynamically, or<br>replicate it for fault-tolerance reasons. Finally, the communication<br>between fragments may be arbitrarily adjusted, e.g., to ensure qual-<br>ity-of-service properties or use available special-purpose communi-<br>cation mechanisms. All of these mechanisms are fully encapsulated<br>in the fragmented objects and are not directly visible on the outer<br>interface that all client application use.<br>Supporting a fragmented object model is clearly an extension to the<br>CORBA object model. With our architecture it is very easy to inte-<br>grate the new model. Just a new profile manager has to be devel-<br>oped and plugged into our ORB. When a client binds to a fragment-<br>ed object, a more complex task than simply loading a local stub is<br>needed. In our system, the local fragment is internally composed of<br>three components, as shown in Fig. 3: the <i>View</i>, the <i>Fragment In-<br>terface (FIfc)</i>, and the <i>Fragment Implementation (FImpl)</i>. The frag-<br>ment implementation is the actual code that provides the fragment<br>behaviour. The fragment interface is the interface that the client us-<br>es. Due to type casts, a client may have more than one interface in-<br>stance for the same fragmented object. Interfaces are instantiated in<br>CORBA </span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:526"><nobr><span class="ft17">narrow</span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:580"><nobr><span class="ft5"> operations; all existing interfaces delegate invo-</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:477"><nobr><span class="ft11">cations to the same implementation. The <i>View</i> is responsible for all<br>management tasks; it stores the object ID and IOR, keeps track of<br>all existing interfaces, and manages dynamical reconfigurations<br>that exchange the local <i>FImpl</i>. The management needs to update all</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:608"><nobr><span class="ft3">Fragment</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:515"><nobr><span class="ft3">Client</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:625"><nobr><span class="ft24">Fragment</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:638"><nobr><span class="ft24">Interface</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:689"><nobr><span class="ft24">View</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:689"><nobr><span class="ft24">Fragment</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:689"><nobr><span class="ft24">Implementation</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:542"><nobr><span class="ft7"><b>Figure 3: Internal structure of a fragment</b></span></nobr></DIV>
<DIV style="position:absolute;top:1090;left:437"><nobr><span class="ft3">73</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="9006.png" alt="background image">
<DIV style="position:absolute;top:850;left:595"><nobr><span class="ft0">6</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft10">references from <i>FIfcs</i> to the <i>FImpl</i> and has to coordinate method in-<br>vocations at the object that run concurrently to reconfigurations.<br>To integrate such a model into a profile-manager-aware CORBA<br>system, it is necessary to create IORs with a special profile for frag-<br>mented objects (APX profile), and to instantiate the local fragment<br>(<i>View-FImpl-FIfc</i>) when a client implicitly or explicitly binds to<br>such an IOR. <br>The IOR creation is highly application specific, thus it is not fully<br>automatic as in traditional CORBA. Instead, the developer of the<br>fragmented object may explicitly define, which information needs<br>to be present in the object. The reference manager creates an empty<br>IOR for a specified IDL type, and subsequently the APX profile<br>manager can be used to add a APX profile to this IOR. This profile<br>usually consists of information about the initial <i>FImpl</i> type that a<br>client needs to load and contact information on how to communi-<br>cate with other fragments of the fragmented object. The initial <i>FIm-<br>pl</i> type may be specified as a simple Java class name in a Java-only<br>environment, or as a DLS name (dynamic loading service, [3]) in a<br>heterogeneous environment, to dynamically load the object-specif-<br>ic local fragment implementation. The contact information may,<br>e.g., indicate a unique ID, which is used to retrieve contact address-<br>es from a location service) or a multicast address for a fragmented<br>object that uses network multicast for internal communication. <br>When an ORB binds to an IOR with an APX profile, the corre-<br>sponding profile manager first checks, if a fragment of the specific<br>object already exists; if so, a reference to the existing local fragment<br>is returned. Otherwise, a new default view is created and connected<br>to a newly instantiated <i>FImpl</i>. Profile information specifies how<br>this <i>FImpl</i> is loaded (direct Java class name for Java-only environ-<br>ments, a code factory reference, or a unique ID for lookup to the<br>global dynamic loading service (DLS)). Finally, a default interface<br>is built and returned to the client application.</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:81"><nobr><span class="ft4"><b>4.2 Jini Profile Manager</b></span></nobr></DIV>
<DIV style="position:absolute;top:630;left:81"><nobr><span class="ft10">Jini is a Java-based open software architecture for network-centric<br>solutions that are highly adaptive to change [9]. It extends the Java<br>programming model with support for code mobility in the net-<br>works; leasing techniques enables self-healing and self-configura-<br>tion of the network. The Jini architecture defines a way for clients<br>and servers to find each other on the network. Service providers<br>supply clients with portable Java objects that implement the remote<br>access to the service. This interaction can use any kind of technolo-<br>gy such as Java RMI, SOAP, or CORBA.<br>The goal of this CORBA extension is to seamlessly integrate Jini<br>services into CORBA. Jini services should be accessible to CORBA<br>clients like any other CORBA object. Jini services offer a Java in-<br>terface. This interface can be converted into an IDL interface using<br>the Java-to-IDL mapping from the OMG [6]. Our CORBA exten-<br>sion provides CORBA-compatible representatives, special proxy<br>objects that appear as CORBA object references, but forward invo-<br>cations to a Jini service. Such references to Jini services can be reg-<br>istered in a CORBA naming service and can be passed as parame-<br>ters to any other CORBA object. CORBA clients do not have to<br>know that those references refer to Jini services.<br>The reference to a Jini service is represented as a CORBA IOR. The<br>Jini profile manager offers operations to create a special Jini profile<br>that refers to a Jini service. It provides operations to marshal refer-<br>ences to such services by retrieving the original IOR from the spe-<br>cialised proxy, to unmarshal IORs to a newly created proxy, and to<br>type cast a proxy to another IDL type.<br>The Jini profile stores a Jini service ID, and optionally a group name<br>and the network address of a Jini lookup service. The profile man-<br>ager uses automatic multicast-based discovery to find a set of<br>lookup services where Jini services usually have to register their</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:477"><nobr><span class="ft10">proxy objects. Those lookup services are asked for the proxy of the<br>service identified by the unique service ID. If an address of a lookup<br>service is given in the profile, the profile manager will only ask this<br>service for a proxy. The retrieved proxy is encapsulated in a wrap-<br>per object that on the outside looks like a CORBA object reference.<br>Inside, it maps parameters from their IDL types to the correspond-<br>ing Java types and forwards the invocation to the original Jini<br>proxy.<br>Jini services may provide a lease for service usage. In the IOR, a<br>method can be named that is supposed to retrieve a lease for the<br>service. This lease will be locally managed by the profile manager<br>and automatically extended if it is due to expire.<br>This extension shows that it is possible to encapsulate access to oth-<br>er middleware platforms inside of profile managers. In case of the<br>Jini profile manager our implementation is rather simple. So, return<br>parameters referring to other Jini services are not (yet) converted to<br>CORBA object references. We also did not yet implement Jini IOR<br>profiles that encapsulate abstract queries: In this case not a specific<br>service ID is stored in the profile, but query parameters for the<br>lookup at the lookup services. This way, it will be possible to create<br>IORs with abstract meaning, e.g., encapsulating a reference to the<br>nearest colour printer service (assumed that such services are regis-<br>tered as Jini services at a lookup service).</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:477"><nobr><span class="ft4"><b>5. EVALUATION</b></span></nobr></DIV>
<DIV style="position:absolute;top:493;left:477"><nobr><span class="ft11">Two aspects need to be discussed to evaluate our design: First, the<br>effort that is needed to integrate our concept into an existing ORB;<br>second, the run-time overhead that this approach introduces. As we<br>used JacORB as basis for our implementation, we compare our im-<br>plementation with the standard JacORB middleware.</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:477"><nobr><span class="ft4"><b>5.1 Implementation Cost</b></span></nobr></DIV>
<DIV style="position:absolute;top:608;left:477"><nobr><span class="ft14">The integration of a generic reference manager into JacORB ver-<br>sion 2.2 affected two classes: </span></nobr></DIV>
<DIV style="position:absolute;top:623;left:650"><nobr><span class="ft17">org.jacorb.orb.ORB</span></nobr></DIV>
<DIV style="position:absolute;top:624;left:812"><nobr><span class="ft5"> and</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:477"><nobr><span class="ft17">org.jacorb.orb.CDROutputStream</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:747"><nobr><span class="ft5">. In </span></nobr></DIV>
<DIV style="position:absolute;top:640;left:781"><nobr><span class="ft17">ORB</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:808"><nobr><span class="ft5">, the</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:477"><nobr><span class="ft5">methods </span></nobr></DIV>
<DIV style="position:absolute;top:656;left:532"><nobr><span class="ft17">object_to_string</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:676"><nobr><span class="ft5">, </span></nobr></DIV>
<DIV style="position:absolute;top:656;left:690"><nobr><span class="ft17">string_to_object</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:834"><nobr><span class="ft5">,</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:477"><nobr><span class="ft5">and </span></nobr></DIV>
<DIV style="position:absolute;top:673;left:500"><nobr><span class="ft17">_getObject</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:590"><nobr><span class="ft5"> (which is used for demarshalling) need to be</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:477"><nobr><span class="ft11">replaced. In addition, the reference manager is automatically loaded<br>at ORB initialisation and made available as initial reference. In</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:477"><nobr><span class="ft17">CDROutputStream</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:612"><nobr><span class="ft5">, the method </span></nobr></DIV>
<DIV style="position:absolute;top:719;left:682"><nobr><span class="ft17">write_Object</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:790"><nobr><span class="ft5"> needs to</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:477"><nobr><span class="ft11">be re-implemented to access the reference manager. These changes<br>amount to less than 100 lines of code (LOC). The generic reference<br>manager consists of about 500 LOC; the IIOP profile manager con-<br>tains 150 LOC in addition to the IIOP implementation reused from<br>JacORB.<br>These figures show that our design easily integrates into an existing<br>CORBA ORB. Moreover, the generic reference manager and pro-<br>file managers may be implemented fully independent of ORB inter-<br>nals, making them portable across ORBs of different vendors--<br>with the obvious restrictions to the same implementation program-<br>ming language.</span></nobr></DIV>
<DIV style="position:absolute;top:919;left:477"><nobr><span class="ft4"><b>5.2 Run-time Measurements of our Imple-</b></span></nobr></DIV>
<DIV style="position:absolute;top:940;left:506"><nobr><span class="ft4"><b>mentation</b></span></nobr></DIV>
<DIV style="position:absolute;top:961;left:477"><nobr><span class="ft10">We performed two experiments to evaluate the run-time cost of our<br>approach; all tests were done on Intel PC 2.66 GHz with Linux<br>2.4.27 operating system and Java 1.5.0, connected with a 100 MBit/<br>s LAN. In all cases, the generic reference manager in our ORB was<br>connected with three profile managers (IIOP, APX, Jini)<br>The first experiment examines the binding cost. For this purpose, a<br>stringified IOR of a simple CORBA servant with one IIOP profile<br>is generated. Then, this reference is repeatedly passed to the ORB</span></nobr></DIV>
<DIV style="position:absolute;top:1094;left:439"><nobr><span class="ft3">74</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft25{font-size:11px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="9007.png" alt="background image">
<DIV style="position:absolute;top:850;left:595"><nobr><span class="ft0">7</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:81"><nobr><span class="ft5">method </span></nobr></DIV>
<DIV style="position:absolute;top:109;left:124"><nobr><span class="ft17">string_to_object</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:268"><nobr><span class="ft5">, which parses the IOR and loads</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:81"><nobr><span class="ft25">a local client stub. Table 1 shows the average time per invocation of<br>100,000 iterations.</span></nobr></DIV>
<DIV style="position:absolute;top:303;left:81"><nobr><span class="ft11">The second test analyses the marshalling cost of remote references.<br>An empty remote method with one reference parameter is invoked<br>100,000 times. These operation involve first a serialisation of the<br>reference at client-side and afterwards a deserialisation and binding<br>at the servant side; all operations are delegated to the reference<br>manager in our ORB. Table 2 shows the results of this test. </span></nobr></DIV>
<DIV style="position:absolute;top:569;left:81"><nobr><span class="ft10">Both experiments show, that the increase in flexibility and extensi-<br>bility is paid for with a slight decrease in performance. It is to be<br>noted that our reference implementation has not yet been optimised<br>for performance, so further improvement might be possible. </span></nobr></DIV>
<DIV style="position:absolute;top:647;left:81"><nobr><span class="ft4"><b>6. CONCLUSION</b></span></nobr></DIV>
<DIV style="position:absolute;top:668;left:81"><nobr><span class="ft10">We have presented a novel, CORBA-compliant middleware archi-<br>tecture that is more flexible and extensible than standard CORBA.<br>It defines a portable reference manager that uses dynamically load-<br>able profile managers for different protocol profiles.<br>The concept is more flexible than traditional approaches. Unlike<br>smart proxies, it does not only modify the client-side behaviour, but<br>allows to modify the complete system structure. In contrast to ven-<br>dor-specific transport protocols, it provides a general extension to<br>CORBA that allows to implement portable profile managers, which<br>in the extreme may even be dynamically loaded as plug-in at run-<br>time. Different from CORBA portable interceptors, it gives the<br>service developer full control over the IOR creation process, has<br>less overhead than interceptors, and allows arbitrary modification<br>of client requests.<br>The concept itself is not limit to CORBA. In fact, it defines a gener-<br>ic design pattern for any existing and future middleware platforms.<br>Extracting all tasks related to the handling of remote references into<br>an extensible module allows to create middleware platforms that are</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:477"><nobr><span class="ft10">easily extended to meet even unanticipated future requirements.<br>Modern developments like ubiquitous computing, increased scala-<br>bility and reliability demands and so on make it likely that such ex-<br>tensions will be demanded. Our design principle allows to imple-<br>ment future systems with best efficiency and least implementation<br>effort.<br>We have presented in some detail two applications of our architec-<br>ture. Besides traditional IIOP for compliance with CORBA, we<br>have implemented a profile manager for fragmented objects and<br>one for accessing Jini services transparently as CORBA objects.<br>Currently, we are working on profile managers to handle fault-tol-<br>erant CORBA and a bridge to Java RMI.</span></nobr></DIV>
<DIV style="position:absolute;top:306;left:477"><nobr><span class="ft4"><b>7. REFERENCES</b></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:477"><nobr><span class="ft5">[1] G. Coulson, G. Blar, M. Clarke, N. Parlavantzas:<i> The design of </i></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:504"><nobr><span class="ft11"><i>a configurable and reconfigurable middleware platform.</i> <br>Distributed Computing 15(2): 2002, pp 109-126</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:477"><nobr><span class="ft5">[2] E. Gamma, R. Helm, R. Johnson, J. Vlissides: <i>Design </i></span></nobr></DIV>
<DIV style="position:absolute;top:397;left:504"><nobr><span class="ft10"><i>patterns</i>. Elements of reusable object-oriented software. <br>Addison-Wesley, 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:477"><nobr><span class="ft5">[3] R. Kapitza, F. Hauck: <i>DLS: a CORBA service for dynamic </i></span></nobr></DIV>
<DIV style="position:absolute;top:448;left:504"><nobr><span class="ft11"><i>loading of code</i>. Proc. of the OTM'03 Conferences; Springer, <br>LNCS 2888, 2003</span></nobr></DIV>
<DIV style="position:absolute;top:482;left:477"><nobr><span class="ft5">[4] M. Makpangou, Y. Gourhand, K.-P. Le Narzul, M. Shapiro: </span></nobr></DIV>
<DIV style="position:absolute;top:498;left:504"><nobr><span class="ft11"><i>Fragmented objects for distributed abstractions</i>. Readings in <br>Distr. Computing Systems, IEEE Comp. Society Press, 1994, <br>pp. 170-186</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:477"><nobr><span class="ft5">[5] Object Management Group:<i> Common object request broker </i></span></nobr></DIV>
<DIV style="position:absolute;top:563;left:504"><nobr><span class="ft11"><i>architecture: core specification, version 3.0.3</i>; OMG <br>specification formal/04-03-12, 2004</span></nobr></DIV>
<DIV style="position:absolute;top:597;left:477"><nobr><span class="ft5">[6] Object Management Group: <i>Java language mapping to OMG </i></span></nobr></DIV>
<DIV style="position:absolute;top:613;left:504"><nobr><span class="ft11"><i>IDL, version 1.3</i>; OMG specification formal/2003-09-04, <br>2003</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:477"><nobr><span class="ft5">[7] H. Reiser, F. Hauck, R. Kapitza, A. Schmied: <i>Integrating </i></span></nobr></DIV>
<DIV style="position:absolute;top:663;left:504"><nobr><span class="ft10"><i>fragmented objects into a CORBA environment</i>. Proc. of the <br>Net.ObjectDays, 2003</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:477"><nobr><span class="ft5">[8] H. Reiser, M. Steckermeier, F. Hauck: <i>IDLflex: A flexible and </i></span></nobr></DIV>
<DIV style="position:absolute;top:713;left:504"><nobr><span class="ft11"><i>generic compiler for CORBA IDL</i>. Proc. of the Net.Object <br>Days, Erfurt, 2001, pp 151-160</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:477"><nobr><span class="ft5">[9] Sun microsystems: <i>Jini technology architectural overview</i>. </span></nobr></DIV>
<DIV style="position:absolute;top:763;left:504"><nobr><span class="ft5">White paper, Jan 1999</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:477"><nobr><span class="ft5">[10] T. Vergnaud, J. Hugues, L. Pautet, F. Kordon: <i>PolyORB: a </i></span></nobr></DIV>
<DIV style="position:absolute;top:798;left:504"><nobr><span class="ft11"><i>schizophrenic middleware to build versatile reliable <br>distributed applications</i>. Proc. of the 9th Int. Conf. on Reliable <br>Software Technologies Ada-Europe 2004 (RST'04),; <br>Springer, LNCS 3063, 2004, pp 106-119</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:477"><nobr><span class="ft5">[11] N. Wang, K. Parameswaran, D. Schmidt: <i>The design and </i></span></nobr></DIV>
<DIV style="position:absolute;top:878;left:504"><nobr><span class="ft10"><i>performance of meta-programming mechanisms for object <br>request broker middleware</i>. Proc. of the 6th USENIX <br>Conference on Object-Oriented Techology and Systems <br>(COOTS'01), 2001</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:84"><nobr><span class="ft7"><b>Table 1: Execution time of ORB::string_to_object invocations</b></span></nobr></DIV>
<DIV style="position:absolute;top:207;left:88"><nobr><span class="ft5">Standard JacORB 2.2.1</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:344"><nobr><span class="ft5">0.22 ms</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:88"><nobr><span class="ft5">AspectIX ORB with reference manager</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:344"><nobr><span class="ft5">0.28 ms</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:137"><nobr><span class="ft5">Overhead</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:344"><nobr><span class="ft5">0.06 ms (27%)</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:86"><nobr><span class="ft7"><b>Table 2: Complete remote invocation time with one reference </b></span></nobr></DIV>
<DIV style="position:absolute;top:441;left:231"><nobr><span class="ft7"><b>parameter</b></span></nobr></DIV>
<DIV style="position:absolute;top:472;left:88"><nobr><span class="ft5">Standard JacORB 2.2.1</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:344"><nobr><span class="ft5">0.64 ms</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:88"><nobr><span class="ft5">AspectIX ORB with reference manager</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:344"><nobr><span class="ft5">0.72 ms</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:137"><nobr><span class="ft5">Overhead</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:344"><nobr><span class="ft5">0.08 ms (12.5%)</span></nobr></DIV>
<DIV style="position:absolute;top:1093;left:437"><nobr><span class="ft3">75</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
