<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>D:\Paper\HTML\170</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2006-11-21T09:37:58+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:22px;font-family:Times;color:#000000;}
	.ft1{font-size:14px;font-family:Times;color:#000000;}
	.ft2{font-size:11px;font-family:Times;color:#000000;}
	.ft3{font-size:15px;font-family:Times;color:#000000;}
	.ft4{font-size:12px;font-family:Times;color:#000000;}
	.ft5{font-size:8px;font-family:Times;color:#000000;}
	.ft6{font-size:16px;font-family:Courier;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:12px;line-height:16px;font-family:Times;color:#000000;}
	.ft9{font-size:8px;line-height:11px;font-family:Times;color:#000000;}
	.ft10{font-size:8px;line-height:12px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="170001.png" alt="background image">
<DIV style="position:absolute;top:138;left:89"><nobr><span class="ft0"><b>Run-Time Dynamic Linking for Reprogramming Wireless Sensor</b></span></nobr></DIV>
<DIV style="position:absolute;top:165;left:405"><nobr><span class="ft0"><b>Networks</b></span></nobr></DIV>
<DIV style="position:absolute;top:230;left:243"><nobr><span class="ft1">Adam Dunkels, Niclas Finne, Joakim Eriksson, Thiemo Voigt</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:233"><nobr><span class="ft2">Swedish Institute of Computer Science, Box 1263, SE-16429 Kista, Sweden</span></nobr></DIV>
<DIV style="position:absolute;top:266;left:234"><nobr><span class="ft1">adam@sics.se, nfi@sics.se, joakime@sics.se, thiemo@sics.se</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:81"><nobr><span class="ft3"><b>Abstract</b></span></nobr></DIV>
<DIV style="position:absolute;top:361;left:99"><nobr><span class="ft4">From experience with wireless sensor networks it has be-</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:81"><nobr><span class="ft8">come apparent that dynamic reprogramming of the sensor<br>nodes is a useful feature. The resource constraints in terms of<br>energy, memory, and processing power make sensor network<br>reprogramming a challenging task. Many different mecha-<br>nisms for reprogramming sensor nodes have been developed<br>ranging from full image replacement to virtual machines.</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:99"><nobr><span class="ft4">We have implemented an in-situ run-time dynamic linker</span></nobr></DIV>
<DIV style="position:absolute;top:495;left:81"><nobr><span class="ft8">and loader that use the standard ELF object file format. We<br>show that run-time dynamic linking is an effective method<br>for reprogramming even resource constrained wireless sen-<br>sor nodes. To evaluate our dynamic linking mechanism we<br>have implemented an application-specific virtual machine<br>and a Java virtual machine and compare the energy cost of<br>the different linking and execution models. We measure the<br>energy consumption and execution time overhead on real<br>hardware to quantify the energy costs for dynamic linking.</span></nobr></DIV>
<DIV style="position:absolute;top:645;left:99"><nobr><span class="ft4">Our results suggest that while in general the overhead of a</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:81"><nobr><span class="ft8">virtual machine is high, a combination of native code and vir-<br>tual machine code provide good energy efficiency. Dynamic<br>run-time linking can be used to update the native code, even<br>in heterogeneous networks.</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:81"><nobr><span class="ft3"><b>Categories and Subject Descriptors</b></span></nobr></DIV>
<DIV style="position:absolute;top:762;left:99"><nobr><span class="ft4">C.2.4 [Computer Communication Networks]:</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:415"><nobr><span class="ft4">Dis-</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:81"><nobr><span class="ft4">tributed Systems--Network Operating Systems</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:81"><nobr><span class="ft3"><b>General Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:830;left:99"><nobr><span class="ft4">Design, Experimentation, Measurement, Performance</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:81"><nobr><span class="ft3"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:881;left:99"><nobr><span class="ft4">Wireless sensor networks, Embedded systems, Operating</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:81"><nobr><span class="ft4">systems, Dynamic linking, Virtual machines</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:81"><nobr><span class="ft9">Permission to make digital or hard copies of all or part of this work for personal or<br>classroom use is granted without fee provided that copies are not made or distributed<br>for profit or commercial advantage and that copies bear this notice and the full citation<br>on the first page. To copy otherwise, to republish, to post on servers or to redistribute<br>to lists, requires prior specific permission and/or a fee.<br>SenSys'06, November 1­3, 2006, Boulder, Colorado, USA.<br>Copyright 2006 ACM 1-59593-343-3/06/0011 ...$5.00</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:477"><nobr><span class="ft3"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:339;left:504"><nobr><span class="ft3"><b>Introduction</b></span></nobr></DIV>
<DIV style="position:absolute;top:360;left:495"><nobr><span class="ft4">Wireless sensor networks consist of a collection of pro-</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:477"><nobr><span class="ft8">grammable radio-equipped embedded systems. The behav-<br>ior of a wireless sensor network is encoded in software run-<br>ning on the wireless sensor network nodes. The software in<br>deployed wireless sensor network systems often needs to be<br>changed, both to update the system with new functionality<br>and to correct software bugs. For this reason dynamically<br>reprogramming of wireless sensor network is an important<br>feature. Furthermore, when developing software for wire-<br>less sensor networks, being able to update the software of a<br>running sensor network greatly helps to shorten the develop-<br>ment time.</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:495"><nobr><span class="ft4">The limitations of communication bandwidth, the limited</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:477"><nobr><span class="ft8">energy of the sensor nodes, the limited sensor node memory<br>which typically is on the order of a few thousand bytes large,<br>the absence of memory mapping hardware, and the limited<br>processing power make reprogramming of sensor network<br>nodes challenging.</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:495"><nobr><span class="ft4">Many different methods for reprogramming sensor nodes</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:477"><nobr><span class="ft8">have been developed, including full system image replace-<br>ment [14, 16], approaches based on binary differences [15,<br>17, 31], virtual machines [18, 19, 20], and loadable na-<br>tive code modules in the first versions of Contiki [5] and<br>SOS [12]. These methods are either inefficient in terms of<br>energy or require non-standard data formats and tools.</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:495"><nobr><span class="ft4">The primary contribution of this paper is that we inves-</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:477"><nobr><span class="ft8">tigate the use of standard mechanisms and file formats for<br>reprogramming sensor network nodes. We show that in-situ<br>dynamic run-time linking and loading of native code using<br>the ELF file format, which is a standard feature on many op-<br>erating systems for PC computers and workstations, is fea-<br>sible even for resource-constrained sensor nodes. Our sec-<br>ondary contribution is that we measure and quantify the en-<br>ergy costs of dynamic linking and execution of native code<br>and compare it to the energy cost of transmission and execu-<br>tion of code for two virtual machines: an application-specific<br>virtual machine and the Java virtual machine.</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:495"><nobr><span class="ft4">We have implemented a dynamic linker in the Contiki op-</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:477"><nobr><span class="ft8">erating system that can link, relocate, and load standard ELF<br>object code files. Our mechanism is independent of the par-<br>ticular microprocessor architecture on the sensor nodes and<br>we have ported the linker to two different sensor node plat-<br>forms with only minor modifications to the architecture de-<br>pendent module of the code.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">15</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft11{font-size:15px;line-height:18px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="170002.png" alt="background image">
<DIV style="position:absolute;top:113;left:99"><nobr><span class="ft4">To evaluate the energy costs of the dynamic linker we im-</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:81"><nobr><span class="ft8">plement an application specific virtual machine for Contiki<br>together with a compiler for a subset of Java. We also adapt<br>the Java virtual machine from the lejOS system [8] to run un-<br>der Contiki. We measure the energy cost of reprogramming<br>and executing a set of program using dynamic linking of na-<br>tive code and the two virtual machines. Using the measure-<br>ments and a simple energy consumption model we calculate<br>break-even points for the energy consumption of the differ-<br>ent mechanisms. Our results suggest that while the execution<br>time overhead of a virtual machine is high, a combination of<br>native code and virtual machine code may give good energy<br>efficiency.</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:99"><nobr><span class="ft4">The remainder of this paper is structured as follows. In</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:81"><nobr><span class="ft8">Section 2 we discuss different scenarios in which reprogram-<br>ming is useful. Section 3 presents a set of mechanisms for<br>executing code inside a sensor node and in Section 4 we dis-<br>cuss loadable modules and the process of linking, relocat-<br>ing, and loading native code. Section 5 describes our imple-<br>mentation of dynamic linking and our virtual machines. Our<br>experiments and the results are presented in Section 6 and<br>discuss the results in Section 7. Related work is reviewed in<br>Section 8. Finally, we conclude the paper in Section 9.</span></nobr></DIV>
<DIV style="position:absolute;top:495;left:81"><nobr><span class="ft3"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:495;left:108"><nobr><span class="ft3"><b>Scenarios for Software Updates</b></span></nobr></DIV>
<DIV style="position:absolute;top:516;left:99"><nobr><span class="ft4">Software updates for sensor networks are necessary for a</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:81"><nobr><span class="ft8">variety of reasons ranging from implementation and testing<br>of new features of an existing program to complete repro-<br>gramming of sensor nodes when installing new applications.<br>In this section we review a set of typical reprogramming sce-<br>narios and compare their qualitative properties.</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:81"><nobr><span class="ft3"><b>2.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:617;left:121"><nobr><span class="ft3"><b>Software Development</b></span></nobr></DIV>
<DIV style="position:absolute;top:636;left:99"><nobr><span class="ft4">Software development is an iterative process where code</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:81"><nobr><span class="ft8">is written, installed, tested, and debugged in a cyclic fash-<br>ion. Being able to dynamically reprogram parts of the sensor<br>network system helps shorten the time of the development<br>cycle. During the development cycle developers typically<br>change only one part of the system, possibly only a single<br>algorithm or a function. A sensor network used for soft-<br>ware development may therefore see large amounts of small<br>changes to its code.</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:81"><nobr><span class="ft3"><b>2.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:787;left:121"><nobr><span class="ft3"><b>Sensor Network Testbeds</b></span></nobr></DIV>
<DIV style="position:absolute;top:806;left:99"><nobr><span class="ft4">Sensor network testbeds are an important tool for devel-</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:81"><nobr><span class="ft8">opment and experimentation with sensor network applica-<br>tions. New applications can be tested in a realistic setting<br>and important measurements can be obtained [36]. When a<br>new application is to be tested in a testbed the application<br>typically is installed in the entire network. The application<br>is then run for a specified time, while measurements are col-<br>lected both from the sensors on the sensor nodes, and from<br>network traffic.</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:99"><nobr><span class="ft4">For testbeds that are powered from a continuous energy</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:81"><nobr><span class="ft8">source, the energy consumption of software updates is only<br>of secondary importance. Instead, qualitative properties such<br>as ease of use and flexibility of the software update mecha-<br>nism are more important. Since the time required to make an<br>update is important, the throughput of a network-wide soft-<br>ware update is of importance. As the size of the transmitted<br>binaries impact the throughput, the binary size still can be</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:583"><nobr><span class="ft2">Update</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:654"><nobr><span class="ft2">Update</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:714"><nobr><span class="ft2">Update</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:771"><nobr><span class="ft2">Program</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:518"><nobr><span class="ft2">Scenario</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:583"><nobr><span class="ft2">frequency</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:654"><nobr><span class="ft2">fraction</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:714"><nobr><span class="ft2">level</span></nobr></DIV>
<DIV style="position:absolute;top:125;left:771"><nobr><span class="ft2">longevity</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:493"><nobr><span class="ft2">Development</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:583"><nobr><span class="ft2">Often</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:654"><nobr><span class="ft2">Small</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:714"><nobr><span class="ft2">All</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:771"><nobr><span class="ft2">Short</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:518"><nobr><span class="ft2">Testbeds</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:583"><nobr><span class="ft2">Seldom</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:654"><nobr><span class="ft2">Large</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:714"><nobr><span class="ft2">All</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:771"><nobr><span class="ft2">Long</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:514"><nobr><span class="ft2">Bug fixes</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:583"><nobr><span class="ft2">Seldom</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:654"><nobr><span class="ft2">Small</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:714"><nobr><span class="ft2">All</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:771"><nobr><span class="ft2">Long</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:513"><nobr><span class="ft2">Reconfig.</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:583"><nobr><span class="ft2">Seldom</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:654"><nobr><span class="ft2">Small</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:714"><nobr><span class="ft2">App</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:771"><nobr><span class="ft2">Long</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:515"><nobr><span class="ft2">Dynamic</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:501"><nobr><span class="ft2">Application</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:583"><nobr><span class="ft2">Often</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:654"><nobr><span class="ft2">Small</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:714"><nobr><span class="ft2">App</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:771"><nobr><span class="ft2">Long</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:477"><nobr><span class="ft8">Table 1. Qualitative comparison between different repro-<br>gramming scenarios.</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:477"><nobr><span class="ft8">used as an evaluation metric for systems where throughput is<br>more important than energy consumption.</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:477"><nobr><span class="ft3"><b>2.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:335;left:517"><nobr><span class="ft3"><b>Correction of Software Bugs</b></span></nobr></DIV>
<DIV style="position:absolute;top:355;left:495"><nobr><span class="ft4">The need for correcting software bugs in sensor networks</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:477"><nobr><span class="ft8">was early identified [7]. Even after careful testing, new bugs<br>can occur in deployed sensor networks caused by, for ex-<br>ample, an unexpected combination of inputs or variable link<br>connectivity that stimulate untested control paths in the com-<br>munication software [30].</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:495"><nobr><span class="ft4">Software bugs can occur at any level of the system. To</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:477"><nobr><span class="ft8">correct bugs it must therefore be possible to reprogram all<br>parts of the system.</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:477"><nobr><span class="ft3"><b>2.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:509;left:517"><nobr><span class="ft3"><b>Application Reconfiguration</b></span></nobr></DIV>
<DIV style="position:absolute;top:529;left:495"><nobr><span class="ft4">In an already installed sensor network, the application</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:477"><nobr><span class="ft8">may need to be reconfigured. This includes change of pa-<br>rameters, or small changes in the application such as chang-<br>ing from absolute temperature readings to notification when<br>thresholds are exceeded [26]. Even though reconfiguration<br>not necessarily include software updates [25], application re-<br>configuration can be done by reprogramming the application<br>software. Hence software updates can be used in an applica-<br>tion reconfiguration scenario.</span></nobr></DIV>
<DIV style="position:absolute;top:683;left:477"><nobr><span class="ft3"><b>2.5</b></span></nobr></DIV>
<DIV style="position:absolute;top:683;left:517"><nobr><span class="ft3"><b>Dynamic Applications</b></span></nobr></DIV>
<DIV style="position:absolute;top:702;left:495"><nobr><span class="ft4">There are many situations where it is useful to replace the</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:477"><nobr><span class="ft8">application software of an already deployed sensor network.<br>One example is the forest fire detection scenario presented by<br>Fok et al. [9] where a sensor network is used to detect a fire.<br>When the fire detection application has detected a fire, the<br>fire fighters might want to run a search and rescue applica-<br>tion as well as a fire tracking application. While it may possi-<br>ble to host these particular applications on each node despite<br>the limited memory of the sensor nodes, this approach is not<br>scalable [9]. In this scenario, replacing the application on the<br>sensor nodes leads to a more scalable system.</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:477"><nobr><span class="ft3"><b>2.6</b></span></nobr></DIV>
<DIV style="position:absolute;top:889;left:517"><nobr><span class="ft3"><b>Summary</b></span></nobr></DIV>
<DIV style="position:absolute;top:909;left:495"><nobr><span class="ft4">Table 1 compares the different scenarios and their prop-</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:477"><nobr><span class="ft8">erties. Update fraction refers to what amount of the system<br>that needs to be updated for every update, update level to<br>at what levels of the system updates are likely to occur, and<br>program longevity to how long an installed program will be<br>expected to reside on the sensor node.</span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:477"><nobr><span class="ft3"><b>3</b></span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:504"><nobr><span class="ft11"><b>Code Execution Models and<br>Reprogramming</b></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:495"><nobr><span class="ft4">Many different execution models and environments have</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:477"><nobr><span class="ft4">been developed or adapted to run on wireless sensor nodes.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">16</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="170003.png" alt="background image">
<DIV style="position:absolute;top:113;left:81"><nobr><span class="ft8">Some with the notion of facilitating programming [1], oth-<br>ers motivated by the potential of saving energy costs for re-<br>programming enabled by the compact code representation of<br>virtual machines [19]. The choice of the execution model<br>directly impacts the data format and size of the data that<br>needs to be transported to a node. In this section we dis-<br>cuss three different mechanisms for executing program code<br>inside each sensor node: script languages, virtual machines,<br>and native code.</span></nobr></DIV>
<DIV style="position:absolute;top:266;left:81"><nobr><span class="ft3"><b>3.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:266;left:121"><nobr><span class="ft3"><b>Script Languages</b></span></nobr></DIV>
<DIV style="position:absolute;top:286;left:99"><nobr><span class="ft4">There are many examples of script languages for em-</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:81"><nobr><span class="ft8">bedded systems, including BASIC variants, Python inter-<br>preters [22], and TCL machines [1]. However, most script<br>interpreters target platforms with much more resources than<br>our target platforms and we have therefore not included them<br>in our comparison.</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:81"><nobr><span class="ft3"><b>3.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:390;left:121"><nobr><span class="ft3"><b>Virtual Machines</b></span></nobr></DIV>
<DIV style="position:absolute;top:410;left:99"><nobr><span class="ft4">Virtual machines are a common approach to reduce the</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:81"><nobr><span class="ft8">cost of transmitting program code in situations where the<br>cost of distributing a program is high. Typically, program<br>code for a virtual machine can be made more compact than<br>the program code for the physical machine. For this reason<br>virtual machines are often used for programming sensor net-<br>works [18, 19, 20, 23].</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:99"><nobr><span class="ft4">While many virtual machines such as the Java virtual ma-</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:81"><nobr><span class="ft8">chine are generic enough to perform well for a variety of<br>different types of programs, most virtual machines for sen-<br>sor networks are designed to be highly configurable in order<br>to allow the virtual machine to be tailored for specific ap-<br>plications. In effect, this means that parts of the application<br>code is implemented as virtual machine code running on the<br>virtual machine, and other parts of the application code is im-<br>plemented in native code that can be used from the programs<br>running on the virtual machine.</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:81"><nobr><span class="ft3"><b>3.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:696;left:121"><nobr><span class="ft3"><b>Native Code</b></span></nobr></DIV>
<DIV style="position:absolute;top:716;left:99"><nobr><span class="ft4">The most straightforward way to execute code on sensor</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:81"><nobr><span class="ft8">nodes is by running native code that is executed directly by<br>the microcontroller of the sensor node. Installing new native<br>code on a sensor node is more complex than installing code<br>for a virtual machine because the native code uses physical<br>addresses which typically need to be updated before the pro-<br>gram can be executed. In this section we discuss two widely<br>used mechanisms for reprogramming sensor nodes that ex-<br>ecute native code: full image replacement and approaches<br>based on binary differences.</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:81"><nobr><span class="ft1">3.3.1</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:130"><nobr><span class="ft1">Full Image Replacement</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:99"><nobr><span class="ft4">The most common way to update software in embedded</span></nobr></DIV>
<DIV style="position:absolute;top:921;left:81"><nobr><span class="ft8">systems and sensor networks is to compile a complete new<br>binary image of the software together with the operating sys-<br>tem and overwrite the existing system image of the sensor<br>node. This is the default method used by the XNP and Del-<br>uge network reprogramming software in TinyOS [13].</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:99"><nobr><span class="ft4">The full image replacement does not require any addi-</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft8">tional processing of the loaded system image before it is<br>loaded into the system, since the loaded image resides at the<br>same, known, physical memory address as the previous sys-<br>tem image. For some systems, such as the Scatterweb system</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:477"><nobr><span class="ft8">code [33], the system contains both an operating system im-<br>age and a small set of functions that provide functionality<br>for loading new operating system images. A new operating<br>system image can overwrite the existing image without over-<br>writing the loading functions. The addresses of the loading<br>functions are hard-coded in the operating system image.</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:477"><nobr><span class="ft1">3.3.2</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:526"><nobr><span class="ft1">Diff-based Approaches</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:495"><nobr><span class="ft4">Often a small update in the code of the system, such as</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:477"><nobr><span class="ft8">a bugfix, will cause only minor differences between in the<br>new and old system image. Instead of distributing a new<br>full system image the binary differences, deltas, between the<br>modified and original binary can be distributed. This reduces<br>the amount of data that needs to be transferred. Several types<br>of diff-based approaches have been developed [15, 17, 31]<br>and it has been shown that the size of the deltas produced by<br>the diff-based approaches is very small compared to the full<br>binary image.</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:477"><nobr><span class="ft3"><b>4</b></span></nobr></DIV>
<DIV style="position:absolute;top:405;left:504"><nobr><span class="ft3"><b>Loadable Modules</b></span></nobr></DIV>
<DIV style="position:absolute;top:426;left:495"><nobr><span class="ft4">A less common alternative to full image replacement and</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:477"><nobr><span class="ft8">diff-based approaches is to use loadable modules to per-<br>form reprogramming. With loadable modules, only parts of<br>the system need to be modified when a single program is<br>changed. Typically, loadable modules require support from<br>the operating system. Contiki and SOS are examples of sys-<br>tems that support loadable modules and TinyOS is an exam-<br>ple of an operating system without loadable module support.</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:495"><nobr><span class="ft4">A loadable module contains the native machine code of</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:477"><nobr><span class="ft8">the program that is to be loaded into the system. The ma-<br>chine code in the module usually contains references to func-<br>tions or variables in the system. These references must be<br>resolved to the physical address of the functions or variables<br>before the machine code can be executed. The process of<br>resolving those references is called linking. Linking can be<br>done either when the module is compiled or when the mod-<br>ule is loaded. We call the former approach pre-linking and<br>the latter dynamic linking. A pre-linked module contains<br>the absolute physical addresses of the referenced functions<br>or variables whereas a dynamically linked module contains<br>the symbolic names of all system core functions or variables<br>that are referenced in the module. This information increases<br>the size of the dynamically linked module compared to the<br>pre-linked module. The difference is shown in Figure 1. Dy-<br>namic linking has not previously been considered for wire-<br>less sensor networks because of the perceived run-time over-<br>head, both in terms of execution time, energy consumption,<br>and memory requirements.</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:495"><nobr><span class="ft4">The machine code in the module usually contains refer-</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:477"><nobr><span class="ft8">ences not only to functions or variables in the system, but<br>also to functions or variables within the module itself. The<br>physical address of those functions will change depending<br>on the memory address at which the module is loaded in the<br>system. The addresses of the references must therefore be<br>updated to the physical address that the function or variable<br>will have when the module is loaded. The process of up-<br>dating these references is known as relocation. Like linking,<br>relocation can be done either at compile-time or at run-time.</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:495"><nobr><span class="ft4">When a module has been linked and relocated the pro-</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:477"><nobr><span class="ft4">gram loader loads the module into the system by copying the</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">17</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft12{font-size:7px;font-family:Times;color:#000000;}
	.ft13{font-size:7px;line-height:11px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="170004.png" alt="background image">
<DIV style="position:absolute;top:396;left:256"><nobr><span class="ft12">memcpy</span></nobr></DIV>
<DIV style="position:absolute;top:151;left:195"><nobr><span class="ft13">   /* ... */<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:195"><nobr><span class="ft13">void radio_send() {<br>   /* ... */<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:160"><nobr><span class="ft12">0x0237</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:160"><nobr><span class="ft12">0x1720</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:221"><nobr><span class="ft12">Core</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:99"><nobr><span class="ft12">memcpy();</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:99"><nobr><span class="ft12">radio_send();</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:160"><nobr><span class="ft12">call 0x1720</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:160"><nobr><span class="ft12">call 0x0237</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:244"><nobr><span class="ft12">Module with dynamic linking information</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:118"><nobr><span class="ft12">Pre-linked module</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:256"><nobr><span class="ft12">memcpy();</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:256"><nobr><span class="ft12">radio_send();</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:317"><nobr><span class="ft12">call 0x0000</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:317"><nobr><span class="ft12">call 0x0000</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:321"><nobr><span class="ft12">call instruction</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:321"><nobr><span class="ft12">call instruction</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:256"><nobr><span class="ft12">radio_send</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:195"><nobr><span class="ft12">int memcpy() {</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:81"><nobr><span class="ft8">Figure 1. The difference between a pre-linked module<br>and a module with dynamic linking information: the pre-<br>linked module contains physical addresses whereas the<br>dynamically linked module contains symbolic names.</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:81"><nobr><span class="ft8">linked and relocated native code into a place in memory from<br>where the program can be executed.</span></nobr></DIV>
<DIV style="position:absolute;top:554;left:81"><nobr><span class="ft3"><b>4.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:554;left:121"><nobr><span class="ft3"><b>Pre-linked Modules</b></span></nobr></DIV>
<DIV style="position:absolute;top:573;left:99"><nobr><span class="ft4">The machine code of a pre-linked module contains abso-</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:81"><nobr><span class="ft8">lute addresses of all functions and variables in the system<br>code that are referenced by the module. Linking of the mod-<br>ule is done at compile time and only relocation is performed<br>at run-time. To link a pre-linked module, information about<br>the physical addresses of all functions and variables in the<br>system into which the module is to be loaded must be avail-<br>able at compile time.</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:99"><nobr><span class="ft4">There are two benefits of pre-linked modules over dynam-</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:81"><nobr><span class="ft8">ically linked modules. First, pre-linked modules are smaller<br>than dynamically linked modules which results in less infor-<br>mation to be transmitted. Second, the process of loading a<br>pre-linked module into the system is less complex than the<br>process of linking a dynamically linked module. However,<br>the fact that all physical addresses of the system core are<br>hard-coded in the pre-linked module is a severe drawback as<br>a pre-linked module can only be loaded into a system with<br>the exact same physical addresses as the system that was to<br>generate the list of addresses that was used for linking the<br>module.</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:99"><nobr><span class="ft4">In the original Contiki system [5] we used pre-linked bi-</span></nobr></DIV>
<DIV style="position:absolute;top:921;left:81"><nobr><span class="ft8">nary modules for dynamic loading. When compiling the<br>Contiki system core, the compiler generated a map file con-<br>taining the mapping between all globally visible functions<br>and variables in the system core and their addresses. This<br>list of addresses was used to pre-link Contiki modules.</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:99"><nobr><span class="ft4">We quickly noticed that while pre-linked binary mod-</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft8">ules worked well for small projects with a homogeneous set<br>of sensor nodes, the system quickly became unmanageable<br>when the number of sensor nodes grew. Even a small change<br>to the system core of one of the sensor nodes would make it</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:477"><nobr><span class="ft8">impossible to load binary a module into the system bedcase<br>the addresses of variables and functions in the core were dif-<br>ferent from when the program was linked. We used version<br>numbers to guard against this situation. Version numbers did<br>help against system crashes, but did not solve the general<br>problem: new modules could not be loaded into the system.</span></nobr></DIV>
<DIV style="position:absolute;top:215;left:477"><nobr><span class="ft3"><b>4.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:517"><nobr><span class="ft3"><b>Dynamic Linking</b></span></nobr></DIV>
<DIV style="position:absolute;top:234;left:495"><nobr><span class="ft4">With dynamic linking, the object files do not only con-</span></nobr></DIV>
<DIV style="position:absolute;top:251;left:477"><nobr><span class="ft8">tain code and data, but also names of functions are variables<br>of the system core that are referenced by the module. The<br>code in the object file cannot be executed before the physi-<br>cal addresses of the referenced variables and functions have<br>been filled in. This process is done at run time by a dynamic<br>linker.</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:495"><nobr><span class="ft4">In the Contiki dynamic linker we use two file formats for</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:477"><nobr><span class="ft4">the dynamically linked modules, ELF and Compact ELF.</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:477"><nobr><span class="ft1">4.2.1</span></nobr></DIV>
<DIV style="position:absolute;top:387;left:526"><nobr><span class="ft1">ELF - Executable and Linkable Format</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:495"><nobr><span class="ft4">One of the most common object code format for dynamic</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:477"><nobr><span class="ft8">linking is the Executable and Linkable Format (ELF) [3]. It<br>is a standard format for object files and executables that is<br>used for most modern Unix-like systems. An ELF object<br>file include both program code and data and additional in-<br>formation such as a symbol table, the names of all external<br>unresolved symbols, and relocation tables. The relocation<br>tables are used to locate the program code and data at other<br>places in memory than for which the object code originally<br>was assembled. Additionally, ELF files can hold debugging<br>information such as the line numbers corresponding to spe-<br>cific machine code instructions, and file names of the source<br>files used when producing the ELF object.</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:495"><nobr><span class="ft4">ELF is also the default object file format produced by the</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:477"><nobr><span class="ft8">GCC utilities and for this reason there are a number of stan-<br>dard software utilities for manipulating ELF files available.<br>Examples include debuggers, linkers, converters, and pro-<br>grams for calculating program code and data memory sizes.<br>These utilities exist for a wide variety of platforms, including<br>MS Windows, Linux, Solaris, and FreeBSD. This is a clear<br>advantage over other solutions such as FlexCup [27], which<br>require specialized utilities and tools.</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:495"><nobr><span class="ft4">Our dynamic linker in Contiki understands the ELF for-</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:477"><nobr><span class="ft8">mat and is able to perform dynamic linking, relocation, and<br>loading of ELF object code files. The debugging features of<br>the ELF format are not used.</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:477"><nobr><span class="ft1">4.2.2</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:526"><nobr><span class="ft1">CELF - Compact ELF</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:495"><nobr><span class="ft4">One problem with the ELF format is the overhead in terms</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:477"><nobr><span class="ft8">of bytes to be transmitted across the network, compared to<br>pre-linked modules. There are a number of reasons for the<br>extra overhead. First, ELF, as any dynamically relocatable<br>file format, includes the symbolic names of all referenced<br>functions or variables that need to be linked at run-time. Sec-<br>ond, and more important, the ELF format is designed to work<br>on 32-bit and 64-bit architectures. This causes all ELF data<br>structures to be defined with 32-bit data types. For 8-bit or<br>16-bit targets the high 16 bits of these fields are unused.</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:495"><nobr><span class="ft4">To quantify the overhead of the ELF format we devise an</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:477"><nobr><span class="ft8">alternative to the ELF object code format that we call CELF<br>- Compact ELF. A CELF file contains the same information<br>as an ELF file, but represented with 8 and 16-bit datatypes.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">18</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft14{font-size:4px;font-family:Times;color:#000000;}
	.ft15{font-size:6px;font-family:Times;color:#ffffff;}
	.ft16{font-size:6px;font-family:Times;color:#000000;}
	.ft17{font-size:5px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="170005.png" alt="background image">
<DIV style="position:absolute;top:113;left:81"><nobr><span class="ft8">CELF files typically are half the size of the corresponding<br>ELF file. The Contiki dynamic loader is able to load CELF<br>files and a utility program is used to convert ELF files to<br>CELF files.</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:99"><nobr><span class="ft4">It is possible to further compress CELF files using lossless</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:81"><nobr><span class="ft8">data compression. However, we leave the investigation of the<br>energy-efficiency of this approach to future work.</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:99"><nobr><span class="ft4">The drawback of the CELF format is that it requires a</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:81"><nobr><span class="ft8">special compressor utility is for creating the CELF files. This<br>makes the CELF format less attractive for use in many real-<br>world situations.</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:81"><nobr><span class="ft3"><b>4.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:300;left:121"><nobr><span class="ft3"><b>Position Independent Code</b></span></nobr></DIV>
<DIV style="position:absolute;top:320;left:99"><nobr><span class="ft4">To avoid performing the relocation step when loading a</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:81"><nobr><span class="ft8">module, it is in some cases possible to compile the module<br>into position independent code. Position independent code is<br>a type of machine code which does not contain any absolute<br>addresses to itself, but only relative references. This is the<br>approach taken by the SOS system.</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:99"><nobr><span class="ft4">To generate position independent code compiler support</span></nobr></DIV>
<DIV style="position:absolute;top:436;left:81"><nobr><span class="ft8">is needed. Furthermore, not all CPU architectures support<br>position independent code and even when supported, pro-<br>grams compiled to position independent code typically are<br>subject to size restrictions. For example, the AVR microcon-<br>troller supports position independent code but restricts the<br>size of programs to 4 kilobytes. For the MSP430 no com-<br>piler is known to fully support position independent code.</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:81"><nobr><span class="ft3"><b>5</b></span></nobr></DIV>
<DIV style="position:absolute;top:557;left:108"><nobr><span class="ft3"><b>Implementation</b></span></nobr></DIV>
<DIV style="position:absolute;top:578;left:99"><nobr><span class="ft4">We have implemented run-time dynamic linking of ELF</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:81"><nobr><span class="ft8">and CELF files in the Contiki operating system [5]. To eval-<br>uate dynamic linking we have implemented an application<br>specific virtual machine for Contiki together with a compiler<br>for a subset of Java, and have ported a Java virtual machine<br>to Contiki.</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:81"><nobr><span class="ft3"><b>5.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:121"><nobr><span class="ft3"><b>The Contiki Operating System</b></span></nobr></DIV>
<DIV style="position:absolute;top:701;left:99"><nobr><span class="ft4">The Contiki operating system was the first operating sys-</span></nobr></DIV>
<DIV style="position:absolute;top:718;left:81"><nobr><span class="ft8">tem for memory-constrained sensor nodes to support dy-<br>namic run-time loading of native code modules. Contiki is<br>built around an event-driven kernel and has very low mem-<br>ory requirements.</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:204"><nobr><span class="ft4">Contiki applications run as extremely</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:81"><nobr><span class="ft8">lightweight protothreads [6] that provide blocking operations<br>on top of the event-driven kernel at a very small memory<br>cost. Contiki is designed to be highly portable and has been<br>ported to over ten different platforms with different CPU ar-<br>chitectures and using different C compilers.</span></nobr></DIV>
<DIV style="position:absolute;top:921;left:292"><nobr><span class="ft14">Loaded program</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:149"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:149"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:149"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:149"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:149"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:149"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:279"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:279"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:279"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:279"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:279"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:279"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:279"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:943;left:279"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:279"><nobr><span class="ft15">00000000000</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:279"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:943;left:279"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:279"><nobr><span class="ft16">11111111111</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:184"><nobr><span class="ft17"><b>RAM</b></span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:141"><nobr><span class="ft14">Core</span></nobr></DIV>
<DIV style="position:absolute;top:989;left:163"><nobr><span class="ft14">Loaded program</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:270"><nobr><span class="ft14">Core</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:314"><nobr><span class="ft17"><b>ROM</b></span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:163"><nobr><span class="ft14">Device drivers</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:163"><nobr><span class="ft14">Contiki kernel</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:292"><nobr><span class="ft14">Contiki kernel</span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:292"><nobr><span class="ft14">Dynamic linker</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:292"><nobr><span class="ft14">Symbol table</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:292"><nobr><span class="ft14">Language run-time</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:292"><nobr><span class="ft14">Device drivers</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft8">Figure 2. Partitioning in Contiki: the core and loadable<br>programs in RAM and ROM.</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:495"><nobr><span class="ft4">A Contiki system is divided into two parts: the core and</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:477"><nobr><span class="ft8">the loadable programs as shown in Figure 2. The core con-<br>sists of the Contiki kernel, device drivers, a set of standard<br>applications, parts of the C language library, and a symbol<br>table. Loadable programs are loaded on top of the core and<br>do not modify the core.</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:495"><nobr><span class="ft4">The core has no information about the loadable programs,</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:477"><nobr><span class="ft8">except for information that the loadable programs explicitly<br>register with the core. Loadable programs, on the other hand,<br>have full knowledge of the core and may freely call func-<br>tions and access variables that reside in the core. Loadable<br>programs can call each other by going through the kernel.<br>The kernel dispatches calls from one loaded program to an-<br>other by looking up the target program in an in-kernel list of<br>active processes. This one-way dependency makes it possi-<br>ble to load and unload programs at run-time without needing<br>to patch the core and without the need for a reboot when a<br>module has been loaded or unloaded.</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:495"><nobr><span class="ft4">While it is possible to replace the core at run-time by run-</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:477"><nobr><span class="ft8">ning a special loadable program that overwrites the current<br>core and reboots the system, experience has shown that this<br>feature is not often used in practice.</span></nobr></DIV>
<DIV style="position:absolute;top:481;left:477"><nobr><span class="ft3"><b>5.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:481;left:517"><nobr><span class="ft3"><b>The Symbol Table</b></span></nobr></DIV>
<DIV style="position:absolute;top:500;left:495"><nobr><span class="ft4">The Contiki core contains a table of the symbolic names</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:477"><nobr><span class="ft8">of all externally visible variable and function names in the<br>Contiki core and their corresponding addresses. The table<br>includes not only the Contiki system, but also the C language<br>run-time library. The symbol table is used by the dynamic<br>linker when linking loaded programs.</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:495"><nobr><span class="ft4">The symbol table is created when the Contiki core binary</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:477"><nobr><span class="ft8">image is compiled. Since the core must contain a correct<br>symbol table, and a correct symbol table cannot be created<br>before the core exists, a three-step process is required to<br>compile a core with a correct symbol table. First, an inter-<br>mediary core image with an empty symbol table is compiled.<br>From the intermediary core image an intermediary symbol<br>table is created. The intermediary symbol table contains the<br>correct symbols of the final core image, but the addresses<br>of the symbols are incorrect. Second, a second intermedi-<br>ary core image that includes the intermediary symbol table<br>is created. This core image now contains a symbol table of<br>the same size as the one in the final core image so the ad-<br>dresses of all symbols in the core are now as they will be<br>in the final core image. The final symbol table is then cre-<br>ated from the second intermediary core image. This symbol<br>table contains both the correct symbols and their correct ad-<br>dresses. Third, the final core image with the correct symbol<br>table is compiled.</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:495"><nobr><span class="ft4">The process of creating a core image is automated through</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:477"><nobr><span class="ft8">a simple make script. The symbol table is created using a<br>combination of standard ELF tools.</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:495"><nobr><span class="ft4">For a typical Contiki system the symbol table contains</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:477"><nobr><span class="ft8">around 300 entries which amounts to approximately 4 kilo-<br>bytes of data stored in flash ROM.</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:477"><nobr><span class="ft3"><b>5.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:517"><nobr><span class="ft3"><b>The Dynamic Linker</b></span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:495"><nobr><span class="ft4">We implemented a dynamic linker for Contiki that is de-</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:477"><nobr><span class="ft8">signed to link, relocate, and load either standard ELF files [3]<br>and CELF, Compact ELF, files. The dynamic linker reads</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">19</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="170006.png" alt="background image">
<DIV style="position:absolute;top:113;left:81"><nobr><span class="ft8">ELF/CELF files through the Contiki virtual filesystem inter-<br>face, CFS, which makes the dynamic linker unaware of the<br>physical location of the ELF/CELF file. Thus the linker can<br>operate on files stored either in RAM, on-chip flash ROM,<br>external EEPROM, or external ROM without modification.<br>Since all file access to the ELF/CELF file is made through<br>the CFS, the dynamic linker does not need to concern it-<br>self with low-level filesystem details such as wear-leveling<br>or fragmentation [4] as this is better handled by the CFS.</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:99"><nobr><span class="ft4">The dynamic linker performs four steps to link, relocate</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:81"><nobr><span class="ft8">and load an ELF/CELF file. The dynamic linker first parses<br>the ELF/CELF file and extracts relevant information about<br>where in the ELF/CELF file the code, data, symbol table,<br>and relocation entries are stored. Second, memory for the<br>code and data is allocated from flash ROM and RAM, re-<br>spectively. Third, the code and data segments are linked and<br>relocated to their respective memory locations, and fourth,<br>the code is written to flash ROM and the data to RAM.</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:99"><nobr><span class="ft4">Currently, memory allocation for the loaded program is</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:81"><nobr><span class="ft8">done using a simple block allocation scheme. More sophis-<br>ticated allocation schemes will be investigated in the future.</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:81"><nobr><span class="ft1">5.3.1</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:130"><nobr><span class="ft1">Linking and Relocating</span></nobr></DIV>
<DIV style="position:absolute;top:476;left:99"><nobr><span class="ft4">The relocation information in an ELF/CELF file consists</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:81"><nobr><span class="ft8">of a list of relocation entries. Each relocation entry corre-<br>sponds to an instruction or address in the code or data in the<br>module that needs to be updated with a new address. A relo-<br>cation entry contains a pointer to a symbol, such as a variable<br>name or a function name, a pointer to a place in the code or<br>data contained in the ELF/CELF file that needs to be up-<br>dated with the address of the symbol, and a relocation type<br>which specifies how the data or code should be updated. The<br>relocation types are different depending on the CPU archi-<br>tecture. For the MSP430 there is only one single relocation<br>type, whereas the AVR has 19 different relocation types.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:99"><nobr><span class="ft4">The dynamic linker processes a relocation entry at a time.</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:81"><nobr><span class="ft8">For each relocation entry, its symbol is looked up in the sym-<br>bol table in the core. If the symbol is found in the core's sym-<br>bol table, the address of the symbol is used to patch the code<br>or data to which the relocation entry points. The code or data<br>is patched in different ways depending on the relocation type<br>and on the CPU architecture.</span></nobr></DIV>
<DIV style="position:absolute;top:788;left:99"><nobr><span class="ft4">If the symbol in the relocation entry was not found in the</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:81"><nobr><span class="ft8">symbol table of the core, the symbol table of the ELF/CELF<br>file itself is searched. If the symbol is found, the address that<br>the symbol will have when the program has been loaded is<br>calculated, and the code or data is patched in the same way<br>as if the symbol was found in the core symbol table.</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:99"><nobr><span class="ft4">Relocation entries may also be relative to the data, BSS,</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:81"><nobr><span class="ft8">or code segment in the ELF/CELF file. In that case no sym-<br>bol is associated with the relocation entry. For such entries<br>the dynamic linker calculates the address that the segment<br>will have when the program has been loaded, and uses that<br>address to patch the code or data.</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:81"><nobr><span class="ft1">5.3.2</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:130"><nobr><span class="ft1">Loading</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:99"><nobr><span class="ft4">When the linking and relocating is completed, the text and</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft8">data have been relocated to their final memory position. The<br>text segment is then written to flash ROM, at the location<br>that was previously allocated. The memory allocated for the<br>data and BSS segments are used as an intermediate storage</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:477"><nobr><span class="ft8">for transferring text segment data from the ELF/CELF file<br>before it is written to flash ROM. Finally, the memory allo-<br>cated for the BSS segment is cleared, and the contents of the<br>data segment is copied from the ELF/CELF file.</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:477"><nobr><span class="ft1">5.3.3</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:526"><nobr><span class="ft1">Executing the Loaded Program</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:495"><nobr><span class="ft4">When the dynamic linker has successfully loaded the code</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:477"><nobr><span class="ft4">and data segments, Contiki starts executing the program.</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:495"><nobr><span class="ft4">The loaded program may replace an already running Con-</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:477"><nobr><span class="ft8">tiki service. If the service that is to be replaced needs to pass<br>state to the newly loaded service, Contiki supports the allo-<br>cation of an external memory buffer for this purpose. How-<br>ever, experience has shown that this mechanism has been<br>very scarcely used in practice and the mechanism is likely<br>to be removed in future versions of Contiki.</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:477"><nobr><span class="ft1">5.3.4</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:526"><nobr><span class="ft1">Portability</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:495"><nobr><span class="ft4">Since the ELF/CELF format is the same across different</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:477"><nobr><span class="ft8">platforms, we designed the Contiki dynamic linker to be eas-<br>ily portable to new platforms. The loader is split into one<br>architecture specific part and one generic part. The generic<br>part parses the ELF/CELF file, finds the relevant sections of<br>the file, looks up symbols from the symbol table, and per-<br>forms the generic relocation logic. The architecture specific<br>part does only three things: allocates ROM and RAM, writes<br>the linked and relocated binary to flash ROM, and under-<br>stands the relocation types in order to modify machine code<br>instructions that need adjustment because of relocation.</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:477"><nobr><span class="ft1">5.3.5</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:526"><nobr><span class="ft1">Alternative Designs</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:495"><nobr><span class="ft4">The Contiki core symbol table contains all externally vis-</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:477"><nobr><span class="ft8">ible symbols in the Contiki core. Many of the symbols may<br>never need to be accessed by loadable programs, thus caus-<br>ing ROM overhead. An alternative design would be to let the<br>symbol table include only a handful of symbols, entry points,<br>that define the only ways for an application program to inter-<br>act with the core. This would lead to a smaller symbol table,<br>but would also require a detailed specification of which entry<br>points that should be included in the symbol table. The main<br>reason why we did not chose this design, however, is that<br>we wish to be able to replace modules at any level of the sys-<br>tem. For this reason, we chose to provide the same amount of<br>symbols to an application program as it would have, would<br>it have been compiled directly into the core. However, we<br>are continuing to investigate this alternative design for future<br>versions of the system.</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:477"><nobr><span class="ft3"><b>5.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:837;left:517"><nobr><span class="ft3"><b>The Java Virtual Machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:856;left:495"><nobr><span class="ft4">We ported the Java virtual machine (JVM) from lejOS [8],</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:477"><nobr><span class="ft8">a small operating system originally developed for the Lego<br>Mindstorms. The Lego Mindstorms are equipped with an<br>Hitachi H8 microcontroller with 32 kilobytes of RAM avail-<br>able for user programs such as the JVM. The lejOS JVM<br>works within this constrained memory while featuring pre-<br>emptive threads, recursion, synchronization and exceptions.<br>The Contiki port required changes to the RAM-only model<br>of the lejOS JVM. To be able to run Java programs within the<br>2 kilobytes of RAM available on our hardware platform, Java<br>classes needs to be stored in flash ROM rather than in RAM.<br>The Contiki port stores the class descriptions including byte-<br>code in flash ROM memory. Static class data and class flags<br>that denote if classes have been initialized are stored in RAM</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">20</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft18{font-size:9px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="170007.png" alt="background image">
<DIV style="position:absolute;top:113;left:81"><nobr><span class="ft8">as well as object instances and execution stacks. The RAM<br>requirements for the Java part of typical sensor applications<br>are a few hundred bytes.</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:99"><nobr><span class="ft4">Java programs can call native code methods by declaring</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:81"><nobr><span class="ft8">native Java methods. The Java virtual machine dispatches<br>calls to native methods to native code. Any native function<br>in Contiki may be called, including services that are part of<br>a loaded Contiki program.</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:81"><nobr><span class="ft3"><b>5.5</b></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:121"><nobr><span class="ft3"><b>CVM - the Contiki Virtual Machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:268;left:99"><nobr><span class="ft4">We designed the Contiki Virtual Machine, CVS, to be a</span></nobr></DIV>
<DIV style="position:absolute;top:285;left:81"><nobr><span class="ft8">compromise between an application-specific and a generic<br>virtual machine. CVM can be configured for the application<br>running on top of the machine by allowing functions to be<br>either implemented as native code or as CVM code. To be<br>able to run the same programs for the Java VM and for CVM,<br>we developed a compiler that compiles a subset of the Java<br>language to CVM bytecode.</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:99"><nobr><span class="ft4">The design of CVM is intentionally similar to other vir-</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:81"><nobr><span class="ft8">tual machines, including Mat´e [19], VM [18], and the Java<br>virtual machine. CVM is a stack-based machine with sepa-<br>rated code and data areas. The CVM instruction set contains<br>integer arithmetic, unconditional and conditional branches,<br>and method invocation instructions. Method invocation can<br>be done in two ways, either by invocation of CVM bytecode<br>functions, or by invocation of functions implemented in na-<br>tive code. Invocation of native functions is done through a<br>special instruction for calling native code. This instruction<br>takes one parameter, which identifies the native function that<br>is to be called. The native function identifiers are defined at<br>compile time by the user that compiles a list of native func-<br>tions that the CVM program should be able to call. With the<br>native function interface, it is possible for a CVM program to<br>call any native functions provided by the underlying system,<br>including services provided by loadable programs.</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:99"><nobr><span class="ft4">Native functions in a CVM program are invoked like any</span></nobr></DIV>
<DIV style="position:absolute;top:697;left:81"><nobr><span class="ft8">other function. The CVM compiler uses the list of native<br>functions to translate calls to such functions into the special<br>instruction for calling native code. Parameters are passed to<br>native functions through the CVM stack.</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:81"><nobr><span class="ft3"><b>6</b></span></nobr></DIV>
<DIV style="position:absolute;top:769;left:108"><nobr><span class="ft3"><b>Evaluation</b></span></nobr></DIV>
<DIV style="position:absolute;top:790;left:99"><nobr><span class="ft4">To evaluate dynamic linking of native code we compare</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:81"><nobr><span class="ft8">the energy costs of transferring, linking, relocating, loading,<br>and executing a native code module in ELF format using dy-<br>namic linking with the energy costs of transferring, loading,<br>and executing the same program compiled for the CVM and<br>the Java virtual machine. We devise a simple model of the<br>energy consumption of the reprogramming process. There-<br>after we experimentally quantify the energy and memory<br>consumption as well as the execution overhead for the repro-<br>gramming, the execution methods and the applications. We<br>use the results of the measurements as input into the model<br>which enables us to perform a quantitative comparison of the<br>energy-efficiency of the reprogramming methods.</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:99"><nobr><span class="ft4">We use the ESB board [33] and the Telos Sky board [29]</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:81"><nobr><span class="ft8">as our experimental platforms. The ESB is equipped with an<br>MSP430 microcontroller with 2 kilobytes of RAM and 60<br>kilobytes of flash ROM, an external 64 kilobyte EEPROM,<br>as well as a set of sensors and a TR1001 radio transceiver.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:517"><nobr><span class="ft9">PROCESS_THREAD(test_blink, ev, data)<br>{</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:528"><nobr><span class="ft9">static struct etimer t;<br>PROCESS_BEGIN();</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:528"><nobr><span class="ft5">etimer_set(&amp;t, CLOCK_SECOND);</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:528"><nobr><span class="ft5">while(1) {</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:538"><nobr><span class="ft10">leds_on(LEDS_GREEN);<br>PROCESS_WAIT_UNTIL(etimer_expired(&amp;t));<br>etimer_reset(&amp;t);</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:538"><nobr><span class="ft10">leds_off(LEDS_GREEN);<br>PROCESS_WAIT_UNTIL(etimer_expired(&amp;t));<br>etimer_reset(&amp;t);</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:528"><nobr><span class="ft5">}</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:528"><nobr><span class="ft5">PROCESS_END();</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:517"><nobr><span class="ft5">}</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:477"><nobr><span class="ft4">Figure 3.</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:552"><nobr><span class="ft4">Example Contiki program that toggles the</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:477"><nobr><span class="ft4">LEDs every second.</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:477"><nobr><span class="ft8">The Telos Sky is equipped with an MSP430 microcontroller<br>with 10 kilobytes of RAM and 48 kilobytes of flash ROM<br>together with a CC2420 radio transceiver. We use the ESB to<br>measure the energy of receiving, storing, linking, relocating,<br>loading and executing loadable modules and the Telos Sky<br>to measure the energy of receiving loadable modules.</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:495"><nobr><span class="ft4">We use three Contiki programs to measure the energy ef-</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:477"><nobr><span class="ft8">ficiency and execution overhead of our different approaches.<br>Blinker, the first of the two programs, is shown in Figure 3.<br>It is a simple program that toggles the LEDs every second.<br>The second program, Object Tracker, is an object tracking<br>application based on abstract regions [35]. To allow run-<br>ning the programs both as native code, as CVM code, and<br>as Java code we have implemented these programs both in C<br>and Java. A schematic illustration of the C implementation<br>is in Figure 4. To support the object tracker program, we<br>implemented a subset of the abstract regions mechanism in<br>Contiki. The Java and CVM versions of the program call na-<br>tive code versions of the abstract regions functions. The third<br>program is a simple 8 by 8 vector convolution calculation.</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:477"><nobr><span class="ft3"><b>6.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:748;left:517"><nobr><span class="ft3"><b>Energy Consumption</b></span></nobr></DIV>
<DIV style="position:absolute;top:767;left:495"><nobr><span class="ft4">We model the energy consumption E of the reprogram-</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:477"><nobr><span class="ft4">ming process with</span></nobr></DIV>
<DIV style="position:absolute;top:810;left:589"><nobr><span class="ft4">E</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:602"><nobr><span class="ft4">= E</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:627"><nobr><span class="ft18">p</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:636"><nobr><span class="ft4">+ E</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:659"><nobr><span class="ft18">s</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:666"><nobr><span class="ft4">+ E</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:689"><nobr><span class="ft18">l</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:695"><nobr><span class="ft4">+ E</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:720"><nobr><span class="ft18">f</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:477"><nobr><span class="ft4">where E</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:528"><nobr><span class="ft18">p</span></nobr></DIV>
<DIV style="position:absolute;top:836;left:539"><nobr><span class="ft4">is the energy spent in transferring the object over</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:477"><nobr><span class="ft4">the network, E</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:566"><nobr><span class="ft18">s</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:576"><nobr><span class="ft4">the energy cost of storing the object on the</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:477"><nobr><span class="ft4">device, E</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:532"><nobr><span class="ft18">l</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:539"><nobr><span class="ft4">the energy consumed by linking and relocating the</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:477"><nobr><span class="ft4">object, and E</span></nobr></DIV>
<DIV style="position:absolute;top:890;left:559"><nobr><span class="ft18">f</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:569"><nobr><span class="ft4">the required energy for of storing the linked</span></nobr></DIV>
<DIV style="position:absolute;top:902;left:477"><nobr><span class="ft8">program in flash ROM. We use a simplified model of the<br>network propagation energy where we assume a propagation<br>protocol where the energy consumption E</span></nobr></DIV>
<DIV style="position:absolute;top:940;left:726"><nobr><span class="ft18">p</span></nobr></DIV>
<DIV style="position:absolute;top:935;left:735"><nobr><span class="ft4">is proportional to</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:477"><nobr><span class="ft4">the size of the object to be transferred. Formally,</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:626"><nobr><span class="ft4">E</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:636"><nobr><span class="ft18">p</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:646"><nobr><span class="ft4">= P</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:669"><nobr><span class="ft18">p</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:676"><nobr><span class="ft4">s</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:681"><nobr><span class="ft18">o</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:477"><nobr><span class="ft4">where s</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:523"><nobr><span class="ft18">o</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:533"><nobr><span class="ft4">is the size of the object file to be transfered and P</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:831"><nobr><span class="ft18">p</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:477"><nobr><span class="ft8">is a constant scale factor that depends on the network proto-<br>col used to transfer the object. We use similar equations for<br>E</span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:486"><nobr><span class="ft18">s</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:495"><nobr><span class="ft4">(energy for storing the binary) and E</span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:716"><nobr><span class="ft18">l</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:724"><nobr><span class="ft4">(energy for linking</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:477"><nobr><span class="ft4">and relocating). The equation for E</span></nobr></DIV>
<DIV style="position:absolute;top:1075;left:699"><nobr><span class="ft18">f</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:710"><nobr><span class="ft4">(the energy for load-</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">21</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="170008.png" alt="background image">
<DIV style="position:absolute;top:114;left:121"><nobr><span class="ft9">PROCESS_THREAD(use_regions_process, ev, data)<br>{</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:132"><nobr><span class="ft5">PROCESS_BEGIN();</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:132"><nobr><span class="ft5">while(1) {</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:143"><nobr><span class="ft5">value = pir_sensor.value();</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:143"><nobr><span class="ft9">region_put(reading_key, value);<br>region_put(reg_x_key, value * loc_x());<br>region_put(reg_y_key, value * loc_y());<br>if(value &gt; threshold) {</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:153"><nobr><span class="ft5">max = region_max(reading_key);</span></nobr></DIV>
<DIV style="position:absolute;top:282;left:153"><nobr><span class="ft5">if(max == value) {</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:164"><nobr><span class="ft9">sum = region_sum(reading_key);<br>sum_x = region_sum(reg_x_key);<br>sum_y = region_sum(reg_y_key);<br>centroid_x = sum_x / sum;<br>centroid_y = sum_y / sum;<br>send(centroid_x, centroid_y);</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:153"><nobr><span class="ft5">}</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:143"><nobr><span class="ft5">}</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:143"><nobr><span class="ft9">etimer_set(&amp;t, PERIODIC_DELAY);<br>PROCESS_WAIT_UNTIL(etimer_expired(&amp;t));</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:132"><nobr><span class="ft5">}</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:132"><nobr><span class="ft5">PROCESS_END();</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:121"><nobr><span class="ft5">}</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:81"><nobr><span class="ft8">Figure 4. Schematic implementation of an object tracker<br>based on abstract regions.</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:81"><nobr><span class="ft8">ing the binary to ROM) contains the size of the compiled<br>code size of the program instead of the size of the object file.<br>This model is intentionally simple and we consider it good<br>enough for our purpose of comparing the energy-efficiency<br>of different reprogramming schemes.</span></nobr></DIV>
<DIV style="position:absolute;top:641;left:81"><nobr><span class="ft1">6.1.1</span></nobr></DIV>
<DIV style="position:absolute;top:641;left:130"><nobr><span class="ft1">Lower Bounds on Radio Reception Energy</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:99"><nobr><span class="ft4">We measured the energy consumption of receiving data</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:81"><nobr><span class="ft8">over the radio for two different radio transceivers: the<br>TR1001 [32], that is used on the ESB board, and the<br>CC2420 [2], that conforms to the IEEE 802.15.4 stan-<br>dard [11] and is used on the Telos Sky board. The TR1001<br>provides a very low-level interface to the radio medium. The<br>transceiver decodes data at the bit level and transmits the<br>bits in real-time to the CPU. Start bit detection, framing,<br>MAC layer, checksums, and all protocol processing must be<br>done in software running on the CPU. In contrast, the inter-<br>face provided by the CC2420 is at a higher level. Start bits,<br>framing, and parts of the MAC protocol are handled by the<br>transceiver. The software driver handles incoming and out-<br>going data on the packet level.</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:99"><nobr><span class="ft4">Since the TR1001 operates at the bit-level, the communi-</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:81"><nobr><span class="ft8">cation speed of the TR1001 is determined by the CPU. We<br>use a data rate of 9600 bits per second. The CC2420 has<br>a data rate of 250 kilobits per second, but also incurs some<br>protocol overhead as it provides a more high-level interface.</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:99"><nobr><span class="ft4">Figure 5 shows the current draw from receiving 1000</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:81"><nobr><span class="ft8">bytes of data with the TR1001 and CC2420 radio<br>transceivers. These measurements constitute a lower bound<br>on the energy consumption for receiving data over the radio,<br>as they do not include any control overhead caused by a code<br>propagation protocol. Nor do they include any packet head-<br>ers. An actual propagation protocol would incur overhead</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:578"><nobr><span class="ft4">Time</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:627"><nobr><span class="ft4">Energy</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:688"><nobr><span class="ft4">Time per</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:760"><nobr><span class="ft4">Energy per</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:488"><nobr><span class="ft4">Transceiver</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:593"><nobr><span class="ft4">(s)</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:643"><nobr><span class="ft4">(mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:697"><nobr><span class="ft4">byte (s)</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:769"><nobr><span class="ft4">byte (mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:488"><nobr><span class="ft4">TR1001</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:583"><nobr><span class="ft4">0.83</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:655"><nobr><span class="ft4">21</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:701"><nobr><span class="ft4">0.0008</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:792"><nobr><span class="ft4">0.021</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:488"><nobr><span class="ft4">CC2420</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:576"><nobr><span class="ft4">0.060</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:651"><nobr><span class="ft4">4.8</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:693"><nobr><span class="ft4">0.00006</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:784"><nobr><span class="ft4">0.0048</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:477"><nobr><span class="ft4">Table 2.</span></nobr></DIV>
<DIV style="position:absolute;top:177;left:544"><nobr><span class="ft4">Lower bounds on the time and energy con-</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:477"><nobr><span class="ft8">sumption for receiving 1000 bytes with the TR1001 and<br>CC2420 transceivers. All values are rounded to two sig-<br>nificant digits.</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:477"><nobr><span class="ft8">because of both packet headers and control traffic. For ex-<br>ample, the Deluge protocol has a control packet overhead of<br>approximately 20% [14]. This overhead is derived from the<br>total number of control packets and the total number of data<br>packets in a sensor network. The average overhead in terms<br>of number of excessive data packets received is 3.35 [14]. In<br>addition to the actual code propagation protocol overhead,<br>there is also overhead from the MAC layer, both in terms of<br>packet headers and control traffic.</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:495"><nobr><span class="ft4">The TR1001 provides a low-level interface to the CPU,</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:477"><nobr><span class="ft8">which enabled us to measure only the current draw of the<br>receiver. We first measured the time required for receiving<br>one byte of data from the radio. To produce the graph in the<br>figure, we measured the current draw of an ESB board which<br>we had programmed to turn on receive mode and busy-wait<br>for the time corresponding to the reception time of 1000<br>bytes.</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:495"><nobr><span class="ft4">When measuring the reception current draw of the</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:477"><nobr><span class="ft8">CC2420, we could not measure the time required for re-<br>ceiving one byte because the CC2420 does not provide an<br>interface at the bit level. Instead, we used two Telos Sky<br>boards and programmed one to continuously send back-to-<br>back packets with 100 bytes of data. We programmed the<br>other board to turn on receive mode when the on-board but-<br>ton was pressed. The receiver would receive 1000 bytes of<br>data, corresponding to 10 packets, before turning the receiver<br>off. We placed the two boards next to each other on a table<br>to avoid packet drops. We produced the graph in Figure 5 by<br>measuring the current draw of the receiver Telos Sky board.<br>To ensure that we did not get spurious packet drops, we re-<br>peated the measurement five times without obtaining differ-<br>ing results.</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:495"><nobr><span class="ft4">Table 2 shows the lower bounds on the time and en-</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:477"><nobr><span class="ft8">ergy consumption for receiving data with the TR1001 and<br>CC2420 transceivers. The results show that while the current<br>draw of the CC2420 is higher than that of the TR1001, the<br>energy efficiency in terms of energy per byte of the CC2420<br>is better because of the shorter time required to receive the<br>data.</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:477"><nobr><span class="ft1">6.1.2</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:526"><nobr><span class="ft1">Energy Consumption of Dynamic Linking</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:495"><nobr><span class="ft4">To evaluate the energy consumption of dynamic linking,</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:477"><nobr><span class="ft8">we measure the energy required for the Contiki dynamic<br>linker to link and load two Contiki programs. Normally,<br>Contiki loads programs from the radio network but to avoid<br>measuring any unrelated radio or network effects, we stored<br>the loadable object files in flash ROM before running the<br>experiments. The loadable objects were stored as ELF files<br>from which all debugging information and symbols that were<br>not needed for run-time linking was removed. At boot-up,</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">22</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft19{font-size:2px;font-family:Times;color:#000000;}
	.ft20{font-size:3px;font-family:Times;color:#000000;}
	.ft21{font-size:4px;line-height:7px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="170009.png" alt="background image">
<DIV style="position:absolute;top:299;left:175"><nobr><span class="ft19"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:175"><nobr><span class="ft19"> 5</span></nobr></DIV>
<DIV style="position:absolute;top:206;left:173"><nobr><span class="ft19"> 10</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:173"><nobr><span class="ft19"> 15</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:173"><nobr><span class="ft19"> 20</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:180"><nobr><span class="ft19"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:232"><nobr><span class="ft19"> 0.2</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:285"><nobr><span class="ft19"> 0.4</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:338"><nobr><span class="ft19"> 0.6</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:391"><nobr><span class="ft19"> 0.8</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:447"><nobr><span class="ft19"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:167"><nobr><span class="ft19">Current (mA)</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:307"><nobr><span class="ft19">Time (s)</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:409"><nobr><span class="ft19">Current</span></nobr></DIV>
<DIV style="position:absolute;top:299;left:476"><nobr><span class="ft19"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:476"><nobr><span class="ft19"> 5</span></nobr></DIV>
<DIV style="position:absolute;top:206;left:473"><nobr><span class="ft19"> 10</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:473"><nobr><span class="ft19"> 15</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:473"><nobr><span class="ft19"> 20</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:481"><nobr><span class="ft19"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:532"><nobr><span class="ft19"> 0.2</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:585"><nobr><span class="ft19"> 0.4</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:639"><nobr><span class="ft19"> 0.6</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:692"><nobr><span class="ft19"> 0.8</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:747"><nobr><span class="ft19"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:218;left:467"><nobr><span class="ft19">Current (mA)</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:607"><nobr><span class="ft19">Time (s)</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:709"><nobr><span class="ft19">Current</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:167"><nobr><span class="ft4">Figure 5. Current draw for receiving 1000 bytes with the TR1001 and CC2420, respectively.</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:125"><nobr><span class="ft20"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:125"><nobr><span class="ft20"> 5</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:122"><nobr><span class="ft20"> 10</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:122"><nobr><span class="ft20"> 15</span></nobr></DIV>
<DIV style="position:absolute;top:364;left:122"><nobr><span class="ft20"> 20</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:130"><nobr><span class="ft20"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:173"><nobr><span class="ft20"> 0.1</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:219"><nobr><span class="ft20"> 0.2</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:264"><nobr><span class="ft20"> 0.3</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:309"><nobr><span class="ft20"> 0.4</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:354"><nobr><span class="ft20"> 0.5</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:399"><nobr><span class="ft20"> 0.6</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:117"><nobr><span class="ft20">Current (mA)</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:259"><nobr><span class="ft20">Time (s)</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:363"><nobr><span class="ft20">Current</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:142"><nobr><span class="ft14">Writing to EEPROM</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:227"><nobr><span class="ft14">Linking and relocating</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:323"><nobr><span class="ft14">Writing</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:323"><nobr><span class="ft14">ROM</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:356"><nobr><span class="ft14">Executing binary</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:323"><nobr><span class="ft14">to flash</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:81"><nobr><span class="ft8">Figure 6. Current draw for writing the Blinker ELF file<br>to EEPROM (0 - 0.166 s), linking and relocating the pro-<br>gram (0.166 - 0.418 s), writing the resulting code to flash<br>ROM (0.418 - 0.488 s), and executing the binary (0.488 s<br>and onward). The current spikes delimit the three steps<br>and are intentionally caused by blinking on-board LEDs.<br>The high energy consumption when executing the binary<br>is caused by the green LED.</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:81"><nobr><span class="ft8">one ELF file was copied into an on-board EEPROM from<br>where the Contiki dynamic linker linked and relocated the<br>ELF file before it loaded the program into flash ROM.</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:99"><nobr><span class="ft4">Figure 6 shows the current draw when loading the Blinker</span></nobr></DIV>
<DIV style="position:absolute;top:806;left:81"><nobr><span class="ft8">program, and Figure 7 shows the current draw when load-<br>ing the Object Tracker program. The current spikes seen<br>in both graphs are intentionally caused by blinking the on-<br>board LEDs. The spikes delimit the four different steps that<br>the loader is going through: copying the ELF object file<br>to EEPROM, linking and relocating the object code, copy-<br>ing the linked code to flash ROM, and finally executing the<br>loaded program. The current draw of the green LED is<br>slightly above 8 mA, which causes the high current draw<br>when executing the blinker program (Figure 6). Similarly,<br>when the object tracking application starts, it turns on the<br>radio for neighbor discovery. This causes the current draw<br>to rise to around 6 mA in Figure 7, and matches the radio<br>current measurements in Figure 5.</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:99"><nobr><span class="ft4">Table 3 shows the energy consumption of loading and</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:81"><nobr><span class="ft8">linking the Blinker program. The energy was obtained from<br>integration of the curve from Figure 6 and multiplying it by</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:521"><nobr><span class="ft20"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:521"><nobr><span class="ft20"> 5</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:518"><nobr><span class="ft20"> 10</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:518"><nobr><span class="ft20"> 15</span></nobr></DIV>
<DIV style="position:absolute;top:364;left:518"><nobr><span class="ft20"> 20</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:526"><nobr><span class="ft20"> 0</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:569"><nobr><span class="ft20"> 0.2</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:614"><nobr><span class="ft20"> 0.4</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:660"><nobr><span class="ft20"> 0.6</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:705"><nobr><span class="ft20"> 0.8</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:752"><nobr><span class="ft20"> 1</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:795"><nobr><span class="ft20"> 1.2</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:512"><nobr><span class="ft20">Current (mA)</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:655"><nobr><span class="ft20">Time (s)</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:759"><nobr><span class="ft20">Current</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:530"><nobr><span class="ft14">Writing to EEPROM</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:729"><nobr><span class="ft14">ROM</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:728"><nobr><span class="ft21">Writing<br>to flash</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:755"><nobr><span class="ft21">Executing<br>binary</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:627"><nobr><span class="ft14">Linking and relocating</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:477"><nobr><span class="ft8">Figure 7. Current draw for writing the Object Tracker<br>ELF file to EEPROM (0 - 0.282 s), linking and relocat-<br>ing the program (0.282 - 0.882 s), writing the resulting<br>code to flash ROM (0.882 - 0.988 s), and executing the<br>binary (0.988 s and onward). The current spikes delimit<br>the three steps and are intentionally caused by blinking<br>on-board LEDs. The high current draw when executing<br>the binary comes from the radio being turned on.</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:477"><nobr><span class="ft8">the voltage used in our experiments (4.5 V). We see that the<br>linking and relocation step is the most expensive in terms of<br>energy. It is also the longest step.</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:495"><nobr><span class="ft4">To evaluate the energy overhead of the ELF file format,</span></nobr></DIV>
<DIV style="position:absolute;top:807;left:477"><nobr><span class="ft8">we compare the energy consumption for receiving four dif-<br>ferent Contiki programs using the ELF and CELF formats.<br>In addition to the two programs from Figures 3 and 4 we in-<br>clude the code for the Contiki code propagation mechanism<br>and a network publish/subscribe program that performs peri-<br>odic flooding and converging of information. The two latter<br>programs are significantly larger. We calculate an estimate of<br>the required energy for receiving the files by using the mea-<br>sured energy consumption of the CC2420 radio transceiver<br>and multiply it by the average overhead by the Deluge code<br>propagation protocol, 3.35 [14]. The results are listed in Ta-<br>ble 4 and show that radio reception is more energy consum-<br>ing than linking and loading a program, even for a small pro-<br>gram. Furthermore, the results show that the relative average<br>size and energy overhead for ELF files compared to the code<br>and data contained in the files is approximately 4 whereas<br>the relative CELF overhead is just under 2.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">23</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="170010.png" alt="background image">
<DIV style="position:absolute;top:110;left:365"><nobr><span class="ft4">ELF</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:437"><nobr><span class="ft4">ELF</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:492"><nobr><span class="ft4">ELF radio</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:571"><nobr><span class="ft4">CELF</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:644"><nobr><span class="ft4">CELF</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:699"><nobr><span class="ft4">CELF radio</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:266"><nobr><span class="ft4">Code</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:316"><nobr><span class="ft4">Data</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:373"><nobr><span class="ft4">file</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:418"><nobr><span class="ft4">file size</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:498"><nobr><span class="ft4">reception</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:589"><nobr><span class="ft4">file</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:634"><nobr><span class="ft4">file size</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:714"><nobr><span class="ft4">reception</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:148"><nobr><span class="ft4">Program</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:275"><nobr><span class="ft4">size</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:321"><nobr><span class="ft4">size</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:368"><nobr><span class="ft4">size</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:410"><nobr><span class="ft4">overhead</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:482"><nobr><span class="ft4">energy (mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:585"><nobr><span class="ft4">size</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:626"><nobr><span class="ft4">overhead</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:698"><nobr><span class="ft4">energy (mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:148"><nobr><span class="ft4">Blinker</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:275"><nobr><span class="ft4">130</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:329"><nobr><span class="ft4">14</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:362"><nobr><span class="ft4">1056</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:445"><nobr><span class="ft4">7.3</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:539"><nobr><span class="ft4">17</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:586"><nobr><span class="ft4">361</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:662"><nobr><span class="ft4">2.5</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:751"><nobr><span class="ft4">5.9</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:148"><nobr><span class="ft4">Object tracker</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:275"><nobr><span class="ft4">344</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:329"><nobr><span class="ft4">22</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:362"><nobr><span class="ft4">1668</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:445"><nobr><span class="ft4">5.0</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:539"><nobr><span class="ft4">29</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:586"><nobr><span class="ft4">758</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:662"><nobr><span class="ft4">2.0</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:755"><nobr><span class="ft4">12</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:148"><nobr><span class="ft4">Code propagator</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:268"><nobr><span class="ft4">2184</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:329"><nobr><span class="ft4">10</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:362"><nobr><span class="ft4">5696</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:445"><nobr><span class="ft4">2.6</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:539"><nobr><span class="ft4">92</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:578"><nobr><span class="ft4">3686</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:662"><nobr><span class="ft4">1.7</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:755"><nobr><span class="ft4">59</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:148"><nobr><span class="ft4">Flood/converge</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:268"><nobr><span class="ft4">4298</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:329"><nobr><span class="ft4">42</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:362"><nobr><span class="ft4">8456</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:445"><nobr><span class="ft4">1.9</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:531"><nobr><span class="ft4">136</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:578"><nobr><span class="ft4">5399</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:662"><nobr><span class="ft4">1.2</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:755"><nobr><span class="ft4">87</span></nobr></DIV>
<DIV style="position:absolute;top:226;left:81"><nobr><span class="ft8">Table 4. The overhead of the ELF and CELF file formats in terms of bytes and estimated reception energy for four Con-<br>tiki programs. The reception energy is the lower bound of the radio reception energy with the CC2420 chip, multiplied<br>by the average Deluge overhead (3.35).</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:206"><nobr><span class="ft4">Blinker</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:269"><nobr><span class="ft4">Energy</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:330"><nobr><span class="ft4">Obj. Tr.</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:395"><nobr><span class="ft4">Energy</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:90"><nobr><span class="ft4">Step</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:205"><nobr><span class="ft4">time (s)</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:284"><nobr><span class="ft4">(mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:331"><nobr><span class="ft4">time (s)</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:410"><nobr><span class="ft4">(mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:90"><nobr><span class="ft4">Wrt. EEPROM</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:217"><nobr><span class="ft4">0.164</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:293"><nobr><span class="ft4">1.1</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:343"><nobr><span class="ft4">0.282</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:419"><nobr><span class="ft4">1.9</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:90"><nobr><span class="ft4">Link &amp; reloc</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:217"><nobr><span class="ft4">0.252</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:293"><nobr><span class="ft4">1.2</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:343"><nobr><span class="ft4">0.600</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:419"><nobr><span class="ft4">2.9</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:90"><nobr><span class="ft4">Wrt. flash ROM</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:217"><nobr><span class="ft4">0.070</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:286"><nobr><span class="ft4">0.62</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:343"><nobr><span class="ft4">0.106</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:412"><nobr><span class="ft4">0.76</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:90"><nobr><span class="ft4">Total</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:217"><nobr><span class="ft4">0.486</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:293"><nobr><span class="ft4">2.9</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:343"><nobr><span class="ft4">0.988</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:419"><nobr><span class="ft4">5.5</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:81"><nobr><span class="ft8">Table 3. Measured energy consumption of the storing,<br>linking and loading of the 1056 bytes large Blinker binary<br>and the 1824 bytes large Object Tracker binary. The size<br>of the Blinker code is 130 bytes and the size of the Object<br>Tracker code is 344 bytes.</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:139"><nobr><span class="ft4">Module</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:298"><nobr><span class="ft4">ROM</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:349"><nobr><span class="ft4">RAM</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:139"><nobr><span class="ft4">Static loader</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:309"><nobr><span class="ft4">670</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:376"><nobr><span class="ft4">0</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:139"><nobr><span class="ft4">Dynamic linker, loader</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:302"><nobr><span class="ft4">5694</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:368"><nobr><span class="ft4">18</span></nobr></DIV>
<DIV style="position:absolute;top:554;left:139"><nobr><span class="ft4">CVM</span></nobr></DIV>
<DIV style="position:absolute;top:554;left:302"><nobr><span class="ft4">1344</span></nobr></DIV>
<DIV style="position:absolute;top:554;left:376"><nobr><span class="ft4">8</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:139"><nobr><span class="ft4">Java VM</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:294"><nobr><span class="ft4">13284</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:368"><nobr><span class="ft4">59</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:81"><nobr><span class="ft8">Table 5. Memory requirements, in bytes. The ROM size<br>for the dynamic linker includes the symbol table. The<br>RAM figures do not include memory for programs run-<br>ning on top of the virtual machines.</span></nobr></DIV>
<DIV style="position:absolute;top:684;left:81"><nobr><span class="ft3"><b>6.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:684;left:121"><nobr><span class="ft3"><b>Memory Consumption</b></span></nobr></DIV>
<DIV style="position:absolute;top:703;left:99"><nobr><span class="ft4">Memory consumption is an important metric for sensor</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:81"><nobr><span class="ft8">nodes since memory is a scarce resource on most sensor node<br>platforms. The ESB nodes feature only 2 KB RAM and 60<br>KB ROM while Mica2 motes provide 128 KB of program<br>memory and 4 KB of RAM. The less memory required for<br>reprogramming, the more is left for applications and support<br>for other important tasks such as security which may also<br>require a large part of the available memory [28].</span></nobr></DIV>
<DIV style="position:absolute;top:834;left:99"><nobr><span class="ft4">Table 5 lists the memory requirements of the static linker,</span></nobr></DIV>
<DIV style="position:absolute;top:851;left:81"><nobr><span class="ft8">the dynamic linker and loader, the CVM and the Java VM.<br>The dynamic linker needs to keep a table of all core symbols<br>in the system. For a complete Contiki system with process<br>management, networking, the dynamic loader, memory allo-<br>cation, Contiki libraries, and parts of the standard C library,<br>the symbol table requires about 4 kilobytes of ROM. This is<br>included in the ROM size for the dynamic linker.</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:81"><nobr><span class="ft3"><b>6.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:968;left:121"><nobr><span class="ft3"><b>Execution Overhead</b></span></nobr></DIV>
<DIV style="position:absolute;top:987;left:99"><nobr><span class="ft4">To measure the execution overhead of the application</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:81"><nobr><span class="ft8">specific virtual machine and the Java virtual machine, we<br>implemented the object tracking program in Figure 4 in C<br>and Java. We compiled the Java code to CVM code and<br>Java bytecode. We ran the compiled code on the MSP430-<br>equipped ESB board.</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:230"><nobr><span class="ft4">The native C code was compiled</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:496"><nobr><span class="ft4">Execution type</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:604"><nobr><span class="ft4">Execution time (ms)</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:744"><nobr><span class="ft4">Energy (mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:496"><nobr><span class="ft4">Native</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:692"><nobr><span class="ft4">0.479</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:769"><nobr><span class="ft4">0.00054</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:496"><nobr><span class="ft4">CVM</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:692"><nobr><span class="ft4">0.845</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:769"><nobr><span class="ft4">0.00095</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:496"><nobr><span class="ft4">Java VM</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:700"><nobr><span class="ft4">1.79</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:777"><nobr><span class="ft4">0.0020</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:477"><nobr><span class="ft8">Table 6. Execution times and energy consumption of one<br>iteration of the tracking program.</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:496"><nobr><span class="ft4">Execution type</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:604"><nobr><span class="ft4">Execution time (ms)</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:744"><nobr><span class="ft4">Energy (mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:496"><nobr><span class="ft4">Native</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:700"><nobr><span class="ft4">0.67</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:769"><nobr><span class="ft4">0.00075</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:496"><nobr><span class="ft4">CVM</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:692"><nobr><span class="ft4">58.52</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:784"><nobr><span class="ft4">0.065</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:496"><nobr><span class="ft4">Java VM</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:700"><nobr><span class="ft4">65.6</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:784"><nobr><span class="ft4">0.073</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:477"><nobr><span class="ft8">Table 7. Execution times and energy consumption of the<br>8 by 8 vector convolution.</span></nobr></DIV>
<DIV style="position:absolute;top:557;left:477"><nobr><span class="ft8">with the MSP430 port of GCC version 3.2.3. The MSP430<br>digitally-controlled oscillator was set to clock the CPU at a<br>speed of 2.4576 MHz. We measured the execution time of<br>the three implementations using the on-chip timer A1 that<br>was set to generate a timer interrupt 1000 times per second.<br>The execution times are averaged over 5000 iterations of the<br>object tracking program.</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:495"><nobr><span class="ft4">The results in Table 6 show the execution time of one run</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:477"><nobr><span class="ft8">of the object tracking application from Figure 4. The exe-<br>cution time measurements are averaged over 5000 runs of<br>the object tracking program. The energy consumption is cal-<br>culated by multiplying the execution time with the average<br>energy consumption when a program is running with the ra-<br>dio turned off. The table shows that the overhead of the Java<br>virtual machine is higher than that of the CVM, which is turn<br>is higher than the execution overhead of the native C code.</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:495"><nobr><span class="ft4">All three implementations of the tracker program use the</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:477"><nobr><span class="ft8">same abstract regions library which is compiled as native<br>code. Thus much of the execution time in the Java VM<br>and CVM implementations of the object tracking program is<br>spent executing the native code in the abstract regions library.<br>Essentially, the virtual machine simply acts as a dispatcher of<br>calls to various native functions. For programs that spend a<br>significant part of their time executing virtual machine code<br>the relative execution times are significantly higher for the<br>virtual machine programs. To illustrate this, Table 7 lists the<br>execution times of a convolution operation of two vectors<br>of length 8. Convolution is a common operation in digital<br>signal processing where it is used for algorithms such as fil-<br>tering or edge detection. We see that the execution time of<br>the program running on the virtual machines is close to ten<br>times that of the native program.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">24</span></nobr></DIV>
</DIV>
<!-- Page 11 -->
<a name="11"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="170011.png" alt="background image">
<DIV style="position:absolute;top:110;left:239"><nobr><span class="ft4">Dynamic</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:352"><nobr><span class="ft4">Full image</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:106"><nobr><span class="ft4">Step</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:221"><nobr><span class="ft4">linking (mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:312"><nobr><span class="ft4">replacement (mJ)</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:106"><nobr><span class="ft4">Receiving</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:279"><nobr><span class="ft4">17</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:394"><nobr><span class="ft4">330</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:106"><nobr><span class="ft4">Wrt. EEPROM</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:276"><nobr><span class="ft4">1.1</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:401"><nobr><span class="ft4">22</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:106"><nobr><span class="ft4">Link &amp; reloc</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:276"><nobr><span class="ft4">1.4</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:411"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:106"><nobr><span class="ft4">Wrt. flash ROM</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:268"><nobr><span class="ft4">0.45</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:401"><nobr><span class="ft4">72</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:106"><nobr><span class="ft4">Total</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:279"><nobr><span class="ft4">20</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:394"><nobr><span class="ft4">424</span></nobr></DIV>
<DIV style="position:absolute;top:226;left:81"><nobr><span class="ft8">Table 8. Comparison of energy-consumption of repro-<br>gramming the blinker application using dynamic linking<br>with an ELF file and full image replacement methods.</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:112"><nobr><span class="ft4">Step</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:230"><nobr><span class="ft4">ELF</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:274"><nobr><span class="ft4">CELF</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:329"><nobr><span class="ft4">CVM</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:385"><nobr><span class="ft4">Java</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:112"><nobr><span class="ft4">Size (bytes)</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:226"><nobr><span class="ft4">1824</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:288"><nobr><span class="ft4">968</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:340"><nobr><span class="ft4">123</span></nobr></DIV>
<DIV style="position:absolute;top:309;left:381"><nobr><span class="ft4">1356</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:112"><nobr><span class="ft4">Receiving</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:241"><nobr><span class="ft4">29</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:296"><nobr><span class="ft4">12</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:344"><nobr><span class="ft4">2.0</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:396"><nobr><span class="ft4">22</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:112"><nobr><span class="ft4">Wrt. EEPROM</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:238"><nobr><span class="ft4">1.9</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:285"><nobr><span class="ft4">0.80</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:358"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:406"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:112"><nobr><span class="ft4">Link &amp; reloc</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:238"><nobr><span class="ft4">2.5</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:292"><nobr><span class="ft4">2.5</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:358"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:406"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:112"><nobr><span class="ft4">Wrt. flash ROM</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:238"><nobr><span class="ft4">1.2</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:292"><nobr><span class="ft4">1.2</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:358"><nobr><span class="ft4">-</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:392"><nobr><span class="ft4">4.7</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:112"><nobr><span class="ft4">Total</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:241"><nobr><span class="ft4">35</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:285"><nobr><span class="ft4">16.5</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:344"><nobr><span class="ft4">2.0</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:384"><nobr><span class="ft4">26.7</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:81"><nobr><span class="ft8">Table 9. Comparison of energy-consumption in mJ of re-<br>programming for the object tracking application using<br>the four different methods.</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:81"><nobr><span class="ft3"><b>6.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:485;left:121"><nobr><span class="ft3"><b>Quantitative Comparison</b></span></nobr></DIV>
<DIV style="position:absolute;top:504;left:99"><nobr><span class="ft4">Using our model from Section 6.1 and the results from</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:81"><nobr><span class="ft8">the above measurements, we can calculate approximations<br>of the energy consumption for distribution, reprogramming,<br>and execution of native and virtual machine programs in or-<br>der to compare the methods with each other. We set P</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:409"><nobr><span class="ft18">p</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:415"><nobr><span class="ft4">, the</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:81"><nobr><span class="ft8">scale factor of the energy consumption for receiving an ob-<br>ject file, to the average Deluge overhead of 3.35.</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:81"><nobr><span class="ft1">6.4.1</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:130"><nobr><span class="ft1">Dynamic Linking vs Full Image Replacement</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:99"><nobr><span class="ft4">We first compare the energy costs for the two native code</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:81"><nobr><span class="ft8">reprogramming models: dynamic linking and full image re-<br>placement. Table 8 shows the results for the energy con-<br>sumption of reprogramming the blinker application. The size<br>of blinker application including the operating system is 20<br>KB which is about 20 times the size of the blinker applica-<br>tion itself. Even though no linking needs to be performed<br>during the full image replacement, this method is about 20<br>times more expensive to perform a whole image replacement<br>compared to a modular update using the dynamic linker.</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:81"><nobr><span class="ft1">6.4.2</span></nobr></DIV>
<DIV style="position:absolute;top:805;left:130"><nobr><span class="ft1">Dynamic Linking vs Virtual Machines</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:99"><nobr><span class="ft4">We use the tracking application to compare reprogram-</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:81"><nobr><span class="ft8">ming using the Contiki dynamic linker with code updates for<br>the CVM and the Java virtual machine. CVM programs are<br>typically very small and are not stored in EEPROM, nor are<br>they linked or written to flash. Java uncompressed class files<br>are loaded into flash ROM before they are executed. Table 9<br>shows the sizes of the corresponding binaries and the energy<br>consumption of each reprogramming step.</span></nobr></DIV>
<DIV style="position:absolute;top:954;left:99"><nobr><span class="ft4">As expected, the process of updating sensor nodes with</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:81"><nobr><span class="ft8">native code is less energy-efficient than updating with a vir-<br>tual machine. Also, as shown in Table 6, executing native<br>code is more energy-efficient than executing code for the vir-<br>tual machines.</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:99"><nobr><span class="ft4">By combining the results in Table 6 and Table 9, we can</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:81"><nobr><span class="ft8">compute break-even points for how often we can execute na-<br>tive code as opposed to virtual machine code for the same</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:571"><nobr><span class="ft17"><b> 0</b></span></nobr></DIV>
<DIV style="position:absolute;top:223;left:567"><nobr><span class="ft17"><b> 20</b></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:567"><nobr><span class="ft17"><b> 40</b></span></nobr></DIV>
<DIV style="position:absolute;top:187;left:567"><nobr><span class="ft17"><b> 60</b></span></nobr></DIV>
<DIV style="position:absolute;top:169;left:567"><nobr><span class="ft17"><b> 80</b></span></nobr></DIV>
<DIV style="position:absolute;top:151;left:563"><nobr><span class="ft17"><b> 100</b></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:563"><nobr><span class="ft17"><b> 120</b></span></nobr></DIV>
<DIV style="position:absolute;top:114;left:563"><nobr><span class="ft17"><b> 140</b></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:579"><nobr><span class="ft17"><b> 0</b></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:606"><nobr><span class="ft17"><b> 20000</b></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:641"><nobr><span class="ft17"><b> 40000</b></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:676"><nobr><span class="ft17"><b> 60000</b></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:711"><nobr><span class="ft17"><b> 80000</b></span></nobr></DIV>
<DIV style="position:absolute;top:249;left:744"><nobr><span class="ft17"><b> 100000</b></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:554"><nobr><span class="ft17"><b>Consumed energy (mJ)</b></span></nobr></DIV>
<DIV style="position:absolute;top:260;left:621"><nobr><span class="ft17"><b>Number of program iterations</b></span></nobr></DIV>
<DIV style="position:absolute;top:120;left:589"><nobr><span class="ft17"><b>Java VM</b></span></nobr></DIV>
<DIV style="position:absolute;top:128;left:604"><nobr><span class="ft17"><b>ELF</b></span></nobr></DIV>
<DIV style="position:absolute;top:135;left:601"><nobr><span class="ft17"><b>CVM</b></span></nobr></DIV>
<DIV style="position:absolute;top:143;left:599"><nobr><span class="ft17"><b>CELF</b></span></nobr></DIV>
<DIV style="position:absolute;top:273;left:477"><nobr><span class="ft8">Figure 8. Break-even points for the object tracking pro-<br>gram implemented with four different linking and execu-<br>tion methods.</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:571"><nobr><span class="ft17"><b> 0</b></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:567"><nobr><span class="ft17"><b> 20</b></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:567"><nobr><span class="ft17"><b> 40</b></span></nobr></DIV>
<DIV style="position:absolute;top:413;left:567"><nobr><span class="ft17"><b> 60</b></span></nobr></DIV>
<DIV style="position:absolute;top:395;left:567"><nobr><span class="ft17"><b> 80</b></span></nobr></DIV>
<DIV style="position:absolute;top:376;left:563"><nobr><span class="ft17"><b> 100</b></span></nobr></DIV>
<DIV style="position:absolute;top:358;left:563"><nobr><span class="ft17"><b> 120</b></span></nobr></DIV>
<DIV style="position:absolute;top:340;left:563"><nobr><span class="ft17"><b> 140</b></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:579"><nobr><span class="ft17"><b> 0</b></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:610"><nobr><span class="ft17"><b> 200</b></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:645"><nobr><span class="ft17"><b> 400</b></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:680"><nobr><span class="ft17"><b> 600</b></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:715"><nobr><span class="ft17"><b> 800</b></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:748"><nobr><span class="ft17"><b> 1000</b></span></nobr></DIV>
<DIV style="position:absolute;top:441;left:554"><nobr><span class="ft17"><b>Consumed energy (mJ)</b></span></nobr></DIV>
<DIV style="position:absolute;top:486;left:621"><nobr><span class="ft17"><b>Number of program iterations</b></span></nobr></DIV>
<DIV style="position:absolute;top:346;left:589"><nobr><span class="ft17"><b>Java VM</b></span></nobr></DIV>
<DIV style="position:absolute;top:353;left:604"><nobr><span class="ft17"><b>ELF</b></span></nobr></DIV>
<DIV style="position:absolute;top:361;left:601"><nobr><span class="ft17"><b>CVM</b></span></nobr></DIV>
<DIV style="position:absolute;top:369;left:599"><nobr><span class="ft17"><b>CELF</b></span></nobr></DIV>
<DIV style="position:absolute;top:499;left:477"><nobr><span class="ft8">Figure 9. Break-even points for the vector convolution<br>implemented with four different linking and execution<br>methods.</span></nobr></DIV>
<DIV style="position:absolute;top:576;left:477"><nobr><span class="ft8">energy consumption. That is, after how many program it-<br>erations do the cheaper execution costs outweigh the more<br>expensive code updates.</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:495"><nobr><span class="ft4">Figure 8 shows the modeled energy consumption for exe-</span></nobr></DIV>
<DIV style="position:absolute;top:642;left:477"><nobr><span class="ft8">cuting the Object Tracking program using native code loaded<br>with an ELF object file, native code loaded with an CELF<br>object file, CVM code, and Java code. We see that the Java<br>virtual machine is expensive in terms of energy and will al-<br>ways require more energy than native code loaded with a<br>CELF file. For native code loaded with an ELF file the en-<br>ergy overhead due to receiving the file makes the Java virtual<br>machine more energy efficient until the program is repeated<br>a few thousand times. Due to the small size of the CVM code<br>it is very energy efficient for small numbers of program iter-<br>ations. It takes about 40000 iterations of the program before<br>the interpretation overhead outweigh the linking and load-<br>ing overhead of same program running as native code and<br>loaded as a CELF file. If the native program was loaded with<br>an ELF file, however, the CVM program needs to be run ap-<br>proximately 80000 iterations before the energy costs are the<br>same. At the break-even point, the energy consumption is<br>only about one fifth of the energy consumption for loading<br>the blink program using full image replacement as shown in<br>Table 8.</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:495"><nobr><span class="ft4">In contrast with Figure 8, Figure 9 contains the break-</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:477"><nobr><span class="ft8">even points from the vector convolution in Table 7. We as-<br>sume that the convolution algorithm is part of a program with<br>the same size as in Figure 8 so that the energy consumption<br>for reprogramming is the same. In this case the break-even<br>points are drastically lower than in Figure 8. Here the native<br>code loaded with an ELF file outperforms the Java imple-</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">25</span></nobr></DIV>
</DIV>
<!-- Page 12 -->
<a name="12"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="170012.png" alt="background image">
<DIV style="position:absolute;top:113;left:81"><nobr><span class="ft8">mentation already at 100 iterations. The CVM implementa-<br>tion has spent as much energy as the native ELF implemen-<br>tation after 500 iterations.</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:81"><nobr><span class="ft3"><b>6.5</b></span></nobr></DIV>
<DIV style="position:absolute;top:168;left:121"><nobr><span class="ft3"><b>Scenario Suitability</b></span></nobr></DIV>
<DIV style="position:absolute;top:188;left:99"><nobr><span class="ft4">We can now apply our results to the software update sce-</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:81"><nobr><span class="ft8">narios discussed in Section 2. In a scenario with frequent<br>code updates, such as the dynamic application scenario or<br>during software development, a low loading overhead is to<br>prefer.</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:134"><nobr><span class="ft4">From Figure 8 we see that both an application-</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:81"><nobr><span class="ft8">specific virtual machine and a Java machine may be good<br>choices. Depending on the type of application it may be ben-<br>eficial to decide to run the program on top of a more flexible<br>virtual machine such as the Java machine. The price for such<br>a decision is higher energy overhead.</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:99"><nobr><span class="ft4">In scenarios where the update frequency is low, e.g. when</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:81"><nobr><span class="ft8">fixing bugs in installed software or when reconfiguring an<br>installed application, the higher price for dynamic linking<br>may be worth paying. If the program is continuously run for<br>a long time, the energy savings of being able to use native<br>code outweigh the energy cost of the linking process. Fur-<br>thermore, with a virtual machine it may not be possible to<br>make changes to all levels of the system. For example, a bug<br>in a low-level driver can usually only be fixed by installing<br>new native code. Moreover, programs that are computation-<br>ally heavy benefit from being implemented as native code as<br>native code has lower energy consumption than virtual ma-<br>chine code.</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:99"><nobr><span class="ft4">The results from Figures 8 and 9 suggest that a combi-</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:81"><nobr><span class="ft8">nation of virtual machin code and native code can be energy<br>efficient. For many situations this may be a viable alternative<br>to running only native code or only virtual machine code.</span></nobr></DIV>
<DIV style="position:absolute;top:641;left:81"><nobr><span class="ft3"><b>6.6</b></span></nobr></DIV>
<DIV style="position:absolute;top:641;left:121"><nobr><span class="ft3"><b>Portability</b></span></nobr></DIV>
<DIV style="position:absolute;top:660;left:99"><nobr><span class="ft4">Because of the diversity of sensor network platforms, the</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:81"><nobr><span class="ft8">Contiki dynamic linker is designed to be portable between<br>different microcontrollers. The dynamic linker is divided<br>into two modules: a generic part that parses and analyzes<br>the ELF/CELF that is to be loaded, and a microcontroller-<br>specific part that allocates memory for the program to be<br>loaded, performs code and data relocation, and writes the<br>linked program into memory.</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:99"><nobr><span class="ft4">To evaluate the portability of our design we have ported</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:81"><nobr><span class="ft8">the dynamic linker to two different microcontrollers: the TI<br>MSP430 and the Atmel AVR. The TI MSP430 is used in<br>several sensor network platforms, including the Telos Sky<br>and the ESB. The Atmel AVR is used in the Mica2 motes.</span></nobr></DIV>
<DIV style="position:absolute;top:876;left:99"><nobr><span class="ft4">Table 10 shows the number of lines of code needed to</span></nobr></DIV>
<DIV style="position:absolute;top:893;left:81"><nobr><span class="ft8">implement each module. The dramatic difference between<br>the MSP430-specific module and the AVR-specific module<br>is due to the different addressing modes used by the ma-<br>chine code of the two microcontrollers. While the MSP430<br>has only one addressing mode, the AVR has 19 different ad-<br>dressing modes. Each addressing mode must be handled dif-<br>ferently by the relocation function, which leads to a larger<br>amount of code for the AVR-specific module.</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:81"><nobr><span class="ft3"><b>7</b></span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:108"><nobr><span class="ft3"><b>Discussion</b></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:99"><nobr><span class="ft4">Standard file formats.</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:261"><nobr><span class="ft4">Our main motivation behind</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:81"><nobr><span class="ft4">choosing the ELF format for dynamic linking in Contiki was</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:609"><nobr><span class="ft4">Lines of code,</span></nobr></DIV>
<DIV style="position:absolute;top:110;left:741"><nobr><span class="ft4">Lines of code,</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:488"><nobr><span class="ft4">Module</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:668"><nobr><span class="ft4">total</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:712"><nobr><span class="ft4">relocation function</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:488"><nobr><span class="ft4">Generic linker</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:672"><nobr><span class="ft4">292</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:488"><nobr><span class="ft4">MSP430-specific</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:679"><nobr><span class="ft4">45</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:818"><nobr><span class="ft4">8</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:488"><nobr><span class="ft4">AVR-specific</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:672"><nobr><span class="ft4">143</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:803"><nobr><span class="ft4">104</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:477"><nobr><span class="ft8">Table 10. Number of lines of code for the dynamic linker<br>and the microcontroller-specific parts.</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:477"><nobr><span class="ft8">that the ELF format is a standard file format. Many com-<br>pilers and utilities, including all GCC utilities, are able to<br>produce and handle ELF files. Hence no special software is<br>needed to compile and upload new programs into a network<br>of Contiki nodes. In contrast, FlexCup [27] or diff-based<br>approaches require the usage of specially crafted utilities to<br>produce meta data or diff scripts required for uploading soft-<br>ware. These special utilities also need to be maintained and<br>ported to the full range of development platforms used for<br>software development for the system.</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:495"><nobr><span class="ft4">Operating system support. Dynamic linking of ELF</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:477"><nobr><span class="ft8">files requires support from the underlying operating system<br>and cannot be done on monolithic operating systems such as<br>TinyOS. This is a disadvantage of our approach. For mono-<br>lithic operating systems, an approach such as FlexCup is bet-<br>ter suited.</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:495"><nobr><span class="ft4">Heterogeneity. With diff-based approaches a binary diff</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:477"><nobr><span class="ft8">is created either at a base station or by an outside server. The<br>server must have knowledge of the exact software configu-<br>ration of the sensor nodes on which the diff script is to be<br>run. If sensor nodes are running different versions of their<br>software, diff-based approaches do not scale.</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:495"><nobr><span class="ft4">Specifically, in many of our development networks we</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:477"><nobr><span class="ft8">have witnessed a form of micro heterogeneity in the soft-<br>ware configuration. Many sensor nodes, which have been<br>running the exact same version of the Contiki operating sys-<br>tem, have had small differences in the address of functions<br>and variables in the core. This micro heterogeneity comes<br>from the different core images being compiled by different<br>developers, each having slightly different versions of the C<br>compiler, the C library and the linker utilities. This results<br>in small variations of the operating system image depending<br>on which developer compiled the operating system image.<br>With diff-based approaches micro heterogeneity poses a big<br>problem, as the base station would have to be aware of all<br>the small differences between each node.</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:495"><nobr><span class="ft4">Combination of native and virtual machine code. Our</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:477"><nobr><span class="ft8">results suggest that a combination of native and virtual ma-<br>chine code is an energy efficient alternative to pure native<br>code or pure virtual machine code approaches. The dynamic<br>linking mechanism can be used to load the native code that<br>is used by the virtual machine code by the native code inter-<br>faces in the virtual machines.</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:477"><nobr><span class="ft3"><b>8</b></span></nobr></DIV>
<DIV style="position:absolute;top:967;left:504"><nobr><span class="ft3"><b>Related Work</b></span></nobr></DIV>
<DIV style="position:absolute;top:987;left:495"><nobr><span class="ft4">Because of the importance of dynamic reprogramming of</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:477"><nobr><span class="ft8">wireless sensor networks there has been a lot of effort in the<br>area of software updates for sensor nodes both in the form<br>of system support for software updates and execution envi-<br>ronments that directly impact the type and size of updates as<br>well as distribution protocols for software updates.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">26</span></nobr></DIV>
</DIV>
<!-- Page 13 -->
<a name="13"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="170013.png" alt="background image">
<DIV style="position:absolute;top:113;left:99"><nobr><span class="ft4">Mainwaring et al. [26] also identified the trade-off be-</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:81"><nobr><span class="ft8">tween using virtual machine code that is more expensive to<br>run but enables more energy-efficient updates and running<br>native code that executes more efficiently but requires more<br>costly updates. This trade-off has been further discussed by<br>Levis and Culler [19] who implemented the Mat´e virtual ma-<br>chine designed to both simplify programming and to lever-<br>age energy-efficient large-scale software updates in sensor<br>networks. Mat´e is implemented on top of TinyOS.</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:99"><nobr><span class="ft4">Levis and Culler later enhanced Mat´e by application spe-</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:81"><nobr><span class="ft8">cific virtual machines (ASVMs) [20]. They address the main<br>limitations of Mat´e: flexibility, concurrency and propaga-<br>tion. Whereas Mat´e was designed for a single application<br>domain only, ASVM supports a wide range of application<br>domains. Further, instead of relying on broadcasts for code<br>propagation as Mat´e, ASVM uses the trickle algorithm [21].</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:99"><nobr><span class="ft4">The MagnetOS [23] system uses the Java virtual ma-</span></nobr></DIV>
<DIV style="position:absolute;top:393;left:81"><nobr><span class="ft8">chine to distribute applications across an ad hoc network<br>of laptops. In MagnetOS, Java applications are partitioned<br>into distributed components. The components transparently<br>communicate by raising events. Unlike Mat´e and Contiki,<br>MagnetOS targets larger platforms than sensor nodes such<br>as PocketPC devices.</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:230"><nobr><span class="ft4">SensorWare [1] is another script-</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:81"><nobr><span class="ft8">based proposal for programming nodes that targets larger<br>platforms. VM* is a framework for runtime environments<br>for sensor networks [18]. Using this framework Koshy and<br>Pandey have implemented a subset of the Java Virtual Ma-<br>chine that enables programmers to write applications in Java,<br>and access sensing devices and I/O through native interfaces.</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:99"><nobr><span class="ft4">Mobile agent-based approaches extend the notion of in-</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:81"><nobr><span class="ft8">jected scripts by deploying dynamic, localized and intelli-<br>gent mobile agents. Using mobile agents, Fok et al. have<br>built the Agilla platform that enables continuous reprogram-<br>ming by injecting new agents into the network [9].</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:99"><nobr><span class="ft4">TinyOS uses a special description language for compos-</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:81"><nobr><span class="ft8">ing a system of smaller components [10] which are statically<br>linked with the kernel to a complete image of the system.<br>After linking, modifying the system is not possible [19] and<br>hence TinyOS requires the whole image to be updated even<br>for small code changes.</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:99"><nobr><span class="ft4">Systems that offer loadable modules besides Contiki in-</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:81"><nobr><span class="ft8">clude SOS [12] and Impala [24]. Impala features an ap-<br>plication updater that enables software updates to be per-<br>formed by linking in updated modules. Updates in Impala<br>are coarse-grained since cross-references between different<br>modules are not possible. Also, the software updater in<br>Impala was only implemented for much more resource-rich<br>hardware than our target devices. The design of SOS [12]<br>is very similar to the Contiki system: SOS consists of a<br>small kernel and dynamically-loaded modules. However,<br>SOS uses position independent code to achieve relocation<br>and jump tables for application programs to access the op-<br>erating system kernel. Application programs can register<br>function pointers with the operating system for performing<br>inter-process communication. Position independent code is<br>not available for all platforms, however, which limits the ap-<br>plicability of this approach.</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:99"><nobr><span class="ft4">FlexCup [27] enables run-time installation of software</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:81"><nobr><span class="ft4">components in TinyOS and thus solves the problem that</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:477"><nobr><span class="ft8">a full image replacement is required for reprogramming<br>TinyOS applications. In contrast to our ELF-based solution,<br>FlexCup uses a non-standard format and is less portable.<br>Further, FlexCup requires a reboot after a program has been<br>installed, requiring an external mechanism to save and re-<br>store the state of all other applications as well as the state of<br>running network protocols across the reboot. Contiki does<br>not need to be rebooted after a program has been installed.</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:495"><nobr><span class="ft4">FlexCup also requires a complete duplicate image of the</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:477"><nobr><span class="ft8">binary image of the system to be stored in external flash<br>ROM. The copy of the system image is used for constructing<br>a new system image when a new program has been loaded.<br>In contrast, the Contiki dynamic linker does not alter the core<br>image when programs are loaded and therefore no external<br>copy of the core image is needed.</span></nobr></DIV>
<DIV style="position:absolute;top:362;left:495"><nobr><span class="ft4">Since the energy consumption of distributing code in sen-</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:477"><nobr><span class="ft8">sor networks increases with the size of the code to be dis-<br>tributed several attempts have been made to reduce the size<br>of the code to be distributed. Reijers and Langendoen [31]<br>produce an edit script based on the difference between the<br>modified and original executable. After various optimiza-<br>tions including architecture-dependent ones, the script is dis-<br>tributed. A similar approach has been developed by Jeong<br>and Culler [15] who use the rsync algorithm to generate the<br>difference between modified and original executable. Koshy<br>and Pandey's diff-based approach [17] reduces the amount<br>of flash rewriting by modifying the linking procedure so that<br>functions that are not changed are not shifted.</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:495"><nobr><span class="ft4">XNP [16] was the previous default reprogramming mech-</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:477"><nobr><span class="ft8">anism in TinyOS which is used by the multi-hop reprogram-<br>ming scheme MOAP (Multihop Over-the-Air Programming)<br>developed to distribute node images in the sensor network.<br>MOAP distributes data to a selective number of nodes on<br>a neighbourhood-by-neighbourhood basis that avoids flood-<br>ing [34]. In Trickle [21] virtual machine code is distributed<br>to a network of nodes. While Trickle is restricted to single<br>packet dissemination, Deluge adds support for the dissemi-<br>nation of large data objects [14].</span></nobr></DIV>
<DIV style="position:absolute;top:752;left:477"><nobr><span class="ft3"><b>9</b></span></nobr></DIV>
<DIV style="position:absolute;top:752;left:504"><nobr><span class="ft3"><b>Conclusions</b></span></nobr></DIV>
<DIV style="position:absolute;top:774;left:495"><nobr><span class="ft4">We have presented a highly portable dynamic linker and</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:477"><nobr><span class="ft8">loader that uses the standard ELF file format and compared<br>the energy-efficiency of run-time dynamic linking with an<br>application specific virtual machine and a Java virtual ma-<br>chine. We show that dynamic linking is feasible even for<br>constrained sensor nodes.</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:495"><nobr><span class="ft4">Our results also suggest that a combination of native and</span></nobr></DIV>
<DIV style="position:absolute;top:890;left:477"><nobr><span class="ft8">virtual machine code provide an energy efficient alternative<br>to pure native code or pure virtual machine approaches. The<br>native code that is called from the virtual machine code can<br>be updated using the dynamic linker, even in heterogeneous<br>systems.</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:477"><nobr><span class="ft3"><b>Acknowledgments</b></span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:495"><nobr><span class="ft4">This work was partly financed by VINNOVA, the</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:477"><nobr><span class="ft8">Swedish Agency for Innovation Systems, and the European<br>Commission under contract IST-004536-RUNES. Thanks to<br>our paper shepherd Feng Zhao for reading and commenting<br>on the paper.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">27</span></nobr></DIV>
</DIV>
<!-- Page 14 -->
<a name="14"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft22{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="170014.png" alt="background image">
<DIV style="position:absolute;top:110;left:81"><nobr><span class="ft3"><b>10</b></span></nobr></DIV>
<DIV style="position:absolute;top:110;left:117"><nobr><span class="ft3"><b>References</b></span></nobr></DIV>
<DIV style="position:absolute;top:137;left:87"><nobr><span class="ft18">[1] A. Boulis, C. Han, and M. B. Srivastava. Design and implementation</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:108"><nobr><span class="ft22">of a framework for efficient and programmable sensor networks. In<br>Proceedings of The First International Conference on Mobile Systems,<br>Applications, and Services (MOBISYS `03), May 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:87"><nobr><span class="ft18">[2] Chipcon</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:163"><nobr><span class="ft18">AS.</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:223"><nobr><span class="ft18">CC2420</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:278"><nobr><span class="ft18">Datasheet</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:339"><nobr><span class="ft18">(rev.</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:375"><nobr><span class="ft18">1.3),</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:414"><nobr><span class="ft18">2005.</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:108"><nobr><span class="ft2">http://www.chipcon.com/</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:87"><nobr><span class="ft18">[3] TIS Committee. Tool Interface Standard (TIS) Executable and Link-</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:108"><nobr><span class="ft18">ing Format (ELF) Specification Version 1.2, May 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:87"><nobr><span class="ft18">[4] H. Dai, M. Neufeld, and R. Han. Elf: an efficient log-structured flash</span></nobr></DIV>
<DIV style="position:absolute;top:278;left:108"><nobr><span class="ft18">file system for micro sensor nodes. In SenSys, pages 176­187, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:87"><nobr><span class="ft18">[5] A. Dunkels, B. Gr¨onvall, and T. Voigt. Contiki - a lightweight and</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:108"><nobr><span class="ft22">flexible operating system for tiny networked sensors. In Proceedings<br>of the First IEEE Workshop on Embedded Networked Sensors, Tampa,<br>Florida, USA, November 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:87"><nobr><span class="ft18">[6] A. Dunkels, O. Schmidt, T. Voigt, and M. Ali. Protothreads: Sim-</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:108"><nobr><span class="ft22">plifying event-driven programming of memory-constrained embedded<br>systems. In Proceedings of the 4th International Conference on Em-<br>bedded Networked Sensor Systems, SenSys 2006, Boulder, Colorado,<br>USA, 2006.</span></nobr></DIV>
<DIV style="position:absolute;top:433;left:87"><nobr><span class="ft18">[7] D. Estrin (editor). Embedded everywhere: A research agenda for net-</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:108"><nobr><span class="ft22">worked systems of embedded computers. National Academy Press, 1st<br>edition, October 2001. ISBN: 0309075688</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:87"><nobr><span class="ft18">[8] G. Ferrari, J. Stuber, A. Gombos, and D. Laverde, editors. Program-</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:108"><nobr><span class="ft22">ming Lego Mindstorms with Java with CD-ROM. Syngress Publishing,<br>2002. ISBN: 1928994555</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:87"><nobr><span class="ft18">[9] C. Fok, G. Roman, and C. Lu. Rapid development and flexible deploy-</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:108"><nobr><span class="ft22">ment of adaptive wireless sensor network applications. In Proceedings<br>of the 24th International Conference on Distributed Computing Sys-<br>tems, June 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:81"><nobr><span class="ft18">[10] D. Gay, P. Levis, R. von Behren, M. Welsh, E. Brewer, and D. Culler.</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:108"><nobr><span class="ft22">The nesC language: A holistic approach to networked embedded sys-<br>tems. In Proceedings of the ACM SIGPLAN 2003 conference on Pro-<br>gramming language design and implementation, pages 1­11, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:81"><nobr><span class="ft18">[11] J. A. Gutierrez, M. Naeve, E. Callaway, M. Bourgeois, V. Mitter, and</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:108"><nobr><span class="ft22">B. Heile. IEEE 802.15.4: A developing standard for low-power low-<br>cost wireless personal area networks. IEEE Network, 15(5):12­19,<br>September/October 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:709;left:81"><nobr><span class="ft18">[12] C. Han, R. K. Rengaswamy, R. Shea, E. Kohler, and M. Srivastava.</span></nobr></DIV>
<DIV style="position:absolute;top:722;left:108"><nobr><span class="ft22">Sos: A dynamic operating system for sensor networks. In MobiSYS<br>'05: Proceedings of the 3rd international conference on Mobile sys-<br>tems, applications, and services. ACM Press, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:81"><nobr><span class="ft18">[13] J. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and K. Pister. Sys-</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:108"><nobr><span class="ft22">tem architecture directions for networked sensors. In Proceedings of<br>the 9th International Conference on Architectural Support for Pro-<br>gramming Languages and Operating Systems, November 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:830;left:81"><nobr><span class="ft18">[14] J. W. Hui and D. Culler. The dynamic behavior of a data dissemina-</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:108"><nobr><span class="ft22">tion protocol for network programming at scale. In Proc. SenSys'04,<br>Baltimore, Maryland, USA, November 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:81"><nobr><span class="ft18">[15] J. Jeong and D. Culler. Incremental network programming for wire-</span></nobr></DIV>
<DIV style="position:absolute;top:890;left:108"><nobr><span class="ft22">less sensors. In Proceedings of the First IEEE Communications Soci-<br>ety Conference on Sensor and Ad Hoc Communications and Networks<br>IEEE SECON (2004), October 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:81"><nobr><span class="ft18">[16] J.</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:129"><nobr><span class="ft18">Jeong,</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:175"><nobr><span class="ft18">S.</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:197"><nobr><span class="ft18">Kim,</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:236"><nobr><span class="ft18">and</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:266"><nobr><span class="ft18">A.</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:290"><nobr><span class="ft18">Broad.</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:358"><nobr><span class="ft18">Network</span></nobr></DIV>
<DIV style="position:absolute;top:937;left:412"><nobr><span class="ft18">repro-</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:108"><nobr><span class="ft18">gramming.</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:205"><nobr><span class="ft18">TinyOS</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:258"><nobr><span class="ft18">documentation,</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:350"><nobr><span class="ft18">2003.</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:421"><nobr><span class="ft18">Vis-</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:108"><nobr><span class="ft18">ited</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:176"><nobr><span class="ft18">2006-04-06.</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:284"><nobr><span class="ft2">http://www.tinyos.net/tinyos-</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:108"><nobr><span class="ft2">1.x/doc/NetworkReprogramming.pdf</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:81"><nobr><span class="ft18">[17] J. Koshy and R. Pandey.</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:243"><nobr><span class="ft18">Remote incremental linking for energy-</span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:108"><nobr><span class="ft22">efficient reprogramming of sensor networks. In Proceedings of the<br>second European Workshop on Wireless Sensor Networks, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:1045;left:81"><nobr><span class="ft18">[18] J. Koshy and R. Pandey. Vm*: Synthesizing scalable runtime envi-</span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:108"><nobr><span class="ft22">ronments for sensor networks. In Proc. SenSys'05, San Diego, CA,<br>USA, November 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:477"><nobr><span class="ft18">[19] P. Levis and D. Culler. Mat´e: A tiny virtual machine for sensor net-</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:504"><nobr><span class="ft22">works. In Proceedings of ASPLOS-X, San Jose, CA, USA, October<br>2002.</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:477"><nobr><span class="ft18">[20] P. Levis, D. Gay, and D Culler. Active sensor networks. In Proc.</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:504"><nobr><span class="ft18">USENIX/ACM NSDI'05, Boston, MA, USA, May 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:477"><nobr><span class="ft18">[21] P. Levis, N. Patel, D. Culler, and S. Shenker. Trickle: A self-regulating</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:504"><nobr><span class="ft22">algorithm for code propagation and maintenance in wireless sensor<br>networks. In Proc. NSDI'04, March 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:477"><nobr><span class="ft18">[22] J. Lilius and I. Paltor.</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:647"><nobr><span class="ft18">Deeply embedded python, a virtual</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:504"><nobr><span class="ft18">machine for embedded systems.</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:699"><nobr><span class="ft18">Web page.</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:778"><nobr><span class="ft18">2006-04-06.</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:504"><nobr><span class="ft2">http://www.tucs.fi/magazin/output.php?ID=2000.N2.LilDeEmPy</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:477"><nobr><span class="ft18">[23] H. Liu, T. Roeder, K. Walsh, R. Barr, and E. G¨un Sirer. Design and</span></nobr></DIV>
<DIV style="position:absolute;top:303;left:504"><nobr><span class="ft22">implementation of a single system image operating system for ad hoc<br>networks. In MobiSys, pages 149­162, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:477"><nobr><span class="ft18">[24] T. Liu, C. Sadler, P. Zhang, and M. Martonosi. Implementing software</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:504"><nobr><span class="ft22">on resource-constrained mobile sensors: Experiences with Impala and<br>ZebraNet. In Proc. Second Intl. Conference on Mobile Systems, Ap-<br>plications and Services (MOBISYS 2004), June 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:397;left:477"><nobr><span class="ft18">[25] G. Mainland, L. Kang, S. Lahaie, D. C. Parkes, and M. Welsh. Using</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:504"><nobr><span class="ft22">virtual markets to program global behavior in sensor networks. In Pro-<br>ceedings of the 2004 SIGOPS European Workshop, Leuven, Belgium,<br>September 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:477"><nobr><span class="ft18">[26] A. Mainwaring, J. Polastre, R. Szewczyk, D. Culler, and J. Anderson.</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:504"><nobr><span class="ft22">Wireless sensor networks for habitat monitoring. In First ACM Work-<br>shop on Wireless Sensor Networks and Applications (WSNA 2002),<br>Atlanta, GA, USA, September 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:518;left:477"><nobr><span class="ft18">[27] P. Jos´e Marr´on, M. Gauger, A. Lachenmann, D. Minder, O. Saukh, and</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:504"><nobr><span class="ft22">K. Rothermel. Flexcup: A flexible and efficient code update mecha-<br>nism for sensor networks. In European Workshop on Wireless Sensor<br>Networks, 2006.</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:477"><nobr><span class="ft18">[28] A. Perrig, R. Szewczyk, V. Wen, D. E. Culler, and J. D. Tygar. SPINS:</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:504"><nobr><span class="ft22">security protocols for sensor netowrks. In Mobile Computing and Net-<br>working, pages 189­199, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:477"><nobr><span class="ft18">[29] J. Polastre, R. Szewczyk, and D. Culler. Telos: Enabling ultra-low</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:504"><nobr><span class="ft22">power wireless research. In Proc. IPSN/SPOTS'05, Los Angeles, CA,<br>USA, April 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:477"><nobr><span class="ft18">[30] N. Ramanathan, E. Kohler, and D. Estrin. Towards a debugging sys-</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:504"><nobr><span class="ft22">tem for sensor networks. International Journal for Network Manage-<br>ment, 3(5), 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:477"><nobr><span class="ft18">[31] N. Reijers and K. Langendoen. Efficient code distribution in wireless</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:504"><nobr><span class="ft22">sensor networks. In Proceedings of the 2nd ACM international con-<br>ference on Wireless sensor networks and applications, pages 60­67,<br>2003.</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:477"><nobr><span class="ft18">[32] RF Monolithics.</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:596"><nobr><span class="ft18">868.35 MHz Hybrid Transceiver TR1001, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:504"><nobr><span class="ft2">http://www.rfm.com</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:477"><nobr><span class="ft18">[33] J. Schiller, H. Ritter, A. Liers, and T. Voigt. Scatterweb - low power</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:504"><nobr><span class="ft22">nodes and energy aware routing. In Proceedings of Hawaii Interna-<br>tional Conference on System Sciences, Hawaii, USA, 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:861;left:477"><nobr><span class="ft18">[34] T. Stathopoulos, J. Heidemann, and D. Estrin. A remote code update</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:504"><nobr><span class="ft22">mechanism for wireless sensor networks. Technical Report CENS-<br>TR-30, University of California, Los Angeles, Center for Embedded<br>Networked Computing, November 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:477"><nobr><span class="ft18">[35] M. Welsh and G. Mainland. Programming sensor networks using ab-</span></nobr></DIV>
<DIV style="position:absolute;top:935;left:504"><nobr><span class="ft22">stract regions. In Proc. USENIX/ACM NSDI'04, San Francisco, CA,,<br>March 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:477"><nobr><span class="ft18">[36] G. Werner-Allen, P. Swieskowski, and M. Welsh. Motelab: A wireless</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:504"><nobr><span class="ft22">sensor network testbed. In Proc. IPSN/SPOTS'05, Los Angeles, CA,<br>USA, April 2005.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft7">28</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
