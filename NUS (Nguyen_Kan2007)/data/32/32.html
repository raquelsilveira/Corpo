<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>An expressive aspect language for system applications with Arachne</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2005-09-29T07:13:49+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Helvetica;color:#000000;}
	.ft1{font-size:15px;font-family:Helvetica;color:#000000;}
	.ft2{font-size:11px;font-family:Times;color:#000000;}
	.ft3{font-size:15px;font-family:Times;color:#000000;}
	.ft4{font-size:9px;font-family:Times;color:#000000;}
	.ft5{font-size:9px;font-family:Times;color:#000000;}
	.ft6{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft7{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32001.png" alt="background image">
<DIV style="position:absolute;top:109;left:103"><nobr><span class="ft0"><b>An expressive aspect language for system applications</b></span></nobr></DIV>
<DIV style="position:absolute;top:139;left:373"><nobr><span class="ft0"><b>with Arachne</b></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:274"><nobr><span class="ft1">R ´emi Douence, Thomas Fritz, Nicolas Loriant,</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:208"><nobr><span class="ft1">Jean-Marc Menaud, Marc S ´egura-Devillechaise, Mario S ¨udholt</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:390"><nobr><span class="ft1">OBASCO project</span></nobr></DIV>
<DIV style="position:absolute;top:282;left:325"><nobr><span class="ft1">´</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:322"><nobr><span class="ft1">Ecole des Mines de Nantes/INRIA</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:380"><nobr><span class="ft1">4 rue Alfred Kastler</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:333"><nobr><span class="ft1">44307 Nantes Cedex 3, France</span></nobr></DIV>
<DIV style="position:absolute;top:339;left:260"><nobr><span class="ft2">{douence,tfritz,nloriant,jmenaud,msegura,sudholt}@emn.fr</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:81"><nobr><span class="ft3"><b>ABSTRACT</b></span></nobr></DIV>
<DIV style="position:absolute;top:401;left:81"><nobr><span class="ft6">C applications, in particular those using operating system<br>level services, frequently comprise multiple crosscutting con-<br>cerns: network protocols and security are typical examples<br>of such concerns. While these concerns can partially be ad-<br>dressed during design and implementation of an application,<br>they frequently become an issue at runtime, e.g., to avoid<br>server downtime. A deployed network protocol might not be<br>efficient enough and may thus need to be replaced. Buffer<br>overflows might be discovered that imply critical breaches in<br>the security model of an application. A prefetching strategy<br>may be required to enhance performance.</span></nobr></DIV>
<DIV style="position:absolute;top:573;left:94"><nobr><span class="ft2">While aspect-oriented programming seems attractive in</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:81"><nobr><span class="ft6">this context, none of the current aspect systems is expres-<br>sive and efficient enough to address such concerns. This<br>paper presents a new aspect system to provide a solution to<br>this problem. While efficiency considerations have played<br>an important part in the design of the aspect language, the<br>language allows aspects to be expressed more concisely than<br>previous approaches. In particular, it allows aspect pro-<br>grammers to quantify over sequences of execution points as<br>well as over accesses through variable aliases. We show how<br>the former can be used to modularize the replacement of net-<br>work protocols and the latter to prevent buffer overflows.<br>We also present an implementation of the language as an<br>extension of Arachne, a dynamic weaver for C applications.<br>Finally, we present performance evaluations supporting that<br>Arachne is fast enough to extend high performance applica-<br>tions, such as the Squid web cache.</span></nobr></DIV>
<DIV style="position:absolute;top:886;left:81"><nobr><span class="ft3"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:908;left:81"><nobr><span class="ft6">aspect language, sequence pointcut, dynamic weaving, sys-<br>tem applications</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:81"><nobr><span class="ft7">Permission to make digital or hard copies of all or part of this work for<br>personal or classroom use is granted without fee provided that copies are<br>not made or distributed for profit or commercial advantage and that copies<br>bear this notice and the full citation on the first page. To copy otherwise, to<br>republish, to post on servers or to redistribute to lists, requires prior specific<br>permission and/or a fee.<br><i>AOSD 05 </i>Chicago Illinois USA<br>Copyright 2005 ACM</span></nobr></DIV>
<DIV style="position:absolute;top:1067;left:186"><nobr><span class="ft4"> 1-59593-042-6/05/03 ...</span></nobr></DIV>
<DIV style="position:absolute;top:1068;left:303"><nobr><span class="ft2">$</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:313"><nobr><span class="ft4">5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:475"><nobr><span class="ft3"><b>1.</b></span></nobr></DIV>
<DIV style="position:absolute;top:379;left:507"><nobr><span class="ft3"><b>INTRODUCTION</b></span></nobr></DIV>
<DIV style="position:absolute;top:399;left:489"><nobr><span class="ft2">Real-world applications typically comprise multiple cross-</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:475"><nobr><span class="ft6">cutting concerns. This applies, in particular, to C applica-<br>tions using operating system level services. We have exam-<br>ined three concerns which are typical for this domain in the<br>context of a large application, the open source web cache<br>Squid [36]. More concretely, we have considered translation<br>of network protocols (which may be necessary for efficiency<br>reasons), insertion of checks for buffer overflows (which are<br>at the heart of many of today's security issues), and in-<br>troduction of prefetching strategies within the cache (which<br>can be used to enhance efficiency of the web cache). We<br>have found that all these concerns are scattered over large<br>portions of the code of Squid.</span></nobr></DIV>
<DIV style="position:absolute;top:603;left:489"><nobr><span class="ft2">Hence, the three concerns are crosscutting in the sense</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:475"><nobr><span class="ft6">of Aspect-Oriented Programming (AOP) [24] and aspects<br>should therefore be a means of choice for their modular-<br>ization. The concerns have three important characteristics.<br>First, they must frequently be applied at runtime, e.g., in<br>order to rapidly fix a buffer overflow and thus prevent secu-<br>rity breaches without incurring server downtime. A dynamic<br>aspect weaver is therefore needed. Second, they expose in-<br>tricate relationships between execution points, e.g., network<br>protocols are most concisely expressed in terms of sequences<br>of execution points, not individual ones. The aspect system<br>must therefore support expressive means for the definition of<br>aspects, in particular pointcuts. Third, efficiency is crucial<br>in the application domain we consider.</span></nobr></DIV>
<DIV style="position:absolute;top:822;left:489"><nobr><span class="ft2">To our knowledge, none of the current aspect systems for</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:475"><nobr><span class="ft6">C meet these three requirements and is suitable for the mod-<br>ularization of such concerns. Moreover, requirements for<br>dynamic weaving and efficiency often trade off with expres-<br>sivity. Squid should be as efficient as possible and therefore<br>exploit any suitable operating system and hardware partic-<br>ularity. Its code base is therefore difficult to understand and<br>manipulate, thus hindering in particular modularization ef-<br>forts. It is therefore highly questionable that the considered<br>modularization problems can be solved without aspects.</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:489"><nobr><span class="ft2">In this paper we propose a solution to the aspectization of</span></nobr></DIV>
<DIV style="position:absolute;top:995;left:475"><nobr><span class="ft6">such concerns of C applications. More concretely, we provide<br>three main contributions. First, we provide a new expressive<br>aspect language featuring a construct for quantification over<br>sequences of execution points as well as over accesses to lo-<br>cal aliases of global variables. We show how this aspect lan-</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">27</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft8{font-size:7px;font-family:Times;color:#000000;}
	.ft9{font-size:7px;font-family:Times;color:#000000;}
	.ft10{font-size:8px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32002.png" alt="background image">
<DIV style="position:absolute;top:84;left:81"><nobr><span class="ft6">guage permits concise expression of the considered concerns<br>as aspects. Second, we present how the aspect language can<br>be implemented efficiently through runtime weaving into bi-<br>nary code. Concretely, this is done by integrating the aspect<br>language into our tool Arachne, a dynamic weaver for C ap-<br>plications. Furthermore, we present how Arachne improves<br>on our previous work µDyner [32]. Finally, we give evidence<br>that our approach meets strong efficiency requirements by<br>showing performance evaluations in the context of Squid.</span></nobr></DIV>
<DIV style="position:absolute;top:226;left:94"><nobr><span class="ft2">The paper is structured as follows. Section 2 presents the</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:81"><nobr><span class="ft6">motivating concerns we identified within Squid. Section 3<br>shows how to modularize these concerns as aspects and de-<br>fines our aspect language. Section 4 describes its implemen-<br>tation within Arachne. Section 5 assesses the performance<br>of our implementation. Section 6 describes related work.<br>Section 7 concludes and suggests futures work.</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:81"><nobr><span class="ft3"><b>2.</b></span></nobr></DIV>
<DIV style="position:absolute;top:355;left:112"><nobr><span class="ft3"><b>MOTIVATIONS</b></span></nobr></DIV>
<DIV style="position:absolute;top:375;left:94"><nobr><span class="ft2">Legacy C applications involve multiple crosscutting con-</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:81"><nobr><span class="ft6">cerns. Many of them remain challenging, both in terms<br>of expressiveness required to handle them properly in an<br>aspect-oriented language and in terms of constraints posed<br>on the weaver. This section describes three such concerns<br>in C applications: switching the network protocol, buffer<br>overflows and prefetching. The network protocol concern is<br>typically scattered through the entire application. It is an<br>issue when administrators discover at runtime that the re-<br>tained protocol is not efficient enough. Likewise the security<br>threats posed by buffer overflows is a real concrete problem<br>for administrators. While guarding all buffers against over-<br>flows might decrease performance considerably, administra-<br>tors are left with no other option than accepting the trade-<br>off between security and performance chosen at application's<br>design time. Prefetching is another well-known crosscutting<br>concern [12]. Since prefetching aims at increasing perfor-<br>mance, prefetching aspects make only sense with an efficient<br>weaver. Yet, it is still difficult to modularize these three con-<br>cerns in today's aspect-oriented language. In this section,<br>we first describe the context in which the concerns arise be-<br>fore showing their crosscutting nature and finally explaining<br>the lack in current aspect-oriented languages to handle them<br>properly.</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:81"><nobr><span class="ft3"><b>2.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:762;left:121"><nobr><span class="ft3"><b>TCP to UDP protocol</b></span></nobr></DIV>
<DIV style="position:absolute;top:782;left:94"><nobr><span class="ft2">HTTP was essentially designed as a file transfer proto-</span></nobr></DIV>
<DIV style="position:absolute;top:798;left:81"><nobr><span class="ft6">col running on top of TCP, a connection-oriented protocol<br>ensuring communication reliability. While the average Web<br>page size does not exceed 8 KB [4], the cost of retrieving<br>a Web page is often dominated by data exchanged for con-<br>trol purposes of TCP rather than by the page content itself.<br>This is not a new problem, many researches have already<br>pointed out that TCP is not suitable for short-lived connec-<br>tions. While HTTP 1.1 has introduced persistent connec-<br>tions allowing a client to retrieve multiple pages from the<br>same server through the same TCP connection, the number<br>of simultaneous TCP connections is limited by operating<br>systems. Servers have a strong incentive to close HTTP<br>connections as soon as possible. Hence, despite the per-<br>sistent connection mechanism, many studies conclude that<br>TCP should be replaced by UDP to retrieve short pages [10,<br>29, 7]. In spite of its performance improvements, the number<br>of legacy Web applications has prevented a wide adoption<br>of this solution. Typical legacy Web applications have to be</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:530"><nobr><span class="ft8">listen</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:530"><nobr><span class="ft8">accept</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:530"><nobr><span class="ft8">read</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:530"><nobr><span class="ft8">write</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:530"><nobr><span class="ft8">close</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:604"><nobr><span class="ft8">write</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:604"><nobr><span class="ft8">read</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:604"><nobr><span class="ft8">close</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:604"><nobr><span class="ft8">connect</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:604"><nobr><span class="ft8">socket</span></nobr></DIV>
<DIV style="position:absolute;top:98;left:533"><nobr><span class="ft9"><i><b>Server</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:98;left:611"><nobr><span class="ft9"><i><b>Client</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:83;left:557"><nobr><span class="ft10">TCP Protocol</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:530"><nobr><span class="ft8">socket</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:530"><nobr><span class="ft8">bind</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:675"><nobr><span class="ft8">close</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:749"><nobr><span class="ft8">close</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:749"><nobr><span class="ft8">socket</span></nobr></DIV>
<DIV style="position:absolute;top:98;left:678"><nobr><span class="ft9"><i><b>Server</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:98;left:756"><nobr><span class="ft9"><i><b>Client</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:83;left:702"><nobr><span class="ft10">UDP Protocol</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:675"><nobr><span class="ft8">recvfrom</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:675"><nobr><span class="ft8">sendto</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:749"><nobr><span class="ft8">recvfrom</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:675"><nobr><span class="ft8">socket</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:675"><nobr><span class="ft8">bind</span></nobr></DIV>
<DIV style="position:absolute;top:98;left:715"><nobr><span class="ft9"><i><b>Network</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:98;left:570"><nobr><span class="ft9"><i><b>Network</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:199;left:749"><nobr><span class="ft8">sendto</span></nobr></DIV>
<DIV style="position:absolute;top:83;left:648"><nobr><span class="ft10">Time</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:475"><nobr><span class="ft2">Figure 1: Typical usage of the TCP and UDP APIs.</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:475"><nobr><span class="ft6">stopped to switch the protocol. The traditional approach<br>to avoid depriving a subnetwork from Internet connectivity<br>while stopping the cache is to swap the application between<br>different machines. This approach is not only expensive in<br>terms of hardware, it complicates the administrative task of<br>the Web cache administrator and poses the problem of con-<br>sistently transferring the runtime state of the application<br>before restarting it. Stopping an e-commerce Web server<br>means a loss of money and many small companies can not<br>afford the cost of redundant servers. For a wide acceptance,<br>a HTTP dialect using UDP as transport protocol should<br>thus be deployable on demand at runtime.</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:489"><nobr><span class="ft2">In addition, replacing TCP by UDP in an application is</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:475"><nobr><span class="ft6">relatively difficult. The choice of a transport protocol is<br>usually based on standards believed to be ever-lasting and<br>made at an early design stage. Hence no particular effort is<br>made to localize this design decision in a single piece of code.<br>For example, despite a modularization effort, the TCP API<br>provided by the operating system is used directly in 7 of the<br>104 ".c" source files of the Squid Web cache.</span></nobr></DIV>
<DIV style="position:absolute;top:631;left:489"><nobr><span class="ft2">As shown in Fig. 1, the TCP API is built around a set of</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:475"><nobr><span class="ft6">C functions to be invoked sequentially by the application. In<br>a properly written program, TCP functions are first used to<br>establish the connection (typically with socket, connect,<br>bind and listen), exchange data through the connection<br>(typically with read and write) and then close it (typically<br>close). UDP uses similar but less functions. UDP applica-<br>tions first direct the operating system to dedicate the appro-<br>priate resources to exchange data (typically with socket and<br>bind), then exchange data through these resources (typically<br>with sendto and recvfrom) before releasing them (typically<br>with close). Hence, the problem is not only difficult be-<br>cause TCP-related function invocations are scattered but<br>because the relative order of each invocation is important in<br>order to map it onto the appropriate UDP function.</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:489"><nobr><span class="ft2">This example is typical of protocol based APIs. When</span></nobr></DIV>
<DIV style="position:absolute;top:882;left:475"><nobr><span class="ft6">such an API is used in an undisciplined way, it becomes<br>quickly impossible to replace it by another one. Today,<br>aspect-oriented systems lack an appropriate sequencing con-<br>struct in their language. Moreover, many do not provide the<br>ability to weave aspects dynamically.</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:475"><nobr><span class="ft3"><b>2.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:982;left:516"><nobr><span class="ft3"><b>Buffer overflows</b></span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:489"><nobr><span class="ft2">In C, the size of an array is fixed at allocation time. Ac-</span></nobr></DIV>
<DIV style="position:absolute;top:1018;left:475"><nobr><span class="ft6">cording to ISO and ANSI standards [2], an invalid array<br>access does not result in an immediate error but leads to<br>an implementation-dependent behavior. Such behavior is<br>increasingly exploited by hackers to circumvent security re-</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">28</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft11{font-size:15px;line-height:20px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32003.png" alt="background image">
<DIV style="position:absolute;top:84;left:81"><nobr><span class="ft6">strictions [37]. It is therefore crucial for C programmers to<br>ensure every access to an array to be valid. On the other<br>hand, bound checking code is error prone: it is easy to for-<br>get to check an access and even when the access is checked,<br>it is easy to compare the index locating the access with an<br>inappropriate bound. Therefore, researchers have proposed<br>to make compilers responsible for enforcing proper array ac-<br>cess [22, 31]. The problem is that even the most efficient<br>system (CRED [31]) slows down an application up to 130%.<br>Moreover, most frequently used compilers like gcc do not<br>support bound checking.</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:94"><nobr><span class="ft2">Today, administrators discovering a buffer overflow in pro-</span></nobr></DIV>
<DIV style="position:absolute;top:273;left:81"><nobr><span class="ft6">duction software are left with no other option than stopping<br>the application and restarting a bug free version. This was<br>the solution chosen when a buffer overflow was discovered<br>in Squid in [6]. While widely used, this solution suffers from<br>three major drawbacks. First, it does not enforce continuous<br>servicing since the service delivered by the application is not<br>available during the update. Second, this solution entails an<br>important information loss: an administrator has no means<br>to learn whether the buffer overflow has been exploited by<br>a hacker or not. Third, it misunderstands the performance<br>trade-off, i.e. it is not necessary to check every array access,<br>it is only necessary to perform enough checking to discour-<br>age hackers. Therefore, bound checking code should only<br>run when an environment becomes hostile [23].</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:94"><nobr><span class="ft2">Bound checking code tends to crosscut the entire applica-</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:81"><nobr><span class="ft6">tion. For example, properly written C functions accepting<br>an array argument commonly take a second argument hold-<br>ing the array size: the first one allows the function to access<br>the array while the second is used to ensure correctness of<br>accesses. In Squid, bound checking code can be found in<br>any of the 104 ".c" files of its source code. On the 57635<br>lines composing these ".c" files, at least 485 check bounds.</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:94"><nobr><span class="ft2">This problem fails to be handled properly in current as-</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:81"><nobr><span class="ft6">pect languages as they lack the ability to trigger advices<br>upon access made through the alias of a variable. Again,<br>many aspect-oriented systems offer only static weaving ca-<br>pabilities preventing the administrator to choose the trade-<br>off security/performance suiting his needs.</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:81"><nobr><span class="ft3"><b>2.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:121"><nobr><span class="ft3"><b>From fetching to prefetching</b></span></nobr></DIV>
<DIV style="position:absolute;top:751;left:94"><nobr><span class="ft2">Operations like retrieving a file on a local disk or over the</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:81"><nobr><span class="ft6">Web can be sped up if the underlying software anticipates<br>user requests and start to fetch documents beforehand. Such<br>prefetching schemes distinguish themselves from each other<br>in the way they predict future user requests. These "ora-<br>cles" actually prevent a clean encapsulation of prefetching<br>in a single module communicating with the rest of the appli-<br>cation through well-defined interfaces since predictions are<br>based on information meant to be private to other modules.<br>In addition, it is very likely that there is no universal per-<br>fect oracle [19]. A statically linked prefetching module is<br>therefore inappropriate, but prefetching modules along with<br>the necessary oracles should be loaded and unloaded on the<br>fly. Due to their crosscutting nature, prefetching modules<br>including such oracles are better written with aspects [32].</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:94"><nobr><span class="ft2">Coady et al. have already pointed out the crosscutting</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:81"><nobr><span class="ft6">nature of prefetching in the FreeBSD OS [12]. In our pre-<br>vious work considering the Squid Web cache, we reached a<br>similar conclusion [32]. We have previously shown that this<br>concern can be addressed with cflow-like constructs.</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:94"><nobr><span class="ft2">Despite potential performance improvements, prefetching</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:475"><nobr><span class="ft6">also increases resource consumption (e.g. network prefetch-<br>ing consumes local storage and bandwidth). When the pres-<br>sure on resources is too high, prefetching computation com-<br>petes for them against regular user requests, and slows down<br>their treatment instead of speeding it up. In such cases,<br>prefetching should therefore be, temporarily, disabled. Squid<br>essentially manages file descriptors, a resource only available<br>in a limited quantity. A file descriptor is used between the<br>underlying operating system and applications to describe a<br>network connection or a file on the disk. Squid's file descrip-<br>tor management is based on a global variable that tracks the<br>number of file descriptors currently in use. By comparing<br>its value with the maximum number of file descriptors al-<br>lowed by the operating system, it is possible to estimate that<br>prefetching should be disabled or resumed.</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:489"><nobr><span class="ft2">For this problem of file descriptor consumption, the cur-</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:475"><nobr><span class="ft6">rent practice of checking if prefetching should be disabled or<br>not within the advice, is a bad practice that impedes both<br>readability and maintainability. A mechanism is needed<br>within the aspect language to restraint the advice execu-<br>tion at times where the pressure on resources is too high.<br>This problem were not addressed in our previous work.</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:475"><nobr><span class="ft3"><b>3.</b></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:507"><nobr><span class="ft11"><b>AN EXPRESSIVE ASPECT LANGUAGE<br>FOR SYSTEM PROGRAMMING IN C</b></span></nobr></DIV>
<DIV style="position:absolute;top:497;left:489"><nobr><span class="ft2">While AOP seems to be the obvious choice to tackle the</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:475"><nobr><span class="ft6">crosscutting concerns introduced above, none of the existing<br>AO systems provides explicit support for some of their es-<br>sential elements, in particular, join point sequences for pro-<br>tocols, and references to aliases which are local to a function.</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:489"><nobr><span class="ft2">In this section we introduce a new aspect language for</span></nobr></DIV>
<DIV style="position:absolute;top:591;left:475"><nobr><span class="ft6">system programming in C that allows such crosscutting con-<br>cerns to be expressed concisely. In order to make this point,<br>we first revisit the examples by concisely aspectizing them<br>using our language. (Note that our aspect language is ex-<br>pressive in the sense of enabling the concise definition of cer-<br>tain types of aspects, especially compared to other tools for<br>system-level manipulations, but not necessarily more expres-<br>sive than existing approaches in a language-theoretic sense.)<br>We then define the join point model underlying our language<br>precisely, followed by the definition of its syntax and infor-<br>mal semantics. Finally, we illustrate how its semantics can<br>be formally defined in terms of a small-step operational se-<br>mantics using the framework introduced in [14].</span></nobr></DIV>
<DIV style="position:absolute;top:809;left:475"><nobr><span class="ft3"><b>3.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:809;left:516"><nobr><span class="ft3"><b>Example crosscutting concerns revisited</b></span></nobr></DIV>
<DIV style="position:absolute;top:829;left:489"><nobr><span class="ft2">We now revisit the concerns discussed in section 2 in order</span></nobr></DIV>
<DIV style="position:absolute;top:845;left:475"><nobr><span class="ft6">to show our language in action and give evidence that it<br>allows such concerns to be concisely modularized.</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:489"><nobr><span class="ft2">The aspect shown in Fig. 2 translates transport protocols</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:475"><nobr><span class="ft6">from TCP to UDP. A protocol defines a sequence of func-<br>tion calls, so the top-level operator of this aspect is seq.<br>The sequence aspect syntactically consists of a list of pairs<br>of pointcut and advice (separated by then). In the exam-<br>ple, the TCP protocol starts with a call to socket() with<br>three constant arguments: AF INET, SOCK STREAM and<br>0. When such a call is matched, the second parameter is<br>replaced by SOCK DGRAM as required by the UDP proto-<br>col. The result of this transformed call, the file descriptor,<br>is bound to fd by return(fd). Then the next call to con-<br>nect() with the same file descriptor fd as its first parameter<br>is matched. In this case the values of the other parameters</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">29</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft12{font-size:6px;font-family:Times;color:#000000;}
	.ft13{font-size:11px;line-height:19px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32004.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft2">seq( call(int socket(int, int, int)) &amp;&amp; args(AF INET, SOCK STREAM, 0) &amp;&amp; return(fd)</span></nobr></DIV>
<DIV style="position:absolute;top:96;left:127"><nobr><span class="ft2">then socket(AF INET, SOCK DGRAM, 0);</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:113"><nobr><span class="ft2">call(int connect(int, struct socketaddr, socklen t)) &amp;&amp; args(fd, address, length)</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:127"><nobr><span class="ft2">then returnZero();</span></nobr></DIV>
<DIV style="position:absolute;top:128;left:257"><nobr><span class="ft2">// where int returnZero() { return 0; }</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:113"><nobr><span class="ft2">( call(size t read(int, void, size t)) &amp;&amp; args(fd, readBuffer, readLength)</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:145"><nobr><span class="ft2">then recvfrom(fd, readBuffer, readLength, 0, address, length);</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:127"><nobr><span class="ft2">|| call(size t write(int, void, size t)) &amp;&amp; args(fd, writeBuffer, writeLength)</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:154"><nobr><span class="ft2">then sendto(fd, writeBuffer, writeLength, 0, address, length); ) </span></nobr></DIV>
<DIV style="position:absolute;top:206;left:113"><nobr><span class="ft2">call(int close(int)) &amp;&amp; args(fd) ; )</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:193"><nobr><span class="ft2">Figure 2: An Aspect for Switching Transport Protocols, from TCP to UDP</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:81"><nobr><span class="ft2">seq( call(void  malloc(size t))</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:127"><nobr><span class="ft2">&amp;&amp; args(allocatedSize) &amp;&amp; return(buffer) ;</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:113"><nobr><span class="ft2">write(buf f er) &amp;&amp; size(writtenSize)</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:131"><nobr><span class="ft6">&amp;&amp; if(writtenSize &gt; allocatedSize)<br>then reportOverflow (); </span></nobr></DIV>
<DIV style="position:absolute;top:359;left:113"><nobr><span class="ft2">call(void free(void)) )</span></nobr></DIV>
<DIV style="position:absolute;top:389;left:81"><nobr><span class="ft2">Figure 3: An Aspect for Detecting Buffer Overflow</span></nobr></DIV>
<DIV style="position:absolute;top:424;left:81"><nobr><span class="ft6">are bound to arguments address and length, and the original<br>call is replaced by returnZero(). Indeed, there is no connect<br>step in the UDP protocol. After that, calls to read() and<br>write() (using the `or' on aspects: ||) on the same file de-<br>scriptor fd are translated to UDP recvfrom() and sendto(),<br>respectively. Note that sequences of such access are poten-<br>tially translated (due to use of the repetition operator ).<br>Finally, a call to close() on fd terminates the TCP protocol<br>as well as the UDP protocol and thus is not modified (i.e.,<br>there is no then clause). This last step is required to free<br>the variables used in the sequence (here, fd, address and<br>length). Indeed, this aspect can use numerous (instances of<br>these) variables when it deals with interleaved sequences, as<br>each call to socket() creates a new instance of the sequence.</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:94"><nobr><span class="ft2">The aspect shown in Fig. 3 detects buffer overflows. The</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:81"><nobr><span class="ft6">corresponding sequence starts when the function malloc()<br>returns the buffer address which is then bound to buffer.<br>Then, each time this address is accessed (through a global<br>variable or a local alias) the size of the data to be written is<br>compared with the size of the initially allocated memory. If<br>the former exceeds the latter, an overflow is indicated. The<br>sequence ends when the memory is deallocated using free().</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:94"><nobr><span class="ft2">The aspect in Fig. 4 introduces prefetching in a web cache.</span></nobr></DIV>
<DIV style="position:absolute;top:785;left:81"><nobr><span class="ft6">The first controlflow phrase initializes prefetching when<br>an HTTP response is built (clientBuildReply()) within the<br>control flow of a client request (clientSendMoreData()). The<br>until clause stops prefetching when the number of connec-<br>tion becomes too large, a situation where prefetching would<br>effectively degrade performance. The second controlflow<br>phrase analyzes hyperlinks in a page being transmitted (i.e.,<br>when comm write mbuf() is called within the control flow<br>of clientSendMoreData()). Finally, the last call phrase pre-<br>fetches hyperlinks analyzed by the second aspect. It does so<br>by replacing the method call to clientWriteComplete() with<br>retrieveHyperlinks(). Finally, note that the two require<br>clauses at the top of the aspect declare the types of the<br>global variables of the base program used in the aspects.</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:81"><nobr><span class="ft3"><b>3.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:121"><nobr><span class="ft3"><b>Join points</b></span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:94"><nobr><span class="ft2">A join point model defines the points in the execution</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:81"><nobr><span class="ft2">of the base program to which pointcuts may refer. In our</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:506"><nobr><span class="ft2">JP</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:560"><nobr><span class="ft2">::= callJP(val funId(-</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:699"><nobr><span class="ft2">val))</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:592"><nobr><span class="ft2">readGlobalJP(varId, val)</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:592"><nobr><span class="ft2">readJP(@, val)</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:592"><nobr><span class="ft2">writeGlobalJP(varId, val, size)</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:592"><nobr><span class="ft2">writeJP(@, val, size)</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:592"><nobr><span class="ft2">controlflowJP(----</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:689"><nobr><span class="ft2">f unId, cfEnd)</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:592"><nobr><span class="ft2">controlflowstarJP(----</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:718"><nobr><span class="ft2">f unId, cfEnd)</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:506"><nobr><span class="ft2">cf End ::= callJP(val funId(-</span></nobr></DIV>
<DIV style="position:absolute;top:430;left:699"><nobr><span class="ft2">val))</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:592"><nobr><span class="ft2">readGlobalJP(varId, val)</span></nobr></DIV>
<DIV style="position:absolute;top:462;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:462;left:592"><nobr><span class="ft2">writeGlobalJP(varId, val, size)</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:506"><nobr><span class="ft2">val</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:560"><nobr><span class="ft2">::= 0 | 1 | 2 | ...</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:733"><nobr><span class="ft2">// int</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:592"><nobr><span class="ft2">@0 | @1 | @2 | ... // int*</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:568"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:592"><nobr><span class="ft2">... // values of other C types</span></nobr></DIV>
<DIV style="position:absolute;top:564;left:560"><nobr><span class="ft2">Figure 5: Join point model</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:475"><nobr><span class="ft6">case, join points are defined by JP in the grammar shown<br>in Fig. 5. A join point is either:</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:475"><nobr><span class="ft2">· A call of a function callJP(v</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:672"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:683"><nobr><span class="ft2">funId(-</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:720"><nobr><span class="ft2"></span></nobr></DIV>
<DIV style="position:absolute;top:638;left:721"><nobr><span class="ft2">v</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:727"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:734"><nobr><span class="ft2">)) with function</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:475"><nobr><span class="ft2">name funId, return value v</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:638"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:650"><nobr><span class="ft2">and a vector of arguments -</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:813"><nobr><span class="ft2"></span></nobr></DIV>
<DIV style="position:absolute;top:654;left:813"><nobr><span class="ft2">v</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:820"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:827"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:475"><nobr><span class="ft2">· A</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:514"><nobr><span class="ft2">read</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:557"><nobr><span class="ft2">access</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:610"><nobr><span class="ft2">which</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:662"><nobr><span class="ft2">comes</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:715"><nobr><span class="ft2">in</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:744"><nobr><span class="ft2">two</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:782"><nobr><span class="ft2">variants:</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:475"><nobr><span class="ft13">readGlobalJP(varId, v) denotes reading a global vari-<br>able with name varId holding the value v ; readJP(@, v)<br>denotes reading a global variable or a local alias with<br>address @ holding the value v .<br>· Write access which also comes in two variants:<br>writeGlobalJP(varId, v, size) denotes assignment to a global<br>variable with name varId of the value v of size size.<br>writeJP(@, v, size) denotes assignment to a global variable<br>or a local alias with address @ of the value v of size size.<br>· A cflow expression controlflowJP(----</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:721"><nobr><span class="ft2">f unId, c), where</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:475"><nobr><span class="ft2">----</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:475"><nobr><span class="ft2">f unId = [funId</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:568"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:575"><nobr><span class="ft2">, .., funId</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:627"><nobr><span class="ft12">n</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:635"><nobr><span class="ft2">] is a stack of function names, and</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:475"><nobr><span class="ft6">c (either a function call or an access to a global variable) oc-<br>curs within the body of function f unId</span></nobr></DIV>
<DIV style="position:absolute;top:895;left:713"><nobr><span class="ft12">n</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:721"><nobr><span class="ft2">. Such a join point</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:475"><nobr><span class="ft2">requires a call to f unId</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:620"><nobr><span class="ft12">i+1</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:643"><nobr><span class="ft2">within the body of f unId</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:799"><nobr><span class="ft12">i</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:804"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:475"><nobr><span class="ft2">· A cflow expression controlflowstarJP(----</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:729"><nobr><span class="ft2">f unId, c), where</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:475"><nobr><span class="ft2">----</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:475"><nobr><span class="ft2">f unId = [funId</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:568"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:575"><nobr><span class="ft2">, .., funId</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:627"><nobr><span class="ft12">n</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:635"><nobr><span class="ft2">] is a partial stack of function</span></nobr></DIV>
<DIV style="position:absolute;top:963;left:475"><nobr><span class="ft6">names, and c (either a function call or an access to a global<br>variable) occurs within the control flow of function f unId</span></nobr></DIV>
<DIV style="position:absolute;top:984;left:822"><nobr><span class="ft12">n</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:830"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:475"><nobr><span class="ft2">Such a join point requires a call to f unId</span></nobr></DIV>
<DIV style="position:absolute;top:1000;left:744"><nobr><span class="ft12">i+1</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:770"><nobr><span class="ft2">within the</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:475"><nobr><span class="ft2">control flow of (i.e., not necessarily in the body of) f unId</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:825"><nobr><span class="ft12">i</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:830"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:489"><nobr><span class="ft2">Two features of this join point model may be surprising</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:475"><nobr><span class="ft6">at first sight: distinction of accesses to aliases from those to<br>global variables and explicit representation of control flow</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">30</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft14{font-size:11px;line-height:17px;font-family:Times;color:#000000;}
	.ft15{font-size:11px;line-height:18px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32005.png" alt="background image">
<DIV style="position:absolute;top:79;left:81"><nobr><span class="ft6">require N umber Of F d as int;<br>require Squid M axF d as int;</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:81"><nobr><span class="ft2">controlflow(call(void clientSendMoreData(void, char, size t)),</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:168"><nobr><span class="ft6">call(HttpReply  clientBuildReply(clientHttpRequest, char, size t))<br>&amp;&amp; args( request, buf f er, buf f erSize ))</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:104"><nobr><span class="ft2">then startPrefetching(request, buffer, bufferSize);</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:81"><nobr><span class="ft2">&amp;&amp; until(writeGlobal(int  N umber Of F d) &amp;&amp; if((N umber Of F d)  100/(Squid M axF d)  75) ; )</span></nobr></DIV>
<DIV style="position:absolute;top:220;left:81"><nobr><span class="ft2">controlflow( call(void clientSendMoreData(void, char, size t)),</span></nobr></DIV>
<DIV style="position:absolute;top:236;left:168"><nobr><span class="ft6">call(void comm write mbuf(int, MemBuf, void, void))<br>&amp;&amp; args(fd, mb, handler, handlerData) &amp;&amp; if(! isP ref etch(handler)) )</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:104"><nobr><span class="ft2">then parseHyperlinks(fd, mb, handler, handlerData);</span></nobr></DIV>
<DIV style="position:absolute;top:299;left:81"><nobr><span class="ft2">call(void clientWriteComplete(int, char, size t, int, void))</span></nobr></DIV>
<DIV style="position:absolute;top:314;left:104"><nobr><span class="ft6">&amp;&amp; args(fd, buf, size, error, data) &amp;&amp; if(! isP ref etch(handler))<br>then retrieveHyperlinks(fd, buf, size, error, data);</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:330"><nobr><span class="ft2">Figure 4: An Aspect for Prefetching</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:81"><nobr><span class="ft6">expressions. Both are motivated by our quest for efficiency<br>and are grounded in strong implementation constraints in<br>the context of dynamic weaving of binary C code: an access<br>to a local alias is several magnitudes slower than that to a<br>global variable and matching of control flow join points can<br>be done using an atomic test on the implementation level.</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:81"><nobr><span class="ft3"><b>3.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:121"><nobr><span class="ft3"><b>Pointcuts</b></span></nobr></DIV>
<DIV style="position:absolute;top:522;left:94"><nobr><span class="ft2">We now present a pointcut language (see Fig. 6) that pro-</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:81"><nobr><span class="ft2">vides constructs to match individual join points.</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:94"><nobr><span class="ft2">Primitive pointcuts are defined by PPrim and comprise</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:81"><nobr><span class="ft6">three basic pointcuts matching calls, global variable accesses,<br>and control flow join points. Primitive pointcuts can also be<br>combined using a logical "or" noted ||.</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:94"><nobr><span class="ft2">A call pointcut PCall selects all function call join points</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:81"><nobr><span class="ft2">callJP(val funId(-</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:188"><nobr><span class="ft2">val)), i.e., all calls to a function matching</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:81"><nobr><span class="ft2">the signature type funId(--</span></nobr></DIV>
<DIV style="position:absolute;top:653;left:233"><nobr><span class="ft2">type), where the arguments of the</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:81"><nobr><span class="ft14">function can be bound to pointcut variables using argument<br>binder args( -----</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:161"><nobr><span class="ft2">pattern ) and the return value can be bound to</span></nobr></DIV>
<DIV style="position:absolute;top:701;left:81"><nobr><span class="ft15">a pointcut variable using a return clause return( pattern ).<br>The two constructs args( -----</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:243"><nobr><span class="ft2">pattern ) and return( pattern )</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:81"><nobr><span class="ft6">can also provide pattern matching by using values (or al-<br>ready bound pointcut variables) in pattern. Pointcuts can<br>also depend on a boolean condition using the if-constructor.</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:94"><nobr><span class="ft2">A global access pointcut PAccGlobal selects either all read</span></nobr></DIV>
<DIV style="position:absolute;top:798;left:81"><nobr><span class="ft6">join points readGlobalJP(varId, val) or all write join points<br>writeGlobalJP(varId, val, size) on the global base program<br>variable varId. In these cases, the read or written value can<br>be bound to a variable using value(pattern); in addition, the<br>size of the written value can be bound with size(varName).<br>Pattern matching can also be used for variable access.</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:94"><nobr><span class="ft2">A control flow pointcut PCf of the form controlflow(</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:81"><nobr><span class="ft2">PCallSig</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:133"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:140"><nobr><span class="ft2">, ..., PCallSig</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:221"><nobr><span class="ft12">n</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:229"><nobr><span class="ft2">, PCfEnd) matches all join points</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:81"><nobr><span class="ft2">of the form controlflowJP(funId</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:278"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:284"><nobr><span class="ft2">, ..., funId</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:345"><nobr><span class="ft12">n</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:351"><nobr><span class="ft2">, cfEnd), where</span></nobr></DIV>
<DIV style="position:absolute;top:939;left:81"><nobr><span class="ft2">the function identifier in P CallSig</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:292"><nobr><span class="ft12">i</span></nobr></DIV>
<DIV style="position:absolute;top:939;left:302"><nobr><span class="ft2">is f unId</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:355"><nobr><span class="ft12">i</span></nobr></DIV>
<DIV style="position:absolute;top:939;left:360"><nobr><span class="ft2">. Similarly, a</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:81"><nobr><span class="ft6">control flow pointcut may match a global variable access<br>for a given stack configuration. The pointcuts of the form<br>controlflowstar(. . . ) select calls or global variable accesses<br>in a stack context allowing for calls that are not directly<br>nested within one another.</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:94"><nobr><span class="ft2">Finally, P Acc, an access pointcut for a global variable or</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:81"><nobr><span class="ft6">all of its local aliases, matches all join points of the form<br>readJP or writeJP.</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:488"><nobr><span class="ft2">Asp</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:566"><nobr><span class="ft2">::= AspP rim [ &amp;&amp; until( AspP rim ) ]</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:573"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:597"><nobr><span class="ft2">AspSeq [ &amp;&amp; until( AspP rim ) ]</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:488"><nobr><span class="ft2">AspP rim</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:566"><nobr><span class="ft2">::= P P rim Advice</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:488"><nobr><span class="ft2">AspSeq</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:566"><nobr><span class="ft2">::= seq( AspP rim</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:630"><nobr><span class="ft6">AspSeqElts<br>AspSeqElt )</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:488"><nobr><span class="ft6">AspSeqElts ::= [AspSeqElts] AspSeqElt [  ]<br>AspSeqElt ::= AspP rim</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:573"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:597"><nobr><span class="ft2">P Acc Advice</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:573"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:597"><nobr><span class="ft2">(AspSeqElt || AspSeqElt)</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:488"><nobr><span class="ft2">Advice</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:566"><nobr><span class="ft2">::= [ then f unId(-----</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:683"><nobr><span class="ft2">pattern) ] ;</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:563"><nobr><span class="ft2">Figure 7: Aspect language</span></nobr></DIV>
<DIV style="position:absolute;top:681;left:475"><nobr><span class="ft3"><b>3.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:516"><nobr><span class="ft3"><b>Aspect Language</b></span></nobr></DIV>
<DIV style="position:absolute;top:701;left:489"><nobr><span class="ft2">The aspect language we propose is defined in Fig. 7. As-</span></nobr></DIV>
<DIV style="position:absolute;top:717;left:475"><nobr><span class="ft6">pects Asp are either primitive AspP rim, or sequences of<br>primitive aspects AspSeq.</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:489"><nobr><span class="ft2">A primitive aspect AspPrim combines a primitive point-</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:475"><nobr><span class="ft6">cut with an advice that will be applied to all join points<br>selected by the pointcut. If the primitive pointcut has the<br>form p</span></nobr></DIV>
<DIV style="position:absolute;top:801;left:515"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:527"><nobr><span class="ft2">|| p</span></nobr></DIV>
<DIV style="position:absolute;top:801;left:547"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:554"><nobr><span class="ft2">, then all variables used in the advice have to</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:475"><nobr><span class="ft2">be bound in both, p</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:596"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:608"><nobr><span class="ft2">and p</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:642"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:650"><nobr><span class="ft2">.</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:489"><nobr><span class="ft2">An advice (Advice) is a C function call that replaces a join</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:475"><nobr><span class="ft6">point in the base program execution (similarly to around in<br>AspectJ). It must have the same return type as the join<br>point it replaces: the type of the global variable in case of a<br>read access, void for a write access and the return type of<br>the function for a call. When the advice is empty (no then<br>clause), the original join point is executed. The original join<br>point can be skipped by calling an empty C function.</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:489"><nobr><span class="ft2">A sequence aspect is composed of a sequence of primitive</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:475"><nobr><span class="ft6">aspects. A sequence starts when the first primitive aspect<br>matches. Then the second primitive aspect becomes active<br>instead of the first one. When it matches, the third aspect<br>becomes active instead of the second one. And so on, until<br>the last primitive aspect in the sequence. All but the first<br>and last primitive aspects can be repeated zero or multiple<br>times by using : in this case, the primitive aspect is ac-</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">31</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1263" src="32006.png" alt="background image">
<DIV style="position:absolute;top:91;left:134"><nobr><span class="ft2">P P rim</span></nobr></DIV>
<DIV style="position:absolute;top:91;left:222"><nobr><span class="ft2">::= P Call</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:230"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:254"><nobr><span class="ft2">P AccGlobal</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:230"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:254"><nobr><span class="ft2">P Cf</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:230"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:254"><nobr><span class="ft2">P P rim || P P rim</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:134"><nobr><span class="ft2">P Call</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:222"><nobr><span class="ft2">::= P CallSig [ &amp;&amp; args( -----</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:390"><nobr><span class="ft2">pattern ) ] [ &amp;&amp; return( pattern ) ] [ &amp;&amp; P If ]</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:134"><nobr><span class="ft2">P CallSig</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:222"><nobr><span class="ft2">::= call( type f unId(--</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:367"><nobr><span class="ft2">type) )</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:134"><nobr><span class="ft2">P If</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:222"><nobr><span class="ft2">::= if( expr ) [ &amp;&amp; P If ]</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:134"><nobr><span class="ft2">P AccGlobal</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:222"><nobr><span class="ft2">::= readGlobal( type varId ) [ &amp;&amp; value( pattern ) ] [ &amp;&amp; P If ]</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:230"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:254"><nobr><span class="ft2">writeGlobal( type varId ) [ &amp;&amp; value( pattern ) ] [ &amp;&amp; size( pattern ) ] [ &amp;&amp; P If ]</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:134"><nobr><span class="ft2">P Cf</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:222"><nobr><span class="ft2">::= controlflow( P CallSigList, P Cf End )</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:230"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:254"><nobr><span class="ft2">controlflowstar( P CallSigList, P Cf End )</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:134"><nobr><span class="ft6">P CallSigList ::= P CallSig [ , P CallSigList ]<br>P Cf End</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:222"><nobr><span class="ft2">::= P Call | P AccGlobal</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:134"><nobr><span class="ft2">P Acc</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:222"><nobr><span class="ft2">::= read( var ) [ &amp;&amp; value( pattern ) ] [ &amp;&amp; P If ]</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:230"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:254"><nobr><span class="ft2">write( var ) [ &amp;&amp; value( pattern ) ] [ &amp;&amp; size( pattern ) ] [ &amp;&amp; P If ]</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:134"><nobr><span class="ft2">pattern</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:222"><nobr><span class="ft2">::= var | val</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:360"><nobr><span class="ft2">Figure 6: Pointcut language</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:88"><nobr><span class="ft2">A</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:116"><nobr><span class="ft2">::= A</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:123"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:148"><nobr><span class="ft2">A || A</span></nobr></DIV>
<DIV style="position:absolute;top:521;left:240"><nobr><span class="ft2">; parallelism</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:88"><nobr><span class="ft2">A</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:116"><nobr><span class="ft2">::= µa.A</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:240"><nobr><span class="ft2">; recursive definition (a  Rec)</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:123"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:148"><nobr><span class="ft2">C £ I; A</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:240"><nobr><span class="ft2">; prefixing</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:123"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:148"><nobr><span class="ft2">C £ I; a</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:240"><nobr><span class="ft2">; end of sequence (a  Rec)</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:123"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:148"><nobr><span class="ft2">C £ I; STOP ; halting aspect</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:123"><nobr><span class="ft2">|</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:148"><nobr><span class="ft2">A P A</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:240"><nobr><span class="ft2">; choice</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:151"><nobr><span class="ft2">Figure 8: Tiny aspect language</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:81"><nobr><span class="ft6">tive as long as the following one in the sequence does not<br>match. Branching, i.e., a logical `or' between two primitive<br>aspects, can be introduced in a sequence by the operator ||.<br>An element of the sequence can also match a global vari-<br>able of the base program and accesses to its local aliases, as<br>soon as its address is known (i.e., a previous primitive point-<br>cut has already bound its address to a pointcut variable).<br>Hence, an aspect matching accesses cannot start a sequence.<br>Every join point matching the first primitive pointcut of a<br>sequence starts a new instance of the sequence. The different<br>instances are matched in parallel.</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:94"><nobr><span class="ft2">A primitive or a sequence aspect a can be used in combi-</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:81"><nobr><span class="ft2">nation with an expression until(a</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:284"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:291"><nobr><span class="ft2">), to restrict its scope. In</span></nobr></DIV>
<DIV style="position:absolute;top:893;left:81"><nobr><span class="ft6">this case, once a join point has been matched by a, the execu-<br>tion of a proceeds as previously described until a</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:376"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:387"><nobr><span class="ft2">matches.</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:94"><nobr><span class="ft2">To conclude the presentation of our language, note that it</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:81"><nobr><span class="ft6">does not include some features, such as named pointcuts as<br>arguments to controlflows and conjunctive terms, which<br>are not necessary for the examples we considered but which<br>could easily be added. (As an aside, note that such exten-<br>sions of the pointcut language may affect the computability<br>of advanced algorithmic problems, such as whether a point-<br>cut matches some part of any base program [25].)</span></nobr></DIV>
<DIV style="position:absolute;top:499;left:475"><nobr><span class="ft3"><b>3.5</b></span></nobr></DIV>
<DIV style="position:absolute;top:499;left:516"><nobr><span class="ft3"><b>Towards a formal semantics for expressive</b></span></nobr></DIV>
<DIV style="position:absolute;top:514;left:516"><nobr><span class="ft3"><b>aspects</b></span></nobr></DIV>
<DIV style="position:absolute;top:534;left:489"><nobr><span class="ft2">In the previous sections, we have given an informal se-</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:475"><nobr><span class="ft6">mantics of our aspect language. We now illustrate how the<br>aspect language could be formally defined by translating one<br>of the example aspects into formal aspect language by ex-<br>tension of that used in the formal framework of [14].</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:489"><nobr><span class="ft2">The original formal language must be extended in order to</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:475"><nobr><span class="ft6">deal with halting aspects, an unbounded number of sequen-<br>tial aspects and arbitrary join point predicates. The gram-<br>mar of the extension, our tiny aspect language, is defined in<br>Figure 8. In this language, aspect expressions A consists of<br>parallel combinations of aspects, C is a join point predicate<br>(similar to our pointcut language) expressed as a conjunc-<br>tion of a term pattern and possibly an expression from the<br>constraint logic programming language CLP(R) [20].</span></nobr></DIV>
<DIV style="position:absolute;top:754;left:489"><nobr><span class="ft2">An aspect A is either:</span></nobr></DIV>
<DIV style="position:absolute;top:775;left:475"><nobr><span class="ft13">· A recursive definition.<br>· A sequence formed using the prefix operation C £ I ; X,<br>where X is an aspect or a recursion variable and I a piece<br>of code (i.e., an advice).<br>· A choice construction A</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:640"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:652"><nobr><span class="ft2">P A</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:678"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:694"><nobr><span class="ft2">which chooses the first</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:475"><nobr><span class="ft6">aspect that matches a join point (the other is thrown away).<br>If both match the same join point, A</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:700"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:710"><nobr><span class="ft2">is chosen.</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:475"><nobr><span class="ft2">· A parallel composition of two aspects A</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:742"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:763"><nobr><span class="ft2">||</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:785"><nobr><span class="ft2">A</span></nobr></DIV>
<DIV style="position:absolute;top:903;left:795"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:809"><nobr><span class="ft2">that</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:475"><nobr><span class="ft13">cannot occur in choice construction.<br>· A halting aspect STOP.</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:489"><nobr><span class="ft2">The semantics of the protocol translation aspect (from</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:475"><nobr><span class="ft6">TCP to UDP) is given in Fig. 9. A sequence can have sev-<br>eral instances. This is translated into the language A by the<br>expression a</span></nobr></DIV>
<DIV style="position:absolute;top:1007;left:550"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:569"><nobr><span class="ft2">|| ... which starts a new sequence a</span></nobr></DIV>
<DIV style="position:absolute;top:1007;left:795"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:807"><nobr><span class="ft2">once</span></nobr></DIV>
<DIV style="position:absolute;top:1018;left:475"><nobr><span class="ft6">the first join point has been matched and continue to match<br>the rest of the sequence in progress. The repetition oper-<br>ator  is translated into recursion on variable the a</span></nobr></DIV>
<DIV style="position:absolute;top:1054;left:792"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:798"><nobr><span class="ft2">. The</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:475"><nobr><span class="ft2">branching operator || is translated into the choice operator</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">32</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft16{font-size:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32007.png" alt="background image">
<DIV style="position:absolute;top:82;left:81"><nobr><span class="ft2">µa</span></nobr></DIV>
<DIV style="position:absolute;top:87;left:96"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:82;left:103"><nobr><span class="ft2">. callJP(fd socket(AF INET, SOCK STREAM, 0)) £ socket(AF INET, SOCK DGRAM, 0);</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:113"><nobr><span class="ft2">a</span></nobr></DIV>
<DIV style="position:absolute;top:103;left:120"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:97;left:130"><nobr><span class="ft2">|| ( callJP(a connect(fd, address, length)) £ returnZero();</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:150"><nobr><span class="ft2">µa</span></nobr></DIV>
<DIV style="position:absolute;top:118;left:165"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:172"><nobr><span class="ft2">. callJP(b close(fd)) £ skip; STOP</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:187"><nobr><span class="ft2">P callJP(c read(fd, readBuffer, readLength)) £ recvfrom(fd, readBuffer, readLength, 0, address, length); a</span></nobr></DIV>
<DIV style="position:absolute;top:134;left:819"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:172"><nobr><span class="ft2">P callJP(d write(fd, writeBuffer, writeLength)) £ recvfrom(fd, writeBuffer, writeLength, 0, address, length); a</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:828"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:185"><nobr><span class="ft2">Figure 9: Definition of the protocol translation using the tiny aspect language</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:81"><nobr><span class="ft6">P. Finally, the last primitive aspect of the sequence occurs<br>as the first aspect of a choice to get priority over the join<br>points read and write because of the . Note that we use<br>pattern matching in A and that an overbar marks the first<br>occurrence of a variable (i.e., its definition not a use).</span></nobr></DIV>
<DIV style="position:absolute;top:288;left:94"><nobr><span class="ft2">Note that formal definitions such as that of the protocol</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:81"><nobr><span class="ft6">translation aspect precisely define several important issues,<br>in particular, when new instances of the sequence aspect are<br>created, and disambiguate of potentially non-deterministic<br>situations, e.g., when two pointcuts of consecutive primitive<br>aspects in the sequence match at the same time.</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:81"><nobr><span class="ft3"><b>4.</b></span></nobr></DIV>
<DIV style="position:absolute;top:402;left:112"><nobr><span class="ft3"><b>DYNAMIC WEAVING WITH ARACHNE</b></span></nobr></DIV>
<DIV style="position:absolute;top:422;left:94"><nobr><span class="ft2">Arachne is built around two tools, an aspect compiler and</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:81"><nobr><span class="ft6">a runtime weaver. The aspect compiler translates the aspect<br>source code into a compiled library that, at weaving time, di-<br>rects the weaver to place the hooks in the base program. The<br>hooking mechanisms used in Arachne are based on improved<br>techniques originally developed for µDyner [32]. These tech-<br>niques allow to rewrite the binary code of executable files<br>on the fly i.e.without pausing the base program, as long<br>as these files conform to the mapping defined by the Unix<br>standard [35] between the C language and x86 assembly lan-<br>guage. Arachne's implementation is structured as an open<br>framework that allows to experiment with new kinds of join<br>points and pointcut constructs. Another important differ-<br>ence between Arachne and µDyner is, that µDyner requires<br>a compile time preparation of the base program, whereas<br>Arachne does not. Hence Arachne is totally transparent for<br>the base program while µDyner is not.</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:81"><nobr><span class="ft3"><b>4.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:700;left:121"><nobr><span class="ft3"><b>The Arachne Open Architecture</b></span></nobr></DIV>
<DIV style="position:absolute;top:720;left:94"><nobr><span class="ft2">The Arachne open architecture is structured around three</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:81"><nobr><span class="ft6">main entities: the aspect compiler, the instrumentation ker-<br>nel, and the different rewriting strategies. The aspect com-<br>piler translates the aspect source code into C before com-<br>piling it. Weaving is accomplished through a command line<br>tool weave that acts as a front end for the instrumentation<br>kernel. weave relays weaving requests to the instrumen-<br>tation kernel loaded in the address space of the program<br>through Unix sockets. Upon reception of a weaving request,<br>the instrumentation kernel selects the appropriate rewriting<br>strategies referred by the aspects to be woven and instru-<br>ments the base program accordingly. The rewriting strat-<br>egy consults the pointcut analysis performed by the aspect<br>compiler to locate the places where the binary code of the<br>base program needs to be rewritten. It finally modifies the<br>binary code to actually tie the aspects to the base program.</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:94"><nobr><span class="ft2">With this approach, the Arachne core is independent of</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:81"><nobr><span class="ft6">a particular aspect, of the aspect language, of the particu-<br>lar processor architecture, and of a particular base program.<br>In fact, all dependencies to aspect language implementation<br>are limited to the aspect compiler. All dependencies to the<br>operating system are localized in the instrumentation ker-<br>nel and finally all dependencies to the underlying hardware</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:475"><nobr><span class="ft2">architecture are modularized in the rewriting strategies.</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:479"><nobr><span class="ft16"><i>4.1.1</i></span></nobr></DIV>
<DIV style="position:absolute;top:240;left:529"><nobr><span class="ft16"><i>The Arachne aspect compilation process</i></span></nobr></DIV>
<DIV style="position:absolute;top:259;left:489"><nobr><span class="ft2">The aspect compilation scheme is relatively straightfor-</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:475"><nobr><span class="ft6">ward: it transforms advices into regular C functions. Point-<br>cuts are rewritten as C code driving hook insertions into<br>the base program at weaving time. There are however cases<br>where the sole introduction of hooks is insufficient to deter-<br>mine whether an advice should be executed. In this case,<br>the aspect compiler generates functions that complement<br>the hooks with dynamic tests on the state of the base pro-<br>gram. These dynamic tests are called residues in AspectJ<br>and the rewritten instructions within the base program the<br>shadow [16]. Once the aspects have been translated into C,<br>the Arachne compiler uses a legacy C compiler to generate a<br>dynamically linked library (DLL) for the compiled aspects.</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:479"><nobr><span class="ft16"><i>4.1.2</i></span></nobr></DIV>
<DIV style="position:absolute;top:478;left:529"><nobr><span class="ft16"><i>The Arachne weaving process</i></span></nobr></DIV>
<DIV style="position:absolute;top:497;left:489"><nobr><span class="ft2">From a user viewpoint, the Arachne weave and deweave</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:475"><nobr><span class="ft6">command line programs the same syntax than µDyner's ver-<br>sion. They both take two arguments. The first identifies the<br>process to weave aspects in or deweave aspects from, and<br>the second indicates the aspect DLL. However, Arachne can<br>target potentially any C application running on the machine<br>while µDyner was limited to applications compiled with it<br>running on the machine. When Arachne's weave receives a<br>request to weave an aspect in a process that does not con-<br>tain the Arachne instrumentation kernel, it loads the kernel<br>in the process address space using standard techniques [11].</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:489"><nobr><span class="ft2">The instrumentation kernel is transparent for the base</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:475"><nobr><span class="ft6">program as the latter cannot access the resources (mem-<br>ory and sockets essentially) used by the former. Once in-<br>jected, the kernel creates a thread with the Linux system<br>call: clone. This thread handles the different weaving re-<br>quests. Compared to the POSIX pthread create function,<br>the usage of clone allows the instrumentation thread to pre-<br>vent the base program to access its sockets. The instrumen-<br>tation kernel allocates memory by using side effect free allo-<br>cation routines (through the Linux mmap API). Because the<br>allocation routines are side effect free, Arachne's memory is<br>totally invisible to the base program. It is up to the aspect<br>to use Arachne's memory allocation routines or base pro-<br>gram specific allocation functions. This transparency turns<br>out to be crucial in our experiments. Legacy applications<br>such as Squid use dedicated resource management routines<br>and expect any piece of code they run to use these routines.<br>Failures will result in an application crash.</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:489"><nobr><span class="ft2">After loading an aspect, the instrumentation kernel rewrites</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:475"><nobr><span class="ft6">the binary code of the base program. These rewriting strate-<br>gies are not included in the kernel and must be fetched on<br>demand by each loaded aspect.</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:475"><nobr><span class="ft3"><b>4.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:516"><nobr><span class="ft3"><b>Rewriting strategies</b></span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:489"><nobr><span class="ft2">Rewriting strategies are responsible for transforming the</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:475"><nobr><span class="ft2">binary code of the base program to effectively tie aspects to</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">33</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft17{font-size:3px;font-family:Times;color:#000000;}
	.ft18{font-size:3px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32008.png" alt="background image">
<DIV style="position:absolute;top:154;left:149"><nobr><span class="ft17"><b>shadow: rewriting</b></span></nobr></DIV>
<DIV style="position:absolute;top:161;left:150"><nobr><span class="ft17"><b>site replaced by a</b></span></nobr></DIV>
<DIV style="position:absolute;top:140;left:154"><nobr><span class="ft18">x86 instruction</span></nobr></DIV>
<DIV style="position:absolute;top:119;left:154"><nobr><span class="ft18">x86 instruction</span></nobr></DIV>
<DIV style="position:absolute;top:188;left:154"><nobr><span class="ft18">x86 instruction</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:154"><nobr><span class="ft18">x86 instruction</span></nobr></DIV>
<DIV style="position:absolute;top:92;left:144"><nobr><span class="ft18">execution flow</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:320"><nobr><span class="ft18">generated at aspect compile time</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:343"><nobr><span class="ft18">Aspect DLL</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:227"><nobr><span class="ft18">Hooks generated at weaving</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:255"><nobr><span class="ft18">time</span></nobr></DIV>
<DIV style="position:absolute;top:166;left:165"><nobr><span class="ft17"><b>jump</b></span></nobr></DIV>
<DIV style="position:absolute;top:233;left:150"><nobr><span class="ft18">Binary code of the</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:155"><nobr><span class="ft18">compiled base</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:163"><nobr><span class="ft18">program</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:348"><nobr><span class="ft18">and/or advices</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:337"><nobr><span class="ft18">Residue (dynamic tests)</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:230"><nobr><span class="ft18">Entry hook</span></nobr></DIV>
<DIV style="position:absolute;top:132;left:227"><nobr><span class="ft18">save registers</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:263"><nobr><span class="ft18">Return hook</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:258"><nobr><span class="ft18">Restore registers</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:223"><nobr><span class="ft18">instruction(s)</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:218"><nobr><span class="ft18">Relocated tailored</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:218"><nobr><span class="ft18">updating registers</span></nobr></DIV>
<DIV style="position:absolute;top:256;left:148"><nobr><span class="ft18">Legacy base program</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:134"><nobr><span class="ft2">Figure 10: Generic hook operations.</span></nobr></DIV>
<DIV style="position:absolute;top:338;left:81"><nobr><span class="ft6">the base program at weaving time. These strategies localize<br>Arachne's main dependencies to the underlying hardware<br>architecture. In general, rewriting strategies need to col-<br>lect information about the base program. These information<br>typically consist of the addresses of the different shadows,<br>their size, the symbol (i.e.function or global variable name)<br>they manipulate, their length etc. In order to keep compiled<br>aspects independent from the base program, this informa-<br>tion is gathered on demand at runtime. The mapping be-<br>tween a symbol name in the base program source code and<br>its address in memory is inferred from linking information<br>contained in the base program executable. However because<br>these information can be costly to retrieve, Arachne collects<br>and stores it into meta-information DLLs. these DLLs be-<br>have as a kind of cache and lessen the problem of collecting<br>the information required to instrument the base program.<br>To implement our aspect language, Arachne provides a set<br>of eight rewriting strategies that might eventually use each<br>other.</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:85"><nobr><span class="ft16"><i>4.2.1</i></span></nobr></DIV>
<DIV style="position:absolute;top:649;left:134"><nobr><span class="ft16"><i>Strategies for</i></span></nobr></DIV>
<DIV style="position:absolute;top:648;left:224"><nobr><span class="ft2">call</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:253"><nobr><span class="ft16"><i>,</i></span></nobr></DIV>
<DIV style="position:absolute;top:648;left:260"><nobr><span class="ft2">readGlobal</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:334"><nobr><span class="ft16"><i>and</i></span></nobr></DIV>
<DIV style="position:absolute;top:648;left:362"><nobr><span class="ft2">writeGlobal</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:94"><nobr><span class="ft2">In Arachne, call, readGlobal and writeGlobal allow an</span></nobr></DIV>
<DIV style="position:absolute;top:683;left:81"><nobr><span class="ft6">advice to be triggered upon a function call, a read on a<br>global variable or a write respectively. While the implemen-<br>tation of readGlobal and writeGlobal in Arachne is close<br>to the one in µDyner, Arachne implements the strategy for<br>call by rewriting function invocations found in the base<br>program. µDyner instead rewrites the function body of the<br>callee. On the Intel architecture, function calls benefit from<br>the direct mapping to the x86 call assembly instruction<br>that is used by almost, if not all, compilers. Write and read<br>accesses to global variables are translated into instructions<br>using immediate, hard coded addresses within the binary<br>code of the base program. By comparing these addresses<br>with linking information contained in the base program ex-<br>ecutable, Arachne can determine where the global variable<br>is being accessed. Therefore those primitive pointcuts do<br>not involve any dynamic tests. The sole rewriting of the<br>binary base program code is enough to trigger advice and<br>residue</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:123"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:134"><nobr><span class="ft2">executions at all appropriate points.</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:94"><nobr><span class="ft2">The size of the x86 call instruction and the size of an x86</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:81"><nobr><span class="ft6">jump (jmp) instruction are the same. Since the instruction<br>performing an access to a global variable involves a hard<br>coded address, x86 instructions that read or write a global</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:81"><nobr><span class="ft12">1</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:88"><nobr><span class="ft2">Residues (i.e. dynamic tests on the base program state) are</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft2">required when these primitive pointcuts are combined with</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:81"><nobr><span class="ft2">conditional pointcuts or when pattern matching is involved.</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:475"><nobr><span class="ft6">variable have at least the size of a x86 jmp instruction. Hence<br>at weaving time, Arachne rewrites them as a jmp instruction<br>to a hook. Hooks are generated on the fly on freshly allo-<br>cated memory. As shown in figure 10, hooks contain a few<br>assembly instructions that save and restore the appropriate<br>registers before and after an advice (or shadow) execution.<br>A generic approach is to have hooks save the whole set of<br>registers, then execute the appropriate residue and/or ad-<br>vice code before restoring the whole set of registers; finally<br>the instructions found at the join point shadow are executed<br>to perform the appropriate side effects on the processor reg-<br>isters. This is accomplished by relocating the instructions<br>found at the join point shadow. Relocating the instructions<br>makes the rewriting strategies handling read and write ac-<br>cess to global variable independent from the instruction gen-<br>erated by the compiler to perform the access</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:747"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:754"><nobr><span class="ft2">. The limited</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:475"><nobr><span class="ft6">number of x86 instructions used to invoke a function allows<br>Arachne's rewriting strategy to exploit more efficient, relo-<br>cation free, hooks.</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:479"><nobr><span class="ft16"><i>4.2.2</i></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:529"><nobr><span class="ft16"><i>Strategies for</i></span></nobr></DIV>
<DIV style="position:absolute;top:395;left:619"><nobr><span class="ft2">controlflow</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:700"><nobr><span class="ft16"><i>and</i></span></nobr></DIV>
<DIV style="position:absolute;top:395;left:728"><nobr><span class="ft2">controlflowstar</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:489"><nobr><span class="ft2">Every time a C function is called, the Linux runtime</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:475"><nobr><span class="ft6">creates an activation record on the call stack [35]. Like<br>µDyner, Arachne's implementation of the rewriting strat-<br>egy for controlflow uses the most deeply nested function<br>call (or global read or write access) in the control flow point-<br>cut as shadow. This shadow triggers a residue. This residue<br>uses the activation record's chaining to check whether the<br>remaining function calls of the control flow, are on the call<br>stack maintained by the Linux runtime. An appropriate<br>usage of hashtables that store the linking information con-<br>tained in the base program executables can thereby de-<br>crease the cost of determining if a specific function is the<br>caller of another to a pointer comparison. Therefore, the<br>residue for a controlflow with n directly nested functions<br>implies exactly n pointer comparisons. However, the residue<br>worst case runtime for the indirect control flow operator<br>controlflowstar that allows for not directly nested func-<br>tions, is proportional to the base program stack depth.</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:479"><nobr><span class="ft16"><i>4.2.3</i></span></nobr></DIV>
<DIV style="position:absolute;top:710;left:529"><nobr><span class="ft16"><i>Strategies for</i></span></nobr></DIV>
<DIV style="position:absolute;top:710;left:621"><nobr><span class="ft2">read</span></nobr></DIV>
<DIV style="position:absolute;top:710;left:654"><nobr><span class="ft16"><i>and</i></span></nobr></DIV>
<DIV style="position:absolute;top:710;left:683"><nobr><span class="ft2">write</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:489"><nobr><span class="ft2">read and write are new join points not included in µDyner</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:475"><nobr><span class="ft6">that have been added to the latest version of Arachne. Their<br>implementation relays on a page memory protection as al-<br>lowed by the Linux operating system interface (i.e. mprotect)<br>and the Intel processor specifications [18]. A read or write<br>pointcut triggers a residue to relocate the bound variable<br>into a memory page that the base program is not allowed<br>to access and adds a dedicated signal handler. Any attempt<br>made by the base program to access the bound variable iden-<br>tified will then trigger the execution of the previously added<br>signal handler. This handler will then inspect the binary<br>instruction trying to access the protected page to determine<br>whether it was a read or a write access before eventually<br>executing the appropriate advice.</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:479"><nobr><span class="ft16"><i>4.2.4</i></span></nobr></DIV>
<DIV style="position:absolute;top:962;left:529"><nobr><span class="ft16"><i>Strategies for</i></span></nobr></DIV>
<DIV style="position:absolute;top:962;left:621"><nobr><span class="ft2">seq</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:489"><nobr><span class="ft2">Like read and write, seq is a new language feature of</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:475"><nobr><span class="ft6">Arachne. µDyner offers no equivalent construct. Arachne's<br>rewriting strategy of this operator associates a linked list to</span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:476"><nobr><span class="ft12">2</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:482"><nobr><span class="ft2">About 250 x86 instruction mnemonics can directly manip-</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:475"><nobr><span class="ft2">ulate a global variable. This corresponds to more than one</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:475"><nobr><span class="ft2">thousand opcodes.</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">34</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft19{font-size:9px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32009.png" alt="background image">
<DIV style="position:absolute;top:84;left:81"><nobr><span class="ft6">every stage inside the sequence except the last one. Each<br>stage in a sequence triggers a residue that updates these<br>linked lists to reflect state transitions of currently match-<br>ing execution flows. Upon matching of the first pointcut<br>of the first primitive aspect in the seq, a node is allocated<br>and added to the associated linked list. This node con-<br>tains a structure holding variables shared among the dif-<br>ferent pointcuts within the sequence. Once a join point<br>matches a pointcut of an primitive aspect denoting a stage<br>in the sequence, Arachne consults every node in the linked<br>list associated with the previous stage and executes the cor-<br>responding advice</span></nobr></DIV>
<DIV style="position:absolute;top:255;left:195"><nobr><span class="ft12">3</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:201"><nobr><span class="ft2">. Arachne eventually updates the node</span></nobr></DIV>
<DIV style="position:absolute;top:273;left:81"><nobr><span class="ft6">and in the absence of a  moves it to the list associated<br>with the currently matched pointcut.If the matching point-<br>cut corresponds to the end of the sequence, structures are<br>not moved into another list but freed. Our aspect compiler<br>includes an optimization where structures are allocated from<br>a resizable pool and upon a sequence termination, structures<br>are not freed but returned to the pool.</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:81"><nobr><span class="ft3"><b>4.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:121"><nobr><span class="ft3"><b>Arachne limitations</b></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:94"><nobr><span class="ft2">Aggressive optimizations of the base program might pre-</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:81"><nobr><span class="ft6">vent Arachne to seamlessly weave aspects. Two optimiza-<br>tions are not yet supported by Arachne. First if the compiler<br>inlines a function in another one within the binary code of<br>the base program, the Arachne weaver will fail to properly<br>handle pointcuts referring to that function. Second, con-<br>trol flow pointcuts are based on the chaining of activation<br>records. On the x86 architecture, in leaf functions, opti-<br>mizing compilers sometimes do not maintain this chaining<br>to free one register for the rest of the computation. This<br>however has not been a problem during our experiments<br>as we used the open source C compiler gcc. Arachne sup-<br>ports two of the three optimization levels proposed by gcc.<br>Stripping that removes linking information and aggressive<br>optimizations that break the interoperability between com-<br>pilers and/or debuggers are incompatible with Arachne. In<br>practice, Arachne can be used on applications compiled like<br>squid with two of the three gcc optimization level.</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:81"><nobr><span class="ft3"><b>5.</b></span></nobr></DIV>
<DIV style="position:absolute;top:723;left:112"><nobr><span class="ft3"><b>PERFORMANCE EVALUATION</b></span></nobr></DIV>
<DIV style="position:absolute;top:743;left:94"><nobr><span class="ft2">Aspect-oriented solutions will be used if the aspect sys-</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:81"><nobr><span class="ft6">tem's language is expressive enough and if the aspect system<br>overhead is low enough, for the task at hand. The purpose<br>of this section is to study Arachne's performance. We first<br>present the speed of each Arachne language construct and<br>compare it to similar C language constructs. We then study<br>the overhead of extending Squid with a prefetching policy.<br>This case study shows that even if the cost of some Arachne<br>aspect language constructs might be high compared to C<br>language constructs, this overhead is largely amortized in<br>real applications.</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:81"><nobr><span class="ft3"><b>5.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:929;left:121"><nobr><span class="ft3"><b>Evaluation of the language constructs</b></span></nobr></DIV>
<DIV style="position:absolute;top:949;left:94"><nobr><span class="ft2">This performance evaluation focuses on studying the cost</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:81"><nobr><span class="ft6">of each construct of our aspect language. To estimate the<br>cost for each construct of our aspect language, we wrote an<br>aspect using this construct that behaves as an interpreter of</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:81"><nobr><span class="ft12">3</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:88"><nobr><span class="ft2">In case the previous stage pointcut was used with a star</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:81"><nobr><span class="ft2">, Arachne examines nodes from linked list associated with</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft2">the last two previous stages, and so on, until a not starred</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:81"><nobr><span class="ft2">primitive aspect in the sequence is reached.</span></nobr></DIV>
<DIV style="position:absolute;top:80;left:603"><nobr><span class="ft19">Execution times (cycles)</span></nobr></DIV>
<DIV style="position:absolute;top:94;left:609"><nobr><span class="ft19">Arachne</span></nobr></DIV>
<DIV style="position:absolute;top:94;left:690"><nobr><span class="ft19">Native</span></nobr></DIV>
<DIV style="position:absolute;top:94;left:755"><nobr><span class="ft19">Ratio</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:523"><nobr><span class="ft19">call</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:616"><nobr><span class="ft19">28</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:629"><nobr><span class="ft12">±2.3%</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:694"><nobr><span class="ft19">21</span></nobr></DIV>
<DIV style="position:absolute;top:107;left:706"><nobr><span class="ft12">±1.9%</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:769"><nobr><span class="ft19">1.3</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:523"><nobr><span class="ft19">seq</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:610"><nobr><span class="ft19">201</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:629"><nobr><span class="ft12">±0.5%</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:694"><nobr><span class="ft19">63</span></nobr></DIV>
<DIV style="position:absolute;top:123;left:706"><nobr><span class="ft12">±1.7%</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:769"><nobr><span class="ft19">3.2</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:523"><nobr><span class="ft19">cflow</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:610"><nobr><span class="ft19">228</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:629"><nobr><span class="ft12">±1.6%</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:694"><nobr><span class="ft19">42</span></nobr></DIV>
<DIV style="position:absolute;top:138;left:706"><nobr><span class="ft12">±1.8%</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:769"><nobr><span class="ft19">5.4</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:523"><nobr><span class="ft19">readGlobal</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:603"><nobr><span class="ft19">2762</span></nobr></DIV>
<DIV style="position:absolute;top:154;left:629"><nobr><span class="ft12">±4.3%</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:700"><nobr><span class="ft19">1</span></nobr></DIV>
<DIV style="position:absolute;top:154;left:706"><nobr><span class="ft12">±0.2%</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:760"><nobr><span class="ft19">2762</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:523"><nobr><span class="ft19">read</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:603"><nobr><span class="ft19">9729</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:629"><nobr><span class="ft12">±4.9%</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:700"><nobr><span class="ft19">1</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:706"><nobr><span class="ft12">±0.6%</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:760"><nobr><span class="ft19">9729</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:475"><nobr><span class="ft6">Table 1: Speed of each language construct used to<br>interpret the base program compared to a native<br>execution.</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:475"><nobr><span class="ft6">the base program. For example, to study the performance<br>of readGlobal, we wrote an aspect whose action returns the<br>value of the global variable referred in the pointcut, i.e., we<br>wrote aspects behaving like the base program. For each of<br>these aspects, we compare the time required to perform the<br>operation matching the pointcut, in case the operation is<br>interpreted by the woven aspect with the time required to<br>carry out the operation natively (without the woven aspect).<br>For example, to study the performance of readGlobal, we<br>first evaluate the time needed to retrieve the global variable<br>value through the code generated by the C compiler gcc<br>without any aspect woven and compare this value to the<br>time needed to retrieve the global variable value through<br>the aspect once it has been woven in the base program.<br>We express our measurements as a ratio between these two<br>durations to abstract from the experimentation platform.</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:489"><nobr><span class="ft2">This approach requires the ability to measure short peri-</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:475"><nobr><span class="ft6">ods of time. For instance, a global variable value is usually<br>retrieved (readGlobal in our aspect language) in a single<br>clock tick. Since standard time measurement APIs were<br>not precise enough, our benchmarking infrastructure relies<br>on the rdtsc assembly instruction [18]. This instruction re-<br>turns the number of clock cycles elapsed since power up. The<br>Pentium 4 processor has the ability to dynamically reorder<br>the instructions it executes. To ensure the validity of our<br>measurement, we thus insert mfence instructions in the gen-<br>erated code whose execution speed is being measured. An<br>mfence forces the preceding instructions to be fully executed<br>before going on. The pipeline mechanism in the Pentium 4<br>processor entails that the speed of a piece of assembly code<br>depends from the preceding instructions. To avoid such hid-<br>den dependencies, we place the operation whose execution<br>time is being measured in a loop. We use gcc to unroll the<br>loop at compile time and we measure the time to execute<br>the complete loop. This measure divided by the number of<br>loop repetitions yields an estimation of the time required<br>to execute the operation. The number of times the loop is<br>executed is chosen after the relative variations of the mea-<br>sures ,i.e., we increased the number of repetitions until ten<br>runs yields an average relative variation not exceeding 5%.<br>To check the correctness of our experimental protocol, we<br>measured the time needed to execute a nop assembly in-<br>struction, that requires one processor cycle according to the<br>Intel specification. The measures of nop presented a relative<br>variation of 1.6%.</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:489"><nobr><span class="ft2">Table 1 summarizes our experimental results. Using the</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:475"><nobr><span class="ft6">aspect language to replace a function that returns immedi-<br>ately is only 1.3 times slower than a direct, aspect-less, call<br>to that empty function. Since the aspect compiler packages<br>advices as regular C functions, and because a call pointcut<br>involves no residue, this good result is not surprising. When</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">35</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
	.ft20{font-size:12px;font-family:Times;color:#000000;}
	.ft21{font-size:10px;font-family:Times;color:#000000;}
	.ft22{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="892" height="1263" src="32010.png" alt="background image">
<DIV style="position:absolute;top:237;left:163"><nobr><span class="ft20"><i><b>Controlflow</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:244;left:127"><nobr><span class="ft10">28 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:151"><nobr><span class="ft10">228 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:176"><nobr><span class="ft10">327 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:151;left:200"><nobr><span class="ft10">424 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:224"><nobr><span class="ft10">522 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:127"><nobr><span class="ft10">1</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:151"><nobr><span class="ft10">2</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:224"><nobr><span class="ft10">5</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:176"><nobr><span class="ft10">3</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:200"><nobr><span class="ft10">4</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:95"><nobr><span class="ft21">10</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:95"><nobr><span class="ft21">20</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:95"><nobr><span class="ft21">30</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:91"><nobr><span class="ft10">Ratio with a normal function call</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:123"><nobr><span class="ft10">Number of imbricated calls</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:289"><nobr><span class="ft10">1</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:313"><nobr><span class="ft10">2</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:386"><nobr><span class="ft10">5</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:338"><nobr><span class="ft10">3</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:362"><nobr><span class="ft10">4</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:253"><nobr><span class="ft10">Ratio with 3 calls</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:269"><nobr><span class="ft10">Number of matching instances</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:261"><nobr><span class="ft21">5</span></nobr></DIV>
<DIV style="position:absolute;top:89;left:257"><nobr><span class="ft21">10</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:293"><nobr><span class="ft10">200.6 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:313"><nobr><span class="ft10">293.2 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:151;left:338"><nobr><span class="ft10">380.8 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:370"><nobr><span class="ft10">466.3 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:342"><nobr><span class="ft20"><i><b>Sequence</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:179;left:419"><nobr><span class="ft10">Ratio</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:410"><nobr><span class="ft21">1000</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:410"><nobr><span class="ft21">2000</span></nobr></DIV>
<DIV style="position:absolute;top:105;left:410"><nobr><span class="ft21">3000</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:390"><nobr><span class="ft10">577 Cycles</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:82"><nobr><span class="ft2">Figure 11: controlflow, seq, and read performances</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:81"><nobr><span class="ft6">an access to a global variable is replaced by an advice exe-<br>cution, the hooks generated by the rewriting strategy need<br>to prepare the processor to call the advice function. This<br>increases the time spent in the hooks. In addition, while<br>an access to a global variable is often performed by a sin-<br>gle x86 instruction, an empty function is often composed<br>of four instructions. Hence the relative cost of an aspect<br>triggered upon a global variable access and a direct, aspect-<br>less, access to a global variable is slightly higher than the<br>corresponding ratio for functions. A seq of three invoca-<br>tions of empty functions is only 3.2 time slower than the<br>direct, aspect-less, three successive functions calls. Com-<br>pared to the pointcuts used to delimit the different stages,<br>the seq overhead is limited to a few pointer exchanges be-<br>tween the linked lists holding the bound variable. On Intel<br>x86, global variable accesses benefit from excellent hardware<br>support. In the absence of aspects, a direct global variable<br>read is usually carried out in a single unique cycle. To trig-<br>ger the advice execution, the Arachne runtime has to save<br>and restore the processor state to ensure the execution co-<br>herency, as advices are packaged as regular C functions (see<br>also 4.2.1). It is therefore not surprising that a global vari-<br>able readGlobal appears as being 2762 times slower than<br>a direct, aspect-less global variable read. read performance<br>can be accounted in the same way: in the absence of aspect,<br>local variables are accessed in a single unique cycle. The<br>signal mechanism used in the read requires that the oper-<br>ating system detects the base program attempt to read into<br>a protected memory page before locating and triggering the<br>signal handler set up by Arachne, as shown in 4.2.3. Such<br>switches to and from kernel space remain slow. Using read<br>to read a local variable is 9729 times slower than retrieving<br>the local variable value directly, without aspects.</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:94"><nobr><span class="ft2">seq and controlflow can refer to several points in the exe-</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:81"><nobr><span class="ft6">cution of the base program (i.e. different stages for seq and<br>different function invocations for the controlflow). The<br>runtime of these pointcuts grows linearly with the number<br>of execution points they refer to and with the number of<br>matching instances. Figure 11 summarizes a few experimen-<br>tal results for controlflow and seq proving these points.</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:81"><nobr><span class="ft3"><b>5.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:996;left:121"><nobr><span class="ft3"><b>Case Study on a real application</b></span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:94"><nobr><span class="ft2">Since, depending on the aspect construct used, interpret-</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:81"><nobr><span class="ft6">ing the base program with aspects can slow it down by a fac-<br>tor ranging between 1.3 and 9729, we studied Arachne's per-<br>formance on a real world application, the Web cache Squid.</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:618"><nobr><span class="ft19">Arachne</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:687"><nobr><span class="ft19">Manual</span></nobr></DIV>
<DIV style="position:absolute;top:94;left:639"><nobr><span class="ft19">Top1</span></nobr></DIV>
<DIV style="position:absolute;top:94;left:703"><nobr><span class="ft19">Top1</span></nobr></DIV>
<DIV style="position:absolute;top:94;left:765"><nobr><span class="ft19">Diff</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:639"><nobr><span class="ft19">Top2</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:703"><nobr><span class="ft19">Top2</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:765"><nobr><span class="ft19">(%)</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:504"><nobr><span class="ft22">Throughput<br>(request/s)</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:648"><nobr><span class="ft19">5.59</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:712"><nobr><span class="ft19">5.59</span></nobr></DIV>
<DIV style="position:absolute;top:135;left:648"><nobr><span class="ft19">5.58</span></nobr></DIV>
<DIV style="position:absolute;top:135;left:712"><nobr><span class="ft19">5.59</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:504"><nobr><span class="ft22">Response Time<br>(ms)</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:629"><nobr><span class="ft19">1131.42</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:693"><nobr><span class="ft19">1146.07</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:756"><nobr><span class="ft19">1.2 ­ -1</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:629"><nobr><span class="ft19">1085.31</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:693"><nobr><span class="ft19">1074.55</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:504"><nobr><span class="ft22">Miss response<br>time (ms)</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:629"><nobr><span class="ft19">2533.50</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:693"><nobr><span class="ft19">2539.52</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:753"><nobr><span class="ft19">0.2 ­ 1.8</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:629"><nobr><span class="ft19">2528.35</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:693"><nobr><span class="ft19">2525.34</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:504"><nobr><span class="ft22">Hit response<br>time (ms)</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:642"><nobr><span class="ft19">28.96</span></nobr></DIV>
<DIV style="position:absolute;top:204;left:706"><nobr><span class="ft19">28.76</span></nobr></DIV>
<DIV style="position:absolute;top:211;left:751"><nobr><span class="ft19">-0.6 ­ 3.8</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:642"><nobr><span class="ft19">30.62</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:706"><nobr><span class="ft19">31.84</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:504"><nobr><span class="ft19">Hit ratio</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:642"><nobr><span class="ft19">59.76</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:706"><nobr><span class="ft19">59.35</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:751"><nobr><span class="ft19">-0.6 ­ 0.7</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:642"><nobr><span class="ft19">61.77</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:706"><nobr><span class="ft19">62.22</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:504"><nobr><span class="ft19">Errors</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:648"><nobr><span class="ft19">0.51</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:712"><nobr><span class="ft19">0.50</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:756"><nobr><span class="ft19">-1.9 ­ 0</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:648"><nobr><span class="ft19">0.34</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:712"><nobr><span class="ft19">0.34</span></nobr></DIV>
<DIV style="position:absolute;top:301;left:474"><nobr><span class="ft6">Table 2: Performances comparison between manual<br>modification and Arachne, for prefechting policy in-<br>tegration in Squid</span></nobr></DIV>
<DIV style="position:absolute;top:381;left:474"><nobr><span class="ft6">We extended Squid with a prefetching policy [9]. As de-<br>scribed in section 3.1, we implemented this policy as a set<br>of aspects and made a second implementation of this policy<br>by editing the Squid source code and recompiling it. This<br>section compares the performance of these two implemen-<br>tations using standard Web cache performance indicators:<br>throughput, response time and hit ratio.</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:488"><nobr><span class="ft2">Obtaining access traces adequate to study a Web cache</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:474"><nobr><span class="ft6">performance is difficult. The trace must be long enough to<br>fill the cache. Due to privacy issues, traces are usually not<br>publicly available. Since traces do not include the content of<br>the accessed pages, these pages must be downloaded again.<br>In the meantime the page contents may have changed and<br>even the URLs may have disappeared.</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:488"><nobr><span class="ft2">Instead of traces, we based our evaluation on Web Poly-</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:474"><nobr><span class="ft6">graph [30]. Polygraph is a benchmarking tool developed by<br>the Squid team and featuring a realistic HTTP and SSL<br>traffic generator and a flexible content simulator.</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:488"><nobr><span class="ft2">We filled up the cache and simulated a one day workload</span></nobr></DIV>
<DIV style="position:absolute;top:678;left:474"><nobr><span class="ft6">with its two request rate peaks observed in real life environ-<br>ments [30]. Table 2 shows results of our simulation. Mea-<br>sures have been made during the two request peaks. The<br>hit time and the miss time, time needed to deliver a docu-<br>ment present, respectively not present, in the cache are very<br>similar. It shows that differences are imperceptible between<br>the version of Squid extended by Arachne and the one ex-<br>tended manually (less than 1%). Hence, even if the cost<br>of Arachne's aspect language constructs might seem high,<br>they are largely amortized in real applications. To give a<br>typical example observed on our experimental platform: in<br>case of a cache hit, a 3.8 MB page was retrieved in a single<br>second, the time spent in prefetching advices amounted to<br>1801 µsec, and the time spent within Arachne to execute the<br>hooks and dynamic tests to 0.45 µsec. In a miss case, on<br>the average, a client retrieved the same page in 1.3 seconds,<br>16679 µsec were spent in the advices and 0.67 µsec within<br>Arachne itself.</span></nobr></DIV>
<DIV style="position:absolute;top:980;left:474"><nobr><span class="ft3"><b>6.</b></span></nobr></DIV>
<DIV style="position:absolute;top:980;left:506"><nobr><span class="ft3"><b>RELATED WORK</b></span></nobr></DIV>
<DIV style="position:absolute;top:1000;left:488"><nobr><span class="ft2">Our work is directly related to other aspect weavers for</span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:474"><nobr><span class="ft6">C, approaches for expressive aspect languages, and dynamic<br>weaving, in particular for C. In this section, we consider<br>related work in each of these fields in turn.</span></nobr></DIV>
<DIV style="position:absolute;top:1063;left:488"><nobr><span class="ft2">Apart from µDyner and Arachne, there are few aspect</span></nobr></DIV>
<DIV style="position:absolute;top:1108;left:449"><nobr><span class="ft2">36</span></nobr></DIV>
</DIV>
<!-- Page 11 -->
<a name="11"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1263" src="32011.png" alt="background image">
<DIV style="position:absolute;top:84;left:81"><nobr><span class="ft6">weavers for C (or even C like languages); some notewor-<br>thy exceptions are AspectC [12] (no available implementa-<br>tion), AspectC++ and [33]. All of these rely on source-code<br>transformation and thus cannot apply aspects to running<br>C applications as required by the applications we consider.<br>Furthermore, none of these systems provides explicit sup-<br>port for aspects over join point sequences.</span></nobr></DIV>
<DIV style="position:absolute;top:194;left:94"><nobr><span class="ft2">There is quite a large body of work now on the notion of</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:81"><nobr><span class="ft6">expressive aspect languages where "more expressive" typi-<br>cally compares to w.r.t. AspectJ's pointcut and advice mod-<br>els. Our work has been inspired by Event-based AOP [15],<br>which aims at the definition of pointcuts in terms of arbi-<br>trary relations between events. Nevertheless, many other<br>approaches to expressive aspect languages exist: e.g., data-<br>flow relations [26], logic programming [13], process algebras<br>[3], graphs [5], and temporal logics [1], have all been pro-<br>posed as a basis for the definition of expressive aspect lan-<br>guages. However, few of these encompass dynamic weaving<br>and only the latter has been applied to C code under effi-<br>ciency considerations similar to our setting.</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:94"><nobr><span class="ft2">Dynamic weaving is commonly realized in Java through</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:81"><nobr><span class="ft6">preprocessing at load-time like [8] or through the JVM De-<br>bugging Interface [28]. These tools rely on bytecode rewrit-<br>ing techniques, have typically limited expressivity (some do<br>not support field accesses) and incur a huge performance<br>overhead. Dynamic weaving through modification at run-<br>time is found infrequently for compiled languages. An ex-<br>ception for Java is JasCo [21] whose most recent version (0.7)<br>supports dynamic weaving through the new instrumentation<br>API of Java 5.</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:94"><nobr><span class="ft2">Many instrumentation techniques have been proposed to</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:81"><nobr><span class="ft6">rewrite binary code on the fly. In these approaches, dif-<br>ficulty issues range from the complexity to rewrite binary<br>code to the lack of a well-defined relationship between source<br>code and the compiler generated binary code. Hence many<br>approaches work on an intermediate representation of the<br>binary code and source language [34]. Producing this repre-<br>sentation first and then regenerating the appropriate binary<br>executable code has proven to be costly both in terms of<br>memory consumption and in CPU time.</span></nobr></DIV>
<DIV style="position:absolute;top:712;left:94"><nobr><span class="ft2">A few other approaches have considered a direct rewrit-</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:81"><nobr><span class="ft6">ing of the binary code at runtime. Dyninst [17] and dynamic<br>probes [27] allow programmers to modify any binary instruc-<br>tion belonging to an executable. Dyninst however relies on<br>the Unix debugging API: ptrace. ptrace allows a third<br>party process to read and write the base program memory.<br>It is however highly inefficient: before using ptrace, the<br>third party process has to suspend the execution of the base<br>program and resume its execution afterwards. In compari-<br>son, Arachne uses ptrace at most once, to inject its kernel<br>DLL into the base program process. In addition, Dyninst<br>does not free the programmer from dealing with low level<br>details. For example, it seems difficult to trigger an advice<br>execution upon a variable access with Dyninst: the transla-<br>tion from the variable identifier to an effective address is left<br>to the user. Worse, Dyninst does not grant that the manip-<br>ulation of the binary instructions it performs will succeed.<br>Dyninst uses an instrumentation strategy where several ad-<br>jacent instructions are relocated. This is unsafe as one of<br>the relocated instructions can be the target of branching<br>instructions. In comparison, Arachne join point model has<br>been carefully chosen to avoid these kind of issues; if an as-<br>pect can be compiled with Arachne, it can always be woven.</span></nobr></DIV>
<DIV style="position:absolute;top:143;left:475"><nobr><span class="ft3"><b>7.</b></span></nobr></DIV>
<DIV style="position:absolute;top:143;left:507"><nobr><span class="ft3"><b>CONCLUSION AND FUTURE WORK</b></span></nobr></DIV>
<DIV style="position:absolute;top:163;left:489"><nobr><span class="ft2">In this paper we have discussed three different crosscut-</span></nobr></DIV>
<DIV style="position:absolute;top:179;left:475"><nobr><span class="ft6">ting concerns which are typical for C applications using OS-<br>level services and which frequently need to be applied at<br>runtime. We have motivated that such concerns can be ex-<br>pressed as aspects and have defined a suitable aspect lan-<br>guage. This language is more expressive than those used in<br>other aspect weavers for C in that it provides support for<br>aspects defined over sequences of execution points as well as<br>for variable aliases. We have presented an integration of this<br>language into Arachne, a weaver for runtime weaving of as-<br>pects in C applications. Finally, we have provided evidence<br>that the integration is efficient enough to apply such aspects<br>dynamically to high-performance applications, in particular<br>the web cache "squid."</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:489"><nobr><span class="ft2">As future work, we intend to investigate the suitability of</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:475"><nobr><span class="ft6">the proposed aspect language for other C-applications. We<br>also intend to investigate Arachne extension to the C++<br>language. Indeed, object-oriented programming heavily uses<br>protocol-based interfaces collaboration (hence sequence as-<br>pects). Along with its open architecture, extending Arachne<br>to support C++, will pave the way to a relatively language<br>independent aspect and weaving infrastructure.</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:789"><nobr><span class="ft2">Finally,</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:475"><nobr><span class="ft6">Arachne's toolbox should be extended with support for as-<br>pect interactions (e.g., analyses and composition operators).</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:475"><nobr><span class="ft3"><b>8.</b></span></nobr></DIV>
<DIV style="position:absolute;top:562;left:507"><nobr><span class="ft3"><b>REFERENCES</b></span></nobr></DIV>
<DIV style="position:absolute;top:584;left:482"><nobr><span class="ft2">[1] R. A. °</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:541"><nobr><span class="ft2">Aberg, J. L. Lawall, M. S¨</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:695"><nobr><span class="ft2">udholt, G. Muller, and</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:503"><nobr><span class="ft6">A.-F. L. Meur. On the automatic evolution of an os<br>kernel using temporal logic and AOP. In Proceedings<br>of Automated Software Engineering (ASE'03), pages<br>196­204. IEEE, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:482"><nobr><span class="ft2">[2] American National Standards Institute.</span></nobr></DIV>
<DIV style="position:absolute;top:679;left:503"><nobr><span class="ft6">ANSI/ISO/IEC 9899-1999: Programming Languages<br>-- C. American National Standards Institute, 1430<br>Broadway, New York, NY 10018, USA, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:482"><nobr><span class="ft2">[3] J. H. Andrews. Process-algebraic foundations of</span></nobr></DIV>
<DIV style="position:absolute;top:744;left:503"><nobr><span class="ft6">aspect-oriented programming. In Proceedings of the<br>3rd International Conference on Metalevel<br>Architectures and Separation of Crosscutting<br>Concerns, volume 2192 of LNCS. Springer Verlag,<br>Sept. 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:482"><nobr><span class="ft2">[4] M. Arlitt and T. Jin. A workload characterization</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:503"><nobr><span class="ft6">study of the 1998 world cup web site. IEEE Network,<br>14(3):30­37, May 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:482"><nobr><span class="ft2">[5] U. Aßmann and A. Ludwig. Aspect weaving by graph</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:503"><nobr><span class="ft6">rewriting. In U. W. Eisenecker and K. Czarnecki,<br>editors, Generative Component-based Software<br>Engineering (GCSE), Erfurt, Oct. 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:482"><nobr><span class="ft2">[6] CERT - Carnegie Mellon University. Vulnerability</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:503"><nobr><span class="ft6">note vu#613459, Feb. 2002. published on line:<br>http://www.kb.cert.org/vuls/id/613459.</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:482"><nobr><span class="ft2">[7] H. Chen and P. Mohapatra. Catp: A context-aware</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:503"><nobr><span class="ft6">transportation protocol for http. In International<br>Workshop on New Advances in Web Servers and<br>Proxy Technologies Held with ICDCS, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:482"><nobr><span class="ft2">[8] S. Chiba and K. Nakagawa. Josh: An open</span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:503"><nobr><span class="ft2">AspectJ-like language. In Proceedings of the third</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">37</span></nobr></DIV>
</DIV>
<!-- Page 12 -->
<a name="12"></a>
<DIV style="position:relative;width:892;height:1263;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="892" height="1263" src="32012.png" alt="background image">
<DIV style="position:absolute;top:84;left:109"><nobr><span class="ft6">international conference on Aspect-oriented software<br>development, pages 102­111. ACM Press, Mar. 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:88"><nobr><span class="ft2">[9] K.-I. Chinen and S. Yamaguchi. An interactive</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:109"><nobr><span class="ft6">prefetching proxy server for improvement of WWW<br>latency. In Seventh Annual Conference of the Internet<br>Society (INET'97), Kuala Lumpur, June 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:182;left:81"><nobr><span class="ft2">[10] I. Cidon, A. Gupta, R. Rom, and C. Schuba. Hybrid</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:109"><nobr><span class="ft6">tcp-udp transport for web traffic. In Proceedings of the<br>18th IEEE International Performance, Computing,<br>and Communications Conference (IPCCC'99), pages<br>177­184, Feb. 1990.</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:81"><nobr><span class="ft2">[11] S. Clowes. Injectso: Modifying and spying on running</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:109"><nobr><span class="ft2">processes under linux. In Black hat briefings, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:81"><nobr><span class="ft2">[12] Y. Coady, G. Kiczales, M. Feeley, and G. Smolyn.</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:109"><nobr><span class="ft6">Using AspectC to improve the modularity of<br>Path-Specific customization in operating system code.<br>In V. Gruhn, editor, Proc. of the Joint 8th European<br>Software Engeneering Conference and 9th ACM<br>SIGSOFT Symposium on the Foundation of Software<br>Engeneering (ESEC/FSE-01), volume 26, 5 of<br>SOFTWARE ENGINEERING NOTES, pages 88­98,<br>New York, Sept. 10­14 2001. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:81"><nobr><span class="ft2">[13] K. de Volder. Aspect-oriented logic meta</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:109"><nobr><span class="ft6">programming. In P. Cointe, editor, Meta-Level<br>Architectures and Reflection, 2nd International<br>Conference on Reflection, volume 1616 of LNCS,<br>pages 250­272. Springer Verlag, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:81"><nobr><span class="ft2">[14] R. Douence, P. Fradet, and M. S¨</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:307"><nobr><span class="ft2">udholt. A framework</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:109"><nobr><span class="ft6">for the detection and resolution of aspect interactions.<br>In Proceedings of the ACM SIGPLAN/SIGSOFT<br>Conference on Generative Programming and<br>Component Engineering (GPCE'02), volume 2487 of<br>LLNCS, pages 173­188. Springer-Verlag, Oct. 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:81"><nobr><span class="ft2">[15] R. Douence, O. Motelet, and M. S¨</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:317"><nobr><span class="ft2">udholt. A formal</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:109"><nobr><span class="ft6">definition of crosscuts. In Proceedings of the 3rd<br>International Conference on Metalevel Architectures<br>and Separation of Crosscutting Concerns, volume 2192<br>of LNCS, pages 170­186. Springer Verlag, Sept. 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:81"><nobr><span class="ft2">[16] E. Hilsdale and J. Hugunin. Advice weaving in</span></nobr></DIV>
<DIV style="position:absolute;top:708;left:109"><nobr><span class="ft6">aspectj. In Proceedings of the 3rd international<br>conference on Aspect-oriented software development,<br>pages 26­35. ACM Press, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:81"><nobr><span class="ft2">[17] J. K. Hollingsworth, B. P. Miller, M. J. R. Goncalves,</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:109"><nobr><span class="ft6">O. Naim, Z. Xu, and L. Zheng. MDL: A language and<br>compiler for dynamic program instrumentation. In<br>IEEE Conference on Parallel Architectures and<br>Compilation Techniques (PACT), pages 201­213, Nov.<br>1997.</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:81"><nobr><span class="ft2">[18] Intel Corportation. IA-32 Intel Architecture Software</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:109"><nobr><span class="ft2">Developer's Manual. Intel Corportation, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:81"><nobr><span class="ft2">[19] V. Issarny, M. Ban^atre, B. Charpiot, and J.-M.</span></nobr></DIV>
<DIV style="position:absolute;top:901;left:109"><nobr><span class="ft6">Menaud. Quality of service and electronic newspaper:<br>The Etel solution. Lecture Notes in Computer Science,<br>1752:472­496, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:81"><nobr><span class="ft2">[20] J. Jaffar, S. Michaylov, P. J. Stuckey, and R. H. C.</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:109"><nobr><span class="ft6">Yap. The clp( r ) language and system. ACM Trans.<br>Program. Lang. Syst., 14(3):339­395, 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:81"><nobr><span class="ft14">[21] JasCo home page. http://ssel.vub.ac.be/jasco/.<br>[22] R. Jones and P. Kelly. Backwards-compatible bounds</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:109"><nobr><span class="ft6">checking for arrays and pointers in c programs. In<br>M. Kamkar, editor, Proceedings of the Third<br>International Workshop on Automatic Debugging,</span></nobr></DIV>
<DIV style="position:absolute;top:84;left:503"><nobr><span class="ft2">volume 2, pages 13­26, May 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:102;left:475"><nobr><span class="ft2">[23] A. D. Keromytis. "Patch on Demand" Saves Even</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:503"><nobr><span class="ft2">More Time? IEEE Computer, 37(8):94­96, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:135;left:475"><nobr><span class="ft2">[24] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda,</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:503"><nobr><span class="ft6">C. Lopes, J.-M. Loingtier, and J. Irwin.<br>Aspect-oriented programming. In M. Ak¸sit and<br>S. Matsuoka, editors, Proceedings European<br>Conference on Object-Oriented Programming, volume<br>1241, pages 220­242. Jyv¨askyl¨a, Finland, June 1997.</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:475"><nobr><span class="ft2">[25] K. J. Lieberherr, J. Palm, and R. Sundaram.</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:503"><nobr><span class="ft6">Expressiveness and complexity of crosscut languages.<br>Technical Report NU-CCIS-04-10, Northeastern<br>University, Sept. 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:294;left:475"><nobr><span class="ft2">[26] H. Masuhara and K. Kawauchi. Dataflow pointcut in</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:503"><nobr><span class="ft6">aspect-oriented programming. In First Asian<br>Symposium on Programming Languages and Systems<br>(APLAS'03), 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:475"><nobr><span class="ft2">[27] R. J. Moore. Dynamic probes and generalised kernel</span></nobr></DIV>
<DIV style="position:absolute;top:374;left:503"><nobr><span class="ft6">hooks interface for Linux. In USENIX, editor,<br>Proceedings of the 4th Annual Linux Showcase and<br>Conference, Atlanta, October 10­14, 2000, Atlanta,<br>Georgia, USA, Berkeley, CA, USA, 2000. USENIX.</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:475"><nobr><span class="ft2">[28] A. Popovici, G. Alonso, and T. Gross. Just-in-time</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:503"><nobr><span class="ft6">aspects: efficient dynamic weaving for Java. In<br>Proceedings of the 2nd international conference on<br>Aspect-oriented software development, pages 100­109,<br>Boston, Massachusetts, Mar. 2003. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:475"><nobr><span class="ft2">[29] M. Rabinovich and H. Wang. DHTTP: An efficient</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:503"><nobr><span class="ft6">and cache-friendly transfer protocol for web traffic. In<br>INFOCOM, pages 1597­1606, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:475"><nobr><span class="ft2">[30] A. Rousskov and D. Wessels. High-performance</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:503"><nobr><span class="ft6">benchmarking with Web Polygraph. Software Practice<br>and Experience, 34(2):187­211, Feb. 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:475"><nobr><span class="ft2">[31] O. Ruwase and M. S. Lam. A practical dynamic buffer</span></nobr></DIV>
<DIV style="position:absolute;top:631;left:503"><nobr><span class="ft6">overflow detector. In Proceedings of the 11th Annual<br>Network and Distributed System Security Symposium.<br>Internet Society, Feb. 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:680;left:475"><nobr><span class="ft2">[32] M. S´egura-Devillechaise, J.-M. Menaud, G. Muller,</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:503"><nobr><span class="ft6">and J. Lawall. Web cache prefetching as an aspect:<br>Towards a dynamic-weaving based solution. In<br>Proceedings of the 2nd international conference on<br>Aspect-oriented software development, pages 110­119,<br>Boston, MA, USA, Mar. 2003. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:475"><nobr><span class="ft2">[33] O. Spinczyk, A. Gal, and W. Schroeder-Preikschat.</span></nobr></DIV>
<DIV style="position:absolute;top:791;left:503"><nobr><span class="ft6">AspectC++: an aspect-oriented extension to the C++<br>programming language. In Proceedings of the Fortieth<br>International Conference on Tools Pacific, pages<br>53­60. Australian Computer Society, Inc., 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:475"><nobr><span class="ft2">[34] A. Srivastava and A. Edwards. Vulcan: Binary</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:503"><nobr><span class="ft6">transformation in a distributed environment. Microsoft<br>Research Tech. Rpt. MSR-TR-2001-50, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:475"><nobr><span class="ft2">[35] U. S. L. System Unix. System V Application Binary</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:503"><nobr><span class="ft6">Interface Intel 386 Architecture Processor Supplement.<br>Prentice Hall Trade, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:953;left:475"><nobr><span class="ft2">[36] D. Wessels. Squid: The Definitive Guide. O'Reilly and</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:503"><nobr><span class="ft2">Associates, Jan. 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:475"><nobr><span class="ft2">[37] J. Wilander and M. Kamkar. A comparison of publicly</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:503"><nobr><span class="ft6">available tools for dynamic buffer overflow prevention.<br>In Proceedings of the 10th Network and Distributed<br>System Security Symposium, pages 149­162, San<br>Diego, California, February 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:1110;left:450"><nobr><span class="ft2">38</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
