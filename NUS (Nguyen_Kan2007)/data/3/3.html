<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE></TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="author" content="">
<META name="keywords" content="">
<META name="date" content="2005-09-13T17:30:59+00:00">
<META name="subject" content="">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
	.ft0{font-size:24px;font-family:Times;color:#000000;}
	.ft1{font-size:18px;font-family:Times;color:#000000;}
	.ft2{font-size:14px;font-family:Times;color:#000000;}
	.ft3{font-size:11px;font-family:Times;color:#000000;}
	.ft4{font-size:11px;font-family:Times;color:#000000;}
	.ft5{font-size:14px;font-family:Times;color:#000000;}
	.ft6{font-size:11px;font-family:Times;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:8px;font-family:Times;color:#000000;}
	.ft9{font-size:9px;font-family:Times;color:#000000;}
	.ft10{font-size:8px;font-family:Times;color:#000000;}
	.ft11{font-size:11px;font-family:Times;color:#000000;}
	.ft12{font-size:16px;font-family:Courier;color:#000000;}
	.ft13{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft14{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft15{font-size:8px;line-height:11px;font-family:Times;color:#000000;}
	.ft16{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1263" src="3001.png" alt="background image">
<DIV style="position:absolute;top:119;left:92"><nobr><span class="ft0"><b>A Computational Approach to Reflective Meta-Reasoning about</b></span></nobr></DIV>
<DIV style="position:absolute;top:149;left:307"><nobr><span class="ft0"><b>Languages with Bindings</b></span></nobr></DIV>
<DIV style="position:absolute;top:140;left:601"><nobr><span class="ft1"></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:249"><nobr><span class="ft2">Aleksey Nogin</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:376"><nobr><span class="ft2">Alexei Kopylov</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:508"><nobr><span class="ft2">Xin Yu</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:583"><nobr><span class="ft2">Jason Hickey</span></nobr></DIV>
<DIV style="position:absolute;top:234;left:369"><nobr><span class="ft3">Department of Computer Science</span></nobr></DIV>
<DIV style="position:absolute;top:249;left:368"><nobr><span class="ft3">California Institute of Technology</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:367"><nobr><span class="ft3">M/C 256-80, Pasadena, CA 91125</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:347"><nobr><span class="ft4">{nogin,kopylov,xiny,jyh}@cs.caltech.edu</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:83"><nobr><span class="ft5"><b>Abstract</b></span></nobr></DIV>
<DIV style="position:absolute;top:389;left:83"><nobr><span class="ft13">We present a foundation for a computational meta-theory of lan-<br>guages with bindings implemented in a computer-aided formal rea-<br>soning environment. Our theory provides the ability to reason ab-<br>stractly about operators, languages, open-ended languages, classes<br>of languages, <i>etc. </i>The theory is based on the ideas of higher-order<br>abstract syntax, with an appropriate induction principle parameter-<br>ized over the language (<i>i.e. </i>a set of operators) being used. In our ap-<br>proach, both the bound and free variables are treated uniformly and<br>this uniform treatment extends naturally to variable-length bind-<br>ings. The implementation is reflective, namely there is a natural<br>mapping between the meta-language of the theorem-prover and the<br>object language of our theory. The object language substitution op-<br>eration is mapped to the meta-language substitution and does not<br>need to be defined recursively. Our approach does not require de-<br>signing a custom type theory; in this paper we describe the im-<br>plementation of this foundational theory within a general-purpose<br>type theory. This work is fully implemented in the MetaPRL the-<br>orem prover, using the pre-existing NuPRL-like Martin-L¨of-style<br>computational type theory. Based on this implementation, we lay<br>out an outline for a framework for programming language experi-<br>mentation and exploration as well as a general reflective reasoning<br>framework. This paper also includes a short survey of the existing<br>approaches to syntactic reflection.</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:83"><nobr><span class="ft5"><i><b>Categories and Subject Descriptors</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:746;left:297"><nobr><span class="ft3">D.3.1 [<i>Programming Lan-</i></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:83"><nobr><span class="ft13"><i>guages</i>]: Formal Definitions and Theory--Syntax; F.4.3 [<i>Math-<br>ematical Logic and Formal Languages</i>]: Formal Languages--<br>Operations on languages</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:83"><nobr><span class="ft5"><i><b>General Terms</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:819;left:178"><nobr><span class="ft3">Languages, Theory, Verification</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:83"><nobr><span class="ft7"><i><b>Keywords</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:150"><nobr><span class="ft3">Higher-Order Abstract Syntax, Reflection, Type The-</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:83"><nobr><span class="ft13">ory, MetaPRL, NuPRL, Programming Language Experimentation,<br>Languages with Bindings.</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:83"><nobr><span class="ft8"></span></nobr></DIV>
<DIV style="position:absolute;top:914;left:90"><nobr><span class="ft9">An extended version of this paper is available as Caltech Technical Report</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:83"><nobr><span class="ft9">CaltechCSTR:2005.003 <A href="3.html#11">[NKYH05]</a></span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:83"><nobr><span class="ft15">Permission to make digital or hard copies of all or part of this work for personal or<br>classroom use is granted without fee provided that copies are not made or distributed<br>for profit or commercial advantage and that copies bear this notice and the full citation<br>on the first page. To copy otherwise, to republish, to post on servers or to redistribute<br>to lists, requires prior specific permission and/or a fee.</span></nobr></DIV>
<DIV style="position:absolute;top:1064;left:83"><nobr><span class="ft10">MERLIN'05</span></nobr></DIV>
<DIV style="position:absolute;top:1064;left:149"><nobr><span class="ft10">September 30, 2005, Tallinn, Estonia.</span></nobr></DIV>
<DIV style="position:absolute;top:1076;left:83"><nobr><span class="ft10">Copyright c 2005 ACM 1-59593-072-8/05/0009. . . $5.00.</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:477"><nobr><span class="ft5"><b>1.</b></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:506"><nobr><span class="ft5"><b>Introduction</b></span></nobr></DIV>
<DIV style="position:absolute;top:389;left:477"><nobr><span class="ft11"><b>1.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:389;left:508"><nobr><span class="ft11"><b>Reflection</b></span></nobr></DIV>
<DIV style="position:absolute;top:410;left:477"><nobr><span class="ft13">Very generally, reflection is the ability of a system to be "self-<br>aware" in some way. More specifically, by reflection we mean the<br>property of a computational or formal system to be able to access<br>and internalize some of its own properties.</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:495"><nobr><span class="ft3">There are many areas of computer science where reflection</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:477"><nobr><span class="ft13">plays or should play a major role. When exploring properties of<br>programming languages (and other languages) one often realizes<br>that languages have at least two kinds of properties -- <i>semantic<br></i>properties that have to do with the <i>meaning </i>of what the language's<br>constructs express and <i>syntactic </i>properties of the language itself.</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:495"><nobr><span class="ft3">Suppose for example that we are exploring some language that</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:477"><nobr><span class="ft16">contains arithmetic operations. And in particular, in this language<br>one can write polynomials like <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:587;left:652"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:660"><nobr><span class="ft4">+ 2<i>x </i>+ 1. In this case the number</span></nobr></DIV>
<DIV style="position:absolute;top:606;left:477"><nobr><span class="ft13">of roots of a polynomial is a semantic property since it has to do<br>with the <i>valuation </i>of the polynomial. On the other hand, the degree<br>of a polynomial could be considered an example of a syntactic<br>property since the most natural way to define it is as a property of<br>the <i>expression </i>that <i>represents </i>that polynomial. Of course, syntactic<br>properties often have semantic consequences, which is what makes<br>them especially important. In this example, the number of roots of<br>a polynomial is bounded by its degree.</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:495"><nobr><span class="ft3">Another area where reflection plays an important role is run-</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:477"><nobr><span class="ft13">time code generation -- in most cases, a language that supports<br>run-time code generation is essentially reflective, as it is capable<br>of manipulating its own syntax. In order to reason about run-time<br>code generation and to express its semantics and properties, it is<br>natural to use a reasoning system that is reflective as well.</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:495"><nobr><span class="ft3">There are many different flavors of reflection. The <i>syntactic</i></span></nobr></DIV>
<DIV style="position:absolute;top:830;left:477"><nobr><span class="ft13"><i>reflection </i>we have seen in the examples above, which is the ability<br>of a system to internalize its own syntax, is just one of these<br>many flavors. Another very important kind of reflection is <i>logical<br>reflection</i>, which is the ability of a reasoning system or logic to<br>internalize and reason about its own logical properties. A good<br>example of a logical reflection is reasoning about knowledge --<br>since the result of reasoning about knowledge is knowledge itself,<br>the logic of knowledge is naturally reflective <A href="3.html#10">[Art04].</a></span></nobr></DIV>
<DIV style="position:absolute;top:949;left:495"><nobr><span class="ft3">In most cases it is natural for reflection to be iterated. In the</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:477"><nobr><span class="ft13">case of syntactic reflection we might care not only about the syntax<br>of our language, but also about the syntax used for expressing the<br>syntax, the syntax for expressing the syntax for expressing the<br>syntax and so forth. In the case of the logic of knowledge it is<br>natural to have iterations of the form "I know that he knows that<br>I know . . .".</span></nobr></DIV>
<DIV style="position:absolute;top:1054;left:495"><nobr><span class="ft3">When a formal system is used to reason about properties of pro-</span></nobr></DIV>
<DIV style="position:absolute;top:1069;left:477"><nobr><span class="ft3">gramming languages, iterated reflection magnifies the power of the</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:456"><nobr><span class="ft3">2</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
	.ft17{font-size:9px;font-family:Times;color:#000000;}
	.ft18{font-size:9px;font-family:Times;color:#000000;}
	.ft19{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft20{font-size:11px;line-height:12px;font-family:Times;color:#000000;}
	.ft21{font-size:11px;line-height:17px;font-family:Times;color:#000000;}
	.ft22{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft23{font-size:11px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1263" src="3002.png" alt="background image">
<DIV style="position:absolute;top:111;left:83"><nobr><span class="ft13">system, making it more natural to reason not just about individual<br>languages, but also about <i>classes </i>of languages, language <i>schemas</i>,<br>and so on. More generally, reflection adds a lot of additional power<br>to a formal reasoning system <A href="3.html#10">[GS89, Art99]. </a>In particular, it is<br>well-known <A href="3.html#10">[G¨od36, </a><A href="3.html#11">Mos52, </a><A href="3.html#10">EM71, </a><A href="3.html#11">Par71] </a>that reflection allows<br>a super-exponential reduction in the size of certain proofs. In addi-<br>tion, reflection could be a very useful mechanism for implement-<br>ing proof search algorithms <A href="3.html#9">[ACU93, </a><A href="3.html#10">GWZ00, CFW04]. </a>See also<br><A href="3.html#10">[Har95] </a>for a survey of reflection in theorem proving.</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:83"><nobr><span class="ft11"><b>1.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:113"><nobr><span class="ft11"><b>Uniform Reflection Framework</b></span></nobr></DIV>
<DIV style="position:absolute;top:305;left:83"><nobr><span class="ft13">For each of the examples in the previous section there are many<br><i>ad-hoc </i>ways of achieving the specific benefits of a specific fla-<br>vor of reflection. This work aims at creating a <i>unifying reflective<br>framework </i>that would allow achieving most of these benefits in a<br>uniform manner, without having to reinvent and re-implement the<br>basic reflective methodology every time. We believe that such a<br>framework will increase the power of the formal reasoning tools,<br>and it may also become an invaluable tool for exploring the proper-<br>ties of novel programming languages, for analyzing run-time code<br>generation, and for formalizing logics of knowledge.</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:101"><nobr><span class="ft3">This paper establishes a foundation for the development of this</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:83"><nobr><span class="ft13">framework -- a new approach to reflective meta-reasoning about<br>languages with bindings. We present a theory of syntax that:</span></nobr></DIV>
<DIV style="position:absolute;top:518;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:102"><nobr><span class="ft13">in a natural way provides both a higher-order abstract syntax<br>(HOAS) approach to bindings and a de Bruijn-style approach<br>to bindings, with easy and natural translation between the two;</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:102"><nobr><span class="ft13">provides a uniform HOAS-style approach to both bound and<br>free variables that extends naturally to variable-length "vectors"<br>of binders;</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:102"><nobr><span class="ft13">permits meta-reasoning about languages -- in particular, the<br>operators, languages, open-ended languages, classes of lan-<br>guages <i>etc</i>. are all first-class objects that can be reasoned about<br>both abstractly and concretely;</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:102"><nobr><span class="ft13">comes with a natural induction principle for syntax that can be<br>parameterized by the language being used;</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:102"><nobr><span class="ft13">provides a natural mapping between the object syntax and meta-<br>syntax that is free of exotic terms, and allows mapping the<br>object-level substitution operation directly to the meta-level one<br>(<i>i.e. </i>-reduction);</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:102"><nobr><span class="ft13">is fully derived in a pre-existing type theory in a theorem<br>prover;</span></nobr></DIV>
<DIV style="position:absolute;top:822;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:102"><nobr><span class="ft13">is designed to serve as a foundation for a general reflective<br>reasoning framework in a theorem prover;</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:861;left:102"><nobr><span class="ft13">is designed to serve as a foundation for a programming lan-<br>guage experimentation framework.</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:101"><nobr><span class="ft3">The paper is structured as follows. Our work inherits a large</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:83"><nobr><span class="ft19">number of ideas from previous efforts and we start in Section <A href="3.html#2">2<br></a>with a brief survey of existing techniques for formal reasoning<br>about syntax. Next in Section <A href="3.html#4">3 </a>we outline our approach to rea-<br>soning about syntax and in Section <A href="3.html#5">4 </a>we present a formal account<br>of our theory based on a Martin-L¨of style computational type the-<br>ory <A href="3.html#10">[CAB</a></span></nobr></DIV>
<DIV style="position:absolute;top:996;left:137"><nobr><span class="ft17"><A href="3.html#10">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:147"><nobr><span class="ft3"><A href="3.html#10">86, HAB</a></span></nobr></DIV>
<DIV style="position:absolute;top:996;left:196"><nobr><span class="ft17"><A href="3.html#10">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:205"><nobr><span class="ft3"><A href="3.html#10">] </a>and the implementation of that account in</span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:83"><nobr><span class="ft3">the MetaPRL theorem prover <A href="3.html#11">[Hic97, Hic99, Hic01, HNC</a></span></nobr></DIV>
<DIV style="position:absolute;top:1011;left:415"><nobr><span class="ft17"><A href="3.html#11">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:425"><nobr><span class="ft3"><A href="3.html#11">03,</a></span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:83"><nobr><span class="ft3"><A href="3.html#11">HNK</a></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:112"><nobr><span class="ft17"><A href="3.html#11">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:122"><nobr><span class="ft3"><A href="3.html#11">, </a><A href="3.html#10">HAB</a></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:156"><nobr><span class="ft17"><A href="3.html#10">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:166"><nobr><span class="ft3"><A href="3.html#10">]. </a>Then in Section <A href="3.html#8">5 </a>we outline our plan for building</span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:83"><nobr><span class="ft13">a uniform reflection framework based on the syntactic reflection.<br>Finally, in Section <A href="3.html#9">6 </a>we resume the discussion of related work that<br>was started in Section <A href="3.html#2">2.</a></span></nobr></DIV>
<DIV style="position:absolute;top:111;left:477"><nobr><span class="ft11"><b>1.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:111;left:508"><nobr><span class="ft11"><b>Notation and Terminology</b></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:477"><nobr><span class="ft21">We believe that our approach to reasoning about syntax is fairly<br>general and does not rely on any special features of the theo-<br>rem prover we use. However, since we implement this theory in<br>MetaPRL, we introduce some basic knowledge about MetaPRL<br>terms.</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:495"><nobr><span class="ft3">A MetaPRL term consists of:</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:482"><nobr><span class="ft3">1. An operator name (like "sum"), which is a unique name indi-</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:497"><nobr><span class="ft3">cating the logic and component of a term;</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:482"><nobr><span class="ft3">2. A list of parameters representing constant values; and</span></nobr></DIV>
<DIV style="position:absolute;top:288;left:482"><nobr><span class="ft3">3. A set of subterms with possible variable bindings.</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:477"><nobr><span class="ft22">We use the following syntax to describe terms, based on the NuPRL<br>definition <A href="3.html#9">[ACHA90]:</a></span></nobr></DIV>
<DIV style="position:absolute;top:352;left:545"><nobr><span class="ft6"><i>opname</i></span></nobr></DIV>
<DIV style="position:absolute;top:375;left:532"><nobr><span class="ft18"><i>operator name</i></span></nobr></DIV>
<DIV style="position:absolute;top:350;left:602"><nobr><span class="ft4">[ <i>p</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:615"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:621"><nobr><span class="ft4">; · · · ; <i>p</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:664"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:350;left:671"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:613"><nobr><span class="ft18"><i>parameters</i></span></nobr></DIV>
<DIV style="position:absolute;top:350;left:677"><nobr><span class="ft4">{v</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:689"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:695"><nobr><span class="ft4">.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:703"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:709"><nobr><span class="ft4">; · · · ; v</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:750"><nobr><span class="ft18"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:350;left:760"><nobr><span class="ft4">.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:356;left:767"><nobr><span class="ft18"><i>m</i></span></nobr></DIV>
<DIV style="position:absolute;top:350;left:777"><nobr><span class="ft4">}</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:707"><nobr><span class="ft18"><i>subt er ms</i></span></nobr></DIV>
<DIV style="position:absolute;top:398;left:495"><nobr><span class="ft3">In addition, MetaPRL has a meta-syntax somewhat similar to</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:477"><nobr><span class="ft23">the higher-order abstract syntax presented in Pfenning and Elliott<br><A href="3.html#11">[PE88]. </a>MetaPRL uses the second-order variables in the style of<br>Huet and Lang <A href="3.html#11">[HL78] </a>to describe term schemas. For example,<br><i>x</i>.<i>V </i>[<i>x</i>], where <i>V </i>is a second-order variable of arity 1, is a schema<br>that stands for an arbitrary term whose top-level operator is .</span></nobr></DIV>
<DIV style="position:absolute;top:487;left:495"><nobr><span class="ft3">This meta-syntax requires that every time a binding occurrence</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:477"><nobr><span class="ft20">is explicitly specified in a schema, all corresponding bound occur-<br>rences have to be specified as well. This requirement makes it very<br>easy to specify free variable restrictions -- for example, <i>x</i>.<i>V </i>,<br>where <i>V </i>is a second-order meta-variable of arity 0, is a schema<br>that stands for an arbitrary term whose top-level operator is  <i>and<br></i>whose body does not have any free occurrences of the variable<br>bound by that . In particular, the schema <i>x</i>.<i>V </i>matches the term<br><i>y</i>.1, but not the term <i>x</i>.<i>x</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:495"><nobr><span class="ft3">In addition, this meta-language allows specifying certain term</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:477"><nobr><span class="ft13">transformations, including implicit substitution specifications. For<br>example, a beta reduction transformation may be specified using<br>the following schema:</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:588"><nobr><span class="ft4">(<i>x</i>.<i>V</i></span></nobr></DIV>
<DIV style="position:absolute;top:695;left:620"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:626"><nobr><span class="ft4">[<i>x</i>]) <i>V</i></span></nobr></DIV>
<DIV style="position:absolute;top:695;left:659"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:670"><nobr><span class="ft4"> <i>V</i></span></nobr></DIV>
<DIV style="position:absolute;top:695;left:696"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:702"><nobr><span class="ft4">[<i>V</i></span></nobr></DIV>
<DIV style="position:absolute;top:695;left:715"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:721"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:477"><nobr><span class="ft3">Here the substitution of <i>V</i></span></nobr></DIV>
<DIV style="position:absolute;top:720;left:616"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:625"><nobr><span class="ft3">for <i>x </i>in <i>V</i></span></nobr></DIV>
<DIV style="position:absolute;top:720;left:677"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:716;left:687"><nobr><span class="ft3">is specified implicitly.</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:495"><nobr><span class="ft3">Throughout this paper we will use this second-order notation to</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:477"><nobr><span class="ft13">denote arbitrary terms -- namely, unless stated otherwise, when we<br>write "<i>x</i>.<i>t </i>[<i>x</i>]" we mean an arbitrary term of this form, not a term<br>containing a concrete second-order variable named "t".</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:495"><nobr><span class="ft3">As in LF <A href="3.html#11">[HHP93] </a>we assume that object level variables (<i>i.e.</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:477"><nobr><span class="ft13">the variables of the language whose syntax we are expressing)<br>are directly mapped to meta-theory variables (<i>i.e. </i>the variable of<br>the language that we use to express the syntax). Similarly, we<br>assume that the object-level binding structure is mapped to the<br>meta-level binding structure. In other words, the object-level notion<br>of the "binding/bound occurrence" is a subset of that in the meta-<br>language. We also consider -equal terms -- both on the object<br>level and on the meta-level -- to be identical and we assume that<br>substitution avoids capture by renaming.</span></nobr></DIV>
<DIV style="position:absolute;top:940;left:495"><nobr><span class="ft3">The sequent schema language we use <A href="3.html#11">[NH02] </a>contains a num-</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:477"><nobr><span class="ft13">ber of more advanced features in addition to those outlined here.<br>However, for the purposes of this presentation, the basic features<br>outlined above are sufficient.</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:477"><nobr><span class="ft5"><b>2.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:506"><nobr><span class="ft5"><b>Previous Models of Reflection</b></span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:477"><nobr><span class="ft13">In 1931 G¨odel used reflection to prove his famous incompleteness<br>theorem <A href="3.html#10">[G¨od31]. </a>To express arithmetic in arithmetic itself, he<br>assigned a unique number (a <i>G¨odel number</i>) to each arithmetic</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:456"><nobr><span class="ft3">3</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1263" src="3003.png" alt="background image">
<DIV style="position:absolute;top:111;left:83"><nobr><span class="ft13">formula. A G¨odel number of a formula is essentially a numeric<br>code of a string of symbols used to represent that formula.</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:101"><nobr><span class="ft3">A modern version of the G¨odel's approach was used by Aitken</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:83"><nobr><span class="ft19"><i>et al. </i><A href="3.html#9">[ACHA90, AC92, ACU93, </a><A href="3.html#10">Con94] </a>to implement reflection<br>in the NuPRL theorem prover <A href="3.html#10">[CAB</a></span></nobr></DIV>
<DIV style="position:absolute;top:166;left:284"><nobr><span class="ft17"><A href="3.html#10">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:171;left:294"><nobr><span class="ft3"><A href="3.html#10">86, </a><A href="3.html#9">ACE</a></span></nobr></DIV>
<DIV style="position:absolute;top:166;left:341"><nobr><span class="ft17"><A href="3.html#9">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:171;left:350"><nobr><span class="ft3"><A href="3.html#9">00]. </a>A large part</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:83"><nobr><span class="ft20">of this effort was essentially a reimplementation of the core of the<br>NuPRL prover inside NuPRL's logical theory.</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:101"><nobr><span class="ft3">In G¨odel's approach and its variations (including Aitken's one),</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:83"><nobr><span class="ft13">a general mechanism that could be used for formalizing one logical<br>theory in another is applied to formalizing a logical theory in itself.<br>This can be very convenient for reasoning <i>about </i>reflection, but for<br>our purposes it turns out to be extremely impractical. First, when<br>formalizing a theory in itself using generic means, the identity<br>between the theory being formalized and the one in which the<br>formalization happens becomes very obfuscated, which makes it<br>almost impossible to relate the reflected theory back to the original<br>one. Second, when one has a theorem proving system that already<br>implements the logical theory in question, creating a completely<br>new implementation of this logical theory inside itself is a very<br>tedious redundant effort. Another practical disadvantage of the<br>G¨odel numbers approach is that it tends to blow up the size of<br>the formulas; and iterated reflection would cause the blow-up to<br>be iterated as well, making it exponential or worse.</span></nobr></DIV>
<DIV style="position:absolute;top:455;left:101"><nobr><span class="ft3">A much more practical approach is being used in some pro-</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:83"><nobr><span class="ft13">gramming languages, such as Lisp and Scheme. There, the com-<br>mon solution is for the implementation to <i>expose </i>its internal syntax<br>representation to user-level code by the quote constructor (where<br>quote (<i>t</i>) prevents the evaluation of the expression <i>t</i>). The prob-<br>lems outlined above are solved instantly by this approach: there is<br>no blow-up, there is no repetition of structure definitions, there is<br>even no need for verifying that the reflected part is equivalent to the<br>original implementation since they are <i>identical</i>. Most Scheme im-<br>plementations take this even further: the eval function is the inter-<br>nal function for evaluating a Scheme expression, which is exposed<br>to the user-level; Smith <A href="3.html#11">[Smi84] </a>showed how this approach can<br>achieve an infinite tower of processors. A similar language with the<br>quotation and antiquotation operators was introduced in <A href="3.html#10">[GMO03].</a></span></nobr></DIV>
<DIV style="position:absolute;top:664;left:101"><nobr><span class="ft3">This approach, however, violates the <i>congruence property </i>with</span></nobr></DIV>
<DIV style="position:absolute;top:679;left:83"><nobr><span class="ft19">respect to computation: if two terms are computationally equal then<br>one can be substituted for the other in any context. For instance,<br>although 2  2 is equal to 4, the expressions "2*2" and "4" are<br>syntactically different, thus we can not substitute 2*2 by 4 in<br>the expression quote(2*2). The congruence property is essential<br>in many logical reasoning systems, including the NuPRL system<br>mentioned above and the MetaPRL system <A href="3.html#11">[HNC</a></span></nobr></DIV>
<DIV style="position:absolute;top:764;left:367"><nobr><span class="ft17"><A href="3.html#11">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:769;left:377"><nobr><span class="ft3"><A href="3.html#11">03, HNK</a></span></nobr></DIV>
<DIV style="position:absolute;top:764;left:429"><nobr><span class="ft17"><A href="3.html#11">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:769;left:438"><nobr><span class="ft3"><A href="3.html#11">,</a></span></nobr></DIV>
<DIV style="position:absolute;top:784;left:83"><nobr><span class="ft3"><A href="3.html#10">HAB</a></span></nobr></DIV>
<DIV style="position:absolute;top:779;left:111"><nobr><span class="ft17"><A href="3.html#10">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:784;left:121"><nobr><span class="ft3"><A href="3.html#10">] </a>that our group uses.</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:101"><nobr><span class="ft3">A possible way to expose the internal syntax without violat-</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:83"><nobr><span class="ft23">ing the congruence property is to use the so-called "quoted" or<br>"shifted" operators <A href="3.html#9">[AA99, </a><A href="3.html#10">Bar01, Bar05] </a>rather than quoting the<br>whole expression at once. For any operator <i>op </i>in the original lan-<br>guage, we add the <i>quoted operator </i>(denoted as <i>op</i>) to represent a<br>term built with the operator <i>op</i>. For example, if the original lan-<br>guage contains the constant "0" (which, presumably, represents the<br>number 0), then in the reflected language, 0 would stand for the<br>term that denotes the expression "0". Generally, the quoted opera-<br>tor has the same arity as the original operator, but it is defined on<br>syntactic terms rather than on semantic objects. For instance, while<br> is a binary operator on numbers,  is a binary operator on terms.<br>Namely, if <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:148"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:159"><nobr><span class="ft3">and <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:186"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:196"><nobr><span class="ft3">are syntactic terms that stand for expressions</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:83"><nobr><span class="ft6"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:89"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:98"><nobr><span class="ft3">and <i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:126"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:136"><nobr><span class="ft3">respectively, then <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:235"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:241"><nobr><span class="ft4"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:252"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:261"><nobr><span class="ft3">is a new syntactic term that stands</span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:83"><nobr><span class="ft3">for the expression <i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:187"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:194"><nobr><span class="ft4"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:208"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:214"><nobr><span class="ft3">. Thus, the quotation of the expression 12</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:83"><nobr><span class="ft3">would be 1  2.</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:495"><nobr><span class="ft3">In general, the well-formedness (typing) rule for a quoted oper-</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:477"><nobr><span class="ft3">ator is the following:</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:565"><nobr><span class="ft6"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:154;left:569"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:148;left:579"><nobr><span class="ft4"> Term</span></nobr></DIV>
<DIV style="position:absolute;top:148;left:649"><nobr><span class="ft4">. . .</span></nobr></DIV>
<DIV style="position:absolute;top:150;left:693"><nobr><span class="ft6"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:154;left:697"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:708"><nobr><span class="ft4"> Term</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:597"><nobr><span class="ft6"><i>op</i>{<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:173;left:619"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:625"><nobr><span class="ft4">; . . . ; <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:173;left:661"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:167;left:668"><nobr><span class="ft4">}  Term</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:820"><nobr><span class="ft3">(1)</span></nobr></DIV>
<DIV style="position:absolute;top:193;left:477"><nobr><span class="ft3">where Term is a type of terms.</span></nobr></DIV>
<DIV style="position:absolute;top:208;left:495"><nobr><span class="ft3">Note that quotations can be iterated arbitrarily many times,</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:477"><nobr><span class="ft13">allowing us to quote quoted terms. For instance, 1 stands for the<br>term that denotes the term that denotes the numeral 1.</span></nobr></DIV>
<DIV style="position:absolute;top:253;left:495"><nobr><span class="ft3">Problems arise when quoting expressions that contain binding</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:477"><nobr><span class="ft13">variables. For example, what is the quotation of <i>x</i>.<i>x</i>? There are<br>several possible ways of answering this question. A commonly<br>used approach <A href="3.html#11">[PE88, </a><A href="3.html#10">DH94, DFH95, </a><A href="3.html#9">ACM02, ACM03] </a>in logical<br>frameworks such as Elf <A href="3.html#11">[Pfe89], </a>LF <A href="3.html#11">[HHP93], </a>and Isabelle <A href="3.html#11">[PN90,<br>Pau94] </a>is to construct an object logic with a concrete  operator<br>that has a type like</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:502"><nobr><span class="ft4">(Term  Term)  Term or (Var  Term)  Term.</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:477"><nobr><span class="ft13">In this approach, the quoted <i>x</i>.<i>x </i>might look like (<i>x</i>.<i>x</i>) and the<br>quoted <i>x</i>.1 might look like (<i>x</i>.1). Note that in these examples<br>the quoted terms have to make use of both the syntactic (<i>i.e. </i>quoted)<br>operator  and the semantic operator .</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:495"><nobr><span class="ft11"><b>Exotic Terms.</b></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:581"><nobr><span class="ft3">Na¨ive implementations of the above approach</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:477"><nobr><span class="ft13">suffer from the well-known problem of exotic terms <A href="3.html#10">[DH95,<br>DFH95]. </a>The issue is that in general we can not allow applying<br>the  operator to an arbitrary function that maps terms to terms (or<br>variables to terms) and expect the result of such an application to<br>be a "proper" reflected term.</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:495"><nobr><span class="ft3">Consider for example the following term:</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:579"><nobr><span class="ft4">(<i>x</i>. <b>if </b><i>x </i>= 1 <b>then </b>1 <b>else </b>2)</span></nobr></DIV>
<DIV style="position:absolute;top:598;left:477"><nobr><span class="ft20">It is relatively easy to see that it is not a real syntactic term and<br>can not be obtained by quoting an actual term. (For comparison,<br>consider (<i>x</i>. <b>if </b><i>x </i>= 1 <b>then </b>1 <b>else </b>2), which is a quotation of<br><i>x</i>. <b>if </b><i>x </i>= 1 <b>then </b>1 <b>else </b>2).</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:495"><nobr><span class="ft3">How can one ensure that <i>e </i>denotes a "real" term and not an</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:477"><nobr><span class="ft13">"exotic" one? That is, is it equal to a result of quoting an actual<br>term of the object language? One possibility is to require <i>e </i>to be<br>a <i>substitution function</i>; in other words it has to be equal to an<br>expression of the form <i>x</i>.<i>t </i>[<i>x</i>] where <i>t </i>is composed entirely of term<br>constructors (<i>i.e. </i>quoted operators) and <i>x</i>, while using <i>destructors<br></i>(such as case analysis, the <b>if </b>operator used in the example above,<br><i>etc</i>) is prohibited.</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:495"><nobr><span class="ft3">There are a number of approaches to enforcing the above restric-</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:477"><nobr><span class="ft13">tion. One of them is the usage of logical frameworks with restricted<br>function spaces <A href="3.html#11">[PE88, HHP93], </a>where -terms may only con-<br>tain constructors. Another is to first formalize the larger type that<br>does include exotic terms and then to define recursively a predicate<br>describing the "validity" or "well-formedness" of a term <A href="3.html#10">[DH94,<br>DFH95] </a>thus removing the exotic terms from consideration. Yet<br>another approach is to create a specialized type theory that com-<br>bines the idea of restricted function spaces with a modal type oper-<br>ator <A href="3.html#10">[DPS97, DL99, DL01]. </a>There the case analysis is disallowed<br>on objects of "pure" type <i>T </i>, but is allowed on objects of a special<br>type</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:515"><nobr><span class="ft6"><i>T </i>. This allows expressing both the restricted function space</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:477"><nobr><span class="ft3">"<i>T</i></span></nobr></DIV>
<DIV style="position:absolute;top:961;left:491"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:501"><nobr><span class="ft4"> <i>T</i></span></nobr></DIV>
<DIV style="position:absolute;top:961;left:527"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:533"><nobr><span class="ft3">" and the unrestricted one "( <i>T</i></span></nobr></DIV>
<DIV style="position:absolute;top:961;left:701"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:708"><nobr><span class="ft4">)  <i>T</i></span></nobr></DIV>
<DIV style="position:absolute;top:961;left:742"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:749"><nobr><span class="ft3">" within a single</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:477"><nobr><span class="ft3">type theory.</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:495"><nobr><span class="ft3">Another way of regarding the problem of exotic terms is that it</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:477"><nobr><span class="ft13">is caused by the attempt to give a semantic definition to a primarily<br>syntactic property. A more syntax-oriented approach was used by<br>Barzilay <i>et al. </i><A href="3.html#10">[BA02, BAC03, Bar05]. </a>In Barzilay's approach, the<br>quoted version of an operator that introduces a binding has the<br>same <i>shape </i>(<i>i.e. </i>the number of subterms and the binding structure)<br>as the original one and the variables (both the binding and the</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:456"><nobr><span class="ft3">4</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
	.ft24{font-size:11px;line-height:5px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1263" src="3004.png" alt="background image">
<DIV style="position:absolute;top:111;left:83"><nobr><span class="ft13">bound occurrences) are unaffected by the quotation. For instance,<br>the quotation of <i>x</i>.<i>x </i>is just <i>x</i>.<i>x</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:141;left:101"><nobr><span class="ft3">The advantages of this approach include:</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:102"><nobr><span class="ft3">This approach is simple and clear.</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:102"><nobr><span class="ft13">Quoted terms have the same structure as original ones, inherit-<br>ing a lot of properties of the object syntax.</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:102"><nobr><span class="ft20">In all the above approaches, the -equivalence relation for<br>quoted terms is inherited "for free". For example, <i>x</i>.<i>x </i>and<br><i>y</i>.<i>y </i>are automatically considered to be the same term.</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:102"><nobr><span class="ft13">Substitution is also easy: we do not need to re-implement the<br>substitution that renames binding variables to avoid the capture<br>of free variables; we can use the substitution of the original<br>language instead.</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:101"><nobr><span class="ft3">To prune exotic terms, Barzilay says that <i>x</i>.<i>t </i>[<i>x</i>] is a valid term</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:83"><nobr><span class="ft13">when <i>x</i>.<i>t </i>[<i>x</i>] is a <i>substitution function</i>. He demonstrates that it is<br>possible to formalize this notion in a <i>purely syntactical </i>fashion. In<br>this setting, the general well-formedness rule for quoted terms with<br>bindings is the following:</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:96"><nobr><span class="ft6"><i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:427;left:138"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:421;left:147"><nobr><span class="ft4">{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:427;left:158"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:165"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:427;left:205"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:421;left:211"><nobr><span class="ft4">.<i>t</i>[<i>x</i>]}</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:257"><nobr><span class="ft4">· · ·</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:289"><nobr><span class="ft6"><i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:427;left:330"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:421;left:337"><nobr><span class="ft4">{<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:427;left:348"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:354"><nobr><span class="ft4">, · · · , <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:427;left:394"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:421;left:398"><nobr><span class="ft4">.<i>s</i>[<i>z</i>]}</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:115"><nobr><span class="ft6"><i>op</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:140"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:146"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:187"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:440;left:193"><nobr><span class="ft4">.<i>t</i>[<i>x</i>];</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:239"><nobr><span class="ft4">· · · ;</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:280"><nobr><span class="ft6"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:285"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:440;left:292"><nobr><span class="ft4">, · · · , <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:331"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:440;left:336"><nobr><span class="ft4">.<i>s</i>[<i>z</i>]}  Term</span></nobr></DIV>
<DIV style="position:absolute;top:455;left:426"><nobr><span class="ft3">(2)</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:83"><nobr><span class="ft3">where <i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:473;left:161"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:467;left:170"><nobr><span class="ft4">{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:474;left:181"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:188"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:473;left:228"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:468;left:235"><nobr><span class="ft4">.<i>t</i>[<i>x</i>]} is the proposition that <i>t </i>is a sub-</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:83"><nobr><span class="ft3">stitution function over variables <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:489;left:265"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:271"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:488;left:312"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:485;left:322"><nobr><span class="ft3">(in other words, it is a</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:83"><nobr><span class="ft13">syntactic version of the Valid predicate of <A href="3.html#10">[DH94, DFH95]). </a>This<br>proposition is defined syntactically by the following two rules:</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:193"><nobr><span class="ft6"><i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:551;left:234"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:546;left:244"><nobr><span class="ft4">{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:552;left:255"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:262"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:551;left:302"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:546;left:309"><nobr><span class="ft4">. <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:552;left:322"><nobr><span class="ft18"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:546;left:327"><nobr><span class="ft4">}</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:83"><nobr><span class="ft3">and</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:141"><nobr><span class="ft6"><i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:594;left:183"><nobr><span class="ft18"><i>n</i>+<i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:207"><nobr><span class="ft4">{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:594;left:218"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:225"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:593;left:265"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:272"><nobr><span class="ft4">, <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:594;left:285"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:292"><nobr><span class="ft4">, · · · , <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:594;left:332"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:339"><nobr><span class="ft4">.<i>t</i>[<i>x</i>; <i>y</i>]}</span></nobr></DIV>
<DIV style="position:absolute;top:603;left:260"><nobr><span class="ft24">.<br>.<br>.</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:142"><nobr><span class="ft6"><i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:636;left:183"><nobr><span class="ft18"><i>n</i>+<i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:205"><nobr><span class="ft4">{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:636;left:217"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:223"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:635;left:263"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:270"><nobr><span class="ft4">, <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:636;left:283"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:289"><nobr><span class="ft4">, · · · , <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:636;left:329"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:333"><nobr><span class="ft4">.<i>s</i>[<i>x</i>; <i>z</i>]}}</span></nobr></DIV>
<DIV style="position:absolute;top:651;left:90"><nobr><span class="ft6"><i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:655;left:132"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:649;left:141"><nobr><span class="ft4">{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:655;left:152"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:161"><nobr><span class="ft4">· · · <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:655;left:186"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:649;left:193"><nobr><span class="ft4">.<i>op</i>{<i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:655;left:222"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:230"><nobr><span class="ft4">· · · <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:655;left:255"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:649;left:261"><nobr><span class="ft4">.<i>t</i>[<i>x</i>; <i>y</i>]; · · · ; <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:655;left:348"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:357"><nobr><span class="ft4">· · · <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:655;left:380"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:649;left:385"><nobr><span class="ft4">.<i>s</i>[<i>x</i>; <i>z</i>]}}</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:101"><nobr><span class="ft3">In this approach the <i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:676;left:254"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:671;left:263"><nobr><span class="ft4">{} and  operators are essentially</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:83"><nobr><span class="ft13"><i>untyped </i>(in NuPRL type theory, the computational properties of<br>untyped terms are at the core of the semantics; types are added on<br>top of the untyped computational system).</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:101"><nobr><span class="ft11"><b>Recursive Definition and Structural Induction Principle.</b></span></nobr></DIV>
<DIV style="position:absolute;top:733;left:432"><nobr><span class="ft3">A</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:83"><nobr><span class="ft13">difficulty shared by both the straightforward implementations of<br>the (Term  Term)  Term approach and by the Barzilay's one<br>is the problem of recursively defining the Term type. We want to<br>define the Term type as the smallest set satisfying rules <A href="3.html#3">(1) </a>and <A href="3.html#4">(2).<br></a>Note, however, that unlike rule <A href="3.html#3">(1), </a>rule <A href="3.html#4">(2) </a>is not monotonic in the<br>sense that <i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:826;left:183"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:820;left:191"><nobr><span class="ft4">{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:827;left:203"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:209"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:826;left:250"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:820;left:256"><nobr><span class="ft4">.<i>t</i>[<i>x</i>]} depends non-monotonically</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:83"><nobr><span class="ft13">on the Term type. For example, to say whether <i>x</i>.<i>t </i>[<i>x</i>] is a term, we<br>should check whether <i>t </i>is a substitution function over <i>x</i>. It means at<br>least that <i>for every x </i>in Term, <i>t </i>[<i>x</i>] should be in Term as well. Thus<br>we need to define the whole type Term before using <A href="3.html#4">(2), </a>which<br>produces a logical circle. Moreover, since  has type (Term <br>Term)  Term, it is hard to formulate the structural induction<br>principle for terms built with the  term constructor.</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:101"><nobr><span class="ft11"><b>Variable-Length Lists of Binders.</b></span></nobr></DIV>
<DIV style="position:absolute;top:942;left:297"><nobr><span class="ft3">In Barzilay's approach, for</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:83"><nobr><span class="ft3">each number <i>n</i>, <i>is subst</i></span></nobr></DIV>
<DIV style="position:absolute;top:960;left:212"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:954;left:221"><nobr><span class="ft4">{} is considered to be a separate operator</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:83"><nobr><span class="ft13">-- there is no way to quantify over <i>n</i>, and there is no way to<br>express variable-length lists of binders. This issue of expressing the<br>unbounded-length lists of binders is common to some of the other<br>approaches as well.</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:101"><nobr><span class="ft11"><b>Meta-Reasoning.</b></span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:202"><nobr><span class="ft3">Another difficulty that is especially apparent</span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:83"><nobr><span class="ft13">in Barzilay's approach is that it only allows reasoning about <i>con-<br>crete </i>operators in concrete languages. This approach does not pro-<br>vide the ability to reason about operators <i>abstractly</i>; in particular,</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:477"><nobr><span class="ft13">there is no way to state and prove meta-theorems that quantify over<br>operators or languages, much less <i>classes </i>of languages.</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:477"><nobr><span class="ft5"><b>3.</b></span></nobr></DIV>
<DIV style="position:absolute;top:156;left:506"><nobr><span class="ft5"><b>Higher-Order Abstract Syntax</b></span></nobr></DIV>
<DIV style="position:absolute;top:176;left:477"><nobr><span class="ft5"><b>with Inductive Definitions</b></span></nobr></DIV>
<DIV style="position:absolute;top:199;left:477"><nobr><span class="ft13">Although it is possible to solve the problems outlined in the previ-<br>ous Section (and we will return to the discussion of some of those<br>solutions in Section <A href="3.html#9">6), </a>our desire is to avoid these difficulties from<br>the start. We propose a natural model of reflection that manages to<br>work around those difficulties. We will show how to give a sim-<br>ple <i>recursive definition </i>of terms with binding variables, which <i>does<br>not allow </i>the construction of exotic terms and <i>does allow </i>structural<br>induction on terms.</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:495"><nobr><span class="ft3">In this Section we provide a conceptual overview of our ap-</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:477"><nobr><span class="ft3">proach; details are given in Section <A href="3.html#5">4.</a></span></nobr></DIV>
<DIV style="position:absolute;top:358;left:477"><nobr><span class="ft11"><b>3.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:358;left:508"><nobr><span class="ft11"><b>Bound Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:379;left:477"><nobr><span class="ft13">One of the key ideas of our approach is how we deal with terms<br>containing free variables. We extend to free variables the principle<br>that <i>variable names do not really matter</i>. In fact, we model free<br>variables as <i>bindings </i>that can be arbitrarily -renamed. Namely,<br>we will write <i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:443;left:600"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:436;left:606"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:442;left:646"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:436;left:653"><nobr><span class="ft4">.<i>t</i>[<i>x</i>]} for a term <i>t </i>over variables</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:478"><nobr><span class="ft6"><i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:458;left:484"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:491"><nobr><span class="ft3">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:534"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:454;left:541"><nobr><span class="ft3">. For example, instead of term <i>x</i><i>y </i>we will use the</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:477"><nobr><span class="ft3">term <i>bterm</i>{<i>x</i>, <i>y</i>.<i>x</i><i>y</i>} when it is considered over variables <i>x </i>and</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:478"><nobr><span class="ft13"><i>y </i>and <i>bterm</i>{<i>x</i>, <i>y</i>, <i>z</i>.<i>x</i><i>y</i>} when it is considered over variables <i>x</i>,<br><i>y </i>and <i>z</i>. Free occurrences of <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:502;left:659"><nobr><span class="ft18"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:498;left:670"><nobr><span class="ft3">in <i>t </i>[<i>x</i>] are considered bound</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:477"><nobr><span class="ft3">in <i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:518;left:537"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:543"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:517;left:584"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:511;left:591"><nobr><span class="ft4">.<i>t</i>[<i>x</i>]} and two -equal <i>bterm</i>{} expressions</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:477"><nobr><span class="ft3">("bterms") are considered to be <i>identical</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:495"><nobr><span class="ft3">Not every bterm is necessarily well-formed. We will define the</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:477"><nobr><span class="ft13">type of terms in such a way as to eliminate exotic terms. Consider<br>for example a definition of lambda-terms.</span></nobr></DIV>
<DIV style="position:absolute;top:597;left:478"><nobr><span class="ft3">E</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:487"><nobr><span class="ft10">XAMPLE</span></nobr></DIV>
<DIV style="position:absolute;top:597;left:538"><nobr><span class="ft3">1. <i>We can define a set of reflected lambda-terms as the</i></span></nobr></DIV>
<DIV style="position:absolute;top:612;left:477"><nobr><span class="ft6"><i>smallest set such that</i></span></nobr></DIV>
<DIV style="position:absolute;top:631;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:497"><nobr><span class="ft6"><i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:638;left:540"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:631;left:546"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:637;left:587"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:631;left:594"><nobr><span class="ft4">.<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:638;left:604"><nobr><span class="ft18"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:631;left:609"><nobr><span class="ft4">}<i>, where </i>1  <i>i </i> <i>n, is a lambda-term (a</i></span></nobr></DIV>
<DIV style="position:absolute;top:649;left:497"><nobr><span class="ft6"><i>variable);</i></span></nobr></DIV>
<DIV style="position:absolute;top:663;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:497"><nobr><span class="ft6"><i>if bterm x</i></span></nobr></DIV>
<DIV style="position:absolute;top:669;left:552"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:559"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:669;left:599"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:663;left:606"><nobr><span class="ft4">, <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:669;left:619"><nobr><span class="ft18"><i>n</i>+1</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:641"><nobr><span class="ft4">.<i>t</i>[<i>x</i>] <i>is a lambda-term, then</i></span></nobr></DIV>
<DIV style="position:absolute;top:689;left:582"><nobr><span class="ft6"><i>bterm x</i></span></nobr></DIV>
<DIV style="position:absolute;top:693;left:627"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:633"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:692;left:673"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:687;left:680"><nobr><span class="ft4">.<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:693;left:698"><nobr><span class="ft18"><i>n</i>+1</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:719"><nobr><span class="ft4">.<i>t</i>[<i>x</i>]</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:497"><nobr><span class="ft6"><i>is also a lambda-term (an abstraction);</i></span></nobr></DIV>
<DIV style="position:absolute;top:725;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:497"><nobr><span class="ft6"><i>if bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:555"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:561"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:602"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:725;left:609"><nobr><span class="ft4">.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:616"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:622"><nobr><span class="ft4">[<i>x</i>]} <i>and bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:722"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:729"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:769"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:725;left:776"><nobr><span class="ft4">.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:783"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:790"><nobr><span class="ft4">[<i>x</i>]} <i>are</i></span></nobr></DIV>
<DIV style="position:absolute;top:742;left:497"><nobr><span class="ft6"><i>lambda-terms, then</i></span></nobr></DIV>
<DIV style="position:absolute;top:764;left:563"><nobr><span class="ft6"><i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:768;left:606"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:613"><nobr><span class="ft4">; · · · ; <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:768;left:654"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:762;left:661"><nobr><span class="ft4">.<i>apply</i>{<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:768;left:703"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:710"><nobr><span class="ft4">[<i>x</i>]; <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:768;left:737"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:762;left:743"><nobr><span class="ft4">[<i>x</i>]}}</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:497"><nobr><span class="ft6"><i>is also a lambda-term (an application).</i></span></nobr></DIV>
<DIV style="position:absolute;top:810;left:495"><nobr><span class="ft3">In a way, bterms could be understood as an explicit coding for</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:477"><nobr><span class="ft13">Barzilay's substitution functions. And indeed, some of the basic<br>definitions are quite similar. The notion of bterms is also very<br>similar to that of <i>local variable contexts </i><A href="3.html#10">[FPT99].</a></span></nobr></DIV>
<DIV style="position:absolute;top:880;left:477"><nobr><span class="ft11"><b>3.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:880;left:508"><nobr><span class="ft11"><b>Terminology</b></span></nobr></DIV>
<DIV style="position:absolute;top:900;left:477"><nobr><span class="ft3">Before we proceed further, we need to define some terminology.</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:478"><nobr><span class="ft3">D</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:488"><nobr><span class="ft10">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:550"><nobr><span class="ft3">1. <i>We change the notion of </i>subterm <i>so that the sub-</i></span></nobr></DIV>
<DIV style="position:absolute;top:939;left:477"><nobr><span class="ft14"><i>terms of a bterm are also bterms. For example, the immediate sub-<br>terms of bterm</i>{<i>x </i>, <i>y</i>.<i>x </i><i>y</i>} <i>are bterm</i>{<i>x </i>, <i>y</i>.<i>x </i>} <i>and bterm</i>{<i>x </i>, <i>y</i>.<i>y</i>}<i>; the<br>immediate subterm of bterm</i>{<i>x </i>.<i>y</i>.<i>x </i>} <i>is bterm</i>{<i>x</i>, <i>y</i>.<i>x </i>}<i>.</i></span></nobr></DIV>
<DIV style="position:absolute;top:993;left:478"><nobr><span class="ft3">D</span></nobr></DIV>
<DIV style="position:absolute;top:995;left:488"><nobr><span class="ft10">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:993;left:550"><nobr><span class="ft3">2. <i>We call the number of outer binders in a bterm</i></span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:477"><nobr><span class="ft14"><i>expression its </i>binding depth<i>. Namely, the </i>binding depth <i>of the<br>bterm bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:555"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:562"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:602"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:1020;left:609"><nobr><span class="ft4">.<i>t</i>[<i>x</i>]} <i>is n.</i></span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:478"><nobr><span class="ft3">D</span></nobr></DIV>
<DIV style="position:absolute;top:1048;left:488"><nobr><span class="ft10">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:550"><nobr><span class="ft3">3. <i>Throughout the rest of the paper we use the notion</i></span></nobr></DIV>
<DIV style="position:absolute;top:1061;left:477"><nobr><span class="ft14"><i>of operator </i>shape<i>. The </i>shape <i>of an operator is a list of natural num-<br>bers each stating how many new binders the operator introduces on</i></span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:456"><nobr><span class="ft3">5</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
	.ft25{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1263" src="3005.png" alt="background image">
<DIV style="position:absolute;top:111;left:83"><nobr><span class="ft14"><i>the corresponding subterm. The length of the shape list is therefore<br>the arity of the operator. For example, the shape of the </i>+ <i>operator<br>is </i>[0; 0] <i>and the shape of the </i> <i>operator is </i>[1]<i>.</i></span></nobr></DIV>
<DIV style="position:absolute;top:168;left:101"><nobr><span class="ft3">The mapping from operators to shapes is also sometimes called</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:83"><nobr><span class="ft3">a <i>binding signature </i>of a language <A href="3.html#10">[FPT99, </a><A href="3.html#11">Plo90].</a></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:83"><nobr><span class="ft3">D</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:94"><nobr><span class="ft10">EFINITION</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:156"><nobr><span class="ft3">4. <i>Let op be an operator with shape </i>[<i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:215;left:376"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:208;left:382"><nobr><span class="ft4">; · · · ; <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:214;left:424"><nobr><span class="ft18"><i>N</i></span></nobr></DIV>
<DIV style="position:absolute;top:208;left:434"><nobr><span class="ft4">]<i>,</i></span></nobr></DIV>
<DIV style="position:absolute;top:225;left:83"><nobr><span class="ft6"><i>and let btl be a list of bterms </i>[<i>b</i></span></nobr></DIV>
<DIV style="position:absolute;top:230;left:269"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:275"><nobr><span class="ft4">; · · · ; <i>b</i></span></nobr></DIV>
<DIV style="position:absolute;top:229;left:317"><nobr><span class="ft18"><i>M</i></span></nobr></DIV>
<DIV style="position:absolute;top:223;left:328"><nobr><span class="ft4">]<i>. We say that btl is</i></span></nobr></DIV>
<DIV style="position:absolute;top:240;left:83"><nobr><span class="ft3">compatible <i>with op at depth n when,</i></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:87"><nobr><span class="ft25"><i>1. N </i>= <i>M;<br>2. the binding depth of bterm b</i></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:257"><nobr><span class="ft18"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:280;left:265"><nobr><span class="ft6"><i>is n </i>+ <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:284;left:310"><nobr><span class="ft18"><i>j</i></span></nobr></DIV>
<DIV style="position:absolute;top:280;left:319"><nobr><span class="ft6"><i>for each </i>1  <i>j </i> <i>N .</i></span></nobr></DIV>
<DIV style="position:absolute;top:309;left:83"><nobr><span class="ft11"><b>3.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:309;left:113"><nobr><span class="ft11"><b>Abstract Operators</b></span></nobr></DIV>
<DIV style="position:absolute;top:330;left:83"><nobr><span class="ft13">Expressions of the form <i>bterm</i>{<i>x</i>.<i>op</i>{· · · }} can only be used to ex-<br>press syntax with <i>concrete </i>operators. In other words, each expres-<br>sion of this form contains a specific constant operator <i>op</i>. However,<br>we would like to reason about operators abstractly; in particular,<br>we want to make it possible to have variables of the type "Op" that<br>can be quantified over and used in the same manner as operator<br>constants. In order to address this we use explicit term constructors<br>in addition to <i>bterm</i>{<i>x</i>.<i>op</i>{· · · }} constants.</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:101"><nobr><span class="ft3">The expression <i>mk bterm</i>{<i>n</i>; "<i>op</i>"; <i>btl</i>}, where "<i>op</i>" is some en-</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:83"><nobr><span class="ft13">coding of the quoted operator <i>op</i>, stands for a bterm with binding<br>depth <i>n</i>, operator <i>op </i>and subterms <i>btl</i>. Namely,</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:100"><nobr><span class="ft6"><i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:507;left:246"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:252"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:293"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:500;left:300"><nobr><span class="ft4">, <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:507;left:313"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:320"><nobr><span class="ft4">.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:507;left:327"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:333"><nobr><span class="ft4">[<i>x</i>; <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:507;left:359"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:366"><nobr><span class="ft4">]} :: · · · ::</span></nobr></DIV>
<DIV style="position:absolute;top:517;left:203"><nobr><span class="ft6"><i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:522;left:246"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:252"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:521;left:293"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:515;left:300"><nobr><span class="ft4">, <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:521;left:313"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:515;left:320"><nobr><span class="ft4">.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:521;left:327"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:515;left:333"><nobr><span class="ft4">[<i>x</i>; <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:521;left:359"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:515;left:366"><nobr><span class="ft4">]} :: nil}</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:83"><nobr><span class="ft3">is <i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:147"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:153"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:544;left:194"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:539;left:201"><nobr><span class="ft4">.<i>op </i>{<i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:232"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:238"><nobr><span class="ft4">.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:246"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:252"><nobr><span class="ft4">[<i>x</i>; <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:278"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:284"><nobr><span class="ft4">]; · · · ; <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:330"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:539;left:336"><nobr><span class="ft4">.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:344"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:539;left:350"><nobr><span class="ft4">[<i>x</i>; <i>y</i></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:376"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:539;left:382"><nobr><span class="ft4">]}}. Here,</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:83"><nobr><span class="ft23">nil is the empty list and :: is the list cons operator and there-<br>fore the expression <i>b</i></span></nobr></DIV>
<DIV style="position:absolute;top:575;left:194"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:205"><nobr><span class="ft4">:: · · · :: <i>b</i></span></nobr></DIV>
<DIV style="position:absolute;top:574;left:253"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:568;left:264"><nobr><span class="ft4">:: nil represents the concrete list</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:83"><nobr><span class="ft4">[<i>b</i></span></nobr></DIV>
<DIV style="position:absolute;top:590;left:94"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:101"><nobr><span class="ft4">; · · · ; <i>b</i></span></nobr></DIV>
<DIV style="position:absolute;top:589;left:142"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:583;left:149"><nobr><span class="ft4">].</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:101"><nobr><span class="ft3">Note that if we know the shape of the operator <i>op </i>and we know</span></nobr></DIV>
<DIV style="position:absolute;top:615;left:83"><nobr><span class="ft13">that the <i>mk bterm </i>expression is well-formed (or, more specifically,<br>if we know that <i>btl </i>is compatible with <i>op </i>at depth <i>n</i>), then it<br>would normally be possible to deduce the value of <i>n </i>(since <i>n </i>is<br>the difference between the binding depth of any element of the list<br><i>btl </i>and the corresponding element of the shape(<i>op</i>) list). There are<br>two reasons, however, for supplying <i>n </i>explicitly:</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:714;left:102"><nobr><span class="ft13">When <i>btl </i>is empty (in other words, when the arity of <i>op </i>is 0),<br>the value of <i>n </i>can not be deduced this way and still needs to be<br>supplied somehow. One could consider 0-arity operators to be a<br>special case, but this results in a significant loss of uniformity.</span></nobr></DIV>
<DIV style="position:absolute;top:777;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:102"><nobr><span class="ft14">When we do <i>not </i>know whether an <i>mk bterm </i>expression is<br>necessarily well-formed (and as we will see it is often useful<br>to allow this to happen), then a lot of definitions and proofs<br>are greatly simplified when the binding depth of <i>mk bterm<br></i>expressions is explicitly specified.</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:101"><nobr><span class="ft3">Using the <i>mk bterm </i>constructor and a few other similar con-</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:83"><nobr><span class="ft13">structors that will be introduced later, it becomes easy to reason ab-<br>stractly about operators. Indeed, the second argument to <i>mk bterm<br></i>can now be an arbitrary expression, not just a constant. This has a<br>cost of making certain definitions slightly more complicated. For<br>example, the notion of "compatible with <i>op </i>at depth <i>n</i>" now be-<br>comes an important part of the theory and will need to be explicitly<br>formalized. However, this is a small price to pay for the ability to<br>reason abstractly about operators, which easily extends to reason-<br>ing abstractly about languages, classes of languages and so forth.</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:83"><nobr><span class="ft11"><b>3.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:113"><nobr><span class="ft11"><b>Inductively Defining the Type of Well-Formed Bterms</b></span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:83"><nobr><span class="ft13">There are two equivalent approaches to inductively defining the<br>general type (set) of all well-formed bterms. The first one follows<br>the same idea as in Example <A href="3.html#4">1:</a></span></nobr></DIV>
<DIV style="position:absolute;top:109;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:497"><nobr><span class="ft6"><i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:115;left:540"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:546"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:114;left:587"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:109;left:594"><nobr><span class="ft4">.<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:115;left:604"><nobr><span class="ft18"><i>i</i></span></nobr></DIV>
<DIV style="position:absolute;top:109;left:609"><nobr><span class="ft4">} is a well-formed bterm for 1  <i>i </i> <i>n</i>;</span></nobr></DIV>
<DIV style="position:absolute;top:130;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:132;left:497"><nobr><span class="ft13"><i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>btl</i>} is a well-formed bterm when <i>op </i>is a well-<br>formed quoted operator and <i>btl </i>is a list of well-formed bterms<br>that is compatible with <i>op </i>at some depth <i>n</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:495"><nobr><span class="ft3">If we denote <i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:189;left:617"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:182;left:624"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:189;left:664"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:182;left:668"><nobr><span class="ft4">, <i>y</i>, <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:189;left:695"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:182;left:702"><nobr><span class="ft4">, · · · , <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:188;left:741"><nobr><span class="ft18"><i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:182;left:748"><nobr><span class="ft4">.<i>y</i>} as <i>var</i>{<i>l</i>; <i>r</i>},</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:477"><nobr><span class="ft13">we can restate the base case of the above definition as "<i>var</i>{<i>l</i>; <i>r </i>},<br>where <i>l </i>and <i>r </i>are arbitrary natural numbers, is a well-formed<br>bterm". Once we do this it becomes apparent that the above def-<br>inition has a lot of similarities with de Bruijn-style indexing of<br>variables <A href="3.html#10">[dB72]. </a>Indeed, one might call the numbers <i>l </i>and <i>r </i>the<br><i>left and right indices of the variable var</i>{<i>l</i>; <i>r </i>}.</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:495"><nobr><span class="ft3">It is possible to provide an alternate definition that is closer to</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:477"><nobr><span class="ft3">pure HOAS:</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:497"><nobr><span class="ft13"><i>bnd</i>{<i>x </i>.<i>t </i>[<i>x</i>]}, where <i>t </i>is a well-formed substitution function, is<br>a well-formed bterm (the <i>bnd </i>operation increases the binding<br>depth of <i>t </i>by one by adding <i>x </i>to the beginning of the list of <i>t</i>'s<br>outer binders).</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:497"><nobr><span class="ft13"><i>mk term</i>{<i>op</i>; <i>btl</i>}, where <i>op </i>is a well-formed quoted operator,<br>and <i>btl </i>is a list of well-formed bterms that is compatible with<br><i>op </i>at depth 0, is a well-formed bterm (of binding depth 0).</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:495"><nobr><span class="ft3">Other than better capturing the idea of HOAS, the latter defini-</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:477"><nobr><span class="ft13">tion also makes it easier to express the reflective correspondence<br>between the meta-syntax (the syntax used to express the theory of<br>syntax, namely the one that includes the operators <i>mk bterm</i>, <i>bnd</i>,<br><i>etc.</i>) and the meta-meta-syntax (the syntax that is used to express<br>the theory of syntax and the underlying theory, in other words, the<br>syntax that includes the second-order notations.) Namely, provided<br>that we define the <i>subst</i>{<i>bt</i>; <i>t </i>} operation to compute the result of<br>substituting a closed term <i>t </i>for the first outer binder of the bterm<br><i>bt</i>, we can state that</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:571"><nobr><span class="ft6"><i>subst</i>{<i>bnd</i>{<i>x </i>.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:643"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:650"><nobr><span class="ft4">[<i>x</i>]} ; <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:684"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:691"><nobr><span class="ft4">}  <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:717"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:724"><nobr><span class="ft4">[<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:732"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:738"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:820"><nobr><span class="ft3">(3)</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:477"><nobr><span class="ft3">(where <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:522"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:531"><nobr><span class="ft3">and <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:558"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:568"><nobr><span class="ft3">are literal second-order variables). In other words,</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:477"><nobr><span class="ft13">we can state that the substitution operator <i>subst </i>and the implicit<br>second-order substitution in the "meta-meta-" language are equiv-<br>alent.</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:495"><nobr><span class="ft3">The downside of the alternate definition is that it requires defin-</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:477"><nobr><span class="ft3">ing the notion of "being a substitution function".</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:477"><nobr><span class="ft11"><b>3.5</b></span></nobr></DIV>
<DIV style="position:absolute;top:727;left:508"><nobr><span class="ft11"><b>Our Approach</b></span></nobr></DIV>
<DIV style="position:absolute;top:748;left:477"><nobr><span class="ft13">In our work we try to combine the advantages of both approaches<br>outlined above. In the next Section we present a theory that includes<br>both the HOAS-style operations (<i>bnd</i>, <i>mk term</i>) and the de Bruijn-<br>style ones (<i>var</i>, <i>mk bterm</i>). Our theory also allows deriving the<br>equivalence <A href="3.html#5">(3). </a>In our theory the definition of the basic syntactic<br>operations is based on the HOAS-style operators; however, the<br>recursive definition of the type of well-formed syntax is based on<br>the de Bruijn-style operations. Our theory includes also support for<br>variable-length lists of binders.</span></nobr></DIV>
<DIV style="position:absolute;top:901;left:477"><nobr><span class="ft5"><b>4.</b></span></nobr></DIV>
<DIV style="position:absolute;top:901;left:506"><nobr><span class="ft5"><b>Formal Implementation in a Theorem Prover</b></span></nobr></DIV>
<DIV style="position:absolute;top:924;left:477"><nobr><span class="ft13">In this Section we describe how the foundations of our theory are<br>formally defined and derived in the NuPRL-style Computational<br>Type Theory in the MetaPRL Theorem Prover. For brevity, we<br>will present a slightly simplified version of our implementation;<br>full details are available in the extended version of this paper<br><A href="3.html#11">[NKYH05, </a>Appendix].</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:477"><nobr><span class="ft11"><b>4.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:508"><nobr><span class="ft11"><b>Computations and Types</b></span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:477"><nobr><span class="ft13">In our work we make heavy usage of the fact that our type theory<br>allows us to define computations <i>without </i>stating upfront (or even<br>knowing) what the relevant types are. In NuPRL-style type theo-</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:456"><nobr><span class="ft3">6</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
	.ft26{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
	.ft27{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1263" src="3006.png" alt="background image">
<DIV style="position:absolute;top:111;left:83"><nobr><span class="ft13">ries (which some even dubbed "untyped type theory"), one may de-<br>fine arbitrary recursive functions (even potentially nonterminating<br>ones). Only when proving that such function belongs to a particular<br>type, one may have to prove termination. See <A href="3.html#10">[All87a, All87b] </a>for<br>a semantics that justifies this approach.</span></nobr></DIV>
<DIV style="position:absolute;top:186;left:101"><nobr><span class="ft3">The formal definition of the syntax of terms consists of two</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:83"><nobr><span class="ft3">parts:</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:224;left:102"><nobr><span class="ft13">The definition of untyped term constructors and term oper-<br>ations, which includes both HOAS-style operations and de<br>Bruijn-style operations. As it turns out, we can establish most<br>of the reduction properties without explicitly giving types to all<br>the operations.</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:102"><nobr><span class="ft13">The definition of the type of terms. We will define the type of<br>terms as the type that contains all terms that can be legitimately<br>constructed by the term constructors.</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:83"><nobr><span class="ft11"><b>4.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:363;left:113"><nobr><span class="ft11"><b>HOAS Constructors</b></span></nobr></DIV>
<DIV style="position:absolute;top:384;left:83"><nobr><span class="ft13">At the core of our term syntax definition are two basic HOAS-style<br>constructors:</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:102"><nobr><span class="ft13"><i>bnd</i>{<i>x </i>.<i>t </i>[<i>x</i>]} is meant to represent a term with a free variable <i>x</i>.<br>The intended semantics (which will not become explicit until<br>later) is that <i>bnd</i>{<i>x</i>.<i>t </i>[<i>x</i>]} will only be considered well-formed<br>when <i>t </i>is a substitution function.</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:102"><nobr><span class="ft3">Internally, <i>bnd</i>{<i>x</i>.<i>t </i>[<i>x</i>]} is implemented simply as the pair</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:107"><nobr><span class="ft3">0, <i>x</i>.<i>t </i>[<i>x</i>] . This definition is truly internal and is used only</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:102"><nobr><span class="ft13">to prove the properties of the two destructors presented below;<br>it is never used outside of this Section (Section <A href="3.html#6">4.2).</a></span></nobr></DIV>
<DIV style="position:absolute;top:550;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:102"><nobr><span class="ft14"><i>mk term</i>{<i>op</i>; <i>ts</i>} pairs <i>op </i>with <i>ts</i>. The intended usage of this<br>operation (which, again, will only become explicit later) is that<br>it represents a closed term (<i>i.e. </i>a <i>bterm </i>of binding depth 0) with<br>operator <i>op </i>and subterms <i>ts</i>. It will be considered well-formed<br>when <i>op </i>is an operator and <i>ts </i>is a list of terms that is <i>compatible<br></i>with <i>op </i>at depth 0. For example, <i>mk term</i>{; <i>bnd</i>{<i>x</i>.<i>x</i>}} is <i>x</i>.<i>x</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:102"><nobr><span class="ft3">Internally, <i>mk term</i>{<i>op</i>; <i>ts</i>} is implemented as the nested pair</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:107"><nobr><span class="ft3">1, <i>op</i>, <i>ts </i>. Again, this definition is never used outside of this</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:102"><nobr><span class="ft3">Section.</span></nobr></DIV>
<DIV style="position:absolute;top:699;left:101"><nobr><span class="ft3">We also implement two destructors:</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:102"><nobr><span class="ft13"><i>subst</i>{<i>bt</i>; <i>t </i>} is meant to represent the result of substituting term<br><i>t </i>for the first variable of the bterm <i>bt</i>. Internally, <i>subst</i>{<i>bt</i>; <i>t </i>}<br>is defined simply as an application (<i>bt</i>.2) <i>t </i>(where <i>bt</i>.2 is the<br>second element of the pair <i>bt </i>).</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:102"><nobr><span class="ft3">We derive the following property of this substitution operation:</span></nobr></DIV>
<DIV style="position:absolute;top:810;left:186"><nobr><span class="ft6"><i>subst</i>{<i>bnd</i>{<i>x</i>.<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:814;left:259"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:265"><nobr><span class="ft4">[<i>x</i>]} ; <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:814;left:299"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:306"><nobr><span class="ft4">}  <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:814;left:333"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:339"><nobr><span class="ft4">[<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:814;left:347"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:354"><nobr><span class="ft4">]</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:102"><nobr><span class="ft3">where "" is the computational equality relation</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:372"><nobr><span class="ft9"><A href="3.html#6">1</a></span></nobr></DIV>
<DIV style="position:absolute;top:835;left:383"><nobr><span class="ft3">and <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:411"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:422"><nobr><span class="ft3">and</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:102"><nobr><span class="ft6"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:854;left:106"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:117"><nobr><span class="ft3">may be absolutely arbitrary, even ill-typed. This derivation</span></nobr></DIV>
<DIV style="position:absolute;top:864;left:102"><nobr><span class="ft13">is the only place where the internal definition of <i>subst</i>{<i>bt</i>; <i>t</i>} is<br>used.</span></nobr></DIV>
<DIV style="position:absolute;top:899;left:102"><nobr><span class="ft13">Note that the above equality is exactly the "reflective property<br>of substitution" <A href="3.html#5">(3) </a>that was one of the design goals for our<br>theory.</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:102"><nobr><span class="ft13"><i>weak dest </i>{<i>bt</i>; <i>bcase</i>; <i>op</i>, <i>ts</i>.<i>mkt case</i>[<i>op</i>; <i>ts</i>]} is designed to<br>provide a way to find out whether <i>bt </i>is a <i>bnd</i>{} or a <i>mk term</i>{<i>op</i>; <i>ts</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:83"><nobr><span class="ft10">1</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:90"><nobr><span class="ft9">In NuPRL-style type theories the computational equality relation (which</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:83"><nobr><span class="ft26">is also sometimes called "squiggle equality" and is sometimes denoted<br>as "" or "") is the finest-grained equality relation in the theory.<br>When <i>a </i> <i>b </i>is true, <i>a </i>may be replaced with <i>b </i>in an arbitrary context.<br>Examples of computational equality include beta-reduction <i>x</i>.<i>a</i>[<i>x</i>] <i>b </i><br><i>a</i>[<i>b</i>], arithmetical equalities (1 + 2  3), and definitional equality (an<br>abstraction is considered to be computationally equal to its definition).</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:497"><nobr><span class="ft19">and to "extract" the <i>op </i>and <i>ts </i>in the latter case. In the rest of<br>this paper we will use the "pretty-printed" form for <i>weak dest<br></i>-- "match <i>bt </i>with <i>bnd</i>{ }  <i>bcase </i>| <i>mk term</i>{<i>op</i>; <i>ts</i>} <br><i>mkt case</i>[<i>op</i>; <i>ts</i>]". Internally, it is defined as<br><b>if </b><i>bt</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:523"><nobr><span class="ft3">1 = 0 <b>then </b><i>bcase </i><b>else </b><i>mkt case</i>[<i>bt</i>.2.1; <i>bt</i>.2.2].</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:497"><nobr><span class="ft13">From this internal definition we derive the following properties<br>of <i>weak dest</i>:</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:512"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:238;left:512"><nobr><span class="ft4">match <i>bnd</i>{<i>x</i>.<i>t</i>[<i>x</i>]} with</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:534"><nobr><span class="ft6"><i>bnd</i>{ }  <i>bcase</i></span></nobr></DIV>
<DIV style="position:absolute;top:255;left:526"><nobr><span class="ft4">| <i>mk term</i>{<i>op</i>; <i>ts</i>}  <i>mkt case[op; ts]</i></span></nobr></DIV>
<DIV style="position:absolute;top:214;left:730"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:238;left:730"><nobr><span class="ft4">  <i>bcase</i></span></nobr></DIV>
<DIV style="position:absolute;top:276;left:512"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:300;left:512"><nobr><span class="ft4">match <i>mk term</i>{<i>op</i>; <i>ts</i>} with</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:534"><nobr><span class="ft6"><i>bnd</i>{ }  <i>bcase</i></span></nobr></DIV>
<DIV style="position:absolute;top:317;left:526"><nobr><span class="ft4">| <i>mk term</i>{<i>o</i>; <i>t</i>}  <i>mkt case</i>[<i>o</i>; <i>t</i>]</span></nobr></DIV>
<DIV style="position:absolute;top:276;left:706"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:300;left:706"><nobr><span class="ft4">  <i>mkt case</i>[<i>op</i>; <i>ts</i>]</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:477"><nobr><span class="ft11"><b>4.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:349;left:508"><nobr><span class="ft11"><b>Vector HOAS Operations</b></span></nobr></DIV>
<DIV style="position:absolute;top:370;left:477"><nobr><span class="ft13">As we have mentioned at the end of Section <A href="3.html#2">2, </a>some approaches to<br>reasoning about syntax make it hard or even impossible to express<br>arbitrary-length lists of binders. In our approach, we address this<br>challenge by allowing operators where a single binding in the meta-<br>language stands for a list of object-level bindings. In particular, we<br>allow representing <i>bnd</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:616"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:622"><nobr><span class="ft4">.<i>bnd</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:658"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:664"><nobr><span class="ft4">. · · · <i>bnd</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:448;left:720"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:443;left:727"><nobr><span class="ft4">.<i>t</i>[<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:449;left:747"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:753"><nobr><span class="ft4">; . . . ; <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:448;left:792"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:443;left:799"><nobr><span class="ft4">]} · · ·}}</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:477"><nobr><span class="ft13">as<br><i>vbnd</i>{<i>n</i>; <i>x </i>.<i>t </i>[<i>nth</i>{1; <i>x</i>} ; . . . ; <i>nth</i>{<i>n</i>; <i>x</i>}]}, where "<i>nth</i>{<i>i </i>; <i>l</i>}" is the "<i>i </i>-<br>th element of the list <i>l</i>" function.</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:495"><nobr><span class="ft3">We define the following vector-style operations:</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:497"><nobr><span class="ft16"><i>vbnd</i>{<i>n</i>; <i>x </i>.<i>t </i>[<i>x</i>]} represents a "telescope" of nested <i>bnd </i>opera-<br>tions. It is defined by induction</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:673"><nobr><span class="ft9"><A href="3.html#6">2</a></span></nobr></DIV>
<DIV style="position:absolute;top:545;left:684"><nobr><span class="ft3">on the natural number <i>n </i>as</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:497"><nobr><span class="ft3">follows:</span></nobr></DIV>
<DIV style="position:absolute;top:581;left:542"><nobr><span class="ft6"><i>vbnd</i>{0; <i>x</i>.<i>t </i>[<i>x</i>]}</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:640"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:581;left:669"><nobr><span class="ft6"><i>t </i>[nil]</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:518"><nobr><span class="ft6"><i>vbnd</i>{<i>n </i>+ 1; <i>x</i>.<i>t </i>[<i>x</i>]}</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:640"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:596;left:669"><nobr><span class="ft6"><i>bnd</i>{v.<i>vbnd</i>{<i>n</i>; <i>x </i>.<i>t </i>[v :: <i>x </i>]}}</span></nobr></DIV>
<DIV style="position:absolute;top:624;left:497"><nobr><span class="ft13">We also introduce <i>vbnd</i>{<i>n</i>; <i>t </i>} as a simplified notation for<br><i>vbnd</i>{<i>n</i>; <i>x </i>.<i>t </i>} when <i>t </i>does not have free occurrences of <i>x</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:497"><nobr><span class="ft13"><i>vsubst</i>{<i>bt</i>; <i>ts</i>} is a "vector" substitution operation that is meant<br>to represent the result of simultaneous substitution of the terms<br>in the <i>ts </i>list for the first |<i>ts</i>| variables of the bterm <i>bt </i>(here |<i>l</i>| is<br>the length of the list <i>l</i>). <i>vsubst</i>{<i>bt</i>; <i>ts</i>} is defined by induction on<br>the list <i>ts </i>as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:546"><nobr><span class="ft6"><i>vsubst</i>{<i>bt</i>; nil}</span></nobr></DIV>
<DIV style="position:absolute;top:738;left:643"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:673"><nobr><span class="ft6"><i>bt</i></span></nobr></DIV>
<DIV style="position:absolute;top:755;left:539"><nobr><span class="ft6"><i>vsubst</i>{<i>bt</i>; <i>t </i>:: <i>ts</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:643"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:673"><nobr><span class="ft6"><i>vsubst</i>{<i>subst</i>{<i>bt</i>; <i>t </i>} ; <i>ts</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:495"><nobr><span class="ft3">Below are some of the derived properties of these operations:</span></nobr></DIV>
<DIV style="position:absolute;top:807;left:639"><nobr><span class="ft6"><i>bnd</i>{v.<i>t </i>[v]}  <i>vbnd</i>{1; hd(v)}</span></nobr></DIV>
<DIV style="position:absolute;top:807;left:820"><nobr><span class="ft3">(4)</span></nobr></DIV>
<DIV style="position:absolute;top:823;left:488"><nobr><span class="ft4"><i>m</i>, <i>n </i> N.</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:503"><nobr><span class="ft6"><i>vbnd</i>{<i>m </i>+ <i>n</i>; <i>x </i>.<i>t </i>[<i>x</i>]}  <i>vbnd</i>{<i>m</i>; <i>y</i>.<i>vbnd</i>{<i>n</i>; <i>z</i>.<i>t </i>[<i>y</i>@<i>z</i>]}}</span></nobr></DIV>
<DIV style="position:absolute;top:834;left:820"><nobr><span class="ft3">(5)</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:547"><nobr><span class="ft4"><i>l </i> List. (<i>vsubst</i>{<i>vbnd</i>{|<i>l</i>|; v.<i>t</i>[v]} ; <i>l</i>}  <i>t</i>[<i>l</i>])</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:820"><nobr><span class="ft3">(6)</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:482"><nobr><span class="ft4"><i>l </i> List.<i>n </i> N. (<i>n </i> |<i>l</i>|) </span></nobr></DIV>
<DIV style="position:absolute;top:894;left:494"><nobr><span class="ft4">(<i>vsubst</i>{<i>vbnd</i>{<i>n</i>; v.<i>t</i>[v]} ; <i>l</i>}  <i>vbnd</i>{<i>n </i>- |<i>l</i>|; v.<i>bt</i>[<i>l</i>@v]})</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:820"><nobr><span class="ft3">(7)</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:488"><nobr><span class="ft4"><i>n </i> N.</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:503"><nobr><span class="ft6"><i>vbnd</i>{<i>n</i>; <i>l</i>.<i>vsubst</i>{<i>vbnd</i>{<i>n</i>; v.<i>t </i>[v]} ; <i>l</i>}}  <i>vbnd</i>{<i>n</i>; <i>l</i>.<i>t </i>[<i>l</i>]}</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:820"><nobr><span class="ft3">(8)</span></nobr></DIV>
<DIV style="position:absolute;top:956;left:477"><nobr><span class="ft13">where "hd" is the list "head" operation, "@" is the list append<br>operation, "List" is the type of arbitrary lists (the elements of a list<br>do not have to belong to any particular type), N is the type of natural<br>numbers, and all the variables that are not explicitly constrained to<br>a specific type stand for arbitrary expressions.</span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:477"><nobr><span class="ft10">2</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:485"><nobr><span class="ft9">Our presentation of the inductive definitions is slightly simplified by</span></nobr></DIV>
<DIV style="position:absolute;top:1064;left:477"><nobr><span class="ft9">omitting some minor technical details. See <A href="3.html#11">[NKYH05, </a>Appendix]</span></nobr></DIV>
<DIV style="position:absolute;top:1064;left:822"><nobr><span class="ft9">for</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:477"><nobr><span class="ft9">complete details.</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:456"><nobr><span class="ft3">7</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1263" src="3007.png" alt="background image">
<DIV style="position:absolute;top:111;left:101"><nobr><span class="ft3">Equivalence <A href="3.html#6">(5) </a>allows the merging and splitting of vector <i>bnd</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:83"><nobr><span class="ft13">operations. Equivalence <A href="3.html#6">(6) </a>is a vector variant of equivalence <A href="3.html#5">(3).<br></a>Equivalence <A href="3.html#6">(8) </a>is very similar to equivalence <A href="3.html#6">(6) </a>applied in the<br><i>vbnd</i>{<i>n</i>; <i>l</i>. · · ·} context, except that <A href="3.html#6">(8) </a>does not require <i>l </i>to be a<br>member of any special type.</span></nobr></DIV>
<DIV style="position:absolute;top:201;left:83"><nobr><span class="ft11"><b>4.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:113"><nobr><span class="ft11"><b>De Bruijn-style Operations</b></span></nobr></DIV>
<DIV style="position:absolute;top:222;left:83"><nobr><span class="ft13">Based on the HOAS constructors defined in the previous two sec-<br>tions, we define two de Bruijn-style constructors.</span></nobr></DIV>
<DIV style="position:absolute;top:259;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:102"><nobr><span class="ft13"><i>var</i>{<i>i </i>; <i>j </i>} is defined as <i>vbnd</i>{<i>i </i>; <i>bnd</i>{v.<i>vbnd</i>{ <i>j </i>; v}}}. It is easy to<br>see that this definition indeed corresponds to the informal</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:177"><nobr><span class="ft6"><i>bterm</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:305;left:220"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:227"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:304;left:267"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:298;left:272"><nobr><span class="ft4">, <i>y</i>, <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:305;left:298"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:305"><nobr><span class="ft4">, · · · , <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:304;left:344"><nobr><span class="ft18"><i>r</i></span></nobr></DIV>
<DIV style="position:absolute;top:298;left:351"><nobr><span class="ft4">.<i>y</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:106"><nobr><span class="ft3">definition given in Section <A href="3.html#5">3.4.</a></span></nobr></DIV>
<DIV style="position:absolute;top:343;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:102"><nobr><span class="ft13"><i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>ts</i>} is meant to compute a bterm of binding<br>depth <i>n</i>, with operator <i>op</i>, and with <i>ts </i>as its subterms. This op-<br>eration is defined by induction on natural number <i>n </i>as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:156"><nobr><span class="ft6"><i>mk bterm</i>{0; <i>op</i>; <i>ts</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:276"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:305"><nobr><span class="ft6"><i>mk term</i>{<i>op</i>; <i>ts</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:414;left:132"><nobr><span class="ft6"><i>mk bterm</i>{<i>n </i>+ 1; <i>op</i>; <i>ts</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:276"><nobr><span class="ft4">:=</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:163"><nobr><span class="ft6"><i>bnd</i>{v.<i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>map </i><i>t</i>.<i>subst</i>{<i>t </i>; v} <i>ts</i>}}</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:102"><nobr><span class="ft13">Note that, if <i>ts </i>is a list of <i>bnd </i>expressions (which is the intended<br>usage of the <i>mk bterm </i>operation), then the</span></nobr></DIV>
<DIV style="position:absolute;top:491;left:175"><nobr><span class="ft6"><i>bnd</i>{v. · · · <i>map </i><i>t</i>.<i>subst</i>{<i>t </i>; v} <i>ts </i>· · ·}</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:102"><nobr><span class="ft14">has the effect of stripping the outer <i>bnd </i>from each of the mem-<br>bers of the <i>ts </i>list and "moving" them into a single "merged" <i>bnd<br></i>on the outside.</span></nobr></DIV>
<DIV style="position:absolute;top:570;left:101"><nobr><span class="ft3">We also define a number of de Bruijn-style destructors, <i>i.e.</i>, op-</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:83"><nobr><span class="ft13">erations that compute various de Bruijn-style characteristics of a<br>bterm. Since the <i>var </i>and <i>mk bterm </i>constructors are defined in terms<br>of the HOAS constructors, the destructors have to be defined in<br>terms of HOAS operations as well. Because of this, these defini-<br>tions are often far from straightforward.</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:101"><nobr><span class="ft3">It is important to emphasize that the tricky definitions that we</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:83"><nobr><span class="ft13">use here are only needed to establish the basic properties of the<br>operations we defined. Once the basic theory is complete, we can<br>raise the level of abstraction and no usage of this theory will<br>ever require using any of these definitions, being aware of these<br>definitions, or performing similar tricks again.</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:102"><nobr><span class="ft13"><i>bdepth</i>{<i>t </i>} computes the binding depth of term <i>t </i>. It is defined<br>recursively using the <i>Y </i>combinator as</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:115"><nobr><span class="ft6"><i>Y</i></span></nobr></DIV>
<DIV style="position:absolute;top:789;left:126"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:813;left:126"><nobr><span class="ft4"> <i>f</i>.<i>b</i>.match <i>b </i>with</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:183"><nobr><span class="ft6"><i>bnd</i>{ }  1 + <i>f subst</i>{<i>b</i>; <i>mk term</i>{0; 0}}</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:176"><nobr><span class="ft4">| <i>mk term</i>{ ; }  0</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:411"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:813;left:411"><nobr><span class="ft4"> <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:858;left:102"><nobr><span class="ft13">In effect, this recursive function strips the outer binders from a<br>bterm one by one using substitution (note that here we can use<br>an arbitrary <i>mk bterm </i>expression as a second argument for the<br>substitution function; the arguments to <i>mk bterm </i>do not have<br>to have the "correct" type) and counts the number of times it<br>needs to do this before the outermost <i>mk bterm </i>is exposed.</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:102"><nobr><span class="ft3">We derive the following properties of <i>bdepth</i>:</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:152"><nobr><span class="ft4"><i>l</i>, <i>r </i> N. <i>bdepth</i>{<i>var</i>{<i>l</i>; <i>r</i>}}  (<i>l </i>+ <i>r </i>+ 1) ;</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:154"><nobr><span class="ft4"><i>n </i> N. <i>bdepth</i>{<i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>ts</i>}}  <i>n </i>.</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:102"><nobr><span class="ft13">Note that the latter equivalence only requires <i>n </i>to have the<br>"correct" type, while <i>op </i>and <i>ts </i>may be arbitrary. Since the<br><i>bdepth </i>operator is needed for defining the type of Term of well-<br>formed bterms, at this point we would not have been able to<br>express what the "correct" type for <i>ts </i>would be.</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:497"><nobr><span class="ft13"><i>left</i>{<i>t </i>} is designed to compute the "left index" of a <i>var </i>expres-<br>sion. It is defined as</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:527"><nobr><span class="ft6"><i>Y</i></span></nobr></DIV>
<DIV style="position:absolute;top:136;left:539"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:160;left:539"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:168;left:539"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:176;left:539"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:185;left:539"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:144;left:549"><nobr><span class="ft4"> <i>f</i>.<i>b</i>.<i>l</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:556"><nobr><span class="ft4">match <i>b </i>with</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:567"><nobr><span class="ft6"><i>bnd</i>{ } </span></nobr></DIV>
<DIV style="position:absolute;top:192;left:570"><nobr><span class="ft3">1 + <i>f subst</i>{<i>b</i>; <i>mk term</i>{<i>l</i>; 0}} (<i>l </i>+ 1)</span></nobr></DIV>
<DIV style="position:absolute;top:206;left:560"><nobr><span class="ft4">| <i>mk term l </i>;</span></nobr></DIV>
<DIV style="position:absolute;top:206;left:649"><nobr><span class="ft4"> <i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:136;left:776"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:160;left:776"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:168;left:776"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:176;left:776"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:185;left:776"><nobr><span class="ft4"> <i>t </i>0</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:497"><nobr><span class="ft13">In effect, this recursive function substitutes <i>mk term</i>{0; 0}<br>for the first binding of <i>t </i>, <i>mk term</i>{1; 0} for the second one,<br><i>mk term</i>{2; 0} for the next one and so forth. Once all the binders<br>are stripped and a <i>mk term</i>{<i>l</i>; 0} is exposed, <i>l </i>is the index<br>we were looking for. Note that here we intentionally supply<br><i>mk term </i>with an argument of a "wrong" type (N instead of<br>Op); we could have avoided this, but then the definition would<br>have been significantly more complicated.</span></nobr></DIV>
<DIV style="position:absolute;top:356;left:497"><nobr><span class="ft3">As expected, we derive that</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:585"><nobr><span class="ft4"><i>l</i>, <i>r </i> N.(<i>left</i>{<i>var</i>{<i>l</i>; <i>r</i>}}  <i>l</i>).</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:497"><nobr><span class="ft13"><i>right</i>{<i>t </i>} computes the "right index" of a <i>var </i>expression. It<br>is trivial to define in terms of the previous two operators:<br><i>right</i>{<i>t </i>} := <i>bdepth</i>{<i>t </i>} - <i>left</i>{<i>t </i>} - 1.</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:497"><nobr><span class="ft6"><i>get op</i>{<i>t </i>; <i>op</i>} is an operation such that</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:531"><nobr><span class="ft4"><i>n </i> N. <i>get op mk bterm</i>{<i>n</i>; <i>op</i>; <i>ts</i>} ; <i>op </i> <i>op </i>,</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:556"><nobr><span class="ft4"><i>l</i>, <i>r </i> N. (<i>get op</i>{<i>var</i>{<i>i</i>; <i>j</i>} ; <i>op</i>}  <i>op </i>.</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:497"><nobr><span class="ft3">Its definition is similar to that of <i>left</i>{}.</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:497"><nobr><span class="ft13"><i>subterms</i>{<i>t </i>} is designed to recover the last argument of a<br><i>mk bterm </i>expression. The definition is rather technical and<br>complicated, so we omit it; see <A href="3.html#11">[NKYH05, </a>Appendix C] for<br>details. The main property of the <i>subterms </i>operation that we<br>derive is</span></nobr></DIV>
<DIV style="position:absolute;top:621;left:511"><nobr><span class="ft4"><i>n </i> N.<i>btl </i> List. <i>subterms</i>{<i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>btl</i>}} </span></nobr></DIV>
<DIV style="position:absolute;top:640;left:629"><nobr><span class="ft6"><i>map </i><i>b</i>.<i>vbnd</i>{<i>n</i>; v.<i>vsubst</i>{<i>b</i>; v}} <i>btl</i></span></nobr></DIV>
<DIV style="position:absolute;top:663;left:497"><nobr><span class="ft13">The right-hand side of this equivalence is not quite the plain<br>"<i>btl</i>" that one might have hoped to see here. However, when<br><i>btl </i>is a list of bterms with binding depths at least <i>n</i>, which is<br>necessarily the case for any well-formed <i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>btl</i>},<br>equivalence <A href="3.html#6">(8) </a>would allow simplifying this right-hand side to<br>the desired <i>btl</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:477"><nobr><span class="ft11"><b>4.5</b></span></nobr></DIV>
<DIV style="position:absolute;top:768;left:508"><nobr><span class="ft11"><b>Operators</b></span></nobr></DIV>
<DIV style="position:absolute;top:788;left:477"><nobr><span class="ft13">For this basic theory the exact representation details for operators<br>are not essential and we define the type of operators Op abstractly.<br>We only require that operators have decidable equality and that<br>there exist a function of the type Op  N List that computes<br>operators' shapes.</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:495"><nobr><span class="ft3">Using this shape function and the <i>bdepth </i>function from Sec-</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:477"><nobr><span class="ft13">tion <A href="3.html#7">4.4, </a>it is trivial to formalize the "<i>ts is compatible with op at<br>depth n</i>" predicate of Definition <A href="3.html#5">4. </a>We denote this predicate as<br><i>shape compat</i>{<i>n</i>; <i>op</i>; <i>ts</i>} and define it as</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:497"><nobr><span class="ft4">|<i>shape</i>{<i>op</i>}| = |<i>btl</i>|</span></nobr></DIV>
<DIV style="position:absolute;top:956;left:511"><nobr><span class="ft4"><i>i </i> 1..|<i>btl</i>|.<i>bdepth</i>{<i>nth</i>{<i>btl</i>; <i>i</i>}} = <i>n </i>+ <i>nth</i>{<i>shape</i>{<i>op</i>}; <i>i</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:477"><nobr><span class="ft11"><b>4.6</b></span></nobr></DIV>
<DIV style="position:absolute;top:987;left:508"><nobr><span class="ft11"><b>The Type of Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:477"><nobr><span class="ft13">In this section we will define the type of terms (<i>i.e. </i>well-formed<br>bterms), Term, as the type of all terms that can be constructed by<br>the de Bruijn constructors from Section <A href="3.html#7">4.4. </a>That is, the Term type<br>contains all expressions of the forms:</span></nobr></DIV>
<DIV style="position:absolute;top:1074;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:1076;left:497"><nobr><span class="ft6"><i>var</i>{<i>i </i>; <i>j </i>} for all natural numbers <i>i</i>, <i>j </i>; or</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:456"><nobr><span class="ft3">8</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
	.ft28{font-size:9px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1263" src="3008.png" alt="background image">
<DIV style="position:absolute;top:109;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:102"><nobr><span class="ft13"><i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>ts</i>} for any natural number <i>n</i>, operator <i>op</i>, and<br>list of terms <i>ts </i>that is compatible with <i>op </i>at depth <i>n</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:148;left:101"><nobr><span class="ft3">The Term type is defined as a fixpoint of the following function</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:83"><nobr><span class="ft3">from types to types:</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:159"><nobr><span class="ft6"><i>Iter</i>(<i>X </i>) := Image(<i>dom</i>(<i>X </i>); <i>x </i>.<i>mk</i>(<i>x </i>)),</span></nobr></DIV>
<DIV style="position:absolute;top:208;left:83"><nobr><span class="ft3">where</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:228;left:102"><nobr><span class="ft13">Image is a type constructor such that Image(<i>T </i>; <i>x</i>. <i>f </i>[<i>x</i>]) is the<br>type of all the <i>f </i>[<i>t </i>] for <i>t </i> <i>T </i>(for it to be well-formed, <i>T </i>must<br>be a well-formed type and <i>f </i>must not have any free variables<br>except for <i>x</i>);</span></nobr></DIV>
<DIV style="position:absolute;top:293;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:102"><nobr><span class="ft6"><i>dom</i>(<i>X </i>) is a type defined as</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:102"><nobr><span class="ft4">(N×N)+ <i>n</i>:N×<i>op</i>:Op×{<i>ts</i>:<i>X </i>List | <i>shape compat</i>{<i>n</i>; <i>op</i>; <i>ts</i>}} ;</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:102"><nobr><span class="ft13">and <i>mk</i>(<i>x</i>) (where <i>x </i>is presumably a member of the type<br><i>dom</i>(<i>X </i>)) is defined as</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:161"><nobr><span class="ft4">match <i>x </i>with</span></nobr></DIV>
<DIV style="position:absolute;top:393;left:172"><nobr><span class="ft4">inl (<i>i</i>, <i>j</i>)  <i>var</i>{<i>i</i>; <i>j</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:165"><nobr><span class="ft4">| inr (<i>n</i>, <i>op</i>, <i>ts</i>)  <i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>ts</i>} .</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:101"><nobr><span class="ft3">The fixpoint of <i>Iter </i>is reached by defining</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:102"><nobr><span class="ft3">Term</span></nobr></DIV>
<DIV style="position:absolute;top:463;left:131"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:141"><nobr><span class="ft4">:= <i>Void </i>(an empty type)</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:102"><nobr><span class="ft3">Term</span></nobr></DIV>
<DIV style="position:absolute;top:484;left:131"><nobr><span class="ft18"><i>n</i>+1</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:156"><nobr><span class="ft4">:= <i>Iter</i>(Term</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:226"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:478;left:233"><nobr><span class="ft4">)</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:102"><nobr><span class="ft3">Term :=</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:152"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:522;left:166"><nobr><span class="ft17">N</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:176"><nobr><span class="ft3">Term</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:205"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:542;left:101"><nobr><span class="ft3">We derive the intended introduction rules for the Term type:</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:217"><nobr><span class="ft6"><i>i </i> N</span></nobr></DIV>
<DIV style="position:absolute;top:562;left:277"><nobr><span class="ft6"><i>j </i> N</span></nobr></DIV>
<DIV style="position:absolute;top:581;left:217"><nobr><span class="ft6"><i>var</i>{<i>i </i>; <i>j </i>}  Term</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:83"><nobr><span class="ft3">and</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:94"><nobr><span class="ft6"><i>n </i> N</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:141"><nobr><span class="ft6"><i>op </i> Op</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:200"><nobr><span class="ft6"><i>ts </i> Term List</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:297"><nobr><span class="ft6"><i>shape compat</i>{<i>n</i>; <i>op</i>; <i>ts</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:186"><nobr><span class="ft6"><i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>ts</i>}  Term</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:428"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:101"><nobr><span class="ft3">Also, the structural induction principle is derived for the Term</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:83"><nobr><span class="ft13">type. Namely, we show that to prove that some property <i>P</i>[<i>t </i>] holds<br>for any term <i>t </i>, it is sufficient to prove</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:709;left:102"><nobr><span class="ft13">(Base case) <i>P </i>holds for all variables, that is, <i>P</i>[<i>var</i>{<i>i </i>; <i>j </i>}] holds<br>for all natural numbers <i>i </i>and <i>j </i>;</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:91"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:102"><nobr><span class="ft13">(Induction step) <i>P</i>[<i>mk bterm</i>{<i>n</i>; <i>op</i>; <i>ts</i>}] is true for any natural<br>number <i>n</i>, any operator <i>op</i>, and any list of terms <i>ts </i>that is<br>compatible with <i>op </i>at depth <i>n</i>, provided <i>P</i>[<i>t </i>] is true for any<br>element <i>t </i>of the list <i>ts</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:101"><nobr><span class="ft3">Note that the type of "terms over <i>n </i>variables" (where <i>n </i>= 0 cor-</span></nobr></DIV>
<DIV style="position:absolute;top:827;left:83"><nobr><span class="ft22">responds to closed terms) may be trivially defined using the Term<br>type and the "subset" type constructor -- {<i>t </i>: Term | <i>bdepth</i>{<i>t </i>} =<br><i>n</i>}.</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:83"><nobr><span class="ft5"><b>5.</b></span></nobr></DIV>
<DIV style="position:absolute;top:889;left:112"><nobr><span class="ft5"><b>Conclusions and Future Work</b></span></nobr></DIV>
<DIV style="position:absolute;top:912;left:83"><nobr><span class="ft19">In Sections <A href="3.html#4">3 </a>and <A href="3.html#5">4 </a>we have presented a basic theory of syntax<br>that is fully implemented in a theorem prover. As we mentioned in<br>the introduction, the approach is both natural and expressive, and<br>provides a foundation for reflective reasoning about classes of lan-<br>guages and logics. However, we consider this theory to be only<br>the first step towards building a user-accessible uniform reflection<br>framework and a user-accessible uniform framework for program-<br>ming language reasoning and experimentation, where tasks similar<br>to the ones presented in the P</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:243"><nobr><span class="ft10">OPL</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:265"><nobr><span class="ft3">M</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:278"><nobr><span class="ft10">ARK</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:306"><nobr><span class="ft3">challenge <A href="3.html#9">[ABF</a></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:392"><nobr><span class="ft17"><A href="3.html#9">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:401"><nobr><span class="ft3"><A href="3.html#9">05] </a>can</span></nobr></DIV>
<DIV style="position:absolute;top:1047;left:83"><nobr><span class="ft13">be performed easily and naturally. In this section we provide an out-<br>line of our plans for building such frameworks on top of the basic<br>syntactic theory.</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:477"><nobr><span class="ft11"><b>5.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:111;left:508"><nobr><span class="ft11"><b>Higher-Level User Interface</b></span></nobr></DIV>
<DIV style="position:absolute;top:132;left:477"><nobr><span class="ft13">One obvious shortcoming of the theory presented in Sections <A href="3.html#4">3<br></a>and <A href="3.html#5">4 </a>is that it provides only the basic low-level operations such<br>as <i>bnd</i>, <i>var</i>, <i>subterms</i>, <i>etc</i>. It presents a very low-level account of<br>syntax in a way that would often fail to abstract away the details<br>irrelevant to the user.</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:495"><nobr><span class="ft3">To address this problem we are planning to provide user in-</span></nobr></DIV>
<DIV style="position:absolute;top:222;left:477"><nobr><span class="ft13">terface functionality capable of mapping the high-level concepts<br>to the low-level ones. In particular, we are going to provide an<br>interface that would allow instantiating general theorems to spe-<br>cific collections of operators and specific languages. Thus, the user<br>will be able to write something like "reflect language [<i>x</i>.·;<br><i>apply</i>{·; ·}]" and the system will create all the components outlined<br>in Example <A href="3.html#4">1:</a></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:497"><nobr><span class="ft3">It will create a definition for the type</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:594"><nobr><span class="ft3">Language[<i>x</i>.·; <i>apply</i>{·; ·}]</span></nobr></DIV>
<DIV style="position:absolute;top:382;left:497"><nobr><span class="ft13">of reflected lambda-terms (where Language[<i>l</i>] is a general def-<br>inition of a language over a list of operators <i>l</i>);</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:497"><nobr><span class="ft3">It will state and derive the introduction rules for this type;</span></nobr></DIV>
<DIV style="position:absolute;top:436;left:486"><nobr><span class="ft17">·</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:497"><nobr><span class="ft13">It will state and derive the elimination rule for this type (the<br>induction principle).</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:477"><nobr><span class="ft13">Moreover, we are planning to support even more complicated lan-<br>guage declarations, such as</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:510"><nobr><span class="ft6"><i>t </i>:= int | <i>t </i> <i>t </i>;</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:624"><nobr><span class="ft6"><i>e </i>:= v | <i>x </i>: <i>t</i>.<i>e</i>[<i>x </i>] | <i>apply</i>{<i>e</i>; <i>e</i>}</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:477"><nobr><span class="ft13">that would cause the system to create mutually recursive type<br>definitions and appropriate rules.</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:495"><nobr><span class="ft3">Finally, we are also planning to support "pattern bindings" that</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:477"><nobr><span class="ft19">are needed for a natural encoding of ML-like pattern matching<br>(such as the one sketched in the P</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:654"><nobr><span class="ft10">OPL</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:676"><nobr><span class="ft3">M</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:689"><nobr><span class="ft10">ARK</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:716"><nobr><span class="ft3">challenge <A href="3.html#9">[ABF</a></span></nobr></DIV>
<DIV style="position:absolute;top:594;left:801"><nobr><span class="ft17"><A href="3.html#9">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:599;left:810"><nobr><span class="ft3"><A href="3.html#9">05]).</a></span></nobr></DIV>
<DIV style="position:absolute;top:614;left:477"><nobr><span class="ft13">As far as the underlying theory goes, we believe that the mecha-<br>nisms very similar to the "vector bindings" presented in Section <A href="3.html#6">4.3<br></a>will be sufficient here.</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:477"><nobr><span class="ft11"><b>5.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:674;left:508"><nobr><span class="ft11"><b>"Dereferencing" Quoted Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:694;left:477"><nobr><span class="ft13">As in Barzilay's work, the quoted operator approach makes it easy<br>to define the "unquoting" (or "dereferencing") operator [[]]</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:792"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:709;left:812"><nobr><span class="ft3">. If <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:724;left:477"><nobr><span class="ft3">is a syntactic term, then [[<i>t </i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:728;left:632"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:724;left:656"><nobr><span class="ft3">is the value represented by <i>t </i>. By</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:477"><nobr><span class="ft3">definition,</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:520"><nobr><span class="ft4">[[<i>op</i>{<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:767;left:549"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:555"><nobr><span class="ft4">; . . . ; <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:766;left:591"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:598"><nobr><span class="ft4">}]]</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:610"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:633"><nobr><span class="ft4">= <i>op</i>{[[<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:767;left:676"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:761;left:683"><nobr><span class="ft4">]]</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:689"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:709"><nobr><span class="ft4">; . . . ; [[<i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:766;left:751"><nobr><span class="ft18"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:758"><nobr><span class="ft4">]]</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:765"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:785"><nobr><span class="ft4">}.</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:477"><nobr><span class="ft3">For instance, [[2  3]]</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:588"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:786;left:612"><nobr><span class="ft3">is 2  3 (<i>i.e. </i>6).</span></nobr></DIV>
<DIV style="position:absolute;top:801;left:495"><nobr><span class="ft3">In order to define unquoting on terms with bindings, we need to</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:477"><nobr><span class="ft3">introduce the "guard" operation</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:673"><nobr><span class="ft3">such that [[ <i>t </i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:757"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:781"><nobr><span class="ft3">is <i>t </i>for an</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:477"><nobr><span class="ft3">arbitrary expression <i>t </i>. Then [[]]</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:644"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:831;left:667"><nobr><span class="ft3">can be defined as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:477"><nobr><span class="ft4">[[<i>op</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:509"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:516"><nobr><span class="ft4">, · · ·, <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:552"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:853;left:558"><nobr><span class="ft4">.<i>t</i>[<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:578"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:584"><nobr><span class="ft4">; . . . ; <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:623"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:853;left:629"><nobr><span class="ft4">]; · · · ;<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:672"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:678"><nobr><span class="ft4">, · · ·, <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:713"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:853;left:718"><nobr><span class="ft4">.<i>s</i>[<i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:738"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:745"><nobr><span class="ft4">; . . . ; <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:860;left:782"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:853;left:787"><nobr><span class="ft4">]}]]</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:803"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:853;left:827"><nobr><span class="ft4">=</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:491"><nobr><span class="ft6"><i>op</i>{<i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:875;left:516"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:522"><nobr><span class="ft4">, · · · , <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:874;left:563"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:868;left:569"><nobr><span class="ft4">.[[<i>t</i>[ <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:875;left:602"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:616"><nobr><span class="ft4">; . . . ; <i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:874;left:660"><nobr><span class="ft18"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:868;left:673"><nobr><span class="ft4">]]]</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:684"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:868;left:704"><nobr><span class="ft4">;</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:512"><nobr><span class="ft4">· · · ;</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:510"><nobr><span class="ft6"><i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:904;left:515"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:522"><nobr><span class="ft4">, · · · , <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:904;left:561"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:898;left:566"><nobr><span class="ft4">.[[<i>s</i>[ <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:904;left:599"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:613"><nobr><span class="ft4">; . . . ; <i>z</i></span></nobr></DIV>
<DIV style="position:absolute;top:904;left:656"><nobr><span class="ft18"><i>l</i></span></nobr></DIV>
<DIV style="position:absolute;top:898;left:667"><nobr><span class="ft4">]]]</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:678"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:898;left:698"><nobr><span class="ft4">}.</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:477"><nobr><span class="ft3">For example, [[<i>x</i>.2 <i>x</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:610"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:921;left:636"><nobr><span class="ft4">= <i>x</i>.[[2  <i>x </i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:723"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:921;left:749"><nobr><span class="ft4">= <i>x</i>.[[2]]</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:805"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:921;left:829"><nobr><span class="ft4"></span></nobr></DIV>
<DIV style="position:absolute;top:936;left:477"><nobr><span class="ft4">[[ <i>x </i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:510"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:936;left:533"><nobr><span class="ft4">= <i>x</i>.2  <i>x</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:953;left:495"><nobr><span class="ft3">The unquote operation establishes the identity between the orig-</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:477"><nobr><span class="ft3">inal syntax and the reflected syntax, making it a "true" reflection.</span></nobr></DIV>
<DIV style="position:absolute;top:983;left:495"><nobr><span class="ft3">Note that the type theory (which ensures, in particular, that</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:477"><nobr><span class="ft13">only terminating functions may be shown to belong to a function<br>type) would keep the [[ ]]</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:619"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:644"><nobr><span class="ft3">operation from introducing logical</span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:477"><nobr><span class="ft3">paradox<A href="3.html#8">es.</a></span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:535"><nobr><span class="ft9"><A href="3.html#8">3</a></span></nobr></DIV>
<DIV style="position:absolute;top:1061;left:477"><nobr><span class="ft10">3</span></nobr></DIV>
<DIV style="position:absolute;top:1064;left:485"><nobr><span class="ft9">This is, obviously, not a proper argument. While a proper argument can be</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:477"><nobr><span class="ft9">made here, it is outside of the scope of this particular paper.</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:456"><nobr><span class="ft3">9</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
	.ft29{font-size:8px;font-family:Times;color:#000000;}
	.ft30{font-size:9px;line-height:11px;font-family:Times;color:#000000;}
	.ft31{font-size:9px;line-height:15px;font-family:Times;color:#000000;}
	.ft32{font-size:9px;line-height:14px;font-family:Times;color:#000000;}
	.ft33{font-size:9px;line-height:14px;font-family:Times;color:#000000;}
	.ft34{font-size:9px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1263" src="3009.png" alt="background image">
<DIV style="position:absolute;top:111;left:101"><nobr><span class="ft3">Also, since the notion of the quoted operators is fully open-</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:83"><nobr><span class="ft13">ended, each new language added to the system will automatically<br>get to use the [[ ]]</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:177"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:201"><nobr><span class="ft3">operation for all its newly introduced opera-</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:83"><nobr><span class="ft3">tors.</span></nobr></DIV>
<DIV style="position:absolute;top:181;left:83"><nobr><span class="ft11"><b>5.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:181;left:113"><nobr><span class="ft11"><b>Logical Reflection</b></span></nobr></DIV>
<DIV style="position:absolute;top:202;left:83"><nobr><span class="ft13">After defining syntactic reflection, it is easy to define <i>logical reflec-<br>tion</i>. If we consider the proof system open-ended, then the logical<br>reflection is trivial -- when <i>P </i>is a quotation of a proposition, we<br>can regard "[[<i>P</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:174"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:247;left:194"><nobr><span class="ft3">" as meaning " <i>P </i>is true". The normal modal</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:83"><nobr><span class="ft3">rules for the [[]]</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:169"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:262;left:194"><nobr><span class="ft3">modality are trivially derivable. For example</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:83"><nobr><span class="ft6"><i>modus ponens</i></span></nobr></DIV>
<DIV style="position:absolute;top:296;left:155"><nobr><span class="ft4">[[<i>P </i> <i>Q</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:209"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:296;left:235"><nobr><span class="ft4"> [[<i>P</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:279"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:296;left:305"><nobr><span class="ft4"> [[<i>Q</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:349"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:321;left:83"><nobr><span class="ft3">is trivially true because if we evaluate the first [[]]</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:347"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:321;left:370"><nobr><span class="ft3">(remember,</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:154"><nobr><span class="ft4">[[<i>P </i> <i>Q</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:208"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:342;left:231"><nobr><span class="ft4">= [[<i>P</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:275"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:342;left:301"><nobr><span class="ft4"> [[<i>Q</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:345"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:83"><nobr><span class="ft3">by definition of [[]]</span></nobr></DIV>
<DIV style="position:absolute;top:370;left:183"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:202"><nobr><span class="ft3">), we get an obvious tautology</span></nobr></DIV>
<DIV style="position:absolute;top:386;left:128"><nobr><span class="ft4">([[<i>P</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:157"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:386;left:183"><nobr><span class="ft4"> [[<i>Q</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:228"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:386;left:247"><nobr><span class="ft4">)  [[<i>P</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:302"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:386;left:328"><nobr><span class="ft4"> [[<i>Q</i>]]</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:373"><nobr><span class="ft28"><b>unq</b></span></nobr></DIV>
<DIV style="position:absolute;top:386;left:393"><nobr><span class="ft4">.</span></nobr></DIV>
<DIV style="position:absolute;top:410;left:101"><nobr><span class="ft3">In order to consider a closed proof system (in other words, if</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:83"><nobr><span class="ft13">we want to be able to do induction over derivations), we would<br>need to define a provability predicate for that system. We are<br>planning to provide user interface functionality that would allow<br>users to describe a set of proof rules and the system would generate<br>appropriate proof predicate definitions and derive appropriate rules<br>(in a style similar to the one outlined in Section <A href="3.html#8">5.1 </a>for the case of<br>language descriptions).</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:83"><nobr><span class="ft5"><b>6.</b></span></nobr></DIV>
<DIV style="position:absolute;top:546;left:112"><nobr><span class="ft5"><b>Related Work</b></span></nobr></DIV>
<DIV style="position:absolute;top:568;left:83"><nobr><span class="ft13">In Section <A href="3.html#2">2 </a>we have already discussed a number of approaches<br>that we consider ourselves inheriting from. Here we would like to<br>revisit some of them and mention a few other related efforts.</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:101"><nobr><span class="ft3">Our work has a lot in common with the HOAS implemented in</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:83"><nobr><span class="ft13">Coq by Despeyroux and Hirschowitz <A href="3.html#10">[DH94]. </a>In both cases, the<br>more general space of terms (that include the exotic ones) is later<br>restricted in a recursive manner. In both cases, the higher-order<br>analogs of first-order de Bruijn operators are defined and used as a<br>part of the "well-formedness" specification for the terms. Despey-<br>roux and Hirschowitz use functions over infinite lists of variables<br>to define open terms, which is similar to our vector bindings.</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:101"><nobr><span class="ft3">There are a number of significant differences as well. Our ap-</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:83"><nobr><span class="ft13">proach is sufficiently syntactical, which allows eliminating all ex-<br>otic terms, even those that are extensionally equal to the well-<br>formed ones, while the more semantic approach of</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:401"><nobr><span class="ft3"><A href="3.html#10">[DH94,</a></span></nobr></DIV>
<DIV style="position:absolute;top:793;left:83"><nobr><span class="ft13"><A href="3.html#10">DFH95] </a>has to accept such exotic terms (their solution to this prob-<br>lem is to consider an object term to be represented by the whole<br><i>equivalence class </i>of extensionally equal terms); more generally<br>while <A href="3.html#10">[DH94] </a>states that "this problem of extensionality is recur-<br>rent all over our work", most of our lemmas establish identity and<br>not just equality, thus avoiding most of the issues of extensional<br>equality. In our implementation, the substitution on object terms is<br>mapped directly to -reduction, while Despeyroux <i>et al</i>. <A href="3.html#10">[DFH95]<br></a>have to define it recursively. In addition, we provide a <i>uniform </i>ap-<br>proach to both free and bound variables that naturally extends to<br>variable-length "vector" bindings.</span></nobr></DIV>
<DIV style="position:absolute;top:957;left:101"><nobr><span class="ft3">While our approach is quite different from the modal -calculus</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:83"><nobr><span class="ft13">one <A href="3.html#10">[DPS97, DL99, DL01], </a>there are some similarities in the in-<br>tuition behind it. Despeyroux <i>et al</i>. <A href="3.html#10">[DPS97] </a>says "Intuitively, we<br>interpret</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:144"><nobr><span class="ft6"><i>B </i>as the type of <i>closed </i>objects of type <i>B</i>. We can iter-</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:83"><nobr><span class="ft23">ate or distinguish cases over closed objects, since all constructors<br>are statically known and can be provided for." The intuition be-<br>hind our approach is in part based on the canonical model of the<br>NuPRL type theory <A href="3.html#10">[All87a, All87b], </a>where <i>each </i>type is mapped<br>to an equivalence relations over the closed terms of that type.</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:495"><nobr><span class="ft3">Gordon and Melham <A href="3.html#10">[GM96] </a>define the type of -terms as a</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:477"><nobr><span class="ft13">quotient of the type of terms with concrete binding variables over<br>-equivalence. Michael Norrish <A href="3.html#11">[Nor04] </a>builds upon this work by<br>replacing certain variable "freshness" requirements with variable<br>"swapping". This approach has a number of attractive properties;<br>however, we believe that the level of abstraction provided by the<br>HOAS-style approaches makes the HOAS style more convenient<br>and accessible.</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:495"><nobr><span class="ft3">Ambler, Crole, and Momigliano <A href="3.html#9">[ACM02] </a>have combined the</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:477"><nobr><span class="ft13">HOAS with the induction principle using an approach which in<br>some sense is opposite to ours. Namely, they define the HOAS<br>operators on top of the de Bruijn definition of terms using <i>higher<br>order pattern matching</i>. In a later work <A href="3.html#9">[ACM03] </a>they have de-<br>scribed the notion of "<i>terms-in-infinite-context</i>" which is quite sim-<br>ilar to our approach to vector binding. While our vector bindings<br>presented in Section <A href="3.html#6">4.3 </a>are finite length, the exact same approach<br>would work for the infinite-length "vectors" as well.</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:477"><nobr><span class="ft5"><b>Acknowledgments</b></span></nobr></DIV>
<DIV style="position:absolute;top:407;left:477"><nobr><span class="ft13">The authors are grateful to Eli Barzilay whose ideas were an in-<br>spiration for some of the work that lead to this paper. We are also<br>grateful for his comments on an early draft of this paper.</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:495"><nobr><span class="ft3">We are grateful to the anonymous reviewers for their very thor-</span></nobr></DIV>
<DIV style="position:absolute;top:466;left:477"><nobr><span class="ft3">ough and fair feedback and many helpful suggestions.</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:477"><nobr><span class="ft5"><b>References</b></span></nobr></DIV>
<DIV style="position:absolute;top:522;left:477"><nobr><span class="ft9">[AA99]</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:544"><nobr><span class="ft26">Eric Aaron and Stuart Allen. Justifying calculational logic<br>by a conventional metalinguistic semantics. Technical Report<br>TR99-1771, Cornell University, Ithaca, New York, September<br>1999.</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:477"><nobr><span class="ft9">[ABF</span></nobr></DIV>
<DIV style="position:absolute;top:577;left:505"><nobr><span class="ft8">+</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:513"><nobr><span class="ft9">05]</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:544"><nobr><span class="ft27">Brian E. Aydemir, Aaron Bohannon, Matthew Fairbairn,<br>J. Nathan Foster, Benjamin C. Pierce, Peter Sewell, Dimitrios<br>Vytiniotis, Geoffrey Washburn, Stephanie Weirich, and Steve<br>Zdancewic. Mechanized metatheory for the masses: The<br>POPLmark challenge. Available from <A href="http://www.cis.upenn.edu/group/proj/plclub/mmm/">http://www.cis.<br>upenn.edu/group/proj/plclub/mmm/, </a>2005.</span></nobr></DIV>
<DIV style="position:absolute;top:669;left:477"><nobr><span class="ft9">[AC92]</span></nobr></DIV>
<DIV style="position:absolute;top:669;left:544"><nobr><span class="ft31">William Aitken and Robert L. Constable. Reflecting on<br>NuPRL : Lessons 1­4. Technical report, Cornell University,<br>Computer Science Department, Ithaca, NY, 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:477"><nobr><span class="ft9">[ACE</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:505"><nobr><span class="ft8">+</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:514"><nobr><span class="ft9">00]</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:544"><nobr><span class="ft32">Stuart Allen, Robert Constable, Richard Eaton, Christoph<br>Kreitz, and Lori Lorigo. The NuPRL open logical envi-<br>ronment. In David McAllester, editor, <i>Proceedings of the<br>17</i></span></nobr></DIV>
<DIV style="position:absolute;top:753;left:556"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:757;left:569"><nobr><span class="ft18"><i>International Conference on Automated Deduction</i>, vol-</span></nobr></DIV>
<DIV style="position:absolute;top:770;left:544"><nobr><span class="ft26">ume 1831 of <i>Lecture Notes in Artificial Intelligence</i>, pages<br>170­176. Springer Verlag, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:477"><nobr><span class="ft9">[ACHA90]</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:544"><nobr><span class="ft33">Stuart F. Allen, Robert L. Constable, Douglas J. Howe,<br>and William Aitken. The semantics of reflected proof. In<br><i>Proceedings of the 5</i></span></nobr></DIV>
<DIV style="position:absolute;top:828;left:645"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:831;left:660"><nobr><span class="ft18"><i>Symposium on Logic in Computer</i></span></nobr></DIV>
<DIV style="position:absolute;top:844;left:544"><nobr><span class="ft26"><i>Science</i>, pages 95­197. IEEE Computer Society Press, June<br>1990.</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:477"><nobr><span class="ft9">[ACM02]</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:544"><nobr><span class="ft26">Simon Ambler, Roy L. Crole, and Alberto Momigliano.<br>Combining higher order abstract syntax with tactical theorem<br>proving and (co)induction. In <i>TPHOLs '02: Proceedings<br>of the 15th International Conference on Theorem Proving<br>in Higher Order Logics</i>, pages 13­30, London, UK, 2002.<br>Springer-Verlag.</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:477"><nobr><span class="ft9">[ACM03]</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:544"><nobr><span class="ft34">S. J. Ambler, R. L. Crole, and Alberto Momigliano. A<br>definitional approach to primitive recursion over higher<br>order abstract syntax. In <i>Proceedings of the 2003 workshop<br>on Mechanized reasoning about languages with variable<br>binding</i>, pages 1­11. ACM Press, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:477"><nobr><span class="ft9">[ACU93]</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:544"><nobr><span class="ft26">William Aitken, Robert L. Constable, and Judith Underwood.<br>Metalogical Frameworks II: Using reflected decision pro-<br>cedures. <i>Journal of Automated Reasoning</i>, 22(2):171­221,<br>1993.</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:452"><nobr><span class="ft3">10</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1263" src="3010.png" alt="background image">
<DIV style="position:absolute;top:112;left:83"><nobr><span class="ft9">[All87a]</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:149"><nobr><span class="ft33">Stuart F. Allen. A Non-type-theoretic Definition of Martin-<br>L¨of's Types. In D. Gries, editor, <i>Proceedings of the 2</i></span></nobr></DIV>
<DIV style="position:absolute;top:123;left:401"><nobr><span class="ft29"><i>nd</i></span></nobr></DIV>
<DIV style="position:absolute;top:127;left:416"><nobr><span class="ft18"><i>IEEE</i></span></nobr></DIV>
<DIV style="position:absolute;top:140;left:149"><nobr><span class="ft26"><i>Symposium on Logic in Computer Science</i>, pages 215­224.<br>IEEE Computer Society Press, June 1987.</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:83"><nobr><span class="ft9">[All87b]</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:149"><nobr><span class="ft34">Stuart F. Allen. <i>A Non-Type-Theoretic Semantics for Type-<br>Theoretic Language</i>. PhD thesis, Cornell University, 1987.</span></nobr></DIV>
<DIV style="position:absolute;top:206;left:83"><nobr><span class="ft9">[Art99]</span></nobr></DIV>
<DIV style="position:absolute;top:206;left:149"><nobr><span class="ft26">Sergei Artemov. On explicit reflection in theorem proving<br>and formal verification. In Ganzinger <A href="3.html#10">[Gan99], </a>pages 267­<br>281.</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:83"><nobr><span class="ft9">[Art04]</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:149"><nobr><span class="ft9">Sergei Artemov.</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:241"><nobr><span class="ft9">Evidence-based common knowledge.</span></nobr></DIV>
<DIV style="position:absolute;top:266;left:149"><nobr><span class="ft26">Technical Report TR-2004018, CUNY Ph.D. Program in<br>Computer Science Technical Reports, November 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:83"><nobr><span class="ft9">[BA02]</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:149"><nobr><span class="ft32">Eli Barzilay and Stuart Allen. Reflecting higher-order abstract<br>syntax in NuPRL. In Victor A. Carre~no, C´ezar A. Mu~noz,<br>and Sophi`ene Tahar, editors, <i>Theorem Proving in Higher<br>Order Logics; Track B Proceedings of the 15</i></span></nobr></DIV>
<DIV style="position:absolute;top:337;left:365"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:340;left:378"><nobr><span class="ft18"><i>International</i></span></nobr></DIV>
<DIV style="position:absolute;top:353;left:149"><nobr><span class="ft26"><i>Conference on Theorem Proving in Higher Order Logics<br>(TPHOLs 2002), Hampton, VA, August 2002</i>, pages 23­32.<br>National Aeronautics and Space Administration, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:83"><nobr><span class="ft9">[BAC03]</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:149"><nobr><span class="ft26">Eli Barzilay, Stuart Allen, and Robert Constable. Practical<br>reflection in NuPRL. Short paper presented at 18th Annual<br>IEEE Symposium on Logic in Computer Science, June 22­<br>25, Ottawa, Canada, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:83"><nobr><span class="ft9">[Bar01]</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:149"><nobr><span class="ft26">Eli Barzilay. Quotation and reflection in NuPRL and Scheme.<br>Technical Report TR2001-1832, Cornell University, Ithaca,<br>New York, January 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:83"><nobr><span class="ft9">[Bar05]</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:149"><nobr><span class="ft26">Eli Barzilay. <i>Implementing Reflection in </i>NuPRL. PhD thesis,<br>Cornell University, 2005. In preparation.</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:83"><nobr><span class="ft9">[CAB</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:112"><nobr><span class="ft8">+</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:120"><nobr><span class="ft9">86]</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:149"><nobr><span class="ft26">Robert L. Constable, Stuart F. Allen, H. M. Bromley, W. R.<br>Cleaveland, J. F. Cremer, R. W. Harper, Douglas J. Howe,<br>T. B. Knoblock, N. P. Mendler, P. Panangaden, James T.<br>Sasaki, and Scott F. Smith. <i>Implementing Mathematics with<br>the </i>NuPRL <i>Proof Development System</i>. Prentice-Hall, NJ,<br>1986.</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:83"><nobr><span class="ft9">[CFW04]</span></nobr></DIV>
<DIV style="position:absolute;top:625;left:149"><nobr><span class="ft26">Lu´is Crus-Filipe and Freek Weidijk. Hierarchical reflection.<br>In Slind et al. <A href="3.html#11">[SBG04], </a>pages 66­81.</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:83"><nobr><span class="ft9">[Con94]</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:149"><nobr><span class="ft26">Robert L. Constable. Using reflection to explain and enhance<br>type theory. In Helmut Schwichtenberg, editor, <i>Proof and<br>Computation</i>, volume 139 of <i>NATO Advanced Study Insti-<br>tute, International Summer School held in Marktoberdorf,<br>Germany, July 20-August 1, NATO Series F</i>, pages 65­100.<br>Springer, Berlin, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:83"><nobr><span class="ft9">[dB72]</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:149"><nobr><span class="ft26">N. G. de Bruijn. Lambda calculus notation with nameless<br>dummies, a tool for automatic formula manipulation, with<br>application to the Church-Rosser theorem. <i>Indagaciones<br>Mathematische</i>, 34:381­392, 1972. This also appeared in the<br>Proceedings of the Koninklijke Nederlandse Akademie van<br>Wetenschappen, Amsterdam, series A, 75, No. 5.</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:83"><nobr><span class="ft9">[DFH95]</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:149"><nobr><span class="ft26">Jo¨elle Despeyroux, Amy Felty, and Andr´e Hirschowitz.<br>Higher-order abstract syntax in Coq.</span></nobr></DIV>
<DIV style="position:absolute;top:845;left:348"><nobr><span class="ft9">In M. Dezani-</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:149"><nobr><span class="ft26">Ciancaglini and G. Plotkin, editors, <i>Proceedings of the<br>International Conference on Typed Lambda Calculus and<br>its Applications</i>, volume 902 of <i>Lecture Notes in Computer<br>Science</i>, pages 124­138. Springer-Verlag, April 1995. Also<br>appears as <A href="http://www.inria.fr/rrrt/rr-2556.html">INRIA research report RR-2556.</a></span></nobr></DIV>
<DIV style="position:absolute;top:932;left:83"><nobr><span class="ft9">[DH94]</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:149"><nobr><span class="ft26">Jo¨elle Despeyroux and Andr´e Hirschowitz. Higher-order<br>abstract syntax with induction in Coq.</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:355"><nobr><span class="ft9">In <i>LPAR '94:</i></span></nobr></DIV>
<DIV style="position:absolute;top:959;left:149"><nobr><span class="ft26"><i>Proceedings of the 5th International Conference on Logic<br>Programming and Automated Reasoning</i>, volume 822<br>of <i>Lecture Notes in Computer Science</i>, pages 159­173.<br>Springer-Verlag, 1994. Also appears as <A href="http://www.inria.fr/rrrt/rr-2292.html">INRIA research<br>report RR-2292.</a></span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:83"><nobr><span class="ft9">[DH95]</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:149"><nobr><span class="ft26">James Davis and Daniel Huttenlocher. Shared annotations for<br>cooperative learning. In <i>Proceedings of the ACM Conference<br>on Computer Supported Cooperative Learning</i>, September<br>1995.</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:477"><nobr><span class="ft9">[DL99]</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:544"><nobr><span class="ft34">Jo¨elle Despeyroux and Pierre Leleu. A modal lambda<br>calculus with iteration and case constructs. In T. Altenkirch,<br>W. Naraschewski, and B. Reus, editors, <i>Types for Proofs<br>and Programs: International Workshop, TYPES '98, Kloster<br>Irsee, Germany, March 1998</i>, volume 1657 of <i>Lecture Notes<br>in Computer Science</i>, pages 47­61, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:477"><nobr><span class="ft9">[DL01]</span></nobr></DIV>
<DIV style="position:absolute;top:199;left:544"><nobr><span class="ft34">Jo¨elle Despeyroux and Pierre Leleu. Recursion over objects<br>of functional type. <i>Mathematical Structures in Computer<br>Science</i>, 11(4):555­572, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:477"><nobr><span class="ft9">[DPS97]</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:544"><nobr><span class="ft26">Jo¨elle Despeyroux, Frank Pfenning, and Carsten Sch¨urmann.<br>Primitive recursion for higher­order abstract syntax. In<br>R. Hindley, editor, <i>Proceedings of the Third International<br>Conference on Typed Lambda Calculus and Applications<br>(TLCA'97)</i>, volume 1210 of <i>Lecture Notes in Computer<br>Science</i>, pages 147­163. Springer-Verlag, April 1997. An<br>extended version is available as <A href="http://reports-archive.adm.cs.cmu.edu/anon/1996/CMU-CS-96-172.ps.gz">Technical Report CMU-CS-<br>96-172, </a>Carnegie Mellon University.</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:477"><nobr><span class="ft9">[EM71]</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:544"><nobr><span class="ft9">Andrzej Ehrenfeucht and Jan Mycielski.</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:756"><nobr><span class="ft9">Abbreviating</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:544"><nobr><span class="ft34">proofs by adding new axioms. <i>Bulletin of the American<br>Mathematical Society</i>, 77:366­367, 1971.</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:477"><nobr><span class="ft9">[F</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:488"><nobr><span class="ft8">+</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:497"><nobr><span class="ft9">86]</span></nobr></DIV>
<DIV style="position:absolute;top:405;left:544"><nobr><span class="ft34">Solomon Feferman et al., editors. <i>Kurt G¨odel Collected<br>Works</i>, volume 1.</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:646"><nobr><span class="ft9">Oxford University Press, Oxford,</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:544"><nobr><span class="ft9">Clarendon Press, New York, 1986.</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:477"><nobr><span class="ft9">[FPT99]</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:544"><nobr><span class="ft26">Marcelo Fiore, Gordon Plotkin, and Daniele Turi. Abstract<br>syntax and variable binding. In <i>Proceedings of 14</i></span></nobr></DIV>
<DIV style="position:absolute;top:462;left:790"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:465;left:804"><nobr><span class="ft18"><i>IEEE</i></span></nobr></DIV>
<DIV style="position:absolute;top:479;left:544"><nobr><span class="ft26"><i>Symposium on Logic in Computer Science</i>, pages 193+. IEEE<br>Computer Society Press, 1999.</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:477"><nobr><span class="ft9">[Gan99]</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:544"><nobr><span class="ft9">Harald Ganzinger, editor. <i>Proceedings of the 16</i></span></nobr></DIV>
<DIV style="position:absolute;top:509;left:778"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:512;left:792"><nobr><span class="ft18"><i>Interna-</i></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:544"><nobr><span class="ft26"><i>tional Conference on Automated Deduction</i>, volume 1632<br>of <i>Lecture Notes in Artificial Intelligence</i>, Berlin, July 7­10<br>1999. Trento, Italy.</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:477"><nobr><span class="ft9">[GM96]</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:544"><nobr><span class="ft9">A. D. Gordon and T. Melham.</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:709"><nobr><span class="ft9">Five axioms of alpha-</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:544"><nobr><span class="ft34">conversion. In J. von Wright, J. Grundy, and J. Harrison,<br>editors, <i>Theorem Proving in Higher Order Logics: 9th<br>International Conference, Turku, Finland, August 1996:<br>Proceedings</i>, volume 1125 of <i>Lecture Notes in Computer<br>Science</i>, pages 173­190. Springer-Verlag, 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:477"><nobr><span class="ft9">[GMO03]</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:544"><nobr><span class="ft26">Jim Grundy, Tom Melham, and John O'Leary. A reflective<br>functional language for hardware design and theorem<br>proving. Technical Report PRG-RR-03-16, Oxford Univerity,<br>Computing Laboratory, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:477"><nobr><span class="ft9">[G¨od31]</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:544"><nobr><span class="ft9">Kurt G¨odel. ¨</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:605"><nobr><span class="ft9">Uber formal unentscheidbare s¨atze der principia</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:544"><nobr><span class="ft26">mathematica und verwandter systeme I. <i>Monatshefte f¨ur<br>Mathematik und Physik</i>, 38:173­198, 1931. English version<br>in <A href="3.html#11">[vH67].</a></span></nobr></DIV>
<DIV style="position:absolute;top:778;left:477"><nobr><span class="ft9">[G¨od36]</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:544"><nobr><span class="ft9">K. G¨odel.</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:606"><nobr><span class="ft9">¨</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:603"><nobr><span class="ft9">Uber die L¨ange von beweisen. <i>Ergebnisse</i></span></nobr></DIV>
<DIV style="position:absolute;top:792;left:544"><nobr><span class="ft26"><i>eines mathematischen Kolloquiums</i>, 7:23­24, 1936. English<br>translation in <A href="3.html#10">[F</a></span></nobr></DIV>
<DIV style="position:absolute;top:801;left:620"><nobr><span class="ft8"><A href="3.html#10">+</a></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:629"><nobr><span class="ft9"><A href="3.html#10">86], </a>pages 397­399.</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:477"><nobr><span class="ft9">[GS89]</span></nobr></DIV>
<DIV style="position:absolute;top:825;left:544"><nobr><span class="ft26">F. Giunchiglia and A. Smaill. Reflection in constructive<br>and non-constructive automated reasoning. In H. Abramson<br>and M. H. Rogers, editors, <i>Meta-Programming in Logic<br>Programming</i>, pages 123­140. MIT Press, Cambridge,<br>Mass., 1989.</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:477"><nobr><span class="ft9">[GWZ00]</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:544"><nobr><span class="ft33">H. Geuvers, F. Wiedijk, and J. Zwanenburg. Equational rea-<br>soning via partial reflection. In J. Harrison and M. Aagaard,<br>editors, <i>Theorem Proving in Higher Order Logics: 13</i></span></nobr></DIV>
<DIV style="position:absolute;top:923;left:796"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:926;left:809"><nobr><span class="ft18"><i>Inter-</i></span></nobr></DIV>
<DIV style="position:absolute;top:940;left:544"><nobr><span class="ft26"><i>national Conference, TPHOLs 2000</i>, volume 1869 of <i>Lecture<br>Notes in Computer Science</i>, pages 162­178. Springer-Verlag,<br>2000.</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:477"><nobr><span class="ft9">[HAB</span></nobr></DIV>
<DIV style="position:absolute;top:981;left:507"><nobr><span class="ft8">+</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:515"><nobr><span class="ft9">]</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:544"><nobr><span class="ft27">Jason J. Hickey, Brian Aydemir, Yegor Bryukhov, Alexei<br>Kopylov, Aleksey Nogin, and Xin Yu. A listing of MetaPRL<br>theories. <A href="http://metaprl.org/theories.pdf">http://metaprl.org/theories.pdf.</a></span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:477"><nobr><span class="ft9">[Har95]</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:544"><nobr><span class="ft26">J. Harrison. Metatheory and reflection in theorem proving:<br>A survey and critique. Technical Report CRC-53, SRI<br>International, Cambridge Computer Science Research<br>Centre, Millers Yard, Cambridge, UK, February 1995.</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:452"><nobr><span class="ft3">11</span></nobr></DIV>
</DIV>
<!-- Page 11 -->
<a name="11"></a>
<DIV style="position:relative;width:918;height:1263;">
<STYLE type="text/css">
<!--
	.ft35{font-size:9px;line-height:11px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1263" src="3011.png" alt="background image">
<DIV style="position:absolute;top:112;left:83"><nobr><span class="ft9">[HHP93]</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:149"><nobr><span class="ft9">Robert Harper, Furio Honsell, and Gordon Plotkin.</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:416"><nobr><span class="ft9">A</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:149"><nobr><span class="ft26">framework for defining logics. <i>Journal of the Association<br>for Computing Machinery</i>, 40(1):143­184, January 1993. A<br>revised and expanded verion of '87 paper.</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:83"><nobr><span class="ft9">[Hic97]</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:149"><nobr><span class="ft9">Jason J. Hickey.</span></nobr></DIV>
<DIV style="position:absolute;top:170;left:244"><nobr><span class="ft17">NuPRL-Light: An implementation</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:149"><nobr><span class="ft33">framework for higher-order logics. In William McCune,<br>editor, <i>Proceedings of the 14</i></span></nobr></DIV>
<DIV style="position:absolute;top:197;left:293"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:200;left:307"><nobr><span class="ft18"><i>International Conference</i></span></nobr></DIV>
<DIV style="position:absolute;top:213;left:149"><nobr><span class="ft27"><i>on Automated Deduction</i>, volume 1249 of <i>Lecture Notes in<br>Artificial Intelligence</i>, pages 395­399. Springer, July 13­17<br>1997. An extended version of the paper can be found at<br><A href="http://www.cs.caltech.edu/~jyh/papers/cade14_nl/default.html">http://www.cs.caltech.edu/~jyh/papers/cade14_<br>nl/default.html.</a></span></nobr></DIV>
<DIV style="position:absolute;top:286;left:83"><nobr><span class="ft9">[Hic99]</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:149"><nobr><span class="ft26">Jason J. Hickey. Fault-tolerant distributed theorem proving.<br>In Ganzinger <A href="3.html#10">[Gan99], </a>pages 227­231.</span></nobr></DIV>
<DIV style="position:absolute;top:319;left:83"><nobr><span class="ft9">[Hic01]</span></nobr></DIV>
<DIV style="position:absolute;top:319;left:149"><nobr><span class="ft26">Jason J. Hickey. <i>The </i>MetaPRL <i>Logical Programming<br>Environment</i>. PhD thesis, Cornell University, Ithaca, NY,<br>January 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:83"><nobr><span class="ft9">[HL78]</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:149"><nobr><span class="ft26">G´erard P. Huet and Bernard Lang. Proving and applying<br>program transformations expressed with second-order<br>patterns. <i>Acta Informatica</i>, 11:31­55, 1978.</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:83"><nobr><span class="ft9">[HNC</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:112"><nobr><span class="ft8">+</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:121"><nobr><span class="ft9">03]</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:149"><nobr><span class="ft26">Jason Hickey, Aleksey Nogin, Robert L. Constable,<br>Brian E. Aydemir, Eli Barzilay, Yegor Bryukhov, Richard<br>Eaton, Adam Granicz, Alexei Kopylov, Christoph Kreitz,<br>Vladimir N. Krupski, Lori Lorigo, Stephan Schmitt, Carl<br>Witty, and Xin Yu. MetaPRL -- A modular logical en-<br>vironment. In David Basin and Burkhart Wolff, editors,<br><i>Proceedings of the 16</i></span></nobr></DIV>
<DIV style="position:absolute;top:490;left:255"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:493;left:269"><nobr><span class="ft18"><i>International Conference on Theo-</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:149"><nobr><span class="ft26"><i>rem Proving in Higher Order Logics (TPHOLs 2003)</i>, volume<br>2758 of <i>Lecture Notes in Computer Science</i>, pages 287­303.<br>Springer-Verlag, 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:83"><nobr><span class="ft9">[HNK</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:113"><nobr><span class="ft8">+</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:122"><nobr><span class="ft9">]</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:149"><nobr><span class="ft30">Jason J. Hickey, Aleksey Nogin, Alexei Kopylov, et al.<br>MetaPRL home page. <A href="http://metaprl.org/">http://metaprl.org/.</a></span></nobr></DIV>
<DIV style="position:absolute;top:586;left:83"><nobr><span class="ft9">[Mos52]</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:149"><nobr><span class="ft26">Andrzej Mostowski. <i>Sentences undecidable in formalized<br>arithmetic: an exposition of the theory of Kurt G¨odel</i>.<br>Amsterdam: North-Holland, 1952.</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:83"><nobr><span class="ft9">[NH02]</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:149"><nobr><span class="ft26">Aleksey Nogin and Jason Hickey. Sequent schema for<br>derived rules. In Victor A. Carre~no, C´ezar A. Mu~noz,<br>and Sophi`ene Tahar, editors, <i>Proceedings of the 15</i></span></nobr></DIV>
<DIV style="position:absolute;top:656;left:410"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:673;left:149"><nobr><span class="ft34"><i>International Conference on Theorem Proving in Higher<br>Order Logics (TPHOLs 2002)</i>, volume 2410 of <i>Lecture Notes<br>in Computer Science</i>, pages 281­297. Springer-Verlag, 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:83"><nobr><span class="ft9">[NKYH05]</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:149"><nobr><span class="ft26">Aleksey Nogin, Alexei Kopylov, Xin Yu, and Jason Hickey.<br>A computational approach to reflective meta-reasoning<br>about languages with bindings.</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:315"><nobr><span class="ft9">Technical Report Cal-</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:149"><nobr><span class="ft35">techCSTR:2005.003, California Institure of Technology,<br>2005. Available at <A href="http://resolver.caltech.edu/CaltechCSTR:2005.003">http://resolver.caltech.edu/<br>CaltechCSTR:2005.003.</a></span></nobr></DIV>
<DIV style="position:absolute;top:112;left:477"><nobr><span class="ft9">[Nor04]</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:544"><nobr><span class="ft26">Michael Norrish. Recursive function definition for types with<br>binders. In Slind et al. <A href="3.html#11">[SBG04], </a>pages 241­256.</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:477"><nobr><span class="ft9">[Par71]</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:544"><nobr><span class="ft34">R. Parikh. Existence and feasibility in arithmetic. <i>The Journal<br>of Symbolic Logic</i>, 36:494­508, 1971.</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:477"><nobr><span class="ft9">[Pau94]</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:544"><nobr><span class="ft26">Lawrence C. Paulson. Isabelle<i>: A Generic Theorem Prover</i>,<br>volume 828 of <i>Lecture Notes in Computer Science</i>. Springer-<br>Verlag, New York, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:224;left:477"><nobr><span class="ft9">[PE88]</span></nobr></DIV>
<DIV style="position:absolute;top:224;left:544"><nobr><span class="ft26">Frank Pfenning and Conal Elliott. Higher-order abstract<br>syntax. In <i>Proceedings of the ACM SIGPLAN '88 Conference<br>on Programming Language Design and Implementation<br>(PLDI)</i>, volume 23(7) of <i>SIGPLAN Notices</i>, pages 199­208,<br>Atlanta, Georgia, June 1988. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:477"><nobr><span class="ft9">[Pfe89]</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:544"><nobr><span class="ft33">Frank Pfenning. Elf: a language for logic definition and<br>verified metaprogramming. In <i>Proceedings of the 4</i></span></nobr></DIV>
<DIV style="position:absolute;top:309;left:793"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:312;left:807"><nobr><span class="ft18"><i>IEEE</i></span></nobr></DIV>
<DIV style="position:absolute;top:325;left:544"><nobr><span class="ft26"><i>Symposium on Logic in Computer Science</i>, pages 313­322,<br>Asilomar Conference Center, Pacific Grove, California, June<br>1989. IEEE Computer Society Press.</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:477"><nobr><span class="ft9">[Plo90]</span></nobr></DIV>
<DIV style="position:absolute;top:372;left:544"><nobr><span class="ft26">Gordon Plotkin. An illative theory of relations. In R. Cooper,<br>K. Mukai, and J. Perry, editors, <i>Situation Theory and Its<br>Applications, Volume 1</i>, number 22 in CSLI Lecture Notes,<br>pages 133­146. Centre for the Study of Language and<br>Information, 1990.</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:477"><nobr><span class="ft9">[PN90]</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:544"><nobr><span class="ft26">L. Paulson and T. Nipkow. Isabelle tutorial and user's man-<br>ual. Technical report, University of Cambridge Computing<br>Laboratory, 1990.</span></nobr></DIV>
<DIV style="position:absolute;top:491;left:477"><nobr><span class="ft9">[SBG04]</span></nobr></DIV>
<DIV style="position:absolute;top:491;left:544"><nobr><span class="ft33">Konrad Slind, Annette Bunker, and Ganesh Gopalakrishnan,<br>editors. <i>Proceedings of the 17</i></span></nobr></DIV>
<DIV style="position:absolute;top:503;left:693"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:707"><nobr><span class="ft18"><i>International Conference</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:544"><nobr><span class="ft26"><i>on Theorem Proving in Higher Order Logics (TPHOLs<br>2004)</i>, volume 3223 of <i>Lecture Notes in Computer Science</i>.<br>Springer-Verlag, 2004.</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:477"><nobr><span class="ft9">[Sch01]</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:544"><nobr><span class="ft32">Carsten Sch¨urmann. Recursion for higher-order encodings.<br>In L. Fribourg, editor, <i>Computer Science Logic, Proceedings<br>of the 10</i></span></nobr></DIV>
<DIV style="position:absolute;top:590;left:587"><nobr><span class="ft29"><i>t h</i></span></nobr></DIV>
<DIV style="position:absolute;top:593;left:600"><nobr><span class="ft18"><i>Annual Conference of the EACSL</i>, volume 2142</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:544"><nobr><span class="ft26">of <i>Lecture Notes in Computer Science</i>, pages 585­599.<br>Springer-Verlag, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:477"><nobr><span class="ft9">[Smi84]</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:544"><nobr><span class="ft34">B.C. Smith. Reflection and semantics in Lisp. <i>Principles of<br>Programming Languages</i>, pages 23­35, 1984.</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:477"><nobr><span class="ft9">[vH67]</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:544"><nobr><span class="ft26">J. van Heijenoort, editor. <i>From Frege to G¨odel: A Source<br>Book in Mathematical Logic, 1879­1931</i>. Harvard University<br>Press, Cambridge, MA, 1967.</span></nobr></DIV>
<DIV style="position:absolute;top:1132;left:452"><nobr><span class="ft3">12</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
