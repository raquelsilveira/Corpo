<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>p05-ager.dvi</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.35beta">
<META name="date" content="2003-08-18T16:09:15+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:22px;font-family:Helvetica;color:#000000;}
	.ft1{font-size:14px;font-family:Helvetica;color:#000000;}
	.ft2{font-size:-1px;font-family:Times;color:#000000;}
	.ft3{font-size:11px;font-family:Times;color:#000000;}
	.ft4{font-size:15px;font-family:Times;color:#000000;}
	.ft5{font-size:11px;font-family:Symbol;color:#000000;}
	.ft6{font-size:11px;font-family:Times;color:#000000;}
	.ft7{font-size:11px;font-family:Times;color:#000000;}
	.ft8{font-size:11px;font-family:Courier;color:#000000;}
	.ft9{font-size:8px;font-family:Times;color:#000000;}
	.ft10{font-size:16px;font-family:Courier;color:#000000;}
	.ft11{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft12{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft13{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft14{font-size:8px;line-height:11px;font-family:Times;color:#000000;}
	.ft15{font-size:8px;line-height:12px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="11001.png" alt="background image">
<DIV style="position:absolute;top:135;left:286"><nobr><span class="ft0"><b>A Functional Correspondence</b></span></nobr></DIV>
<DIV style="position:absolute;top:162;left:210"><nobr><span class="ft0"><b>between Evaluators and Abstract Machines</b></span></nobr></DIV>
<DIV style="position:absolute;top:223;left:216"><nobr><span class="ft1">Mads Sig Ager, Dariusz Biernacki, Olivier Danvy, and Jan Midtgaard</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:434"><nobr><span class="ft1">BRICS</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:484"><nobr><span class="ft2">£</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:339"><nobr><span class="ft1">Department of Computer Science</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:387"><nobr><span class="ft1">University of Aarhus</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:531"><nobr><span class="ft3"></span></nobr></DIV>
<DIV style="position:absolute;top:340;left:81"><nobr><span class="ft4"><b>Abstract</b></span></nobr></DIV>
<DIV style="position:absolute;top:373;left:81"><nobr><span class="ft11">We bridge the gap between functional evaluators and abstract ma-<br>chines for the</span></nobr></DIV>
<DIV style="position:absolute;top:383;left:159"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:387;left:166"><nobr><span class="ft3">-calculus, using closure conversion, transformation</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:81"><nobr><span class="ft3">into continuation-passing style, and defunctionalization.</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:81"><nobr><span class="ft11">We illustrate this approach by deriving Krivine's abstract machine<br>from an ordinary call-by-name evaluator and by deriving an ordi-<br>nary call-by-value evaluator from Felleisen et al.'s CEK machine.<br>The first derivation is strikingly simpler than what can be found in<br>the literature. The second one is new. Together, they show that<br>Krivine's abstract machine and the CEK machine correspond to the<br>call-by-name and call-by-value facets of an ordinary evaluator for<br>the</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:101"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:537;left:108"><nobr><span class="ft3">-calculus.</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:81"><nobr><span class="ft12">We then reveal the denotational content of Hannan and Miller's<br>CLS machine and of Landin's SECD machine. We formally com-<br>pare the corresponding evaluators and we illustrate some degrees of<br>freedom in the design spaces of evaluators and of abstract machines<br>for the</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:120"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:627;left:127"><nobr><span class="ft3">-calculus with computational effects.</span></nobr></DIV>
<DIV style="position:absolute;top:657;left:81"><nobr><span class="ft11">Finally, we consider the Categorical Abstract Machine and the ex-<br>tent to which it is more of a virtual machine than an abstract ma-<br>chine.</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:81"><nobr><span class="ft4"><b>Categories and Subject Descriptors</b></span></nobr></DIV>
<DIV style="position:absolute;top:743;left:81"><nobr><span class="ft11">D.1.1 [<b>Software</b>]: Programming Techniques--<i>applicative (func-<br>tional) programming</i>; D.3.4 [<b>Programming Languages</b>]: Proces-<br>sors--<i>interpreters</i></span></nobr></DIV>
<DIV style="position:absolute;top:806;left:81"><nobr><span class="ft4"><b>General Terms</b></span></nobr></DIV>
<DIV style="position:absolute;top:831;left:81"><nobr><span class="ft3">Design, Languages.</span></nobr></DIV>
<DIV style="position:absolute;top:864;left:81"><nobr><span class="ft4"><b>Keywords</b></span></nobr></DIV>
<DIV style="position:absolute;top:888;left:81"><nobr><span class="ft11">Interpreters, abstract machines, closure conversion, transformation<br>into continuation-passing style (CPS), defunctionalization.</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:105"><nobr><span class="ft2"></span></nobr></DIV>
<DIV style="position:absolute;top:930;left:114"><nobr><span class="ft3">Basic Research in Computer Science (</span></nobr></DIV>
<DIV style="position:absolute;top:930;left:321"><nobr><span class="ft8">www.brics.dk</span></nobr></DIV>
<DIV style="position:absolute;top:930;left:403"><nobr><span class="ft3">),</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:114"><nobr><span class="ft3">funded by the Danish National Research Foundation.</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:105"><nobr><span class="ft9"></span></nobr></DIV>
<DIV style="position:absolute;top:961;left:114"><nobr><span class="ft11">Ny Munkegade, Building 540, DK-8000 Aarhus C, Denmark.<br>Email:</span></nobr></DIV>
<DIV style="position:absolute;top:977;left:161"><nobr><span class="ft8">mads,dabi,danvy,jmi @brics.dk</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:81"><nobr><span class="ft14">Permission to make digital or hard copies of all or part of this work for personal or<br>classroom use is granted without fee provided that copies are not made or distributed<br>for profit or commercial advantage and that copies bear this notice and the full citation<br>on the first page. To copy otherwise, to republish, to post on servers or to redistribute<br>to lists, requires prior specific permission and/or a fee.<br>PPDP'03, August 27­29, 2003, Uppsala, Sweden.<br>Copyright 2003 ACM 1-58113-705-2/03/0008 ...$5.00</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:477"><nobr><span class="ft4"><b>1</b></span></nobr></DIV>
<DIV style="position:absolute;top:340;left:504"><nobr><span class="ft4"><b>Introduction and related work</b></span></nobr></DIV>
<DIV style="position:absolute;top:373;left:477"><nobr><span class="ft11">In Hannan and Miller's words [23, Section 7], there are fundamen-<br>tal differences between denotational definitions and definitions of<br>abstract machines. While a functional programmer tends to be<br>familiar with denotational definitions [36], he typically wonders<br>about the following issues:</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:477"><nobr><span class="ft6"><b>Design:</b></span></nobr></DIV>
<DIV style="position:absolute;top:457;left:528"><nobr><span class="ft3">How does one design an abstract machine? How were</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:507"><nobr><span class="ft11">existing abstract machines, starting with Landin's SECD ma-<br>chine, designed? How does one make variants of an existing<br>abstract machine? How does one extend an existing abstract<br>machine to a bigger source language? How does one go about<br>designing a new abstract machine? How does one relate two<br>abstract machines?</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:477"><nobr><span class="ft6"><b>Correctness:</b></span></nobr></DIV>
<DIV style="position:absolute;top:568;left:557"><nobr><span class="ft3">How does one prove the correctness of an abstract</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:507"><nobr><span class="ft3">machine?</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:574"><nobr><span class="ft3">Assuming it implements a reduction strategy,</span></nobr></DIV>
<DIV style="position:absolute;top:598;left:507"><nobr><span class="ft11">should one prove that each of its transitions implements a part<br>of this strategy? Or should one characterize it in reference to<br>a given evaluator, or to another abstract machine?</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:477"><nobr><span class="ft11">A variety of answers to these questions can be found in the lit-<br>erature. Landin invented the SECD machine as an implementa-<br>tion model for functional languages [26], and Plotkin proved its<br>correctness in connection with an evaluation function [30, Sec-<br>tion 2]. Krivine discovered an abstract machine from a logical<br>standpoint [25], and Cr´egut proved its correctness in reference to<br>a reduction strategy; he also generalized it from weak to strong<br>normalization [7]. Curien discovered the Categorical Abstract Ma-<br>chine from a categorical standpoint [6, 8]. Felleisen et al. invented<br>the CEK machine from an operational standpoint [16, 17, 19].<br>Hannan and Miller discovered the CLS machine from a proof-<br>theoretical standpoint [23].</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:641"><nobr><span class="ft3">Many people derived, invented, or</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:477"><nobr><span class="ft11">(re-)discovered Krivine's machine. Many others proposed mod-<br>ifications of existing machines. And recently, Rose presented a<br>method to construct abstract machines from reduction rules [32],<br>while Hardin, Maranget, and Pagano presented a method to extract<br>the reduction strategy of a machine by extracting axioms from its<br>transitions and structural rules from its architecture [24].</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:477"><nobr><span class="ft11">In this article, we propose one constructive answer to all the ques-<br>tions above.</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:558"><nobr><span class="ft3">We present a correspondence between functional</span></nobr></DIV>
<DIV style="position:absolute;top:966;left:477"><nobr><span class="ft11">evaluators and abstract machines based on a two-way derivation<br>consisting of closure conversion, transformation into continuation-<br>passing style (CPS), and defunctionalization. This two-way deriva-<br>tion lets us connect each of the machines above with an evaluator,<br>and makes it possible to echo variations in the evaluator into varia-<br>tions in the abstract machine, and vice versa. The evaluator clarifies<br>the reduction strategy of the corresponding machine. The abstract<br>machine makes the evaluation steps explicit in a transition system.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:456"><nobr><span class="ft3">8</span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft16{font-size:14px;font-family:Times;color:#000000;}
	.ft17{font-size:14px;font-family:Symbol;color:#000000;}
	.ft18{font-size:9px;font-family:Courier;color:#000000;}
	.ft19{font-size:15px;font-family:Symbol;color:#000000;}
	.ft20{font-size:14px;line-height:16px;font-family:Times;color:#000000;}
	.ft21{font-size:15px;line-height:17px;font-family:Times;color:#000000;}
	.ft22{font-size:9px;line-height:13px;font-family:Courier;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="11002.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft3">Some machines operate on</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:229"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:114;left:237"><nobr><span class="ft3">-terms directly whereas others operate</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:81"><nobr><span class="ft3">on compiled</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:155"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:129;left:163"><nobr><span class="ft3">-terms expressed with an instruction set. Accord-</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:81"><nobr><span class="ft11">ingly, we distinguish between <i>abstract </i>machines and <i>virtual </i>ma-<br>chines in the sense that virtual machines have an instruction set and<br>abstract machines do not; instead, abstract machines directly oper-<br>ate on source terms and do not need a compiler from source terms to<br>instructions. (Gr´egoire and Leroy make the same point when they<br>talk about a <i>compiled </i>implementation of strong reduction [21].)</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:81"><nobr><span class="ft20"><i>Prerequisites: ML, observational equivalence, abstract<br>machines,</i></span></nobr></DIV>
<DIV style="position:absolute;top:257;left:151"><nobr><span class="ft17"></span></nobr></DIV>
<DIV style="position:absolute;top:262;left:160"><nobr><span class="ft16"><i>-interpreters, CPS transformation, defunc-</i></span></nobr></DIV>
<DIV style="position:absolute;top:279;left:81"><nobr><span class="ft16"><i>tionalization, and closure conversion.</i></span></nobr></DIV>
<DIV style="position:absolute;top:302;left:81"><nobr><span class="ft11">We use ML as a meta-language, and we assume a basic familiarity<br>with Standard ML and reasoning about ML programs. In particu-<br>lar, given two pure ML expressions</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:284"><nobr><span class="ft18">e</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:294"><nobr><span class="ft3">and</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:319"><nobr><span class="ft18">e'</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:336"><nobr><span class="ft3">we write</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:388"><nobr><span class="ft18">e</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:414"><nobr><span class="ft18">e'</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:431"><nobr><span class="ft3">to</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:81"><nobr><span class="ft3">express that</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:151"><nobr><span class="ft18">e</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:161"><nobr><span class="ft3">and</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:185"><nobr><span class="ft18">e'</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:202"><nobr><span class="ft3">are observationally equivalent. Most of our</span></nobr></DIV>
<DIV style="position:absolute;top:362;left:81"><nobr><span class="ft11">implementations of the abstract machines raise compiler warnings<br>about non-exhaustive matches. These are inherent to programming<br>abstract machines in an ML-like language. The warnings could be<br>avoided with an option type or with an explicit exception, at the<br>price of readability and direct relation to the usual mathematical<br>specifications of abstract machines.</span></nobr></DIV>
<DIV style="position:absolute;top:467;left:81"><nobr><span class="ft11">It would be helpful to the reader to know at least one of the ma-<br>chines considered in the rest of this article, be it Krivine's ma-<br>chine, the CEK machine, the CLS machine, the SECD machine,<br>or the Categorical Abstract Machine.</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:303"><nobr><span class="ft3">It would also be helpful</span></nobr></DIV>
<DIV style="position:absolute;top:527;left:81"><nobr><span class="ft3">to have already seen a</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:215"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:527;left:222"><nobr><span class="ft3">-interpreter written in a functional lan-</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:81"><nobr><span class="ft11">guage [20, 31, 35, 39]. In particular, we make use of Strachey's<br>notions of expressible values, i.e., the values obtained by evaluat-<br>ing an expression, and denotable values, i.e., the values denoted by<br>identifiers [38].</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:81"><nobr><span class="ft11">We make use of the CPS transformation [12, 33]: a term is CPS-<br>transformed by naming all its intermediate results, sequentializing<br>their computation, and introducing continuations. Plotkin was the<br>first to establish the correctness of the CPS transformation [30].</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:81"><nobr><span class="ft11">We also make use of Reynolds's defunctionalization [31]: defunc-<br>tionalizing a program amounts to replacing each of its function<br>spaces by a data type and an apply function; the data type enu-<br>merates all the function abstractions that may give rise to inhabi-<br>tants of this function space in this program [15]. Nielsen, Banerjee,<br>Heintze, and Riecke have established the correctness of defunction-<br>alization [3, 29].</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:81"><nobr><span class="ft11">A particular case of defunctionalization is closure conversion: in<br>an evaluator, closure conversion amounts to replacing each of the<br>function spaces in expressible and denotable values by a tuple, and<br>inlining the corresponding apply function.</span></nobr></DIV>
<DIV style="position:absolute;top:885;left:81"><nobr><span class="ft11">We would like to stress that all the concepts used here are elemen-<br>tary ones, and that the significance of this article is the one-fits-all<br>derivation between evaluators and abstract machines.</span></nobr></DIV>
<DIV style="position:absolute;top:943;left:81"><nobr><span class="ft16"><i>Overview:</i></span></nobr></DIV>
<DIV style="position:absolute;top:966;left:81"><nobr><span class="ft11">The rest of this article is organized as follows. We first consider<br>a call-by-name and a call-by-value evaluator, and we present the<br>corresponding machines, which are Krivine's machine and the CEK<br>machine. We then turn to the CLS machine and the SECD machine,<br>and we present the corresponding evaluators. We finally consider<br>the Categorical Abstract Machine. For simplicity, we do not cover<br>laziness and sharing, but they come for free by threading a heap of<br>updateable thunks in a call-by-name evaluator [2].</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:477"><nobr><span class="ft4"><b>2</b></span></nobr></DIV>
<DIV style="position:absolute;top:111;left:504"><nobr><span class="ft4"><b>Call-by-name, call-by-value, and the</b></span></nobr></DIV>
<DIV style="position:absolute;top:105;left:821"><nobr><span class="ft19"></span></nobr></DIV>
<DIV style="position:absolute;top:111;left:831"><nobr><span class="ft4"><b>-</b></span></nobr></DIV>
<DIV style="position:absolute;top:129;left:504"><nobr><span class="ft4"><b>calculus</b></span></nobr></DIV>
<DIV style="position:absolute;top:158;left:477"><nobr><span class="ft11">We first go from a call-by-name evaluator to Krivine's abstract ma-<br>chine (Section 2.1) and then from the CEK machine to a call-by-<br>value evaluator (Section 2.2). Krivine's abstract machine operates<br>on de Bruijn-encoded</span></nobr></DIV>
<DIV style="position:absolute;top:198;left:600"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:202;left:607"><nobr><span class="ft3">-terms, and the CEK machine operates on</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:477"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:217;left:484"><nobr><span class="ft3">-terms with names. Starting from the corresponding evaluators, it</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:477"><nobr><span class="ft11">is simple to construct a version of Krivine's abstract machine that<br>operates on</span></nobr></DIV>
<DIV style="position:absolute;top:243;left:542"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:247;left:549"><nobr><span class="ft3">-terms with names, and a version of the CEK machine</span></nobr></DIV>
<DIV style="position:absolute;top:262;left:477"><nobr><span class="ft3">that operates on de Bruijn-encoded</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:669"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:262;left:677"><nobr><span class="ft3">-terms (Section 2.3).</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:477"><nobr><span class="ft11">The derivation steps consist of closure conversion, transformation<br>into continuation-passing style, and defunctionalization of continu-<br>ations. Closure converting expressible and denotable values makes<br>the evaluator first order. CPS transforming the evaluator makes its<br>control flow manifest as a continuation. Defunctionalizing the con-<br>tinuation materializes the control flow as a first-order data structure.<br>The result is a transition function, i.e., an abstract machine.</span></nobr></DIV>
<DIV style="position:absolute;top:413;left:477"><nobr><span class="ft4"><b>2.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:413;left:517"><nobr><span class="ft21"><b>From a call-by-name evaluator to Kriv-<br>ine's machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:477"><nobr><span class="ft3">Krivine's abstract machine [7] operates on de Bruijn-encoded</span></nobr></DIV>
<DIV style="position:absolute;top:455;left:826"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:834"><nobr><span class="ft3">-</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:477"><nobr><span class="ft11">terms. In this representation, identifiers are represented by their<br>lexical offset, as traditional since Algol 60 [40].</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:489"><nobr><span class="ft18">datatype term = IND of int</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:672"><nobr><span class="ft18">(* de Bruijn index *)</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:574"><nobr><span class="ft22">| ABS of term<br>| APP of term * term</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:477"><nobr><span class="ft3">Programs are closed terms.</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:477"><nobr><span class="ft16"><i>2.1.1</i></span></nobr></DIV>
<DIV style="position:absolute;top:600;left:526"><nobr><span class="ft20"><i>A higher-order and compositional call-by-<br>name evaluator</i></span></nobr></DIV>
<DIV style="position:absolute;top:644;left:477"><nobr><span class="ft3">Our starting point is the canonical call-by-name evaluator for the</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:477"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:659;left:484"><nobr><span class="ft3">-calculus [35, 37]. This evaluator is compositional in the sense of</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:477"><nobr><span class="ft3">denotational semantics [34, 37, 41] and higher order (</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:769"><nobr><span class="ft18">Eval0.eval</span></nobr></DIV>
<DIV style="position:absolute;top:674;left:830"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:477"><nobr><span class="ft11">It is compositional because it solely defines the meaning of each<br>term as a composition of the meaning of its parts. It is higher or-<br>der because the data types</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:622"><nobr><span class="ft18">Eval0.denval</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:698"><nobr><span class="ft3">and</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:722"><nobr><span class="ft18">Eval0.expval</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:798"><nobr><span class="ft3">contain</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:477"><nobr><span class="ft3">functions: denotable values (</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:631"><nobr><span class="ft18">denval</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:668"><nobr><span class="ft3">) are thunks and expressible val-</span></nobr></DIV>
<DIV style="position:absolute;top:749;left:477"><nobr><span class="ft3">ues (</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:503"><nobr><span class="ft18">expval</span></nobr></DIV>
<DIV style="position:absolute;top:749;left:540"><nobr><span class="ft3">) are functions. An environment is represented as a list</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:477"><nobr><span class="ft11">of denotable values. A program is evaluated in an empty environ-<br>ment (</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:512"><nobr><span class="ft18">Eval0.main</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:573"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:489"><nobr><span class="ft22">structure Eval0<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:513"><nobr><span class="ft18">datatype denval = THUNK of unit -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:544"><nobr><span class="ft18">and expval = FUNCT of denval -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:538"><nobr><span class="ft18">eval : term * denval list -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:763"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:884;left:513"><nobr><span class="ft18">fun eval (IND n, e)</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:538"><nobr><span class="ft18">= let val (THUNK thunk) = List.nth (e, n)</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:550"><nobr><span class="ft22">in thunk ()<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:526"><nobr><span class="ft18">| eval (ABS t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:538"><nobr><span class="ft18">= FUNCT (fn v =&gt; eval (t, v :: e))</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:526"><nobr><span class="ft18">| eval (APP (t0, t1), e)</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:538"><nobr><span class="ft18">= let val (FUNCT f) = eval (t0, e)</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:550"><nobr><span class="ft22">in f (THUNK (fn () =&gt; eval (t1, e)))<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:538"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:678"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:513"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:538"><nobr><span class="ft18">= eval (t, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:501"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:456"><nobr><span class="ft3">9</span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="11003.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft11">An identifier denotes a thunk. Evaluating an identifier amounts<br>to forcing this thunk.</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:215"><nobr><span class="ft3">Evaluating an abstraction yields a func-</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:81"><nobr><span class="ft11">tion. Evaluating an application requires the evaluation of the sub-<br>expression in position of function; the intermediate result is a func-<br>tion, which is applied to a thunk.</span></nobr></DIV>
<DIV style="position:absolute;top:208;left:81"><nobr><span class="ft16"><i>2.1.2</i></span></nobr></DIV>
<DIV style="position:absolute;top:208;left:130"><nobr><span class="ft16"><i>From higher-order functions to closures</i></span></nobr></DIV>
<DIV style="position:absolute;top:240;left:81"><nobr><span class="ft3">We now closure-convert the evaluator of Section 2.1.1.</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:81"><nobr><span class="ft3">In</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:100"><nobr><span class="ft18">Eval0</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:131"><nobr><span class="ft3">, the function spaces in the data types of denotable</span></nobr></DIV>
<DIV style="position:absolute;top:285;left:81"><nobr><span class="ft3">and expressible values are only inhabited by instances of the</span></nobr></DIV>
<DIV style="position:absolute;top:281;left:431"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:285;left:438"><nobr><span class="ft3">-</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:81"><nobr><span class="ft3">abstractions</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:149"><nobr><span class="ft18">fn v =&gt; eval (t, v :: e)</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:299"><nobr><span class="ft3">in the meaning of abstrac-</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:81"><nobr><span class="ft3">tions, and</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:139"><nobr><span class="ft18">fn () =&gt; eval (t1, e)</span></nobr></DIV>
<DIV style="position:absolute;top:315;left:271"><nobr><span class="ft3">in the meaning of applications.</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:81"><nobr><span class="ft3">Each of these</span></nobr></DIV>
<DIV style="position:absolute;top:325;left:159"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:330;left:166"><nobr><span class="ft3">-abstractions has two free variables: a term and an</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:81"><nobr><span class="ft11">environment. We defunctionalize these function spaces into clo-<br>sures [15, 26, 31], and we inline the corresponding apply functions.</span></nobr></DIV>
<DIV style="position:absolute;top:390;left:93"><nobr><span class="ft22">structure Eval1<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:118"><nobr><span class="ft18">datatype denval = THUNK of term * denval list</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:148"><nobr><span class="ft18">and expval = FUNCT of term * denval list</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:142"><nobr><span class="ft18">eval : term * denval list -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:458;left:368"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:471;left:118"><nobr><span class="ft18">fun eval (IND n, e)</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:142"><nobr><span class="ft18">= let val (THUNK (t, e')) = List.nth (e, n)</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:154"><nobr><span class="ft22">in eval (t, e')<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:130"><nobr><span class="ft18">| eval (ABS t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:142"><nobr><span class="ft18">= FUNCT (t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:130"><nobr><span class="ft18">| eval (APP (t0, t1), e)</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:142"><nobr><span class="ft18">= let val (FUNCT (t, e')) = eval (t0, e)</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:154"><nobr><span class="ft22">in eval (t, (THUNK (t1, e)) :: e')<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:142"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:282"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:118"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:142"><nobr><span class="ft18">= eval (t, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:105"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:81"><nobr><span class="ft3">The definition of an abstraction is now</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:291"><nobr><span class="ft18">Eval1.FUNCT (t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:404"><nobr><span class="ft3">instead</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:81"><nobr><span class="ft3">of</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:95"><nobr><span class="ft18">fn v =&gt; Eval0.eval (t, v :: e)</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:278"><nobr><span class="ft3">, and its use is now</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:380"><nobr><span class="ft18">Eval1.eval</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:81"><nobr><span class="ft18">(t, (Eval1.THUNK (t1, e)) :: e')</span></nobr></DIV>
<DIV style="position:absolute;top:718;left:286"><nobr><span class="ft3">instead of</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:356"><nobr><span class="ft18">f (Eval0.THUNK</span></nobr></DIV>
<DIV style="position:absolute;top:735;left:81"><nobr><span class="ft18">(fn () =&gt; Eval0.eval (t1, e)))</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:264"><nobr><span class="ft3">. Similarly, the definition of a</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:81"><nobr><span class="ft3">thunk is now</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:155"><nobr><span class="ft18">Eval1.THUNK (t1, e)</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:275"><nobr><span class="ft3">instead of</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:332"><nobr><span class="ft18">Eval0.THUNK (fn ()</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:81"><nobr><span class="ft18">=&gt; Eval0.eval (t1, e))</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:218"><nobr><span class="ft3">and its use is</span></nobr></DIV>
<DIV style="position:absolute;top:764;left:290"><nobr><span class="ft18">Eval1.eval (t, e')</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:403"><nobr><span class="ft3">instead</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:81"><nobr><span class="ft3">of</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:96"><nobr><span class="ft18">thunk ()</span></nobr></DIV>
<DIV style="position:absolute;top:778;left:144"><nobr><span class="ft3">.</span></nobr></DIV>
<DIV style="position:absolute;top:808;left:81"><nobr><span class="ft11">The following proposition is a corollary of the correctness of de-<br>functionalization.</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:81"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:90"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:163"><nobr><span class="ft3">1</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:185"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:190"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:306"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:81"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:870;left:200"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:256"><nobr><span class="ft7"><i>denoting a program, evaluating</i></span></nobr></DIV>
<DIV style="position:absolute;top:885;left:81"><nobr><span class="ft18">Eval0.main p</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:158"><nobr><span class="ft7"><i>yields a value</i></span></nobr></DIV>
<DIV style="position:absolute;top:885;left:237"><nobr><span class="ft18">FUNCT f</span></nobr></DIV>
<DIV style="position:absolute;top:883;left:284"><nobr><span class="ft7"><i>and evaluating</i></span></nobr></DIV>
<DIV style="position:absolute;top:885;left:369"><nobr><span class="ft18">Eval1.main p</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:81"><nobr><span class="ft7"><i>yields a value</i></span></nobr></DIV>
<DIV style="position:absolute;top:899;left:159"><nobr><span class="ft18">FUNCT (t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:235"><nobr><span class="ft7"><i>such that</i></span></nobr></DIV>
<DIV style="position:absolute;top:925;left:155"><nobr><span class="ft18">f</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:185"><nobr><span class="ft18">fn v =&gt; Eval1.eval (t, v :: e)</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:81"><nobr><span class="ft16"><i>2.1.3</i></span></nobr></DIV>
<DIV style="position:absolute;top:964;left:130"><nobr><span class="ft16"><i>CPS transformation</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:81"><nobr><span class="ft3">We transform</span></nobr></DIV>
<DIV style="position:absolute;top:1000;left:159"><nobr><span class="ft18">Eval1.eval</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:225"><nobr><span class="ft3">into continuation-passing style.</span></nobr></DIV>
<DIV style="position:absolute;top:995;left:395"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:408"><nobr><span class="ft3">Doing</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:81"><nobr><span class="ft3">so makes it tail recursive.</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:99"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:105"><nobr><span class="ft3">Since programs are closed, applying</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:304"><nobr><span class="ft8">List.nth</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:362"><nobr><span class="ft3">cannot fail and</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:81"><nobr><span class="ft11">therefore it denotes a total function. We thus keep it in direct<br>style [14].</span></nobr></DIV>
<DIV style="position:absolute;top:116;left:489"><nobr><span class="ft22">structure Eval2<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:513"><nobr><span class="ft18">datatype denval = THUNK of term * denval list</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:544"><nobr><span class="ft18">and expval = FUNCT of term * denval list</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:538"><nobr><span class="ft18">eval : term * denval list * (expval -&gt; 'a)</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:806"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:581"><nobr><span class="ft18">-&gt; 'a</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:806"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:513"><nobr><span class="ft18">fun eval (IND n, e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:538"><nobr><span class="ft18">= let val (THUNK (t, e')) = List.nth (e, n)</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:550"><nobr><span class="ft22">in eval (t, e', k)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:526"><nobr><span class="ft18">| eval (ABS t, e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:538"><nobr><span class="ft18">= k (FUNCT (t, e))</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:526"><nobr><span class="ft18">| eval (APP (t0, t1), e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:538"><nobr><span class="ft18">= eval (t0, e, fn (FUNCT (t, e'))</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:629"><nobr><span class="ft18">=&gt; eval (t,</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:684"><nobr><span class="ft22">(THUNK (t1, e)) :: e',<br>k))</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:538"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:678"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:513"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:538"><nobr><span class="ft18">= eval (t, nil, fn v =&gt; v)</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:501"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:477"><nobr><span class="ft11">The following proposition is a corollary of the correctness of the<br>CPS transformation. (Here observational equivalence reduces to<br>structural equality over ML values of type</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:707"><nobr><span class="ft18">expval</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:744"><nobr><span class="ft3">.)</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:477"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:485"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:559"><nobr><span class="ft3">2</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:581"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:498;left:586"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:702"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:477"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:512;left:576"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:629"><nobr><span class="ft7"><i>denoting a program,</i></span></nobr></DIV>
<DIV style="position:absolute;top:534;left:572"><nobr><span class="ft18">Eval1.main p</span></nobr></DIV>
<DIV style="position:absolute;top:534;left:669"><nobr><span class="ft18">Eval2.main p</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:477"><nobr><span class="ft16"><i>2.1.4</i></span></nobr></DIV>
<DIV style="position:absolute;top:565;left:526"><nobr><span class="ft16"><i>Defunctionalizing the continuations</i></span></nobr></DIV>
<DIV style="position:absolute;top:589;left:477"><nobr><span class="ft11">The function space of the continuation is inhabited by instances of<br>two</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:501"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:604;left:508"><nobr><span class="ft3">-abstractions: the initial one in the definition of</span></nobr></DIV>
<DIV style="position:absolute;top:606;left:773"><nobr><span class="ft18">Eval2.main</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:834"><nobr><span class="ft3">,</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:477"><nobr><span class="ft11">with no free variables, and one in the meaning of an application,<br>with three free variables. To defunctionalize the continuation, we<br>thus define a data type</span></nobr></DIV>
<DIV style="position:absolute;top:650;left:611"><nobr><span class="ft18">cont</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:641"><nobr><span class="ft3">with two summands and the corre-</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:477"><nobr><span class="ft3">sponding</span></nobr></DIV>
<DIV style="position:absolute;top:665;left:530"><nobr><span class="ft18">apply cont</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:592"><nobr><span class="ft3">function to interpret these summands.</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:489"><nobr><span class="ft22">structure Eval3<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:719;left:513"><nobr><span class="ft18">datatype denval = THUNK of term * denval list</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:544"><nobr><span class="ft22">and expval = FUNCT of term * denval list<br>and</span></nobr></DIV>
<DIV style="position:absolute;top:746;left:581"><nobr><span class="ft18">cont = CONT0</span></nobr></DIV>
<DIV style="position:absolute;top:759;left:611"><nobr><span class="ft18">| CONT1 of term * denval list * cont</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:538"><nobr><span class="ft18">eval : term * denval list * cont -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:806"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:513"><nobr><span class="ft18">fun eval (IND n, e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:813;left:538"><nobr><span class="ft18">= let val (THUNK (t, e')) = List.nth (e, n)</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:550"><nobr><span class="ft22">in eval (t, e', k)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:526"><nobr><span class="ft18">| eval (ABS t, e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:538"><nobr><span class="ft18">= apply_cont (k, FUNCT (t, e))</span></nobr></DIV>
<DIV style="position:absolute;top:880;left:526"><nobr><span class="ft18">| eval (APP (t0, t1), e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:538"><nobr><span class="ft18">= eval (t0, e, CONT1 (t1, e, k))</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:513"><nobr><span class="ft18">and apply_cont (CONT0, v)</span></nobr></DIV>
<DIV style="position:absolute;top:921;left:538"><nobr><span class="ft18">= v</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:526"><nobr><span class="ft18">| apply_cont (CONT1 (t1, e, k), FUNCT (t, e'))</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:538"><nobr><span class="ft18">= eval (t, (THUNK (t1, e)) :: e', k)</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:538"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:678"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:988;left:519"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:544"><nobr><span class="ft18">= eval (t, nil, CONT0)</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:501"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:477"><nobr><span class="ft11">The following proposition is a corollary of the correctness of de-<br>functionalization. (Again, observational equivalence reduces here<br>to structural equality over ML values of type</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:721"><nobr><span class="ft18">expval</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:758"><nobr><span class="ft3">.)</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">10</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft23{font-size:8px;font-family:Times;color:#000000;}
	.ft24{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="11004.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:116;left:90"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:163"><nobr><span class="ft3">3</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:185"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:116;left:190"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:306"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:81"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:131;left:181"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:233"><nobr><span class="ft7"><i>denoting a program,</i></span></nobr></DIV>
<DIV style="position:absolute;top:155;left:176"><nobr><span class="ft18">Eval2.main p</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:273"><nobr><span class="ft18">Eval3.main p</span></nobr></DIV>
<DIV style="position:absolute;top:194;left:81"><nobr><span class="ft3">We identify that</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:173"><nobr><span class="ft18">cont</span></nobr></DIV>
<DIV style="position:absolute;top:194;left:202"><nobr><span class="ft3">is a stack of thunks, and that the transitions</span></nobr></DIV>
<DIV style="position:absolute;top:209;left:81"><nobr><span class="ft3">are those of Krivine's abstract machine.</span></nobr></DIV>
<DIV style="position:absolute;top:242;left:81"><nobr><span class="ft16"><i>2.1.5</i></span></nobr></DIV>
<DIV style="position:absolute;top:242;left:130"><nobr><span class="ft16"><i>Krivine's abstract machine</i></span></nobr></DIV>
<DIV style="position:absolute;top:275;left:81"><nobr><span class="ft11">To obtain the canonical definition of Krivine's abstract machine, we<br>abandon the distinction between denotable and expressible values<br>and we use thunks instead, we represent the defunctionalized con-<br>tinuation as a list of thunks instead of a data type, and we inline</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:81"><nobr><span class="ft18">apply cont</span></nobr></DIV>
<DIV style="position:absolute;top:334;left:140"><nobr><span class="ft3">.</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:93"><nobr><span class="ft22">structure Eval4<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:118"><nobr><span class="ft18">datatype thunk = THUNK of term * thunk list</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:142"><nobr><span class="ft18">eval : term * thunk list * thunk list</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:380"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:166"><nobr><span class="ft18">-&gt; term * thunk list</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:380"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:118"><nobr><span class="ft18">fun eval (IND n, e, s)</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:142"><nobr><span class="ft18">= let val (THUNK (t, e')) = List.nth (e, n)</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:154"><nobr><span class="ft22">in eval (t, e', s)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:499;left:130"><nobr><span class="ft18">| eval (ABS t, e, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:142"><nobr><span class="ft18">= (ABS t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:130"><nobr><span class="ft18">| eval (ABS t, e, (t', e') :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:142"><nobr><span class="ft18">= eval (t, (THUNK (t', e')) :: e, s)</span></nobr></DIV>
<DIV style="position:absolute;top:553;left:130"><nobr><span class="ft18">| eval (APP (t0, t1), e, s)</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:142"><nobr><span class="ft18">= eval (t0, e, (t1, e) :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:124"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:148"><nobr><span class="ft18">main : term -&gt; term * thunk list</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:355"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:124"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:148"><nobr><span class="ft18">= eval (t, nil, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:105"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:662;left:81"><nobr><span class="ft3">The following proposition is straightforward to prove.</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:81"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:90"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:163"><nobr><span class="ft3">4</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:185"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:190"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:306"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:81"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:709;left:181"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:233"><nobr><span class="ft7"><i>denoting a program,</i></span></nobr></DIV>
<DIV style="position:absolute;top:734;left:176"><nobr><span class="ft18">Eval3.main p</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:273"><nobr><span class="ft18">Eval4.main p</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:81"><nobr><span class="ft3">For comparison with</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:201"><nobr><span class="ft18">Eval4</span></nobr></DIV>
<DIV style="position:absolute;top:773;left:232"><nobr><span class="ft3">, the canonical definition of Krivine's</span></nobr></DIV>
<DIV style="position:absolute;top:788;left:81"><nobr><span class="ft11">abstract machine is as follows [7, 22, 25], where <i>t </i>denotes terms, <i>v<br></i>denotes expressible values, <i>e </i>denotes environments, and <i>s </i>denotes<br>stacks of expressible values:</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:111"><nobr><span class="ft3">Source syntax:</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:215"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:872;left:234"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:267"><nobr><span class="ft7"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:868;left:289"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:872;left:296"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:872;left:316"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:877;left:320"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:327"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:877;left:331"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:914;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:111"><nobr><span class="ft3">Expressible values (closures):</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:237"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:929;left:258"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:294"><nobr><span class="ft7"><i>t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:971;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:111"><nobr><span class="ft3">Initial transition, transition rules, and final transition:</span></nobr></DIV>
<DIV style="position:absolute;top:990;left:207"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:999;left:226"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:990;left:259"><nobr><span class="ft7"><i>t nil nil</i></span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:175"><nobr><span class="ft7"><i>n e s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:226"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:259"><nobr><span class="ft7"><i>t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:277"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:287"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:306"><nobr><span class="ft7"><i>where t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:362"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:386"><nobr><span class="ft7"><i>nth</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:403"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:408"><nobr><span class="ft7"><i>e n</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:428"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1022;left:125"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:132"><nobr><span class="ft7"><i>t e t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:164"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:174"><nobr><span class="ft7"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:180"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:190"><nobr><span class="ft3">:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1036;left:226"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:259"><nobr><span class="ft7"><i>t t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:279"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:289"><nobr><span class="ft7"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1031;left:295"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:305"><nobr><span class="ft3">:: <i>e s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:161"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:165"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:172"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:176"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:188"><nobr><span class="ft7"><i>e s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:226"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:259"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:263"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:276"><nobr><span class="ft7"><i>e t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:296"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:308"><nobr><span class="ft7"><i>e </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:161"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:1064;left:168"><nobr><span class="ft7"><i>t e nil</i></span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:226"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1064;left:258"><nobr><span class="ft7"><i>t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft11">Variables <i>n </i>are represented by their de Bruijn index, and the abstract<br>machine operates on triples consisting of a term, an environment,<br>and a stack of expressible values.</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:477"><nobr><span class="ft3">Each line in the canonical definition matches a clause in</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:782"><nobr><span class="ft18">Eval4</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:813"><nobr><span class="ft3">. We</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:477"><nobr><span class="ft11">conclude that Krivine's abstract machine can be seen as a defunc-<br>tionalized, CPS-transformed, and closure-converted version of the<br>standard call-by-name evaluator for the</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:701"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:218;left:708"><nobr><span class="ft3">-calculus. This evalua-</span></nobr></DIV>
<DIV style="position:absolute;top:233;left:477"><nobr><span class="ft11">tor evidently implements Hardin, Maranget, and Pagano's K strat-<br>egy [24, Section 3].</span></nobr></DIV>
<DIV style="position:absolute;top:280;left:477"><nobr><span class="ft4"><b>2.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:280;left:517"><nobr><span class="ft21"><b>From the CEK machine to a call-by-value<br>evaluator</b></span></nobr></DIV>
<DIV style="position:absolute;top:331;left:477"><nobr><span class="ft3">The CEK machine [16, 17, 19] operates on</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:709"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:331;left:717"><nobr><span class="ft3">-terms with names and</span></nobr></DIV>
<DIV style="position:absolute;top:346;left:477"><nobr><span class="ft11">distinguishes between values and computations in their syntax (i.e.,<br>it distinguishes trivial and serious terms, in Reynolds's words [31]).</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:489"><nobr><span class="ft18">datatype term = VALUE of value</span></nobr></DIV>
<DIV style="position:absolute;top:404;left:574"><nobr><span class="ft18">| COMP of comp</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:513"><nobr><span class="ft18">and value = VAR of string</span></nobr></DIV>
<DIV style="position:absolute;top:417;left:690"><nobr><span class="ft18">(* name *)</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:574"><nobr><span class="ft18">| LAM of string * term</span></nobr></DIV>
<DIV style="position:absolute;top:444;left:513"><nobr><span class="ft18">and</span></nobr></DIV>
<DIV style="position:absolute;top:444;left:544"><nobr><span class="ft18">comp = APP of term * term</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:477"><nobr><span class="ft3">Programs are closed terms.</span></nobr></DIV>
<DIV style="position:absolute;top:503;left:477"><nobr><span class="ft16"><i>2.2.1</i></span></nobr></DIV>
<DIV style="position:absolute;top:503;left:526"><nobr><span class="ft16"><i>The CEK abstract machine</i></span></nobr></DIV>
<DIV style="position:absolute;top:535;left:477"><nobr><span class="ft24">Our starting point reads as follows [19, Figure 2, page 239], where<br><i>t </i>denotes terms, <i>w </i>denotes values, <i>v </i>denotes expressible values, <i>k<br></i>denotes evaluation contexts, and <i>e </i>denotes environments:</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:492"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:507"><nobr><span class="ft3">Source syntax:</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:625"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:619;left:645"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:678"><nobr><span class="ft7"><i>w</i></span></nobr></DIV>
<DIV style="position:absolute;top:619;left:702"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:623;left:706"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:713"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:623;left:717"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:621"><nobr><span class="ft7"><i>w</i></span></nobr></DIV>
<DIV style="position:absolute;top:634;left:645"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:678"><nobr><span class="ft7"><i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:629;left:699"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:633;left:707"><nobr><span class="ft7"><i>x t</i></span></nobr></DIV>
<DIV style="position:absolute;top:673;left:492"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:507"><nobr><span class="ft3">Expressible values (closures) and evaluation contexts:</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:567"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:688;left:588"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:624"><nobr><span class="ft7"><i>x t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:703;left:567"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:703;left:588"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:621"><nobr><span class="ft18">stop</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:661"><nobr><span class="ft18">fun</span></nobr></DIV>
<DIV style="position:absolute;top:712;left:679"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:684"><nobr><span class="ft7"><i>v k</i></span></nobr></DIV>
<DIV style="position:absolute;top:712;left:700"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:722"><nobr><span class="ft18">arg</span></nobr></DIV>
<DIV style="position:absolute;top:712;left:740"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:703;left:745"><nobr><span class="ft7"><i>t e k</i></span></nobr></DIV>
<DIV style="position:absolute;top:712;left:772"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:492"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:507"><nobr><span class="ft11">Initial transition, transition rules (two kinds), and final transi-<br>tion:</span></nobr></DIV>
<DIV style="position:absolute;top:775;left:641"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:784;left:663"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:677"><nobr><span class="ft23"><i>init</i></span></nobr></DIV>
<DIV style="position:absolute;top:775;left:714"><nobr><span class="ft7"><i>t mt</i></span></nobr></DIV>
<DIV style="position:absolute;top:776;left:745"><nobr><span class="ft18">stop</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:607"><nobr><span class="ft7"><i>w e k</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:662"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:801;left:675"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:796;left:714"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:792;left:727"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:732"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:796;left:738"><nobr><span class="ft7"><i>w e</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:757"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:595"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:599"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:606"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:609"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:622"><nobr><span class="ft7"><i>e k</i></span></nobr></DIV>
<DIV style="position:absolute;top:820;left:662"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:675"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:811;left:714"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:717"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:730"><nobr><span class="ft7"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:813;left:743"><nobr><span class="ft18">arg</span></nobr></DIV>
<DIV style="position:absolute;top:820;left:761"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:766"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:816;left:770"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:781"><nobr><span class="ft7"><i>e k</i></span></nobr></DIV>
<DIV style="position:absolute;top:820;left:798"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:568"><nobr><span class="ft18">arg</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:586"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:591"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:837;left:594"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:606"><nobr><span class="ft7"><i>e k</i></span></nobr></DIV>
<DIV style="position:absolute;top:842;left:623"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:635"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:842;left:661"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:675"><nobr><span class="ft23"><i>cont</i></span></nobr></DIV>
<DIV style="position:absolute;top:833;left:714"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:837;left:717"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:730"><nobr><span class="ft7"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:835;left:743"><nobr><span class="ft18">fun</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:761"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:833;left:766"><nobr><span class="ft7"><i>v k</i></span></nobr></DIV>
<DIV style="position:absolute;top:842;left:782"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:551"><nobr><span class="ft18">fun</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:569"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:578"><nobr><span class="ft7"><i>x t e k</i></span></nobr></DIV>
<DIV style="position:absolute;top:857;left:623"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:635"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:857;left:661"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:675"><nobr><span class="ft23"><i>cont</i></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:714"><nobr><span class="ft7"><i>t e x</i></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:760"><nobr><span class="ft7"><i>v k</i></span></nobr></DIV>
<DIV style="position:absolute;top:871;left:604"><nobr><span class="ft18">stop</span></nobr></DIV>
<DIV style="position:absolute;top:869;left:635"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:878;left:661"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:674"><nobr><span class="ft23"><i>final</i></span></nobr></DIV>
<DIV style="position:absolute;top:869;left:709"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:898;left:507"><nobr><span class="ft3">where</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:566"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:907;left:571"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:577"><nobr><span class="ft7"><i>x e</i></span></nobr></DIV>
<DIV style="position:absolute;top:907;left:594"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:640"><nobr><span class="ft7"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:907;left:645"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:651"><nobr><span class="ft7"><i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:907;left:657"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:550"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:922;left:556"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:561"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:913;left:569"><nobr><span class="ft7"><i>x t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:922;left:594"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:913;left:643"><nobr><span class="ft7"><i>x t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:951;left:477"><nobr><span class="ft11">Variables <i>x </i>are represented by their name, and the abstract machine<br>consists of two mutually recursive transition functions. The first<br>transition function operates on triples consisting of a term, an envi-<br>ronment, and an evaluation context. The second operates on pairs<br>consisting of an evaluation context and an expressible value. Envi-<br>ronments are extended in the</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:634"><nobr><span class="ft18">fun</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:652"><nobr><span class="ft3">-transition, and consulted in</span></nobr></DIV>
<DIV style="position:absolute;top:1022;left:804"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:810"><nobr><span class="ft3">. The</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:477"><nobr><span class="ft3">empty environment is denoted by <i>mt</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:477"><nobr><span class="ft3">This specification is straightforward to program in ML:</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">11</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="11005.png" alt="background image">
<DIV style="position:absolute;top:116;left:93"><nobr><span class="ft22">signature ENV<br>= sig</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:118"><nobr><span class="ft22">type 'a env<br>val mt : 'a env<br>val lookup : 'a env * string -&gt; 'a<br>val extend : string * 'a * 'a env -&gt; 'a env</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:105"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:81"><nobr><span class="ft3">Environments are represented as a structure</span></nobr></DIV>
<DIV style="position:absolute;top:226;left:326"><nobr><span class="ft18">Env : ENV</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:385"><nobr><span class="ft3">containing</span></nobr></DIV>
<DIV style="position:absolute;top:239;left:81"><nobr><span class="ft3">a representation of the empty environment</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:315"><nobr><span class="ft18">mt</span></nobr></DIV>
<DIV style="position:absolute;top:239;left:327"><nobr><span class="ft3">, an operation</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:406"><nobr><span class="ft18">lookup</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:81"><nobr><span class="ft11">to retrieve the value bound to a name in an environment, and an<br>operation</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:135"><nobr><span class="ft18">extend</span></nobr></DIV>
<DIV style="position:absolute;top:269;left:175"><nobr><span class="ft3">to extend an environment with a binding.</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:93"><nobr><span class="ft22">structure Eval0<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:118"><nobr><span class="ft18">datatype expval</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:172"><nobr><span class="ft18">= CLOSURE of string * term * expval Env.env</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:118"><nobr><span class="ft18">datatype ev_context</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:172"><nobr><span class="ft22">= STOP<br>| ARG of term * expval Env.env * ev_context<br>| FUN of expval * ev_context</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:142"><nobr><span class="ft18">eval : term * expval Env.env * ev_context</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:404"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:185"><nobr><span class="ft18">-&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:404"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:118"><nobr><span class="ft18">fun eval (VALUE v, e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:142"><nobr><span class="ft18">= continue (k, eval_value (v, e))</span></nobr></DIV>
<DIV style="position:absolute;top:474;left:130"><nobr><span class="ft18">| eval (COMP (APP (t0, t1)), e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:142"><nobr><span class="ft18">= eval (t0, e, ARG (t1, e, k))</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:118"><nobr><span class="ft18">and eval_value (VAR x, e)</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:142"><nobr><span class="ft18">= Env.lookup (e, x)</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:130"><nobr><span class="ft18">| eval_value (LAM (x, t), e)</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:142"><nobr><span class="ft18">= CLOSURE (x, t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:118"><nobr><span class="ft18">and continue (STOP, w)</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:142"><nobr><span class="ft18">= w</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:130"><nobr><span class="ft18">| continue (ARG (t1, e, k), w)</span></nobr></DIV>
<DIV style="position:absolute;top:595;left:142"><nobr><span class="ft18">= eval (t1, e, FUN (w, k))</span></nobr></DIV>
<DIV style="position:absolute;top:609;left:130"><nobr><span class="ft18">| continue (FUN (CLOSURE (x, t, e), k), w)</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:142"><nobr><span class="ft18">= eval (t, Env.extend (x, w, e), k)</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:142"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:649;left:282"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:118"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:142"><nobr><span class="ft18">= eval (t, Env.mt, STOP)</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:105"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:81"><nobr><span class="ft16"><i>2.2.2</i></span></nobr></DIV>
<DIV style="position:absolute;top:720;left:130"><nobr><span class="ft20"><i>Refunctionalizing the evaluation contexts into<br>continuations</i></span></nobr></DIV>
<DIV style="position:absolute;top:769;left:81"><nobr><span class="ft3">We identify that the data type</span></nobr></DIV>
<DIV style="position:absolute;top:771;left:241"><nobr><span class="ft18">ev context</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:303"><nobr><span class="ft3">and the function</span></nobr></DIV>
<DIV style="position:absolute;top:771;left:393"><nobr><span class="ft18">continue</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:81"><nobr><span class="ft11">are a defunctionalized representation. The corresponding higher-<br>order evaluator reads as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:279"><nobr><span class="ft3">As can be observed, it is in</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:81"><nobr><span class="ft3">continuation-passing style.</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:93"><nobr><span class="ft22">structure Eval1<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:118"><nobr><span class="ft18">datatype expval</span></nobr></DIV>
<DIV style="position:absolute;top:884;left:172"><nobr><span class="ft18">= CLOSURE of string * term * expval Env.env</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:142"><nobr><span class="ft18">eval : term * expval Env.env * (expval -&gt; 'a)</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:429"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:185"><nobr><span class="ft18">-&gt; 'a</span></nobr></DIV>
<DIV style="position:absolute;top:925;left:429"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:118"><nobr><span class="ft18">fun eval (VALUE v, e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:142"><nobr><span class="ft18">= k (eval_value (v, e))</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:130"><nobr><span class="ft18">| eval (COMP (APP (t0, t1)), e, k)</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:142"><nobr><span class="ft18">= eval (t0, e,</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:191"><nobr><span class="ft22">fn (CLOSURE (x, t, e'))<br>=&gt; eval (t1, e,</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:246"><nobr><span class="ft22">fn w<br>=&gt; eval (t, Env.extend (x, w, e'),</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:300"><nobr><span class="ft18">k)))</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:118"><nobr><span class="ft18">and eval_value (VAR x, e)</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:142"><nobr><span class="ft18">= Env.lookup (e, x)</span></nobr></DIV>
<DIV style="position:absolute;top:116;left:526"><nobr><span class="ft18">| eval_value (LAM (x, t), e)</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:538"><nobr><span class="ft18">= CLOSURE (x, t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:538"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:678"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:513"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:538"><nobr><span class="ft18">= eval (t, Env.mt, fn w =&gt; w)</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:501"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:477"><nobr><span class="ft11">The following proposition is a corollary of the correctness of de-<br>functionalization. (Observational equivalence reduces here to struc-<br>tural equality over ML values of type</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:681"><nobr><span class="ft18">expval</span></nobr></DIV>
<DIV style="position:absolute;top:255;left:718"><nobr><span class="ft3">.)</span></nobr></DIV>
<DIV style="position:absolute;top:285;left:477"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:287;left:485"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:285;left:559"><nobr><span class="ft3">5</span></nobr></DIV>
<DIV style="position:absolute;top:285;left:581"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:287;left:586"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:285;left:702"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:477"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:302;left:576"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:629"><nobr><span class="ft7"><i>denoting a program,</i></span></nobr></DIV>
<DIV style="position:absolute;top:327;left:572"><nobr><span class="ft18">Eval0.main p</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:669"><nobr><span class="ft18">Eval1.main p</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:477"><nobr><span class="ft16"><i>2.2.3</i></span></nobr></DIV>
<DIV style="position:absolute;top:367;left:526"><nobr><span class="ft16"><i>Back to direct style</i></span></nobr></DIV>
<DIV style="position:absolute;top:399;left:477"><nobr><span class="ft11">CPS-transforming the following direct-style evaluator yields the<br>evaluator of Section 2.2.2 [10].</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:489"><nobr><span class="ft22">structure Eval2<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:513"><nobr><span class="ft18">datatype expval</span></nobr></DIV>
<DIV style="position:absolute;top:485;left:568"><nobr><span class="ft18">= CLOSURE of string * term * expval Env.env</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:538"><nobr><span class="ft18">eval : term * expval Env.env -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:512;left:782"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:513"><nobr><span class="ft18">fun eval (VALUE v, e)</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:538"><nobr><span class="ft18">= eval_value (v, e)</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:526"><nobr><span class="ft18">| eval (COMP (APP (t0, t1)), e)</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:538"><nobr><span class="ft18">= let val (CLOSURE (x, t, e')) = eval (t0, e)</span></nobr></DIV>
<DIV style="position:absolute;top:579;left:574"><nobr><span class="ft18">val w = eval (t1, e)</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:550"><nobr><span class="ft22">in eval (t, Env.extend (x, w, e'))<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:513"><nobr><span class="ft18">and eval_value (VAR x, e)</span></nobr></DIV>
<DIV style="position:absolute;top:633;left:538"><nobr><span class="ft18">= Env.lookup (e, x)</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:526"><nobr><span class="ft18">| eval_value (LAM (x, t), e)</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:538"><nobr><span class="ft18">= CLOSURE (x, t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:538"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:687;left:678"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:513"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:714;left:538"><nobr><span class="ft18">= eval (t, Env.mt)</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:501"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:477"><nobr><span class="ft11">The following proposition is a corollary of the correctness of the<br>direct-style transformation. (Again, observational equivalence re-<br>duces here to structural equality over ML values of type</span></nobr></DIV>
<DIV style="position:absolute;top:788;left:782"><nobr><span class="ft18">expval</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:819"><nobr><span class="ft3">.)</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:477"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:485"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:559"><nobr><span class="ft3">6</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:581"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:586"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:816;left:702"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:477"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:833;left:576"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:831;left:629"><nobr><span class="ft7"><i>denoting a program,</i></span></nobr></DIV>
<DIV style="position:absolute;top:858;left:572"><nobr><span class="ft18">Eval1.main p</span></nobr></DIV>
<DIV style="position:absolute;top:858;left:669"><nobr><span class="ft18">Eval2.main p</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:477"><nobr><span class="ft16"><i>2.2.4</i></span></nobr></DIV>
<DIV style="position:absolute;top:898;left:526"><nobr><span class="ft16"><i>From closures to higher-order functions</i></span></nobr></DIV>
<DIV style="position:absolute;top:930;left:477"><nobr><span class="ft3">We observe that the closures, in</span></nobr></DIV>
<DIV style="position:absolute;top:932;left:661"><nobr><span class="ft18">Eval2</span></nobr></DIV>
<DIV style="position:absolute;top:930;left:691"><nobr><span class="ft3">, are defunctionalized rep-</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:477"><nobr><span class="ft11">resentations with an apply function inlined. The corresponding<br>higher-order evaluator reads as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:990;left:489"><nobr><span class="ft22">structure Eval3<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:1017;left:513"><nobr><span class="ft18">datatype expval = CLOSURE of expval -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:1044;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:1044;left:538"><nobr><span class="ft18">eval : term * expval Env.env -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:1044;left:782"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:513"><nobr><span class="ft18">fun eval (VALUE v, e)</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:538"><nobr><span class="ft18">= eval_value (v, e)</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">12</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="11006.png" alt="background image">
<DIV style="position:absolute;top:116;left:130"><nobr><span class="ft18">| eval (COMP (APP (t0, t1)), e)</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:142"><nobr><span class="ft18">= let val (CLOSURE f) = eval (t0, e)</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:179"><nobr><span class="ft18">val w = eval (t1, e)</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:154"><nobr><span class="ft22">in f w<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:118"><nobr><span class="ft18">and eval_value (VAR x, e)</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:142"><nobr><span class="ft18">= Env.lookup (e, x)</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:130"><nobr><span class="ft18">| eval_value (LAM (x, t), e)</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:142"><nobr><span class="ft18">= CLOSURE (fn w</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:209"><nobr><span class="ft18">=&gt; eval (t, Env.extend (x, w, e)))</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:142"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:282"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:118"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:142"><nobr><span class="ft18">= eval (t, Env.mt)</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:105"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:81"><nobr><span class="ft11">The following proposition is a corollary of the correctness of de-<br>functionalization.</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:81"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:90"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:163"><nobr><span class="ft3">7</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:185"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:190"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:306"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:393;left:81"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:394;left:200"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:393;left:256"><nobr><span class="ft7"><i>denoting a program, evaluating</i></span></nobr></DIV>
<DIV style="position:absolute;top:409;left:81"><nobr><span class="ft18">Eval2.main p</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:161"><nobr><span class="ft7"><i>yields a value</i></span></nobr></DIV>
<DIV style="position:absolute;top:409;left:248"><nobr><span class="ft18">CLOSURE (x, t, e)</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:358"><nobr><span class="ft7"><i>and evaluating</i></span></nobr></DIV>
<DIV style="position:absolute;top:424;left:81"><nobr><span class="ft18">Eval3.main p</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:158"><nobr><span class="ft7"><i>yields a value</i></span></nobr></DIV>
<DIV style="position:absolute;top:424;left:235"><nobr><span class="ft18">CLOSURE f</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:293"><nobr><span class="ft7"><i>such that</i></span></nobr></DIV>
<DIV style="position:absolute;top:450;left:112"><nobr><span class="ft18">fn w =&gt; Eval2.eval (t, Env.extend (x, w, e))</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:404"><nobr><span class="ft18">f</span></nobr></DIV>
<DIV style="position:absolute;top:489;left:81"><nobr><span class="ft16"><i>2.2.5</i></span></nobr></DIV>
<DIV style="position:absolute;top:489;left:130"><nobr><span class="ft20"><i>A higher-order and compositional call-by-<br>value evaluator</i></span></nobr></DIV>
<DIV style="position:absolute;top:537;left:81"><nobr><span class="ft3">The result in</span></nobr></DIV>
<DIV style="position:absolute;top:539;left:159"><nobr><span class="ft18">Eval3</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:194"><nobr><span class="ft3">is a call-by-value evaluator that is composi-</span></nobr></DIV>
<DIV style="position:absolute;top:552;left:81"><nobr><span class="ft11">tional and higher-order. This call-by-value evaluator is the canoni-<br>cal one for the</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:164"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:567;left:171"><nobr><span class="ft3">-calculus [31, 35, 37]. We conclude that the CEK</span></nobr></DIV>
<DIV style="position:absolute;top:582;left:81"><nobr><span class="ft11">machine can be seen as a defunctionalized, CPS-transformed, and<br>closure-converted version of the standard call-by-value evaluator<br>for</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:100"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:612;left:107"><nobr><span class="ft3">-terms.</span></nobr></DIV>
<DIV style="position:absolute;top:647;left:81"><nobr><span class="ft4"><b>2.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:647;left:121"><nobr><span class="ft21"><b>Variants of Krivine's machine and of the<br>CEK machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:698;left:81"><nobr><span class="ft3">It is easy to construct a variant of Krivine's abstract machine for</span></nobr></DIV>
<DIV style="position:absolute;top:693;left:430"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:698;left:437"><nobr><span class="ft3">-</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:81"><nobr><span class="ft3">terms with names, by starting from a call-by-name evaluator for</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:81"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:727;left:88"><nobr><span class="ft3">-terms with names. Similarly, it is easy to construct a variant</span></nobr></DIV>
<DIV style="position:absolute;top:742;left:81"><nobr><span class="ft3">of the CEK machine for</span></nobr></DIV>
<DIV style="position:absolute;top:738;left:219"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:742;left:227"><nobr><span class="ft3">-terms with de Bruijn indices, by start-</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:81"><nobr><span class="ft3">ing from a call-by-value evaluator for</span></nobr></DIV>
<DIV style="position:absolute;top:753;left:295"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:757;left:302"><nobr><span class="ft3">-terms with indices. It is</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:81"><nobr><span class="ft3">equally easy to start from a call-by-value evaluator for</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:373"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:772;left:381"><nobr><span class="ft3">-terms with</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:81"><nobr><span class="ft11">de Bruijn indices and no distinction between values and computa-<br>tions; the resulting abstract machine coincides with Hankin's eager<br>machine [22, Section 8.1.2].</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:81"><nobr><span class="ft3">Abstract machines processing</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:246"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:847;left:253"><nobr><span class="ft3">-terms with de Bruijn indices often</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:81"><nobr><span class="ft3">resolve indices with transitions:</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:204"><nobr><span class="ft3">0 <i>v </i>:: <i>e s</i></span></nobr></DIV>
<DIV style="position:absolute;top:909;left:275"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:303"><nobr><span class="ft7"><i>v </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:915;left:183"><nobr><span class="ft7"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:924;left:191"><nobr><span class="ft2">·</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:203"><nobr><span class="ft3">1 <i>v </i>:: <i>e s</i></span></nobr></DIV>
<DIV style="position:absolute;top:924;left:275"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:308"><nobr><span class="ft7"><i>n e s</i></span></nobr></DIV>
<DIV style="position:absolute;top:955;left:81"><nobr><span class="ft11">Compared to the evaluator of Section 2.1.1, the evaluator corre-<br>sponding to this machine has</span></nobr></DIV>
<DIV style="position:absolute;top:972;left:242"><nobr><span class="ft18">List.nth</span></nobr></DIV>
<DIV style="position:absolute;top:970;left:295"><nobr><span class="ft3">inlined and is not composi-</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:81"><nobr><span class="ft3">tional:</span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:105"><nobr><span class="ft18">fun eval (IND 0, denval :: e, s)</span></nobr></DIV>
<DIV style="position:absolute;top:1029;left:130"><nobr><span class="ft18">= ... denval ...</span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:118"><nobr><span class="ft18">| eval (IND n, denval :: e, s)</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:130"><nobr><span class="ft18">= eval (IND (n - 1), e, s)</span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:118"><nobr><span class="ft18">| ...</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:477"><nobr><span class="ft4"><b>2.4</b></span></nobr></DIV>
<DIV style="position:absolute;top:111;left:517"><nobr><span class="ft4"><b>Conclusion</b></span></nobr></DIV>
<DIV style="position:absolute;top:140;left:477"><nobr><span class="ft11">We have shown that Krivine's abstract machine and the CEK ab-<br>stract machine are counterparts of canonical evaluators for call-by-<br>name and for call-by-value</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:626"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:169;left:633"><nobr><span class="ft3">-terms, respectively. The derivation of</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:477"><nobr><span class="ft11">Krivine's machine is strikingly simpler than what can be found in<br>the literature. That the CEK machine can be derived is, to the best<br>of our knowledge, new. That these two machines are two sides of<br>the same coin is also new. We have not explored any other aspect<br>of this call-by-name/call-by-value duality [9].</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:477"><nobr><span class="ft11">Using substitutions instead of environments or inlining one of the<br>standard computational monads (state, continuations, etc. [39]) in<br>the call-by-value evaluator yields variants of the CEK machine that<br>have been documented in the literature [16, Chapter 8]. For ex-<br>ample, inlining the state monad in a monadic evaluator yields a<br>state-passing evaluator. The corresponding abstract machine has<br>one more component to represent the state. In general, inlining<br>monads provides a generic recipe to construct arbitrarily many new<br>abstract machines. It does not seem as straightforward, however, to<br>construct a "monadic abstract machine" and then to inline a monad;<br>we are currently studying the issue.</span></nobr></DIV>
<DIV style="position:absolute;top:454;left:477"><nobr><span class="ft11">On another note, one can consider an evaluator for strictness-<br>annotated</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:533"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:468;left:540"><nobr><span class="ft3">-terms--represented either with names or with indices,</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:477"><nobr><span class="ft11">and with or without distinction between values and computations.<br>One is then led to an abstract machine that generalizes Krivine's<br>machine and the CEK machine [13].</span></nobr></DIV>
<DIV style="position:absolute;top:543;left:477"><nobr><span class="ft11">Finally, it is straightforward to extend Krivine's machine and the<br>CEK machine to bigger source languages (with literals, primi-<br>tive operations, conditional expressions, block structure, recursion,<br>etc.), by starting from evaluators for these bigger languages. For<br>example, all the abstract machines in "The essence of compiling<br>with continuations" [19] are defunctionalized continuation-passing<br>evaluators, i.e., interpreters.</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:477"><nobr><span class="ft11">In the rest of this article, we illustrate further the correspondence<br>between evaluators and abstract machines.</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:477"><nobr><span class="ft4"><b>3</b></span></nobr></DIV>
<DIV style="position:absolute;top:713;left:504"><nobr><span class="ft4"><b>The CLS abstract machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:742;left:477"><nobr><span class="ft11">The CLS abstract machine is due to Hannan and Miller [23]. In the<br>following, <i>t </i>denotes terms, <i>v </i>denotes expressible values, <i>c </i>denotes<br>lists of directives (a term or the special tag</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:713"><nobr><span class="ft18">ap</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:726"><nobr><span class="ft3">), <i>e </i>denotes environ-</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:477"><nobr><span class="ft11">ments, <i>l </i>denotes stacks of environments, and <i>s </i>denotes stacks of<br>expressible values.</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:492"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:507"><nobr><span class="ft3">Source syntax:</span></nobr></DIV>
<DIV style="position:absolute;top:854;left:610"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:854;left:630"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:854;left:663"><nobr><span class="ft7"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:850;left:685"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:854;left:692"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:854;left:712"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:858;left:716"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:854;left:723"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:858;left:727"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:896;left:492"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:507"><nobr><span class="ft3">Expressible values (closures):</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:633"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:909;left:654"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:690"><nobr><span class="ft7"><i>t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:951;left:492"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:942;left:507"><nobr><span class="ft3">Initial transition, transition rules, and final transition:</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:632"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:977;left:651"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:685"><nobr><span class="ft7"><i>t </i>:: <i>nil nil </i>:: <i>nil nil</i></span></nobr></DIV>
<DIV style="position:absolute;top:985;left:558"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:990;left:565"><nobr><span class="ft7"><i>t </i>:: <i>c e </i>:: <i>l s</i></span></nobr></DIV>
<DIV style="position:absolute;top:999;left:651"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:990;left:685"><nobr><span class="ft7"><i>c l t e </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:539"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:544"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:547"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:554"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:558"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:564"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:572"><nobr><span class="ft3">:: <i>c e </i>:: <i>l s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:651"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:685"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:689"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:698"><nobr><span class="ft3">:: <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:711"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:720"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:731"><nobr><span class="ft18">ap</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:746"><nobr><span class="ft3">:: <i>c e </i>:: <i>e </i>:: <i>l s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:533"><nobr><span class="ft3">0 :: <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:566"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:571"><nobr><span class="ft7"><i>v </i>:: <i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:596"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:604"><nobr><span class="ft3">:: <i>l s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:651"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:685"><nobr><span class="ft7"><i>c l v </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:512"><nobr><span class="ft7"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:520"><nobr><span class="ft2">·</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:533"><nobr><span class="ft3">1 :: <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:566"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:571"><nobr><span class="ft7"><i>v </i>:: <i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:596"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:605"><nobr><span class="ft3">:: <i>l s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:651"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:685"><nobr><span class="ft7"><i>n </i>:: <i>c e </i>:: <i>l s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:519"><nobr><span class="ft18">ap</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:534"><nobr><span class="ft3">:: <i>c l v </i>:: <i>t e </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:651"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:684"><nobr><span class="ft7"><i>t </i>:: <i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:715"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:720"><nobr><span class="ft7"><i>v </i>:: <i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:746"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:754"><nobr><span class="ft3">:: <i>l s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:565"><nobr><span class="ft7"><i>nil nil v </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1080;left:651"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:680"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">13</span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="11007.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft11">Variables <i>n </i>are represented by their de Bruijn index, and the abstract<br>machine operates on triples consisting of a list of directives, a stack<br>of environments, and a stack of expressible values.</span></nobr></DIV>
<DIV style="position:absolute;top:182;left:81"><nobr><span class="ft4"><b>3.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:182;left:121"><nobr><span class="ft4"><b>The CLS machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:214;left:81"><nobr><span class="ft11">Hannan and Miller's specification is straightforward to program in<br>ML:</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:93"><nobr><span class="ft18">datatype term = IND of int</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:276"><nobr><span class="ft18">(* de Bruijn index *)</span></nobr></DIV>
<DIV style="position:absolute;top:274;left:179"><nobr><span class="ft22">| ABS of term<br>| APP of term * term</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:81"><nobr><span class="ft3">Programs are closed terms.</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:93"><nobr><span class="ft22">structure Eval0<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:375;left:118"><nobr><span class="ft18">datatype directive = TERM of term</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:233"><nobr><span class="ft18">| AP</span></nobr></DIV>
<DIV style="position:absolute;top:402;left:118"><nobr><span class="ft18">datatype env = ENV of expval list</span></nobr></DIV>
<DIV style="position:absolute;top:415;left:130"><nobr><span class="ft18">and expval = CLOSURE of term * env</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:142"><nobr><span class="ft18">run : directive list * env list * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:429"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:361"><nobr><span class="ft18">-&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:429"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:469;left:118"><nobr><span class="ft18">fun run (nil, nil, v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:483;left:142"><nobr><span class="ft18">= v</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:130"><nobr><span class="ft18">| run ((TERM (IND 0)) :: c, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:510;left:142"><nobr><span class="ft18">= run (c, l, v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:130"><nobr><span class="ft18">| run ((TERM (IND n)) :: c, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:536;left:142"><nobr><span class="ft18">= run ((TERM (IND (n - 1))) :: c,</span></nobr></DIV>
<DIV style="position:absolute;top:550;left:185"><nobr><span class="ft22">(ENV e) :: l,<br>s)</span></nobr></DIV>
<DIV style="position:absolute;top:577;left:130"><nobr><span class="ft18">| run ((TERM (ABS t)) :: c, e :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:590;left:142"><nobr><span class="ft18">= run (c, l, (CLOSURE (t, e)) :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:130"><nobr><span class="ft18">| run ((TERM (APP (t0, t1))) :: c, e :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:142"><nobr><span class="ft18">= run ((TERM t0) :: (TERM t1) :: AP :: c,</span></nobr></DIV>
<DIV style="position:absolute;top:631;left:185"><nobr><span class="ft22">e :: e :: l,<br>s)</span></nobr></DIV>
<DIV style="position:absolute;top:658;left:130"><nobr><span class="ft18">| run (AP :: c, l, v :: (CLOSURE (t, ENV e)) :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:142"><nobr><span class="ft18">= run ((TERM t) :: c, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:698;left:142"><nobr><span class="ft18">main : term -&gt; expval *)</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:118"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:725;left:142"><nobr><span class="ft18">= run ((TERM t) :: nil, (ENV nil) :: nil, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:738;left:105"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:81"><nobr><span class="ft4"><b>3.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:774;left:121"><nobr><span class="ft21"><b>A disentangled definition of the CLS ma-<br>chine</b></span></nobr></DIV>
<DIV style="position:absolute;top:825;left:81"><nobr><span class="ft11">In the definition of Section 3.1, all the possible transitions are<br>meshed together in one recursive function,</span></nobr></DIV>
<DIV style="position:absolute;top:842;left:316"><nobr><span class="ft18">run</span></nobr></DIV>
<DIV style="position:absolute;top:840;left:334"><nobr><span class="ft3">. Instead, let us fac-</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:81"><nobr><span class="ft3">tor</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:99"><nobr><span class="ft18">run</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:121"><nobr><span class="ft3">into several mutually recursive functions, each of them with</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:81"><nobr><span class="ft3">one induction variable.</span></nobr></DIV>
<DIV style="position:absolute;top:900;left:81"><nobr><span class="ft3">In this disentangled definition,</span></nobr></DIV>
<DIV style="position:absolute;top:935;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:111"><nobr><span class="ft18">run c</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:144"><nobr><span class="ft3">interprets the list of control directives, i.e., it specifies</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:111"><nobr><span class="ft11">which transition to take if the list is empty, starts with a term,<br>or starts with an apply directive. If the list is empty, the com-<br>putation terminates. If the list starts with a term,</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:398"><nobr><span class="ft18">run t</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:432"><nobr><span class="ft3">is</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:111"><nobr><span class="ft11">called, caching the term in the first parameter. If the list starts<br>with an apply directive,</span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:241"><nobr><span class="ft18">run a</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:273"><nobr><span class="ft3">is called.</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:1024;left:111"><nobr><span class="ft18">run t</span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:143"><nobr><span class="ft3">interprets the top term in the list of control directives.</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:111"><nobr><span class="ft18">run a</span></nobr></DIV>
<DIV style="position:absolute;top:1044;left:143"><nobr><span class="ft3">interprets the top value in the current stack.</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:81"><nobr><span class="ft3">The disentangled definition reads as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:116;left:489"><nobr><span class="ft22">structure Eval1<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:513"><nobr><span class="ft18">datatype directive = TERM of term</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:629"><nobr><span class="ft18">| AP</span></nobr></DIV>
<DIV style="position:absolute;top:169;left:513"><nobr><span class="ft18">datatype env = ENV of expval list</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:526"><nobr><span class="ft18">and expval = CLOSURE of term * env</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:538"><nobr><span class="ft18">run_c : directive list * env list * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:210;left:836"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:587"><nobr><span class="ft18">-&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:654"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:513"><nobr><span class="ft18">fun run_c (nil, nil, v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:538"><nobr><span class="ft18">= v</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:526"><nobr><span class="ft18">| run_c ((TERM t) :: c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:538"><nobr><span class="ft18">= run_t (t, c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:526"><nobr><span class="ft18">| run_c (AP :: c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:538"><nobr><span class="ft18">= run_a (c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:513"><nobr><span class="ft18">and run_t (IND 0, c, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:538"><nobr><span class="ft18">= run_c (c, l, v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:526"><nobr><span class="ft18">| run_t (IND n, c, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:538"><nobr><span class="ft18">= run_t (IND (n - 1), c, (ENV e) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:526"><nobr><span class="ft18">| run_t (ABS t, c, e :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:538"><nobr><span class="ft18">= run_c (c, l, (CLOSURE (t, e)) :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:526"><nobr><span class="ft18">| run_t (APP (t0, t1), c, e :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:538"><nobr><span class="ft18">= run_t (t0,</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:593"><nobr><span class="ft22">(TERM t1) :: AP :: c,<br>e :: e :: l,<br>s)</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:513"><nobr><span class="ft18">and run_a (c, l, v :: (CLOSURE (t, ENV e)) :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:479;left:538"><nobr><span class="ft18">= run_t (t, c, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:538"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:678"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:513"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:538"><nobr><span class="ft18">= run_t (t, nil, (ENV nil) :: nil, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:501"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:477"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:485"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:559"><nobr><span class="ft3">8</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:581"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:586"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:702"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:477"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:586;left:576"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:629"><nobr><span class="ft7"><i>denoting a program,</i></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:572"><nobr><span class="ft18">Eval0.main p</span></nobr></DIV>
<DIV style="position:absolute;top:606;left:669"><nobr><span class="ft18">Eval1.main p</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:477"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:485"><nobr><span class="ft9">ROOF</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:516"><nobr><span class="ft3">. By fold-unfold [5]. The invariants are as follows. For any</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:477"><nobr><span class="ft3">ML values</span></nobr></DIV>
<DIV style="position:absolute;top:650;left:538"><nobr><span class="ft18">t : term</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:587"><nobr><span class="ft3">,</span></nobr></DIV>
<DIV style="position:absolute;top:650;left:593"><nobr><span class="ft18">e : expval list</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:685"><nobr><span class="ft3">, and</span></nobr></DIV>
<DIV style="position:absolute;top:650;left:714"><nobr><span class="ft18">s : expval list</span></nobr></DIV>
<DIV style="position:absolute;top:648;left:806"><nobr><span class="ft3">,</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:496"><nobr><span class="ft18">Eval1.run c (c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:647"><nobr><span class="ft18">Eval0.run (c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:478"><nobr><span class="ft18">Eval1.run t (t, c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:685;left:647"><nobr><span class="ft18">Eval0.run ((TERM t) :: c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:496"><nobr><span class="ft18">Eval1.run a (c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:647"><nobr><span class="ft18">Eval0.run (AP :: c, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:477"><nobr><span class="ft4"><b>3.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:517"><nobr><span class="ft21"><b>The evaluator corresponding to the CLS<br>machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:778;left:477"><nobr><span class="ft11">In the disentangled definition of Section 3.2, there are three possible<br>ways to construct a list of control directives (nil, cons'ing a term,<br>and cons'ing an apply directive). We could specify these construc-<br>tions as a data type rather than as a list. Such a data type, together<br>with</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:504"><nobr><span class="ft18">run c</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:532"><nobr><span class="ft3">, is in the image of defunctionalization (</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:745"><nobr><span class="ft18">run c</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:776"><nobr><span class="ft3">is the apply</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:477"><nobr><span class="ft11">functions of the data type). The corresponding higher-order evalu-<br>ator is in continuation-passing style. Transforming it back to direct<br>style yields the following evaluator:</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:489"><nobr><span class="ft22">structure Eval3<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:513"><nobr><span class="ft18">datatype env = ENV of expval list</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:526"><nobr><span class="ft18">and expval = CLOSURE of term * env</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:538"><nobr><span class="ft18">run_t : term * env list * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:776"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:611"><nobr><span class="ft18">-&gt; env list * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:776"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:513"><nobr><span class="ft18">fun run_t (IND 0, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:538"><nobr><span class="ft18">= (l, v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:1032;left:526"><nobr><span class="ft18">| run_t (IND n, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:538"><nobr><span class="ft18">= run_t (IND (n - 1), (ENV e) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:526"><nobr><span class="ft18">| run_t (ABS t, e :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:538"><nobr><span class="ft18">= (l, (CLOSURE (t, e)) :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">14</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="11008.png" alt="background image">
<DIV style="position:absolute;top:116;left:130"><nobr><span class="ft18">| run_t (APP (t0, t1), e :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:142"><nobr><span class="ft18">= let val (l, s) = run_t (t0, e :: e :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:179"><nobr><span class="ft18">val (l, s) = run_t (t1, l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:154"><nobr><span class="ft22">in run_a (l, s)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:118"><nobr><span class="ft18">and run_a (l, v :: (CLOSURE (t, ENV e)) :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:142"><nobr><span class="ft18">= run_t (t, (ENV (v :: e)) :: l, s)</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:142"><nobr><span class="ft18">main : term -&gt; expval *)</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:118"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:142"><nobr><span class="ft18">= let val (nil, v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:203"><nobr><span class="ft18">= run_t (t, (ENV nil) :: nil, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:154"><nobr><span class="ft22">in v<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:105"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:81"><nobr><span class="ft12">The following proposition is a corollary of the correctness of de-<br>functionalization and of the CPS transformation. (Here observa-<br>tional equivalence reduces to structural equality over ML values of<br>type</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:108"><nobr><span class="ft18">expval</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:144"><nobr><span class="ft3">.)</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:81"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:90"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:163"><nobr><span class="ft3">9</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:185"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:190"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:306"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:81"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:424;left:181"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:233"><nobr><span class="ft7"><i>denoting a program,</i></span></nobr></DIV>
<DIV style="position:absolute;top:448;left:176"><nobr><span class="ft18">Eval1.main p</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:273"><nobr><span class="ft18">Eval3.main p</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:81"><nobr><span class="ft12">As in Section 2, this evaluator can be made compositional by re-<br>functionalizing the closures into higher-order functions and by fac-<br>toring the resolution of de Bruijn indices into an auxiliary lookup<br>function.</span></nobr></DIV>
<DIV style="position:absolute;top:561;left:81"><nobr><span class="ft11">We conclude that the evaluation model embodied in the CLS ma-<br>chine is a call-by-value interpreter threading a stack of environ-<br>ments and a stack of intermediate results with a caller-save strategy<br>(witness the duplication of environments on the stack in the mean-<br>ing of applications) and with a left-to-right evaluation of sub-terms.<br>In particular, the meaning of a term is a partial endofunction over a<br>stack of environments and a stack of intermediate results.</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:81"><nobr><span class="ft4"><b>4</b></span></nobr></DIV>
<DIV style="position:absolute;top:692;left:108"><nobr><span class="ft4"><b>The SECD abstract machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:725;left:81"><nobr><span class="ft11">The SECD abstract machine is due to Landin [26]. In the follow-<br>ing, <i>t </i>denotes terms, <i>v </i>denotes expressible values, <i>c </i>denotes lists of<br>directives (a term or the special tag</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:277"><nobr><span class="ft18">ap</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:289"><nobr><span class="ft3">), <i>e </i>denotes environments, <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:770;left:81"><nobr><span class="ft11">denotes stacks of expressible values, and <i>d </i>denotes dumps (list of<br>triples consisting of a stack, an environment and a list of directives).</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:815;left:111"><nobr><span class="ft3">Source syntax:</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:210"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:230"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:262"><nobr><span class="ft7"><i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:835;left:284"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:292"><nobr><span class="ft7"><i>x t</i></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:321"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:844;left:325"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:332"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:844;left:336"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:880;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:111"><nobr><span class="ft3">Expressible values (closures):</span></nobr></DIV>
<DIV style="position:absolute;top:896;left:231"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:896;left:251"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:896;left:288"><nobr><span class="ft7"><i>x t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:937;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:111"><nobr><span class="ft3">Initial transition, transition rules, and final transition:</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:246"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:961;left:265"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:952;left:299"><nobr><span class="ft7"><i>nil mt t </i>:: <i>nil nil</i></span></nobr></DIV>
<DIV style="position:absolute;top:974;left:181"><nobr><span class="ft7"><i>s e x </i>:: <i>c d</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:265"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:299"><nobr><span class="ft7"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:305"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:310"><nobr><span class="ft7"><i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:316"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:325"><nobr><span class="ft3">:: <i>s e c d</i></span></nobr></DIV>
<DIV style="position:absolute;top:989;left:155"><nobr><span class="ft7"><i>s e</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:180"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:185"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:989;left:192"><nobr><span class="ft7"><i>x t</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:206"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:989;left:215"><nobr><span class="ft3">:: <i>c d</i></span></nobr></DIV>
<DIV style="position:absolute;top:998;left:265"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:989;left:303"><nobr><span class="ft7"><i>x t e </i>:: <i>s e c d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:156"><nobr><span class="ft7"><i>s e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:181"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:186"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:190"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:197"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:200"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:206"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:215"><nobr><span class="ft3">:: <i>c d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:265"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:299"><nobr><span class="ft7"><i>s e t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:327"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:336"><nobr><span class="ft3">:: <i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1008;left:350"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:359"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:1006;left:369"><nobr><span class="ft18">ap</span></nobr></DIV>
<DIV style="position:absolute;top:1004;left:384"><nobr><span class="ft3">:: <i>c d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:105"><nobr><span class="ft7"><i>x t e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:135"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:145"><nobr><span class="ft3">:: <i>v </i>:: <i>s e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:199"><nobr><span class="ft18">ap</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:214"><nobr><span class="ft3">:: <i>c d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:265"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:299"><nobr><span class="ft7"><i>nil e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:326"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:333"><nobr><span class="ft7"><i>x</i></span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:359"><nobr><span class="ft7"><i>v t </i>:: <i>nil d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1023;left:421"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:297"><nobr><span class="ft7"><i>where d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:339"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:359"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:365"><nobr><span class="ft7"><i>s e c</i></span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:392"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:401"><nobr><span class="ft3">:: <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:109"><nobr><span class="ft7"><i>v </i>:: <i>s e nil</i></span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:174"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:179"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:184"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:193"><nobr><span class="ft7"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:199"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:208"><nobr><span class="ft7"><i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:215"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:219"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:227"><nobr><span class="ft3">:: <i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:265"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:299"><nobr><span class="ft7"><i>v </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:324"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:334"><nobr><span class="ft7"><i>e</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:340"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:350"><nobr><span class="ft7"><i>c</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:356"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:1049;left:366"><nobr><span class="ft7"><i>d</i></span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:166"><nobr><span class="ft7"><i>v </i>:: <i>s e nil nil</i></span></nobr></DIV>
<DIV style="position:absolute;top:1080;left:265"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:294"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft11">Variables <i>x </i>are represented by their name, and the abstract machine<br>operates on quadruples consisting of a stack of expressible values,<br>an environment, a list of directives, and a dump. Environments are<br>consulted in the first transition rule, and extended in the fourth. The<br>empty environment is denoted by <i>mt</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:477"><nobr><span class="ft4"><b>4.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:219;left:517"><nobr><span class="ft4"><b>The SECD machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:252;left:477"><nobr><span class="ft11">Landin's specification is straightforward to program in ML. Pro-<br>grams are closed terms. Environments are as in Section 2.2.</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:489"><nobr><span class="ft18">datatype term = VAR of string</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:690"><nobr><span class="ft18">(* name *)</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:574"><nobr><span class="ft22">| LAM of string * term<br>| APP of term * term</span></nobr></DIV>
<DIV style="position:absolute;top:354;left:489"><nobr><span class="ft22">structure Eval0<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:513"><nobr><span class="ft18">datatype directive = TERM of term</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:629"><nobr><span class="ft18">| AP</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:513"><nobr><span class="ft18">datatype value</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:568"><nobr><span class="ft18">= CLOSURE of string * term * value Env.env</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:513"><nobr><span class="ft18">fun run (v :: nil, e', nil, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:474;left:538"><nobr><span class="ft18">= v</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:526"><nobr><span class="ft18">| run (s, e, (TERM (VAR x)) :: c, d)</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:538"><nobr><span class="ft18">= run ((Env.lookup (e, x)) :: s, e, c, d)</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:526"><nobr><span class="ft18">| run (s, e, (TERM (LAM (x, t))) :: c, d)</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:538"><nobr><span class="ft18">= run ((CLOSURE (x, t, e)) :: s, e, c, d)</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:526"><nobr><span class="ft18">| run (s, e, (TERM (APP (t0, t1))) :: c, d)</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:538"><nobr><span class="ft18">= run (s,</span></nobr></DIV>
<DIV style="position:absolute;top:569;left:580"><nobr><span class="ft22">e,<br>(TERM t1) :: (TERM t0) :: AP :: c,<br>d)</span></nobr></DIV>
<DIV style="position:absolute;top:609;left:526"><nobr><span class="ft18">| run ((CLOSURE (x, t, e')) :: v :: s,</span></nobr></DIV>
<DIV style="position:absolute;top:622;left:568"><nobr><span class="ft22">e,<br>AP :: c,<br>d)</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:538"><nobr><span class="ft18">= run (nil,</span></nobr></DIV>
<DIV style="position:absolute;top:676;left:580"><nobr><span class="ft22">Env.extend (x, v, e'),<br>(TERM t) :: nil,<br>(s, e, c) :: d)</span></nobr></DIV>
<DIV style="position:absolute;top:717;left:526"><nobr><span class="ft18">| run (v :: nil, e', nil, (s, e, c) :: d)</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:538"><nobr><span class="ft18">= run (v :: s, e, c, d)</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:513"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:538"><nobr><span class="ft18">main : term -&gt; value</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:672"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:770;left:513"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:538"><nobr><span class="ft18">= run (nil, Env.mt, (TERM t) :: nil, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:501"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:841;left:477"><nobr><span class="ft4"><b>4.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:841;left:517"><nobr><span class="ft21"><b>A disentangled definition of the SECD ma-<br>chine</b></span></nobr></DIV>
<DIV style="position:absolute;top:892;left:477"><nobr><span class="ft11">As in the CLS machine, in the definition of Section 4.1, all the pos-<br>sible transitions are meshed together in one recursive function,</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:816"><nobr><span class="ft18">run</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:835"><nobr><span class="ft3">.</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:477"><nobr><span class="ft3">Instead, we can factor</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:596"><nobr><span class="ft18">run</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:618"><nobr><span class="ft3">into several mutually recursive functions,</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:477"><nobr><span class="ft11">each of them with one induction variable. These mutually recur-<br>sive functions are in defunctionalized form: the one processing the<br>dump is an apply function for the data type representing the dump<br>(a list of stacks, environments, and lists of directives), and the one<br>processing the control is an apply function for the data type repre-<br>senting the control (a list of directives). The corresponding higher-<br>order evaluator is in continuation-passing style with two nested con-<br>tinuations and one control delimiter,</span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:678"><nobr><span class="ft18">reset</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:712"><nobr><span class="ft3">[12, 18]. The delimiter</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:477"><nobr><span class="ft3">resets the control continuation when evaluating the body of a</span></nobr></DIV>
<DIV style="position:absolute;top:1052;left:826"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:834"><nobr><span class="ft3">-</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:477"><nobr><span class="ft3">abstraction. (More detail is available in a technical report [11].)</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">15</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="11009.png" alt="background image">
<DIV style="position:absolute;top:111;left:81"><nobr><span class="ft4"><b>4.3</b></span></nobr></DIV>
<DIV style="position:absolute;top:111;left:121"><nobr><span class="ft21"><b>The evaluator corresponding to the SECD<br>machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:158;left:81"><nobr><span class="ft11">The direct-style version of the evaluator from Section 4.2 reads as<br>follows:</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:93"><nobr><span class="ft22">structure Eval4<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:118"><nobr><span class="ft18">datatype value</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:172"><nobr><span class="ft18">= CLOSURE of string * term * value Env.env</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:142"><nobr><span class="ft18">eval : term * value list * value Env.env</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:398"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:209"><nobr><span class="ft18">-&gt; value list * value Env.env</span></nobr></DIV>
<DIV style="position:absolute;top:284;left:398"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:118"><nobr><span class="ft18">fun eval (VAR x, s, e)</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:142"><nobr><span class="ft18">= ((Env.lookup (x, e)) :: s, e)</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:130"><nobr><span class="ft18">| eval (LAM (x, t), s, e)</span></nobr></DIV>
<DIV style="position:absolute;top:338;left:142"><nobr><span class="ft18">= ((CLOSURE (x, t, e)) :: s, e)</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:130"><nobr><span class="ft18">| eval (APP (t0, t1), s, e)</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:142"><nobr><span class="ft18">= let val (s, e) = eval (t1, s, e)</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:179"><nobr><span class="ft18">val (s, e) = eval (t0, s, e)</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:154"><nobr><span class="ft22">in apply (s, e)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:118"><nobr><span class="ft18">and apply ((CLOSURE (x, t, e')) :: v :: s, e)</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:142"><nobr><span class="ft18">= let val (v :: nil, _)</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:203"><nobr><span class="ft18">= reset (fn ()</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:258"><nobr><span class="ft18">=&gt; eval (t,</span></nobr></DIV>
<DIV style="position:absolute;top:472;left:313"><nobr><span class="ft22">nil,<br>Env.extend (x,</span></nobr></DIV>
<DIV style="position:absolute;top:499;left:386"><nobr><span class="ft22">v,<br>e')))</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:154"><nobr><span class="ft22">in (v :: s, e)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:142"><nobr><span class="ft18">main : term -&gt; value</span></nobr></DIV>
<DIV style="position:absolute;top:566;left:276"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:580;left:118"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:593;left:142"><nobr><span class="ft18">= let val (v :: nil, _)</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:203"><nobr><span class="ft18">= reset (fn ()</span></nobr></DIV>
<DIV style="position:absolute;top:620;left:258"><nobr><span class="ft18">=&gt; eval (t, nil, Env.mt))</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:154"><nobr><span class="ft22">in v<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:111"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:689;left:81"><nobr><span class="ft11">The following proposition is a corollary of the correctness of de-<br>functionalization and of the CPS transformation. (Here observa-<br>tional equivalence reduces to structural equality over ML values of<br>type</span></nobr></DIV>
<DIV style="position:absolute;top:736;left:108"><nobr><span class="ft18">value</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:138"><nobr><span class="ft3">.)</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:81"><nobr><span class="ft3">P</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:90"><nobr><span class="ft9">ROPOSITION</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:163"><nobr><span class="ft3">10</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:192"><nobr><span class="ft3">(</span></nobr></DIV>
<DIV style="position:absolute;top:766;left:197"><nobr><span class="ft9">FULL CORRECTNESS</span></nobr></DIV>
<DIV style="position:absolute;top:765;left:314"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:81"><nobr><span class="ft7"><i>For any ML value</i></span></nobr></DIV>
<DIV style="position:absolute;top:781;left:181"><nobr><span class="ft18">p : term</span></nobr></DIV>
<DIV style="position:absolute;top:779;left:233"><nobr><span class="ft7"><i>denoting a program,</i></span></nobr></DIV>
<DIV style="position:absolute;top:807;left:176"><nobr><span class="ft18">Eval0.main p</span></nobr></DIV>
<DIV style="position:absolute;top:807;left:273"><nobr><span class="ft18">Eval4.main p</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:81"><nobr><span class="ft11">As in Sections 2 and 3, this evaluator can be made compositional<br>by refunctionalizing the closures into higher-order functions.</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:81"><nobr><span class="ft11">We conclude that the evaluation model embodied in the SECD ma-<br>chine is a call-by-value interpreter threading a stack of intermediate<br>results and an environment with a callee-save strategy (witness the<br>dynamic passage of environments in the meaning of applications),<br>a right-to-left evaluation of sub-terms, and a control delimiter. In<br>particular, the meaning of a term is a partial endofunction over a<br>stack of intermediate results and an environment. Furthermore, this<br>evaluator evidently implements Hardin, Maranget, and Pagano's L<br>strategy, i.e., right-to-left call by value, without us having to "guess"<br>its inference rules [24, Section 4].</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:81"><nobr><span class="ft11">The denotational content of the SECD machine puts a new light<br>on it. For example, its separation between a control register and a</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft11">dump register is explained by the control delimiter in the evaluator<br>(</span></nobr></DIV>
<DIV style="position:absolute;top:131;left:481"><nobr><span class="ft18">reset</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:516"><nobr><span class="ft3">in</span></nobr></DIV>
<DIV style="position:absolute;top:131;left:530"><nobr><span class="ft18">Eval4.eval</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:591"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:599"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:609"><nobr><span class="ft3">Removing this control delimiter gives rise</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:477"><nobr><span class="ft11">to an abstract machine with a single stack component for control--<br>not by a clever change in the machine itself, but by a straightforward<br>simplification in the corresponding evaluator.</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:477"><nobr><span class="ft4"><b>5</b></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:504"><nobr><span class="ft21"><b>Variants of the CLS machine and of the<br>SECD machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:256;left:477"><nobr><span class="ft3">It is straightforward to construct a variant of the CLS machine for</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:477"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:484"><nobr><span class="ft3">-terms with names, by starting from an evaluator for</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:773"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:781"><nobr><span class="ft3">-term with</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:477"><nobr><span class="ft11">names. Similarly, it is straightforward to construct a variant of the<br>SECD machine for</span></nobr></DIV>
<DIV style="position:absolute;top:296;left:582"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:301;left:589"><nobr><span class="ft3">-terms with de Bruijn indices, by starting from</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:477"><nobr><span class="ft3">an evaluator for</span></nobr></DIV>
<DIV style="position:absolute;top:311;left:566"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:316;left:573"><nobr><span class="ft3">-term with indices. In the same vein, it is simple</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:477"><nobr><span class="ft11">to construct call-by-name versions of the CLS machine and of the<br>SECD machine, by starting from call-by-name evaluators. It is also<br>simple to construct a properly tail recursive version of the SECD<br>machine, and to extend the CLS machine and the SECD machine to<br>bigger source languages, by extending the corresponding evaluator.</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:477"><nobr><span class="ft4"><b>6</b></span></nobr></DIV>
<DIV style="position:absolute;top:422;left:504"><nobr><span class="ft4"><b>The Categorical Abstract Machine</b></span></nobr></DIV>
<DIV style="position:absolute;top:455;left:477"><nobr><span class="ft11">What is the difference between an abstract machine and a virtual<br>machine? Elsewhere [1], we propose to distinguish them based on<br>the notion of instruction set: A virtual machine has an instruction<br>set whereas an abstract machine does not. Therefore, an abstract<br>machine directly operates on a</span></nobr></DIV>
<DIV style="position:absolute;top:510;left:652"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:515;left:659"><nobr><span class="ft3">-term, but a virtual machine op-</span></nobr></DIV>
<DIV style="position:absolute;top:530;left:477"><nobr><span class="ft3">erates on a compiled representation of a</span></nobr></DIV>
<DIV style="position:absolute;top:525;left:706"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:530;left:713"><nobr><span class="ft3">-term, expressed using</span></nobr></DIV>
<DIV style="position:absolute;top:545;left:477"><nobr><span class="ft11">an instruction set. (This distinction can be found elsewhere in the<br>literature [21].)</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:477"><nobr><span class="ft11">The Categorical Abstract Machine [6], for example, has an in-<br>struction set--categorical combinators--and therefore (despite its<br>name) it is a virtual machine, not an abstract machine. In con-<br>trast, Krivine's machine, the CEK machine, the CLS machine, and<br>the SECD machine are all abstract machines, not virtual machines,<br>since they directly operate on</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:643"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:664;left:650"><nobr><span class="ft3">-terms. In this section, we present</span></nobr></DIV>
<DIV style="position:absolute;top:679;left:477"><nobr><span class="ft11">the abstract machine corresponding to the Categorical Abstract Ma-<br>chine (CAM). We start from the evaluation model embodied in the<br>CAM [1].</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:477"><nobr><span class="ft4"><b>6.1</b></span></nobr></DIV>
<DIV style="position:absolute;top:740;left:517"><nobr><span class="ft4"><b>The evaluator corresponding to the CAM</b></span></nobr></DIV>
<DIV style="position:absolute;top:773;left:477"><nobr><span class="ft11">The evaluation model embodied in the CAM is an interpreter<br>threading a stack with its top element cached in a register, represent-<br>ing environments as expressible values (namely nested pairs linked<br>as lists), with a caller-save strategy (witness the duplication of the<br>register on the stack in the meaning of applications below), and with<br>a left-to-right evaluation of sub-terms. In particular, the meaning of<br>a term is a partial endofunction over the register and the stack. This<br>evaluator reads as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:489"><nobr><span class="ft18">datatype term = IND of int (* de Bruijn index *)</span></nobr></DIV>
<DIV style="position:absolute;top:921;left:574"><nobr><span class="ft22">| ABS of term<br>| APP of term * term<br>| NIL<br>| CONS of term * term<br>| CAR of term<br>| CDR of term</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:477"><nobr><span class="ft3">Programs are closed terms.</span></nobr></DIV>
<DIV style="position:absolute;top:1038;left:495"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:501"><nobr><span class="ft3">A rough definition of</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:619"><nobr><span class="ft8">reset</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:656"><nobr><span class="ft3">is</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:669"><nobr><span class="ft8">fun reset t = t ()</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:792"><nobr><span class="ft3">.</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:477"><nobr><span class="ft11">A more accurate definition, however, falls out of the scope of this<br>article [12, 18].</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">16</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="11010.png" alt="background image">
<DIV style="position:absolute;top:116;left:93"><nobr><span class="ft22">structure Eval0<br>= struct</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:118"><nobr><span class="ft18">datatype expval</span></nobr></DIV>
<DIV style="position:absolute;top:156;left:172"><nobr><span class="ft22">= NULL<br>| PAIR of expval * expval<br>| CLOSURE of expval * (expval * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:196;left:294"><nobr><span class="ft18">-&gt; expval * expval list)</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:142"><nobr><span class="ft18">access : int * expval * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:223;left:368"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:215"><nobr><span class="ft18">-&gt; expval * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:237;left:368"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:118"><nobr><span class="ft18">fun access (0, PAIR (v1, v2), s)</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:142"><nobr><span class="ft18">= (v2, s)</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:130"><nobr><span class="ft18">| access (n, PAIR (v1, v2), s)</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:142"><nobr><span class="ft18">= access (n - 1, v1, s)</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:142"><nobr><span class="ft18">eval : term * expval * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:361"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:209"><nobr><span class="ft18">-&gt; expval * expval list</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:361"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:118"><nobr><span class="ft18">fun eval (IND n, v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:142"><nobr><span class="ft18">= access (n, v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:371;left:130"><nobr><span class="ft18">| eval (ABS t, v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:142"><nobr><span class="ft18">= (CLOSURE (v, fn (v, s) =&gt; eval (t, v, s)), s)</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:130"><nobr><span class="ft18">| eval (APP (t0, t1), v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:142"><nobr><span class="ft18">= let val (v, v' :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:425;left:203"><nobr><span class="ft18">= eval (t0, v, v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:179"><nobr><span class="ft18">val (v', (CLOSURE (v, f)) :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:203"><nobr><span class="ft18">= eval (t1, v', v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:154"><nobr><span class="ft22">in f (PAIR (v, v'), s)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:492;left:130"><nobr><span class="ft18">| eval (NIL, v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:142"><nobr><span class="ft18">= (NULL, s)</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:130"><nobr><span class="ft18">| eval (CONS (t1, t2), v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:142"><nobr><span class="ft18">= let val (v, v' :: s) = eval (t1, v, v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:179"><nobr><span class="ft18">val (v, v' :: s) = eval (t2, v', v :: s)</span></nobr></DIV>
<DIV style="position:absolute;top:559;left:154"><nobr><span class="ft22">in (PAIR (v', v), s)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:130"><nobr><span class="ft18">| eval (CAR t, v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:142"><nobr><span class="ft18">= let val (PAIR (v1, v2), s) = eval (t, v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:154"><nobr><span class="ft22">in (v1, s)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:130"><nobr><span class="ft18">| eval (CDR t, v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:142"><nobr><span class="ft18">= let val (PAIR (v1, v2), s) = eval (t, v, s)</span></nobr></DIV>
<DIV style="position:absolute;top:667;left:154"><nobr><span class="ft22">in (v2, s)<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:118"><nobr><span class="ft18">(*</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:142"><nobr><span class="ft18">main : term -&gt; expval</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:282"><nobr><span class="ft18">*)</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:118"><nobr><span class="ft18">fun main t</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:142"><nobr><span class="ft18">= let val (v, nil) = eval (t, NULL, nil)</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:154"><nobr><span class="ft22">in v<br>end</span></nobr></DIV>
<DIV style="position:absolute;top:775;left:105"><nobr><span class="ft18">end</span></nobr></DIV>
<DIV style="position:absolute;top:802;left:81"><nobr><span class="ft11">This evaluator evidently implements Hardin, Maranget, and<br>Pagano's X strategy [24, Section 6].</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:81"><nobr><span class="ft4"><b>6.2</b></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:121"><nobr><span class="ft21"><b>The abstract machine corresponding to<br>the CAM</b></span></nobr></DIV>
<DIV style="position:absolute;top:899;left:81"><nobr><span class="ft11">As in Sections 2, 3, and 4, we can closure-convert the evaluator of<br>Section 6.1 by defunctionalizing its expressible values, transform<br>it into continuation-passing style, and defunctionalize its continu-<br>ations. The resulting abstract machine reads as follows, where <i>t<br></i>denotes terms, <i>v </i>denotes expressible values, <i>k </i>denotes evaluation<br>contexts, and <i>s </i>denotes stacks of expressible values.</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:111"><nobr><span class="ft3">Source syntax:</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:155"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:175"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:207"><nobr><span class="ft7"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:230"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:237"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:257"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:261"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:268"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:272"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:293"><nobr><span class="ft18">nil</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:327"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:332"><nobr><span class="ft18">cons</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:358"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:362"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:369"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:373"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:379"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1050;left:208"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:213"><nobr><span class="ft18">car</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:232"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1050;left:237"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1050;left:258"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:263"><nobr><span class="ft18">cdr</span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:282"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:1050;left:287"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:1080;left:97"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:111"><nobr><span class="ft3">Expressible values (unit value, pairs, and closures) and evalu-</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:507"><nobr><span class="ft3">ation contexts:</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:518"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:144;left:539"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:572"><nobr><span class="ft18">null</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:612"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:617"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:623"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:636"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:148;left:642"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:648"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:144;left:673"><nobr><span class="ft7"><i>v t</i></span></nobr></DIV>
<DIV style="position:absolute;top:159;left:518"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:159;left:539"><nobr><span class="ft3">::</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:572"><nobr><span class="ft18">CONT0</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:618"><nobr><span class="ft18">CONT1</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:649"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:654"><nobr><span class="ft7"><i>t k</i></span></nobr></DIV>
<DIV style="position:absolute;top:168;left:671"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:692"><nobr><span class="ft18">CONT2</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:722"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:728"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:168;left:734"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:755"><nobr><span class="ft18">CONT3</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:785"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:790"><nobr><span class="ft7"><i>t k</i></span></nobr></DIV>
<DIV style="position:absolute;top:168;left:808"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:572"><nobr><span class="ft18">CONT4</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:602"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:608"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:183;left:614"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:635"><nobr><span class="ft18">CONT5</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:665"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:671"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:183;left:677"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:175;left:698"><nobr><span class="ft18">CONT6</span></nobr></DIV>
<DIV style="position:absolute;top:183;left:728"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:174;left:733"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:183;left:740"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:216;left:492"><nobr><span class="ft2">¯</span></nobr></DIV>
<DIV style="position:absolute;top:207;left:507"><nobr><span class="ft11">Initial transition, transition rules (two kinds), and final transi-<br>tion:</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:629"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:255;left:651"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:665"><nobr><span class="ft23"><i>init</i></span></nobr></DIV>
<DIV style="position:absolute;top:246;left:702"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:247;left:713"><nobr><span class="ft18">null</span></nobr></DIV>
<DIV style="position:absolute;top:246;left:744"><nobr><span class="ft7"><i>nil</i></span></nobr></DIV>
<DIV style="position:absolute;top:247;left:765"><nobr><span class="ft18">CONT0</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:586"><nobr><span class="ft7"><i>n v s k</i></span></nobr></DIV>
<DIV style="position:absolute;top:276;left:650"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:272;left:663"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:267;left:702"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:263;left:715"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:276;left:720"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:726"><nobr><span class="ft7"><i>n v</i></span></nobr></DIV>
<DIV style="position:absolute;top:276;left:744"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:756"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:278;left:581"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:282;left:588"><nobr><span class="ft7"><i>t v s k</i></span></nobr></DIV>
<DIV style="position:absolute;top:291;left:650"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:287;left:663"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:282;left:702"><nobr><span class="ft7"><i>k v t s</i></span></nobr></DIV>
<DIV style="position:absolute;top:299;left:574"><nobr><span class="ft18">nil</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:599"><nobr><span class="ft7"><i>v s k</i></span></nobr></DIV>
<DIV style="position:absolute;top:306;left:650"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:302;left:663"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:297;left:702"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:299;left:715"><nobr><span class="ft18">null</span></nobr></DIV>
<DIV style="position:absolute;top:297;left:746"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:312;left:572"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:317;left:575"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:582"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:317;left:586"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:599"><nobr><span class="ft7"><i>v s k</i></span></nobr></DIV>
<DIV style="position:absolute;top:321;left:650"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:317;left:663"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:312;left:702"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:317;left:705"><nobr><span class="ft9">0</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:718"><nobr><span class="ft7"><i>v v </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:314;left:761"><nobr><span class="ft18">CONT1</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:792"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:796"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:317;left:800"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:312;left:813"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:321;left:819"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:536"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:329;left:541"><nobr><span class="ft18">cons</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:566"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:570"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:577"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:581"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:587"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:599"><nobr><span class="ft7"><i>v s k</i></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:650"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:332;left:663"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:327;left:702"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:705"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:718"><nobr><span class="ft7"><i>v v </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:329;left:761"><nobr><span class="ft18">CONT3</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:792"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:796"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:800"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:813"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:336;left:819"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:558"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:563"><nobr><span class="ft18">car</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:582"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:351;left:587"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:599"><nobr><span class="ft7"><i>v s k</i></span></nobr></DIV>
<DIV style="position:absolute;top:351;left:650"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:347;left:663"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:342;left:702"><nobr><span class="ft7"><i>t v s</i></span></nobr></DIV>
<DIV style="position:absolute;top:344;left:737"><nobr><span class="ft18">CONT5</span></nobr></DIV>
<DIV style="position:absolute;top:351;left:767"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:772"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:351;left:779"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:558"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:563"><nobr><span class="ft18">cdr</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:582"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:587"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:599"><nobr><span class="ft7"><i>v s k</i></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:650"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:362;left:663"><nobr><span class="ft23"><i>eval</i></span></nobr></DIV>
<DIV style="position:absolute;top:357;left:702"><nobr><span class="ft7"><i>t v s</i></span></nobr></DIV>
<DIV style="position:absolute;top:359;left:737"><nobr><span class="ft18">CONT6</span></nobr></DIV>
<DIV style="position:absolute;top:366;left:767"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:772"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:779"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:378;left:524"><nobr><span class="ft18">CONT1</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:554"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:559"><nobr><span class="ft7"><i>t k</i></span></nobr></DIV>
<DIV style="position:absolute;top:385;left:577"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:589"><nobr><span class="ft7"><i>v v</i></span></nobr></DIV>
<DIV style="position:absolute;top:380;left:606"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:613"><nobr><span class="ft3">:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:385;left:649"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:663"><nobr><span class="ft23"><i>cont</i></span></nobr></DIV>
<DIV style="position:absolute;top:376;left:702"><nobr><span class="ft7"><i>t v</i></span></nobr></DIV>
<DIV style="position:absolute;top:380;left:719"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:729"><nobr><span class="ft7"><i>v </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:378;left:761"><nobr><span class="ft18">CONT2</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:791"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:376;left:796"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:385;left:802"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:393;left:517"><nobr><span class="ft18">CONT2</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:547"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:552"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:400;left:558"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:570"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:576"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:590"><nobr><span class="ft7"><i>v t </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:400;left:649"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:395;left:663"><nobr><span class="ft23"><i>cont</i></span></nobr></DIV>
<DIV style="position:absolute;top:391;left:702"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:400;left:713"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:718"><nobr><span class="ft7"><i>v v</i></span></nobr></DIV>
<DIV style="position:absolute;top:396;left:736"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:739"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:751"><nobr><span class="ft7"><i>s k</i></span></nobr></DIV>
<DIV style="position:absolute;top:408;left:519"><nobr><span class="ft18">CONT3</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:549"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:554"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:411;left:558"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:571"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:577"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:589"><nobr><span class="ft7"><i>v v</i></span></nobr></DIV>
<DIV style="position:absolute;top:411;left:606"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:613"><nobr><span class="ft3">:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:649"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:411;left:663"><nobr><span class="ft23"><i>cont</i></span></nobr></DIV>
<DIV style="position:absolute;top:407;left:702"><nobr><span class="ft7"><i>t</i></span></nobr></DIV>
<DIV style="position:absolute;top:411;left:705"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:718"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:411;left:724"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:734"><nobr><span class="ft7"><i>v </i>:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:408;left:766"><nobr><span class="ft18">CONT4</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:796"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:801"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:416;left:807"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:423;left:535"><nobr><span class="ft18">CONT4</span></nobr></DIV>
<DIV style="position:absolute;top:431;left:566"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:571"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:577"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:589"><nobr><span class="ft7"><i>v v</i></span></nobr></DIV>
<DIV style="position:absolute;top:426;left:606"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:613"><nobr><span class="ft3">:: <i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:649"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:426;left:663"><nobr><span class="ft23"><i>cont</i></span></nobr></DIV>
<DIV style="position:absolute;top:422;left:702"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:715"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:720"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:426;left:726"><nobr><span class="ft2">¼</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:736"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:742"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:422;left:754"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:438;left:522"><nobr><span class="ft18">CONT5</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:552"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:558"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:564"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:576"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:581"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:441;left:587"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:600"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:441;left:606"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:446;left:612"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:624"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:446;left:649"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:663"><nobr><span class="ft23"><i>cont</i></span></nobr></DIV>
<DIV style="position:absolute;top:437;left:702"><nobr><span class="ft7"><i>k v</i></span></nobr></DIV>
<DIV style="position:absolute;top:441;left:721"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:437;left:734"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:453;left:522"><nobr><span class="ft18">CONT6</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:552"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:558"><nobr><span class="ft7"><i>k</i></span></nobr></DIV>
<DIV style="position:absolute;top:461;left:564"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:576"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:581"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:587"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:600"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:606"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:461;left:612"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:624"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:461;left:649"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:456;left:663"><nobr><span class="ft23"><i>cont</i></span></nobr></DIV>
<DIV style="position:absolute;top:452;left:702"><nobr><span class="ft7"><i>k v</i></span></nobr></DIV>
<DIV style="position:absolute;top:456;left:721"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:452;left:734"><nobr><span class="ft7"><i>s</i></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:566"><nobr><span class="ft18">CONT0</span></nobr></DIV>
<DIV style="position:absolute;top:473;left:603"><nobr><span class="ft7"><i>v nil</i></span></nobr></DIV>
<DIV style="position:absolute;top:482;left:649"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:662"><nobr><span class="ft23"><i>final</i></span></nobr></DIV>
<DIV style="position:absolute;top:473;left:697"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:500;left:507"><nobr><span class="ft3">where</span></nobr></DIV>
<DIV style="position:absolute;top:495;left:550"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:509;left:556"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:561"><nobr><span class="ft3">0</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:573"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:578"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:504;left:584"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:597"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:504;left:603"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:509;left:609"><nobr><span class="ft2">µµ</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:660"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:504;left:665"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:510;left:550"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:524;left:556"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:561"><nobr><span class="ft7"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:524;left:573"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:578"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:584"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:597"><nobr><span class="ft7"><i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:603"><nobr><span class="ft9">2</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:609"><nobr><span class="ft2">µµ</span></nobr></DIV>
<DIV style="position:absolute;top:510;left:660"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:524;left:665"><nobr><span class="ft2">´</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:670"><nobr><span class="ft7"><i>n</i></span></nobr></DIV>
<DIV style="position:absolute;top:524;left:679"><nobr><span class="ft2"> </span></nobr></DIV>
<DIV style="position:absolute;top:515;left:691"><nobr><span class="ft3">1 <i>v</i></span></nobr></DIV>
<DIV style="position:absolute;top:519;left:709"><nobr><span class="ft9">1</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:715"><nobr><span class="ft2">µ</span></nobr></DIV>
<DIV style="position:absolute;top:541;left:477"><nobr><span class="ft11">Variables <i>n </i>are represented by their de Bruijn index, and the ab-<br>stract machine consists of two mutually recursive transition func-<br>tions. The first transition function operates on quadruples consist-<br>ing of a term, an expressible value, a stack of expressible values,<br>and an evaluation context. The second transition function operates<br>on triples consisting of an evaluation context, an expressible value,<br>and a stack of expressible values.</span></nobr></DIV>
<DIV style="position:absolute;top:660;left:477"><nobr><span class="ft11">This abstract machine embodies the evaluation model of the CAM.<br>Naturally, more intuitive names could be chosen instead of</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:804"><nobr><span class="ft18">CONT0</span></nobr></DIV>
<DIV style="position:absolute;top:675;left:835"><nobr><span class="ft3">,</span></nobr></DIV>
<DIV style="position:absolute;top:692;left:477"><nobr><span class="ft18">CONT1</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:507"><nobr><span class="ft3">, etc.</span></nobr></DIV>
<DIV style="position:absolute;top:726;left:477"><nobr><span class="ft4"><b>7</b></span></nobr></DIV>
<DIV style="position:absolute;top:726;left:504"><nobr><span class="ft4"><b>Conclusion and issues</b></span></nobr></DIV>
<DIV style="position:absolute;top:759;left:477"><nobr><span class="ft11">We have presented a constructive correspondence between func-<br>tional evaluators and abstract machines.</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:722"><nobr><span class="ft3">This correspondence</span></nobr></DIV>
<DIV style="position:absolute;top:788;left:477"><nobr><span class="ft11">builds on off-the-shelf program transformations: closure conver-<br>sion, CPS transformation, defunctionalization, and inlining.</span></nobr></DIV>
<DIV style="position:absolute;top:801;left:805"><nobr><span class="ft9">3</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:819"><nobr><span class="ft3">We</span></nobr></DIV>
<DIV style="position:absolute;top:818;left:477"><nobr><span class="ft11">have shown how to reconstruct known machines (Krivine's ma-<br>chine, the CEK machine, the CLS machine, and the SECD ma-<br>chine) and how to construct new ones. Conversely, we have re-<br>vealed the denotational content of known abstract machines. We<br>have shown that Krivine's abstract machine and the CEK machine<br>correspond to canonical evaluators for the</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:704"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:893;left:712"><nobr><span class="ft3">-calculus. We have also</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:477"><nobr><span class="ft11">shown that they are dual of each other since they correspond to<br>call-by-name and call-by-value evaluators in the same direct style.<br>In terms of denotational semantics [27, 34], Krivine's machine and<br>the CEK machine correspond to a standard semantics, whereas the<br>CLS machine and the SECD machine correspond to a stack seman-<br>tics of the</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:536"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:983;left:543"><nobr><span class="ft3">-calculus. Finally, we have exhibited the abstract ma-</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:477"><nobr><span class="ft11">chine corresponding to the CAM, which puts the reader in a new<br>position to answer the recurrent question as to whether the CLS<br>machine is closer to the CAM or to the SECD machine.</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:495"><nobr><span class="ft9">3</span></nobr></DIV>
<DIV style="position:absolute;top:1056;left:501"><nobr><span class="ft3">Indeed the push-enter twist of Krivine's machine is obtained</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:477"><nobr><span class="ft3">by inlining</span></nobr></DIV>
<DIV style="position:absolute;top:1072;left:539"><nobr><span class="ft8">apply cont</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:609"><nobr><span class="ft3">in Section 2.1.5.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">17</span></nobr></DIV>
</DIV>
<!-- Page 11 -->
<a name="11"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft25{font-size:11px;line-height:14px;font-family:Courier;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="11011.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft11">Since this article was written, we have studied the correspondence<br>between functional evaluators and abstract machines for call by<br>need [2] and for Propositional Prolog [4]. In both cases, we de-<br>rived sensible machines out of canonical evaluators.</span></nobr></DIV>
<DIV style="position:absolute;top:189;left:81"><nobr><span class="ft11">It seems to us that this correspondence between functional evalua-<br>tors and abstract machines builds a reliable bridge between denota-<br>tional definitions and definitions of abstract machines. On the one<br>hand, it allows one to identify the denotational content of an ab-<br>stract machine in the form of a functional interpreter. On the other<br>hand, it gives one a precise and generic recipe to construct arbitrar-<br>ily many new variants of abstract machines (e.g., with substitutions<br>or environments, or with stacks) or of arbitrarily many new abstract<br>machines, starting from an evaluator with any given computational<br>monad [28].</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:81"><nobr><span class="ft16"><i>Acknowledgments:</i></span></nobr></DIV>
<DIV style="position:absolute;top:378;left:81"><nobr><span class="ft11">We are grateful to Malgorzata Biernacka, Julia Lawall, and Hen-<br>ning Korsholm Rohde for timely comments. Thanks are also due to<br>the anonymous reviewers.</span></nobr></DIV>
<DIV style="position:absolute;top:433;left:81"><nobr><span class="ft11">This work is supported by the ESPRIT Working Group APPSEM II<br>(</span></nobr></DIV>
<DIV style="position:absolute;top:450;left:85"><nobr><span class="ft18">http://www.appsem.org</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:214"><nobr><span class="ft3">).</span></nobr></DIV>
<DIV style="position:absolute;top:475;left:81"><nobr><span class="ft4"><b>8</b></span></nobr></DIV>
<DIV style="position:absolute;top:475;left:108"><nobr><span class="ft4"><b>References</b></span></nobr></DIV>
<DIV style="position:absolute;top:508;left:88"><nobr><span class="ft3">[1] Mads Sig Ager, Dariusz Biernacki, Olivier Danvy, and Jan</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:111"><nobr><span class="ft3">Midtgaard.</span></nobr></DIV>
<DIV style="position:absolute;top:523;left:185"><nobr><span class="ft3">From interpreter to compiler and virtual ma-</span></nobr></DIV>
<DIV style="position:absolute;top:538;left:111"><nobr><span class="ft11">chine: a functional derivation. Technical Report BRICS RS-<br>03-14, DAIMI, Department of Computer Science, University<br>of Aarhus, Aarhus, Denmark, March 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:88"><nobr><span class="ft3">[2] Mads Sig Ager, Olivier Danvy, and Jan Midtgaard. A func-</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:111"><nobr><span class="ft11">tional correspondence between call-by-need evaluators and<br>lazy abstract machines.</span></nobr></DIV>
<DIV style="position:absolute;top:619;left:256"><nobr><span class="ft3">Technical Report BRICS RS-03-</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:111"><nobr><span class="ft11">24, DAIMI, Department of Computer Science, University of<br>Aarhus, Aarhus, Denmark, June 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:88"><nobr><span class="ft3">[3] Anindya Banerjee, Nevin Heintze, and Jon G. Riecke. Design</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:111"><nobr><span class="ft11">and correctness of program transformations based on control-<br>flow analysis. In Naoki Kobayashi and Benjamin C. Pierce,<br>editors, <i>Theoretical Aspects of Computer Software, 4th Inter-<br>national Symposium, TACS 2001</i>, number 2215 in Lecture<br>Notes in Computer Science, Sendai, Japan, October 2001.<br>Springer-Verlag.</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:88"><nobr><span class="ft3">[4] Dariusz Biernacki and Olivier Danvy.</span></nobr></DIV>
<DIV style="position:absolute;top:782;left:335"><nobr><span class="ft3">From interpreter to</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:111"><nobr><span class="ft3">logic engine: A functional derivation.</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:346"><nobr><span class="ft3">Technical Report</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:111"><nobr><span class="ft11">BRICS RS-03-25, DAIMI, Department of Computer Science,<br>University of Aarhus, Aarhus, Denmark, June 2003. Accepted<br>for presentation at LOPSTR 2003.</span></nobr></DIV>
<DIV style="position:absolute;top:864;left:88"><nobr><span class="ft3">[5] Rod M. Burstall and John Darlington. A transformational</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:111"><nobr><span class="ft11">system for developing recursive programs. <i>Journal of ACM</i>,<br>24(1):44­67, 1977.</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:88"><nobr><span class="ft3">[6] Guy Cousineau, Pierre-Louis Curien, and Michel Mauny. The</span></nobr></DIV>
<DIV style="position:absolute;top:930;left:111"><nobr><span class="ft24">categorical abstract machine. <i>Science of Computer Program-<br>ming</i>, 8(2):173­202, 1987.</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:88"><nobr><span class="ft3">[7] Pierre Cr´egut. An abstract machine for lambda-terms nor-</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:111"><nobr><span class="ft3">malization.</span></nobr></DIV>
<DIV style="position:absolute;top:982;left:185"><nobr><span class="ft3">In Mitchell Wand, editor, <i>Proceedings of the</i></span></nobr></DIV>
<DIV style="position:absolute;top:997;left:111"><nobr><span class="ft11"><i>1990 ACM Conference on Lisp and Functional Programming</i>,<br>pages 333­340, Nice, France, June 1990. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:88"><nobr><span class="ft3">[8] Pierre-Louis Curien. <i>Categorical Combinators, Sequential</i></span></nobr></DIV>
<DIV style="position:absolute;top:1048;left:111"><nobr><span class="ft11"><i>Algorithms and Functional Programming</i>. Progress in The-<br>oretical Computer Science. Birkha¨user, 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:483"><nobr><span class="ft3">[9] Pierre-Louis Curien and Hugo Herbelin. The duality of com-</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:507"><nobr><span class="ft11">putation. In Philip Wadler, editor, <i>Proceedings of the 2000<br>ACM SIGPLAN International Conference on Functional Pro-<br>gramming</i>, SIGPLAN Notices, Vol. 35, No. 9, pages 233­<br>243, Montr´eal, Canada, September 2000. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:477"><nobr><span class="ft3">[10] Olivier Danvy. Back to direct style. <i>Science of Computer</i></span></nobr></DIV>
<DIV style="position:absolute;top:210;left:507"><nobr><span class="ft7"><i>Programming</i>, 22(3):183­195, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:477"><nobr><span class="ft3">[11] Olivier Danvy. A lambda-revelation of the SECD machine.</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:507"><nobr><span class="ft11">Technical Report BRICS RS-02-53, DAIMI, Department of<br>Computer Science, University of Aarhus, Aarhus, Denmark,<br>December 2002.</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:477"><nobr><span class="ft3">[12] Olivier Danvy and Andrzej Filinski. Representing control, a</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:507"><nobr><span class="ft24">study of the CPS transformation. <i>Mathematical Structures in<br>Computer Science</i>, 2(4):361­391, 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:477"><nobr><span class="ft3">[13] Olivier Danvy and John Hatcliff. CPS transformation after</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:507"><nobr><span class="ft24">strictness analysis. <i>ACM Letters on Programming Languages<br>and Systems</i>, 1(3):195­212, 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:477"><nobr><span class="ft3">[14] Olivier Danvy and John Hatcliff. On the transformation be-</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:507"><nobr><span class="ft11">tween direct and continuation semantics. In Stephen Brookes,<br>Michael Main, Austin Melton, Michael Mislove, and David<br>Schmidt, editors, <i>Proceedings of the 9th Conference on Math-<br>ematical Foundations of Programming Semantics</i>, number<br>802 in Lecture Notes in Computer Science, pages 627­648,<br>New Orleans, Louisiana, April 1993. Springer-Verlag.</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:477"><nobr><span class="ft3">[15] Olivier Danvy and Lasse R. Nielsen.</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:731"><nobr><span class="ft3">Defunctionalization</span></nobr></DIV>
<DIV style="position:absolute;top:528;left:507"><nobr><span class="ft11">at work. In Harald Søndergaard, editor, <i>Proceedings of the<br>Third International ACM SIGPLAN Conference on Principles<br>and Practice of Declarative Programming (PPDP'01)</i>, pages<br>162­174, Firenze, Italy, September 2001. ACM Press. Ex-<br>tended version available as the technical report BRICS RS-<br>01-23.</span></nobr></DIV>
<DIV style="position:absolute;top:624;left:477"><nobr><span class="ft3">[16] Matthias Felleisen and Matthew Flatt.</span></nobr></DIV>
<DIV style="position:absolute;top:624;left:736"><nobr><span class="ft3">Programming lan-</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:507"><nobr><span class="ft3">guages and lambda calculi.</span></nobr></DIV>
<DIV style="position:absolute;top:639;left:685"><nobr><span class="ft3">Unpublished lecture notes.</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:507"><nobr><span class="ft25">http://www.ccs.neu.edu/home/matthias/3810-w02/<br>readings.html</span></nobr></DIV>
<DIV style="position:absolute;top:669;left:596"><nobr><span class="ft3">, 1989-2003.</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:477"><nobr><span class="ft3">[17] Matthias Felleisen and Daniel P. Friedman. Control operators,</span></nobr></DIV>
<DIV style="position:absolute;top:706;left:507"><nobr><span class="ft3">the SECD machine, and the</span></nobr></DIV>
<DIV style="position:absolute;top:701;left:656"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:706;left:663"><nobr><span class="ft3">-calculus. In Martin Wirsing, ed-</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:507"><nobr><span class="ft11">itor, <i>Formal Description of Programming Concepts III</i>, pages<br>193­217. Elsevier Science Publishers B.V. (North-Holland),<br>Amsterdam, 1986.</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:477"><nobr><span class="ft3">[18] Andrzej Filinski. Representing monads. In Hans-J. Boehm,</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:507"><nobr><span class="ft11">editor, <i>Proceedings of the Twenty-First Annual ACM Sympo-<br>sium on Principles of Programming Languages</i>, pages 446­<br>457, Portland, Oregon, January 1994. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:477"><nobr><span class="ft3">[19] Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias</span></nobr></DIV>
<DIV style="position:absolute;top:854;left:507"><nobr><span class="ft11">Felleisen. The essence of compiling with continuations. In<br>David W. Wall, editor, <i>Proceedings of the ACM SIGPLAN'93<br>Conference on Programming Languages Design and Imple-<br>mentation</i>, SIGPLAN Notices, Vol. 28, No 6, pages 237­247,<br>Albuquerque, New Mexico, June 1993. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:935;left:477"><nobr><span class="ft3">[20] Daniel P. Friedman, Mitchell Wand, and Christopher T.</span></nobr></DIV>
<DIV style="position:absolute;top:950;left:507"><nobr><span class="ft24">Haynes. <i>Essentials of Programming Languages, second edi-<br>tion</i>. The MIT Press, 2001.</span></nobr></DIV>
<DIV style="position:absolute;top:987;left:477"><nobr><span class="ft3">[21] Benjamin Gr´egoire and Xavier Leroy. A compiled imple-</span></nobr></DIV>
<DIV style="position:absolute;top:1002;left:507"><nobr><span class="ft11">mentation of strong reduction. In Simon Peyton Jones, ed-<br>itor, <i>Proceedings of the 2002 ACM SIGPLAN International<br>Conference on Functional Programming</i>, SIGPLAN Notices,<br>Vol. 37, No. 9, pages 235­246, Pittsburgh, Pennsylvania,<br>September 2002. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">18</span></nobr></DIV>
</DIV>
<!-- Page 12 -->
<a name="12"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="11012.png" alt="background image">
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft3">[22] Chris Hankin. <i>Lambda Calculi, a guide for computer scien-</i></span></nobr></DIV>
<DIV style="position:absolute;top:129;left:111"><nobr><span class="ft11"><i>tists</i>, volume 1 of <i>Graduate Texts in Computer Science</i>. Ox-<br>ford University Press, 1994.</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:81"><nobr><span class="ft3">[23] John Hannan and Dale Miller. From operational semantics</span></nobr></DIV>
<DIV style="position:absolute;top:180;left:111"><nobr><span class="ft24">to abstract machines. <i>Mathematical Structures in Computer<br>Science</i>, 2(4):415­459, 1992.</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:81"><nobr><span class="ft3">[24] Th´er`ese Hardin, Luc Maranget, and Bruno Pagano. Func-</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:111"><nobr><span class="ft11">tional runtime systems within the lambda-sigma calculus.<br><i>Journal of Functional Programming</i>, 8(2):131­172, 1998.</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:81"><nobr><span class="ft3">[25] Jean-Louis Krivine.</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:237"><nobr><span class="ft3">Un interpr`ete du</span></nobr></DIV>
<DIV style="position:absolute;top:264;left:339"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:268;left:347"><nobr><span class="ft3">-calcul.</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:403"><nobr><span class="ft3">Brouil-</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:111"><nobr><span class="ft3">lon. Available online at</span></nobr></DIV>
<DIV style="position:absolute;top:285;left:259"><nobr><span class="ft18">http://www.logique.jussieu.fr/</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:111"><nobr><span class="ft18">~krivine</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:160"><nobr><span class="ft3">, 1985.</span></nobr></DIV>
<DIV style="position:absolute;top:320;left:81"><nobr><span class="ft3">[26] Peter J. Landin. The mechanical evaluation of expressions.</span></nobr></DIV>
<DIV style="position:absolute;top:335;left:111"><nobr><span class="ft7"><i>The Computer Journal</i>, 6(4):308­320, 1964.</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:81"><nobr><span class="ft3">[27] Robert E. Milne and Christopher Strachey. <i>A Theory of Pro-</i></span></nobr></DIV>
<DIV style="position:absolute;top:372;left:111"><nobr><span class="ft11"><i>gramming Language Semantics</i>. Chapman and Hall, London,<br>and John Wiley, New York, 1976.</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:81"><nobr><span class="ft3">[28] Eugenio Moggi. Notions of computation and monads. <i>Infor-</i></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:111"><nobr><span class="ft7"><i>mation and Computation</i>, 93:55­92, 1991.</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:81"><nobr><span class="ft3">[29] Lasse R. Nielsen. A denotational investigation of defunction-</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:111"><nobr><span class="ft11">alization. Technical Report BRICS RS-00-47, DAIMI, De-<br>partment of Computer Science, University of Aarhus, Aarhus,<br>Denmark, December 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:81"><nobr><span class="ft3">[30] Gordon D. Plotkin. Call-by-name, call-by-value and the</span></nobr></DIV>
<DIV style="position:absolute;top:507;left:430"><nobr><span class="ft5"></span></nobr></DIV>
<DIV style="position:absolute;top:511;left:437"><nobr><span class="ft3">-</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:111"><nobr><span class="ft3">calculus. <i>Theoretical Computer Science</i>, 1:125­159, 1975.</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:81"><nobr><span class="ft3">[31] John C. Reynolds. Definitional interpreters for higher-order</span></nobr></DIV>
<DIV style="position:absolute;top:563;left:111"><nobr><span class="ft11">programming languages. <i>Higher-Order and Symbolic Com-<br>putation</i>, 11(4):363­397, 1998. Reprinted from the proceed-<br>ings of the 25th ACM National Conference (1972).</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:81"><nobr><span class="ft3">[32] Kristoffer H. Rose.</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:231"><nobr><span class="ft3">Explicit substitution ­ tutorial &amp; sur-</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:111"><nobr><span class="ft11">vey. BRICS Lecture Series LS-96-3, DAIMI, Department of<br>Computer Science, University of Aarhus, Aarhus, Denmark,<br>September 1996.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:477"><nobr><span class="ft3">[33] Amr Sabry and Matthias Felleisen.</span></nobr></DIV>
<DIV style="position:absolute;top:114;left:717"><nobr><span class="ft3">Reasoning about pro-</span></nobr></DIV>
<DIV style="position:absolute;top:129;left:507"><nobr><span class="ft24">grams in continuation-passing style. <i>Lisp and Symbolic Com-<br>putation</i>, 6(3/4):289­360, 1993.</span></nobr></DIV>
<DIV style="position:absolute;top:165;left:477"><nobr><span class="ft3">[34] David A. Schmidt. <i>Denotational Semantics: A Methodology</i></span></nobr></DIV>
<DIV style="position:absolute;top:180;left:507"><nobr><span class="ft7"><i>for Language Development</i>. Allyn and Bacon, Inc., 1986.</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:477"><nobr><span class="ft3">[35] Guy L. Steele Jr. and Gerald J. Sussman.</span></nobr></DIV>
<DIV style="position:absolute;top:202;left:775"><nobr><span class="ft3">The art of</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:507"><nobr><span class="ft11">the interpreter or, the modularity complex (parts zero, one,<br>and two).</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:576"><nobr><span class="ft3">AI Memo 453, Artificial Intelligence Labora-</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:507"><nobr><span class="ft11">tory, Massachusetts Institute of Technology, Cambridge, Mas-<br>sachusetts, May 1978.</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:477"><nobr><span class="ft3">[36] Joseph Stoy.</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:598"><nobr><span class="ft3">Some mathematical aspects of functional</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:507"><nobr><span class="ft3">programming.</span></nobr></DIV>
<DIV style="position:absolute;top:298;left:598"><nobr><span class="ft3">In John Darlington, Peter Henderson, and</span></nobr></DIV>
<DIV style="position:absolute;top:313;left:507"><nobr><span class="ft24">David A. Turner, editors, <i>Functional Programming and its<br>Applications</i>. Cambridge University Press, 1982.</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:477"><nobr><span class="ft3">[37] Joseph E. Stoy. <i>Denotational Semantics: The Scott-Strachey</i></span></nobr></DIV>
<DIV style="position:absolute;top:365;left:507"><nobr><span class="ft11"><i>Approach to Programming Language Theory</i>. The MIT Press,<br>1977.</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:477"><nobr><span class="ft3">[38] Christopher Strachey.</span></nobr></DIV>
<DIV style="position:absolute;top:401;left:641"><nobr><span class="ft3">Fundamental concepts in program-</span></nobr></DIV>
<DIV style="position:absolute;top:416;left:507"><nobr><span class="ft11">ming languages. <i>Higher-Order and Symbolic Computation</i>,<br>13(1/2):1­49, 2000.</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:477"><nobr><span class="ft3">[39] Philip Wadler. The essence of functional programming (in-</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:507"><nobr><span class="ft11">vited talk). In Andrew W. Appel, editor, <i>Proceedings of the<br>Nineteenth Annual ACM Symposium on Principles of Pro-<br>gramming Languages</i>, pages 1­14, Albuquerque, New Mex-<br>ico, January 1992. ACM Press.</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:477"><nobr><span class="ft3">[40] Mitchell Wand. A short proof of the lexical addressing algo-</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:507"><nobr><span class="ft3">rithm. <i>Information Processing Letters</i>, 35:1­5, 1990.</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:477"><nobr><span class="ft3">[41] Glynn Winskel. <i>The Formal Semantics of Programming Lan-</i></span></nobr></DIV>
<DIV style="position:absolute;top:586;left:507"><nobr><span class="ft11"><i>guages</i>. Foundation of Computing Series. The MIT Press,<br>1993.</span></nobr></DIV>
<DIV style="position:absolute;top:1128;left:452"><nobr><span class="ft3">19</span></nobr></DIV>
</DIV>
</BODY>
</HTML>
